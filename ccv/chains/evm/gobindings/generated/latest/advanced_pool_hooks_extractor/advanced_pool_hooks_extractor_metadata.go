// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package advanced_pool_hooks_extractor

var SolidityStandardInput = "{\"version\":\"v0.8.26+commit.8a97fa7a\",\"language\":\"Solidity\",\"settings\":{\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"appendCBOR\":true,\"bytecodeHash\":\"none\",\"useLiteralContent\":false},\"optimizer\":{\"enabled\":true,\"runs\":50000},\"outputSelection\":{\"contracts/interfaces/IAdvancedPoolHooks.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/interfaces/IPoolV2.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/libraries/Pool.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/pools/extractors/AdvancedPoolHooksExtractor.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/ace/packages/policy-management/src/interfaces/IExtractor.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/ace/packages/policy-management/src/interfaces/IPolicyEngine.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/utils/introspection/IERC165.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]}},\"remappings\":[\"forge-std/=node_modules/@chainlink/contracts/src/v0.8/vendor/forge-std/src/\",\"@chainlink/ace/policy-management/=node_modules/@chainlink/ace/packages/policy-management/src/\",\"@chainlink/contracts/=node_modules/@chainlink/contracts/\",\"@openzeppelin/contracts@4.8.3/=node_modules/@openzeppelin/contracts-4.8.3/\",\"@openzeppelin/contracts@5.3.0/=node_modules/@openzeppelin/contracts-5.3.0/\",\"@arbitrum/=node_modules/@arbitrum/\",\"@eth-optimism/=node_modules/@eth-optimism/\",\"@offchainlabs/=node_modules/@offchainlabs/\",\"@scroll-tech/=node_modules/@scroll-tech/\",\"@zksync/=node_modules/@zksync/\",\"hardhat/=node_modules/@zksync/contracts/l1-contracts/node_modules/hardhat/\",\"solady/=node_modules/solady/\"],\"viaIR\":true},\"sources\":{\"contracts/interfaces/IAdvancedPoolHooks.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\nimport {Pool} from \\\"../libraries/Pool.sol\\\";\\nimport {IPoolV2} from \\\"./IPoolV2.sol\\\";\\n\\n/// @notice Interface for AdvancedPoolHooks contract. Implementations may contain no-op logic.\\ninterface IAdvancedPoolHooks {\\n  /// @notice Preflight check before lock or burn operation.\\n  /// @param lockOrBurnIn The lock or burn input parameters.\\n  /// @param blockConfirmationRequested The block confirmation requested.\\n  /// @param tokenArgs Additional token arguments.\\n  /// @param amountPostFee The amount after token pool bps-based fees have been deducted.\\n  /// @dev This function may revert if the preflight check fails. This means the transaction is rolled back on source.\\n  function preflightCheck(\\n    Pool.LockOrBurnInV1 calldata lockOrBurnIn,\\n    uint16 blockConfirmationRequested,\\n    bytes calldata tokenArgs,\\n    uint256 amountPostFee\\n  ) external;\\n\\n  /// @notice Postflight check before releasing or minting tokens.\\n  /// @param releaseOrMintIn The release or mint output parameters.\\n  /// @param localAmount The local amount to be released or minted.\\n  /// @param blockConfirmationRequested The block confirmation requested.\\n  /// @dev This function may revert if the postflight check fails. This means the transaction is unexecutable until\\n  /// the issue is resolved.\\n  function postflightCheck(\\n    Pool.ReleaseOrMintInV1 calldata releaseOrMintIn,\\n    uint256 localAmount,\\n    uint16 blockConfirmationRequested\\n  ) external;\\n\\n  /// @notice Returns the set of required CCVs for transfers in a specific direction.\\n  /// @param localToken The address of the local token.\\n  /// @param remoteChainSelector The remote chain selector for this transfer.\\n  /// @param amount The amount being transferred.\\n  /// @param blockConfirmationRequested Requested block confirmation.\\n  /// @param extraData Direction-specific payload forwarded by the caller (e.g. token args or source pool data).\\n  /// @param direction The direction of the transfer (Inbound or Outbound).\\n  /// @return requiredCCVs Set of required CCV addresses.\\n  function getRequiredCCVs(\\n    address localToken,\\n    uint64 remoteChainSelector,\\n    uint256 amount,\\n    uint16 blockConfirmationRequested,\\n    bytes calldata extraData,\\n    IPoolV2.MessageDirection direction\\n  ) external view returns (address[] memory requiredCCVs);\\n}\\n\"},\"contracts/interfaces/IPoolV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {Pool} from \\\"../libraries/Pool.sol\\\";\\n\\nimport {IERC165} from \\\"@openzeppelin/contracts@5.3.0/utils/introspection/IERC165.sol\\\";\\n\\n/// @notice Shared public interface for multiple V2 pool types.\\n/// Each pool type handles a different child token model e.g. lock/release, mint/burn.\\ninterface IPoolV2 is IERC165 {\\n  struct TokenTransferFeeConfig {\\n    uint32 destGasOverhead; // ───────────────────────╮ Gas charged to execute the token transfer on the destination chain.\\n    uint32 destBytesOverhead; //                      │ Data availability bytes.\\n    uint32 defaultBlockConfirmationFeeUSDCents; //    │ Fee to charge for token transfer with default block confirmation, multiples of 0.01 USD.\\n    uint32 customBlockConfirmationFeeUSDCents; //     │ Fee to charge for token transfer with custom block confirmation, multiples of 0.01 USD.\\n    //                                                │ The following two fee is deducted from the transferred asset, not added on top.\\n    uint16 defaultBlockConfirmationTransferFeeBps; // │ Fee in basis points for default finality transfers [0-10_000].\\n    uint16 customBlockConfirmationTransferFeeBps; //  │ Fee in basis points for custom finality transfers [0-10_000].\\n    bool isEnabled; // ───────────────────────────────╯ Whether this config is enabled.\\n  }\\n\\n  enum MessageDirection {\\n    Outbound,\\n    Inbound\\n  }\\n\\n  /// @notice Lock tokens into the pool or burn the tokens.\\n  /// @param lockOrBurnIn Encoded data fields for the processing of tokens on the source chain.\\n  /// @param blockConfirmationRequested Requested block confirmation.\\n  /// @param tokenArgs Additional token arguments.\\n  /// @return lockOrBurnOut Encoded data fields for the processing of tokens on the destination chain.\\n  /// @return destTokenAmount The amount of tokens that will be set in TokenTransferV1.amount to be released/mint on destination.\\n  function lockOrBurn(\\n    Pool.LockOrBurnInV1 calldata lockOrBurnIn,\\n    uint16 blockConfirmationRequested,\\n    bytes calldata tokenArgs\\n  ) external returns (Pool.LockOrBurnOutV1 memory lockOrBurnOut, uint256 destTokenAmount);\\n\\n  /// @notice Releases or mints tokens on the destination chain.\\n  /// @param releaseOrMintIn Encoded data fields for the processing of tokens on the destination chain.\\n  /// @param blockConfirmationRequested Requested block confirmation.\\n  /// @return releaseOrMintOut Encoded data fields describing the result of the release or mint.\\n  function releaseOrMint(\\n    Pool.ReleaseOrMintInV1 calldata releaseOrMintIn,\\n    uint16 blockConfirmationRequested\\n  ) external returns (Pool.ReleaseOrMintOutV1 memory releaseOrMintOut);\\n\\n  /// @notice Returns the set of required CCVs for transfers in a given direction.\\n  /// @param localToken The address of the local token.\\n  /// @param remoteChainSelector The chain selector of the remote chain.\\n  /// @param amount The amount of tokens to be transferred.\\n  /// @param blockConfirmationRequested Requested block confirmation.\\n  /// @param extraData Direction-specific payload forwarded by the caller (e.g. token args or source pool data).\\n  /// @param direction Whether CCVs are required for outbound (source -\\u003e remote) or inbound (remote -\\u003e destination) transfers.\\n  /// @return requiredCCVs A set of addresses representing the required CCVs.\\n  function getRequiredCCVs(\\n    address localToken,\\n    uint64 remoteChainSelector,\\n    uint256 amount,\\n    uint16 blockConfirmationRequested,\\n    bytes calldata extraData,\\n    MessageDirection direction\\n  ) external view returns (address[] memory requiredCCVs);\\n\\n  /// @notice Returns the fee overrides for transferring the pool's token to a destination chain.\\n  /// @param localToken The address of the local token.\\n  /// @param destChainSelector The chain selector of the destination chain.\\n  /// @param blockConfirmationRequested Requested block confirmation.\\n  /// @param tokenArgs Additional token argument from the CCIP message.\\n  /// @return feeConfig the fee configuration for transferring the token to the destination chain.\\n  function getTokenTransferFeeConfig(\\n    address localToken,\\n    uint64 destChainSelector,\\n    uint16 blockConfirmationRequested,\\n    bytes calldata tokenArgs\\n  ) external view returns (TokenTransferFeeConfig memory feeConfig);\\n\\n  /// @notice Returns the pool fee parameters that will apply to a transfer.\\n  /// @param localToken The local asset being transferred.\\n  /// @param destChainSelector The destination lane selector.\\n  /// @param amount The amount of tokens being bridged on this lane.\\n  /// @param feeToken The token used to pay feeUSDCents.\\n  /// @param blockConfirmationRequested Requested block confirmation.\\n  /// @param tokenArgs Opaque token arguments supplied by the caller.\\n  /// @return feeUSDCents Flat fee charged in USD cents (crumbs) for this transfer.\\n  /// @return destGasOverhead Destination gas charged for accounting in the cost model.\\n  /// @return destBytesOverhead Destination calldata size attributed to the transfer.\\n  /// @return tokenFeeBps Bps charged in token units. Value of zero implies no in-token fee.\\n  /// @return isEnabled Whether the pool's fee config is enabled. If false, OnRamp should use FeeQuoter defaults.\\n  function getFee(\\n    address localToken,\\n    uint64 destChainSelector,\\n    uint256 amount,\\n    address feeToken,\\n    uint16 blockConfirmationRequested,\\n    bytes calldata tokenArgs\\n  )\\n    external\\n    view\\n    returns (uint256 feeUSDCents, uint32 destGasOverhead, uint32 destBytesOverhead, uint16 tokenFeeBps, bool isEnabled);\\n\\n  /// @notice Gets the token address on the remote chain.\\n  /// @param remoteChainSelector Remote chain selector.\\n  /// @dev To support non-evm chains, this value is encoded into bytes.\\n  function getRemoteToken(\\n    uint64 remoteChainSelector\\n  ) external view returns (bytes memory);\\n}\\n\"},\"contracts/libraries/Pool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice This library contains various token pool functions to aid constructing the return data.\\nlibrary Pool {\\n  // The tag used to signal support for the pool v1 standard.\\n  // bytes4(keccak256(\\\"CCIP_POOL_V1\\\"))\\n  bytes4 public constant CCIP_POOL_V1 = 0xaff2afbf;\\n\\n  // The number of bytes in the return data for a pool v1 releaseOrMint call.\\n  // This should match the size of the ReleaseOrMintOutV1 struct.\\n  uint16 public constant CCIP_POOL_V1_RET_BYTES = 32;\\n\\n  // The default max number of bytes in the return data for a pool v1 lockOrBurn call.\\n  // This data can be used to send information to the destination chain token pool. Can be overwritten\\n  // in the TokenTransferFeeConfig.destBytesOverhead if more data is required.\\n  uint32 public constant CCIP_LOCK_OR_BURN_V1_RET_BYTES = 32;\\n\\n  struct LockOrBurnInV1 {\\n    bytes receiver; //  The recipient of the tokens on the destination chain. For EVM source chains, this is abi-encoded (32 bytes).\\n    uint64 remoteChainSelector; // ─╮ The chain ID of the destination chain.\\n    address originalSender; // ─────╯ The original sender of the tx on the source chain.\\n    uint256 amount; //  The amount of tokens to lock or burn, denominated in the source token's decimals.\\n    address localToken; // The address on this chain of the token to lock or burn.\\n  }\\n\\n  struct LockOrBurnOutV1 {\\n    // The address of the destination token, abi encoded in the case of EVM chains.\\n    // This value is UNTRUSTED as any pool owner can return whatever value they want.\\n    bytes destTokenAddress;\\n    // Optional pool data to be transferred to the destination chain. Be default this is capped at\\n    // CCIP_LOCK_OR_BURN_V1_RET_BYTES bytes. If more data is required, the TokenTransferFeeConfig.destBytesOverhead\\n    // has to be set for the specific token.\\n    bytes destPoolData;\\n  }\\n\\n  struct ReleaseOrMintInV1 {\\n    bytes originalSender; //            The original sender of the tx on the source chain.\\n    uint64 remoteChainSelector; // ───╮ The chain ID of the source chain.\\n    address receiver; // ─────────────╯ The recipient of the tokens on the destination chain.\\n    uint256 sourceDenominatedAmount; // The amount of tokens to release or mint, denominated in the source token's decimals.\\n    address localToken; //              The address on this chain of the token to release or mint.\\n    /// @dev WARNING: sourcePoolAddress should be checked prior to any processing of funds. Make sure it matches the\\n    /// expected pool address for the given remoteChainSelector.\\n    bytes sourcePoolAddress; //         The address of the source pool, abi encoded in the case of EVM chains.\\n    bytes sourcePoolData; //            The data received from the source pool to process the release or mint.\\n    /// @dev WARNING: offchainTokenData is untrusted data.\\n    bytes offchainTokenData; //         The offchain data to process the release or mint.\\n  }\\n\\n  struct ReleaseOrMintOutV1 {\\n    // The number of tokens released or minted on the destination chain, denominated in the local token's decimals.\\n    // This value is expected to be equal to the ReleaseOrMintInV1.amount in the case where the source and destination\\n    // chain have the same number of decimals.\\n    uint256 destinationAmount;\\n  }\\n}\\n\"},\"contracts/pools/extractors/AdvancedPoolHooksExtractor.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\nimport {IAdvancedPoolHooks} from \\\"../../interfaces/IAdvancedPoolHooks.sol\\\";\\nimport {IExtractor} from \\\"@chainlink/ace/policy-management/interfaces/IExtractor.sol\\\";\\nimport {IPolicyEngine} from \\\"@chainlink/ace/policy-management/interfaces/IPolicyEngine.sol\\\";\\n\\nimport {Pool} from \\\"../../libraries/Pool.sol\\\";\\n\\n/// @notice Extracts named parameters from AdvancedPoolHooks preflightCheck and postflightCheck calldata\\n/// for ACE policy evaluation.\\ncontract AdvancedPoolHooksExtractor is IExtractor {\\n  string public constant override typeAndVersion = \\\"AdvancedPoolHooksExtractor 2.0.0-dev\\\";\\n\\n  /// @notice Parameter key for the sender address initiating the transfer.\\n  bytes32 public constant PARAM_FROM = keccak256(\\\"from\\\");\\n  /// @notice Parameter key for the recipient. Raw bytes in preflight, abi.encoded in postflight.\\n  bytes32 public constant PARAM_TO = keccak256(\\\"to\\\");\\n  /// @notice Parameter key for the transfer amount specified during ccipSend.\\n  bytes32 public constant PARAM_AMOUNT = keccak256(\\\"amount\\\");\\n  /// @notice Parameter key for the transfer amount after fee deduction. Only present in preflight.\\n  bytes32 public constant PARAM_AMOUNT_POST_FEE = keccak256(\\\"amount_post_fee\\\");\\n  /// @notice Parameter key for the remote chain selector.\\n  bytes32 public constant PARAM_REMOTE_CHAIN_SELECTOR = keccak256(\\\"remote_chain_selector\\\");\\n  /// @notice Parameter key for the local token address.\\n  bytes32 public constant PARAM_TOKEN = keccak256(\\\"token\\\");\\n  /// @notice Parameter key for the requested number of block confirmations.\\n  bytes32 public constant PARAM_BLOCK_CONFIRMATION_REQUESTED = keccak256(\\\"block_confirmation_requested\\\");\\n  /// @notice Parameter key for the source pool address. Only present in postflight.\\n  bytes32 public constant PARAM_SOURCE_POOL_ADDRESS = keccak256(\\\"source_pool_address\\\");\\n  /// @notice Parameter key for the source pool data. Only present in postflight.\\n  bytes32 public constant PARAM_SOURCE_POOL_DATA = keccak256(\\\"source_pool_data\\\");\\n  /// @notice Parameter key for the source-denominated transfer amount. Only present in postflight.\\n  bytes32 public constant PARAM_SOURCE_DENOMINATED_AMOUNT = keccak256(\\\"source_denominated_amount\\\");\\n\\n  /// @inheritdoc IExtractor\\n  function extract(\\n    IPolicyEngine.Payload calldata payload\\n  ) public pure virtual returns (IPolicyEngine.Parameter[] memory) {\\n    if (payload.selector == IAdvancedPoolHooks.preflightCheck.selector) {\\n      return _extractPreflightCheck(payload);\\n    }\\n\\n    if (payload.selector == IAdvancedPoolHooks.postflightCheck.selector) {\\n      return _extractPostflightCheck(payload);\\n    }\\n\\n    revert IPolicyEngine.UnsupportedSelector(payload.selector);\\n  }\\n\\n  /// @dev Decodes preflightCheck arguments: (LockOrBurnInV1, uint16, bytes, uint256).\\n  function _extractPreflightCheck(\\n    IPolicyEngine.Payload calldata payload\\n  ) internal pure returns (IPolicyEngine.Parameter[] memory) {\\n    // tokenArgs is skipped as it is treated as context in the payload.\\n    (Pool.LockOrBurnInV1 memory lockOrBurnIn, uint16 blockConfirmationRequested,, uint256 amountPostFee) =\\n      abi.decode(payload.data, (Pool.LockOrBurnInV1, uint16, bytes, uint256));\\n\\n    IPolicyEngine.Parameter[] memory result = new IPolicyEngine.Parameter[](7);\\n    result[0] = IPolicyEngine.Parameter(PARAM_FROM, abi.encode(lockOrBurnIn.originalSender));\\n    result[1] = IPolicyEngine.Parameter(PARAM_TO, lockOrBurnIn.receiver);\\n    result[2] = IPolicyEngine.Parameter(PARAM_AMOUNT, abi.encode(lockOrBurnIn.amount));\\n    result[3] = IPolicyEngine.Parameter(PARAM_AMOUNT_POST_FEE, abi.encode(amountPostFee));\\n    result[4] = IPolicyEngine.Parameter(PARAM_REMOTE_CHAIN_SELECTOR, abi.encode(lockOrBurnIn.remoteChainSelector));\\n    result[5] = IPolicyEngine.Parameter(PARAM_TOKEN, abi.encode(lockOrBurnIn.localToken));\\n    result[6] = IPolicyEngine.Parameter(PARAM_BLOCK_CONFIRMATION_REQUESTED, abi.encode(blockConfirmationRequested));\\n\\n    return result;\\n  }\\n\\n  /// @dev Decodes postflightCheck arguments: (ReleaseOrMintInV1, uint256, uint16).\\n  function _extractPostflightCheck(\\n    IPolicyEngine.Payload calldata payload\\n  ) internal pure returns (IPolicyEngine.Parameter[] memory) {\\n    (Pool.ReleaseOrMintInV1 memory releaseOrMintIn, uint256 localAmount, uint16 blockConfirmationRequested) =\\n      abi.decode(payload.data, (Pool.ReleaseOrMintInV1, uint256, uint16));\\n\\n    // offchainTokenData is skipped as it is treated as context in the payload.\\n    // Note offchainTokenData is no longer used in v2+ TokenPools.\\n    IPolicyEngine.Parameter[] memory result = new IPolicyEngine.Parameter[](9);\\n    result[0] = IPolicyEngine.Parameter(PARAM_FROM, releaseOrMintIn.originalSender);\\n    result[1] = IPolicyEngine.Parameter(PARAM_TO, abi.encode(releaseOrMintIn.receiver));\\n    result[2] = IPolicyEngine.Parameter(PARAM_AMOUNT, abi.encode(localAmount));\\n    result[3] = IPolicyEngine.Parameter(PARAM_REMOTE_CHAIN_SELECTOR, abi.encode(releaseOrMintIn.remoteChainSelector));\\n    result[4] = IPolicyEngine.Parameter(PARAM_TOKEN, abi.encode(releaseOrMintIn.localToken));\\n    result[5] = IPolicyEngine.Parameter(PARAM_BLOCK_CONFIRMATION_REQUESTED, abi.encode(blockConfirmationRequested));\\n    result[6] = IPolicyEngine.Parameter(PARAM_SOURCE_POOL_ADDRESS, releaseOrMintIn.sourcePoolAddress);\\n    result[7] = IPolicyEngine.Parameter(PARAM_SOURCE_POOL_DATA, releaseOrMintIn.sourcePoolData);\\n    result[8] =\\n      IPolicyEngine.Parameter(PARAM_SOURCE_DENOMINATED_AMOUNT, abi.encode(releaseOrMintIn.sourceDenominatedAmount));\\n\\n    return result;\\n  }\\n}\\n\"},\"node_modules/@chainlink/ace/packages/policy-management/src/interfaces/IExtractor.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.20;\\n\\nimport {IPolicyEngine} from \\\"./IPolicyEngine.sol\\\";\\n\\n/**\\n * @title IExtractor\\n * @dev Interface for extracting parameters from a payload.\\n */\\ninterface IExtractor {\\n  /**\\n   * @notice Returns the type and version of the extractor.\\n   * @return A string representing the type and version of the extractor.\\n   */\\n  function typeAndVersion() external pure returns (string memory);\\n\\n  /**\\n   * @notice Extracts parameters from a payload.\\n   * @param payload The payload to extract parameters from.\\n   * @return The extracted parameters.\\n   */\\n  function extract(IPolicyEngine.Payload calldata payload) external view returns (IPolicyEngine.Parameter[] memory);\\n}\\n\"},\"node_modules/@chainlink/ace/packages/policy-management/src/interfaces/IPolicyEngine.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title IPolicyEngine\\n * @dev Interface for the policy engine.\\n */\\ninterface IPolicyEngine {\\n  /// @notice Error emitted when the target is not attached to the policy engine.\\n  error TargetNotAttached(address target);\\n  /// @notice Error emitted when the target is already attached to the policy engine.\\n  error TargetAlreadyAttached(address target);\\n  /// @notice Error emitted when the policy engine is missing or not present.\\n  error PolicyEngineUndefined();\\n  /// @notice Error emitted when the PolicyEngine run has been rejected by one of the polices.\\n  error PolicyRunRejected(address policy, string rejectReason, Payload payload);\\n  /// @notice Error emitted when a policy mapper results in an error.\\n  error PolicyMapperError(address policy, bytes errorReason, Payload payload);\\n  /// @notice Error emitted when an individual policy is rejecting a transaction.\\n  error PolicyRejected(string rejectReason);\\n  /// @notice Error emitted when the PolicyEngine run encounters an error while executing one of the policies.\\n  error PolicyRunError(address policy, bytes errorReason, Payload payload);\\n  /// @notice Error emitted when a policy run is unauthorized.\\n  error PolicyRunUnauthorizedError(address account);\\n  /// @notice Error emitted when a policy postRun results in an error.\\n  error PolicyPostRunError(address policy, bytes errorReason, Payload payload);\\n  /// @notice Error emitted when a policy extractor is run with an unsupported selector.\\n  error UnsupportedSelector(bytes4 selector);\\n  /// @notice Error emitted when a policy action results in an error.\\n  error PolicyActionError(address policy, bytes errorReason);\\n  /// @notice Error emitted when a policy configuration change results in an error.\\n  error PolicyConfigurationError(address policy, bytes errorReason);\\n  /// @notice Error emitted when a policy configuration version does not match the expected version.\\n  error PolicyConfigurationVersionError(address policy, uint256 expectedVersion, uint256 actualVersion);\\n  /// @notice Error emitted when an extraction of parameters results in an error.\\n  error ExtractorError(address extractor, bytes errorReason, Payload payload);\\n\\n  /**\\n   * @notice Emitted when a target contract has attached to the policy engine.\\n   * @param target The target contract.\\n   */\\n  event TargetAttached(address indexed target);\\n\\n  /**\\n   * @notice Emitted when a target contract has detached from the policy engine.\\n   * @param target The target contract.\\n   */\\n  event TargetDetached(address indexed target);\\n\\n  /**\\n   * @notice Emitted when a policy configuration is performed.\\n   * @param policy The address of the policy.\\n   * @param configSelector The selector of the configuration function.\\n   * @param configVersion The version of the configuration.\\n   * @param configData The data of the configuration.\\n   */\\n  event PolicyConfigured(\\n    address indexed policy, uint256 indexed configVersion, bytes4 indexed configSelector, bytes configData\\n  );\\n\\n  /**\\n   * @notice Emitted when a policy engine run has completed successfully.\\n   * @param sender The sender of the transaction.\\n   * @param target The target contract that invoked the method.\\n   * @param selector The selector of the method invoked on the target.\\n   * @param extractedParameters The parameters extracted from the payload for policy evaluation.\\n   * @param context Additional context data from the payload.\\n   */\\n  event PolicyRunComplete(\\n    address indexed sender,\\n    address indexed target,\\n    bytes4 indexed selector,\\n    Parameter[] extractedParameters,\\n    bytes context\\n  );\\n\\n  /**\\n   * @notice Emitted when a policy is added to the policy engine.\\n   * @param target The address of the target contract for which the policy was configured.\\n   * @param selector The selector of the policy.\\n   * @param policy The policy address.\\n   * @param position The position of the policy in the policy chain.\\n   * @param policyParameterNames The parameter names for the policy.\\n   */\\n  event PolicyAdded(\\n    address indexed target, bytes4 indexed selector, address policy, uint256 position, bytes32[] policyParameterNames\\n  );\\n\\n  /**\\n   * @notice Emitted when a policy is added to the policy engine at a specific position.\\n   * @param target The address of the target contract for which the policy was configured.\\n   * @param selector The selector of the policy.\\n   * @param policy The policy address.\\n   * @param position The position of the policy in the policy chain.\\n   * @param policyParameterNames The parameter names for the policy.\\n   * @param policies The complete ordered array of all policy addresses after the insertion.\\n   */\\n  event PolicyAddedAt(\\n    address indexed target,\\n    bytes4 indexed selector,\\n    address policy,\\n    uint256 position,\\n    bytes32[] policyParameterNames,\\n    address[] policies\\n  );\\n\\n  /**\\n   * @notice Emitted when a policy is removed from the policy engine.\\n   * @param target The address of the target contract for which the policy was configured.\\n   * @param selector The selector of the policy.\\n   * @param policy The policy address.\\n   */\\n  event PolicyRemoved(address indexed target, bytes4 indexed selector, address policy);\\n\\n  /**\\n   * @notice Emitted when an extractor is set for a selector.\\n   * @param selector The selector.\\n   * @param extractor The extractor address.\\n   */\\n  event ExtractorSet(bytes4 indexed selector, address indexed extractor);\\n\\n  /**\\n   * @notice Emitted when a policy mapper is set for a policy.\\n   * @param policy The policy address.\\n   * @param mapper The mapper address.\\n   */\\n  event PolicyMapperSet(address indexed policy, address indexed mapper);\\n\\n  /**\\n   * @notice Emitted when policy parameters are set for a policy.\\n   * @param policy The policy address.\\n   * @param parameters The parameters for the policy.\\n   */\\n  event PolicyParametersSet(address indexed policy, bytes[] parameters);\\n\\n  /**\\n   * @notice Emitted when the default policy action rule is set for the policy engine.\\n   * @param defaultAllow Indicates whether to allow or reject a transaction if no policy explicitly returns an Allow\\n   * or a Reject. True to allow, false to reject.\\n   */\\n  event DefaultPolicyAllowSet(bool defaultAllow);\\n\\n  /**\\n   * @notice Emitted when the default policy allow rule for a target is set.\\n   * @param target The target contract.\\n   * @param defaultAllow Indicates whether to allow or reject a transaction if no policy explicitly returns an Allow\\n   * or a Reject. True to allow, false to reject.\\n   */\\n  event TargetDefaultPolicyAllowSet(address indexed target, bool defaultAllow);\\n\\n  /**\\n   * @notice The PolicyResult enum represents the possible types of success results of a policy run. When a policy\\n   * should reject a transaction, it MUST revert using the `PolicyReject` error with a descriptive reject message.\\n   * @param None No specific policy result, typically used as a default or uninitialized state.\\n   * @param Allowed The policy allowed the run.\\n   * @param Continue The policy did not reject the run and processing should continue to the next policy.\\n   */\\n  enum PolicyResult {\\n    None,\\n    Allowed,\\n    Continue\\n  }\\n\\n  /**\\n   * @notice The Payload struct combines the components on which policies operate.\\n   * @param selector The selector of the method being invoked on the target.\\n   * @param sender The sender of the transaction.\\n   * @param data The original calldata of the invoked transaction.\\n   * @param context Additional information or authorization to perform the operation.\\n   */\\n  struct Payload {\\n    bytes4 selector;\\n    address sender;\\n    bytes data;\\n    bytes context;\\n  }\\n\\n  /**\\n   * @notice The Parameter struct contains the data of the parameters sent to policies.\\n   * @param name The name of the parameter.\\n   * @param value The value of the parameter.\\n   */\\n  struct Parameter {\\n    bytes32 name;\\n    bytes value;\\n  }\\n\\n  /**\\n   * @notice Returns the type and version of the policy engine.\\n   * @return A string representing the type and version of the policy engine.\\n   */\\n  function typeAndVersion() external pure returns (string memory);\\n\\n  /**\\n   * @notice Attaches the calling contract to the policy engine.\\n   */\\n  function attach() external;\\n\\n  /**\\n   * @notice Detaches the calling contract from the policy engine.\\n   */\\n  function detach() external;\\n\\n  /**\\n   * @notice Assigns an extractor to the specified selector, enabling policies to utilize it for parameter extraction.\\n   * @param selector The selector of the policy.\\n   * @param extractor The extractor address.\\n   */\\n  function setExtractor(bytes4 selector, address extractor) external;\\n\\n  /**\\n   * @notice Assigns an extractor to the specified selectors, enabling policies to utilize it for parameter extraction.\\n   * @param selectors The selectors of the policies.\\n   * @param extractor The extractor address.\\n   */\\n  function setExtractors(bytes4[] calldata selectors, address extractor) external;\\n\\n  /**\\n   * @notice Gets the extractor for a given selector.\\n   * @param selector The selector.\\n   * @return The extractor for the selector.\\n   */\\n  function getExtractor(bytes4 selector) external view returns (address);\\n\\n  /**\\n   * @notice Sets the custom policy parameter mapper for a policy.\\n   * @param policy The policy address.\\n   * @param mapper The mapper address, address(0) to use the default mapper.\\n   */\\n  function setPolicyMapper(address policy, address mapper) external;\\n\\n  /**\\n   * @notice Gets the policy parameter mapper for a given policy.\\n   * @param policy The policy address.\\n   * @return The custom policy parameter mapper for the policy, address(0) if the policy uses the default mapper.\\n   */\\n  function getPolicyMapper(address policy) external view returns (address);\\n\\n  /**\\n   * @notice Adds a policy to the policy engine.\\n   *\\n   * - Policy MUST be added to the end of the current policy list.\\n   *\\n   * @param target The address of the target contract for which the policy apply.\\n   * @param selector The selector of the policy.\\n   * @param policy The policy address.\\n   * @param policyParameterNames The parameter names for the policy.\\n   */\\n  function addPolicy(address target, bytes4 selector, address policy, bytes32[] calldata policyParameterNames) external;\\n\\n  /**\\n   * @notice Adds a policy to the policy engine at a specific position.\\n   *\\n   * @param target The address of the target contract for which the policy apply.\\n   * @param selector The selector of the policy.\\n   * @param policy The policy address.\\n   * @param policyParameterNames The parameter names for the policy.\\n   * @param position The position to add the policy at.\\n   */\\n  function addPolicyAt(\\n    address target,\\n    bytes4 selector,\\n    address policy,\\n    bytes32[] calldata policyParameterNames,\\n    uint256 position\\n  )\\n    external;\\n\\n  /**\\n   * @notice Removes a policy from the policy engine.\\n   * @param target The address of the target contract for which the policy was configured.\\n   * @param selector The selector of the policy.\\n   * @param policy The policy address.\\n   */\\n  function removePolicy(address target, bytes4 selector, address policy) external;\\n\\n  /**\\n   * @notice Gets the policies for a given selector and target.\\n   *\\n   * - MUST return the policies in the order they will execute.\\n   * - MUST return an empty array if no policies are found.\\n   *\\n   * @param selector The selector of the policy.\\n   * @param target The address of the target contract for which the policies are configured.\\n   * @return The policies for the selector and target.\\n   */\\n  function getPolicies(address target, bytes4 selector) external view returns (address[] memory);\\n\\n  /**\\n   * @notice Sets the configuration for a policy.\\n   * @param policy The address of the policy to configure.\\n   * @param configVersion The version of the configuration.\\n   * @param configSelector The selector of the configuration function.\\n   * @param configData The calldata for the configuration function.\\n   */\\n  function setPolicyConfiguration(\\n    address policy,\\n    uint256 configVersion,\\n    bytes4 configSelector,\\n    bytes calldata configData\\n  )\\n    external;\\n\\n  /**\\n   * @notice Gets the current configuration version for a policy.\\n   * @param policy The address of the policy.\\n   * @return The current configuration version for the policy.\\n   */\\n  function getPolicyConfigVersion(address policy) external view returns (uint256);\\n\\n  /**\\n   * @notice Sets whether to allow or reject the transaction if no policy explicitly returns an Allow or a Reject.\\n   * @param defaultAllow Indicates whether to allow or reject a transaction if no policy explicitly returns an Allow\\n   * or a Reject. True to allow, false to reject.\\n   */\\n  function setDefaultPolicyAllow(bool defaultAllow) external;\\n\\n  /**\\n   * @notice Sets whether to allow or reject the transaction if no policy explicitly returns an Allow or a Reject\\n   * for a specific target.\\n   * @param target The address of the target contract.\\n   * @param defaultAllow Indicates whether to allow or reject a transaction if no policy explicitly returns an Allow\\n   * or a Reject. True to allow, false to reject.\\n   */\\n  function setTargetDefaultPolicyAllow(address target, bool defaultAllow) external;\\n\\n  /**\\n   * @notice Runs the policies for a given payload for offchain pre-validation. MUST revert on policy rejection/failure.\\n   * @param payload The payload to run the policies on.\\n   */\\n  function check(Payload calldata payload) external view;\\n\\n  /**\\n   * @notice Runs the policies for a given operation payload.\\n   *\\n   * - MUST revert on policy rejection/failure.\\n   * - MUST revert if the target contract that invoked the method is not allowed. Target contract address is\\n   *   obtained from the msg.sender global variable.\\n   * - MUST execute policies in the order they were added or that were specified using `addPolicyAt`.\\n   *\\n   * @param payload The payload to run the policies on.\\n   */\\n  function run(Payload calldata payload) external;\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"}}}"
