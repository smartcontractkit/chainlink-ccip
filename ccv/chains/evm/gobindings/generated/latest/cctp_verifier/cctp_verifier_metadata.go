// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.


package cctp_verifier

var SolidityStandardInput = "{\"version\":\"v0.8.26+commit.8a97fa7a\",\"language\":\"Solidity\",\"settings\":{\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"appendCBOR\":true,\"bytecodeHash\":\"none\",\"useLiteralContent\":false},\"optimizer\":{\"enabled\":true,\"runs\":80000},\"outputSelection\":{\"contracts/ccvs/CCTPVerifier.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/ccvs/components/BaseVerifier.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/interfaces/ICrossChainVerifierV1.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/interfaces/IRMNRemote.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/interfaces/IRouter.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/libraries/Client.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/libraries/Internal.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/libraries/MessageV1Codec.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/pools/USDC/CCTPMessageTransmitterProxy.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/pools/USDC/interfaces/IMessageTransmitter.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/pools/USDC/interfaces/ITokenMessenger.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2Step.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2StepMsgSender.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/IOwnable.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/ITypeAndVersion.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-4.8.3/token/ERC20/IERC20.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-4.8.3/token/ERC20/extensions/draft-IERC20Permit.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-4.8.3/token/ERC20/utils/SafeERC20.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-4.8.3/utils/Address.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.0.2/utils/introspection/IERC165.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.0.2/utils/structs/EnumerableSet.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]}},\"remappings\":[\"forge-std/=node_modules/@chainlink/contracts/src/v0.8/vendor/forge-std/src/\",\"@chainlink/contracts/=node_modules/@chainlink/contracts/\",\"@openzeppelin/contracts@4.8.3/=node_modules/@openzeppelin/contracts-4.8.3/\",\"@openzeppelin/contracts@5.0.2/=node_modules/@openzeppelin/contracts-5.0.2/\",\"@arbitrum/=node_modules/@arbitrum/\",\"@eth-optimism/=node_modules/@eth-optimism/\",\"@offchainlabs/=node_modules/@offchainlabs/\",\"@scroll-tech/=node_modules/@scroll-tech/\",\"@zksync/=node_modules/@zksync/\",\"solady/=node_modules/solady/\"],\"viaIR\":true},\"sources\":{\"contracts/ccvs/CCTPVerifier.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\nimport {ICrossChainVerifierV1} from \\\"../interfaces/ICrossChainVerifierV1.sol\\\";\\nimport {IMessageTransmitter} from \\\"../pools/USDC/interfaces/IMessageTransmitter.sol\\\";\\nimport {ITokenMessenger} from \\\"../pools/USDC/interfaces/ITokenMessenger.sol\\\";\\n\\nimport {MessageV1Codec} from \\\"../libraries/MessageV1Codec.sol\\\";\\nimport {CCTPMessageTransmitterProxy} from \\\"../pools/USDC/CCTPMessageTransmitterProxy.sol\\\";\\nimport {BaseVerifier} from \\\"./components/BaseVerifier.sol\\\";\\nimport {Ownable2StepMsgSender} from \\\"@chainlink/contracts/src/v0.8/shared/access/Ownable2StepMsgSender.sol\\\";\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts@4.8.3/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts@4.8.3/token/ERC20/utils/SafeERC20.sol\\\";\\n\\n/// @notice The CCTPVerifier creates USDC burn messages on source and delivers them on destination.\\n/// @dev This verifier is for CCTP V2 and is not backwards compatible with CCTP V1.\\ncontract CCTPVerifier is Ownable2StepMsgSender, BaseVerifier {\\n  using SafeERC20 for IERC20;\\n\\n  error InvalidCCVData();\\n  error InvalidCCVVersion(bytes4 expected, bytes4 got);\\n  error InvalidMessageTransmitterOnProxy(address expected, address got);\\n  error InvalidMessageTransmitterVersion(uint32 expected, uint32 got);\\n  error InvalidReceiver(bytes receiver);\\n  error InvalidTokenMessengerVersion(uint32 expected, uint32 got);\\n  error InvalidMessageId(bytes32 expected, bytes32 got);\\n  error InvalidMessageSender(bytes32 expected, bytes32 got);\\n  error InvalidMessageVersion(uint32 expected, uint32 got);\\n  error InvalidToken(bytes token);\\n  error InvalidTokenTransferLength(uint256 length);\\n  error MaxFeeExceedsUint32(uint256 maxFee);\\n  error OnlyCallableByOwnerOrAllowlistAdmin();\\n  error ReceiveMessageCallFailed();\\n  error InvalidFastFinalityBps(uint16 fastFinalityBps);\\n  error InvalidSetDomainArgs(SetDomainArgs args);\\n  error UnknownDomain(uint64 chainSelector);\\n  error UnsupportedFinality(uint32 finality);\\n  error ZeroAddressNotAllowed();\\n\\n  event DomainsSet(SetDomainArgs[] domains);\\n  event DynamicConfigSet(DynamicConfig dynamicConfig);\\n  event StaticConfigSet(\\n    address tokenMessenger, address messageTransmitterProxy, address usdcToken, uint32 localDomainIdentifier\\n  );\\n\\n  /// @notice The static configuration.\\n  struct StaticConfig {\\n    address tokenMessenger; // The address of the token messenger.\\n    address messageTransmitterProxy; // The address of the message transmitter proxy.\\n    address usdcToken; // The address of the USDC token.\\n    uint32 localDomainIdentifier; // The local domain identifier.\\n  }\\n\\n  /// @notice The arguments required to update a remote domain.\\n  struct SetDomainArgs {\\n    bytes32 allowedCallerOnDest; // Address allowed to call receiveMessage on the domain (i.e. the MessageTransmitterProxy).\\n    bytes32 allowedCallerOnSource; // Address allowed to call depositForBurn on the domain (i.e. the TokenMessengerProxy).\\n    bytes32 mintRecipientOnDest; // Address to mint USDC to on the destination chain.\\n    uint64 chainSelector; // The corresponding CCIP destination chain selector for the domain.\\n    uint32 domainIdentifier; // Unique domain ID used across CCTP.\\n    bool enabled; // Whether or not the domain is enabled.\\n  }\\n\\n  /// @notice Parameters for _depositForBurn (stack too deep measure).\\n  struct DepositForBurnParams {\\n    bytes32 messageId; // The message ID of the CCIP message.\\n    uint32 finality; // The finality of the CCIP message.\\n    uint32 finalityThreshold; // The CCTP finality threshold.\\n  }\\n\\n  /// @notice A domain is a CCTP-specific representation of a destination chain.\\n  /// @dev Zero is a valid domain identifier.\\n  struct Domain {\\n    bytes32 allowedCallerOnDest; // Address allowed to call receiveMessage on the domain (i.e. the MessageTransmitterProxy).\\n    bytes32 allowedCallerOnSource; // Address allowed to call depositForBurn on the domain (i.e. the TokenMessengerProxy).\\n    bytes32 mintRecipientOnDest; // Address to mint USDC to on the destination chain.\\n    uint32 domainIdentifier; // ─╮ Unique domain ID used across CCTP.\\n    bool enabled; // ────────────╯ Whether or not the domain is enabled.\\n  }\\n\\n  /// @notice Dynamic configuration for this chain.\\n  struct DynamicConfig {\\n    address feeAggregator; // ──╮ Address to which fees are withdrawn.\\n    address allowlistAdmin; //  | Address permitted to update the allowlist (in addition to the owner).\\n    uint16 fastFinalityBps; // ─╯ Basis points charged for fast finality on destination.\\n  }\\n\\n  string public constant override typeAndVersion = \\\"CCTPVerifier 1.7.0-dev\\\";\\n  /// @notice The preimage is bytes4(keccak256(\\\"CCTPVerifier 1.7.0\\\")).\\n  bytes4 private constant VERSION_TAG_V1_7_0 = 0x8e1d1a9d;\\n  /// @notice CCTP contracts use the number 1 to represent V2, as 0 represents V1.\\n  uint32 private constant SUPPORTED_CCTP_VERSION = 1;\\n  /// @notice The division factor for basis points. This also represents the maximum bps fee.\\n  uint16 private constant BPS_DIVIDER = 10_000;\\n  /// @notice The length of a CCTP message, including the message body + hook data expected by this verifier.\\n  /// @dev Message format.\\n  ///     * Field                      Bytes      Type       Index\\n  ///     * version                    4          uint32     0\\n  ///     * sourceDomain               4          uint32     4\\n  ///     * destinationDomain          4          uint32     8\\n  ///     * nonce                      32         bytes32   12\\n  ///     * sender                     32         bytes32   44\\n  ///     * recipient                  32         bytes32   76\\n  ///     * destinationCaller          32         bytes32   108\\n  ///     * minFinalityThreshold       4          uint32    140\\n  ///     * finalityThresholdExecuted  4          uint32    144\\n  ///     * messageBody                dynamic    bytes     148\\n  /// @dev CCTP burn message body format.\\n  ///     * Field                      Bytes      Type       Index\\n  ///     * version                    4          uint32     0\\n  ///     * burnToken                  32         bytes32    4\\n  ///     * mintRecipient              32         bytes32    36\\n  ///     * amount                     32         uint256    68\\n  ///     * messageSender              32         bytes32    100\\n  ///     * maxFee                     32         uint256    132\\n  ///     * feeExecuted                32         uint256    164\\n  ///     * expirationBlock            32         uint256    196\\n  ///     * hookData                   dynamic    bytes      228\\n  /// @dev Hook data format.\\n  ///     * Field                      Bytes      Type       Index\\n  ///     * verifierVersion            4          bytes4     0\\n  ///     * messageId                  32         bytes32    4\\n  /// @dev Total CCTP message bytes = (4 * 3) + (32 * 4) + (4 * 2) + 4 + (32 * 7) + 4 + 32 = 412.\\n  uint256 private constant CCTP_MESSAGE_SIZE = 412;\\n  /// @notice The number of bytes in the verifier version.\\n  /// @dev We include the verifier version in the prefix to enable compatibility with version-based proxy contracts.\\n  /// We also include it within the hook data to ensure that it gets signed by the attestation service.\\n  uint256 private constant VERIFIER_VERSION_SIZE = 4;\\n  /// @notice Total CCV data bytes = VERIFIER_VERSION_SIZE + CCTP_MESSAGE_SIZE + 65 (ECDSA signature with recovery byte).\\n  /// CCTP message transmitter requires a minimum signature threshold of 1, so we account for at least one signature here.\\n  uint256 private constant MINIMUM_CCV_DATA_SIZE = VERIFIER_VERSION_SIZE + CCTP_MESSAGE_SIZE + 65;\\n  /// @notice The starting index of the messageSender in the CCV data.\\n  uint256 private constant MESSAGE_SENDER_START = VERIFIER_VERSION_SIZE + 148 + 100;\\n  /// @notice The starting index of the verifier version (hook data location) in the CCV data.\\n  uint256 private constant VERIFIER_VERSION_START = VERIFIER_VERSION_SIZE + 148 + 228;\\n  /// @notice The starting index of the message ID in the CCV data.\\n  uint256 private constant MESSAGE_ID_START = VERIFIER_VERSION_SIZE + 148 + 228 + VERIFIER_VERSION_SIZE;\\n  /// @notice The standard finality threshold for CCTP.\\n  /// @dev Used when CCIP finality == 0 (i.e. the default value).\\n  uint32 private constant CCTP_STANDARD_FINALITY_THRESHOLD = 2000;\\n  /// @notice The fast finality threshold for CCTP.\\n  /// @dev Used when CCIP finality \\u003e 0.\\n  uint32 private constant CCTP_FAST_FINALITY_THRESHOLD = 1000;\\n\\n  /// @notice The USDC token contract.\\n  IERC20 private immutable i_usdcToken;\\n  /// @notice The message transmitter proxy, which is used on destination as a non-upgradeable caller of all CCTP messages.\\n  /// @dev Instead of calling receiveMessage directly, we use a proxy to enable upgrades to the verifier without invalidating in-flight messages.\\n  /// CCTP messages define an address permitted to call receiveMessage, which will always be the message transmitter proxy.\\n  CCTPMessageTransmitterProxy private immutable i_messageTransmitterProxy;\\n  /// @notice The token messenger, which is used on source to send USDC over CCTP.\\n  /// @dev The token messenger calls into the message transmitter after burning USDC and forming the app-specific message body.\\n  ITokenMessenger private immutable i_tokenMessenger; // TODO: Update to TokenMessengerProxy when available.\\n  /// @notice The local domain identifier, i.e. a CCTP-specific identifier for the chain to which this contract is deployed.\\n  uint32 private immutable i_localDomainIdentifier;\\n\\n  /// @notice A mapping of CCIP chain selectors to CCTP domain configurations.\\n  mapping(uint64 remoteChainSelector =\\u003e Domain cctpDomain) private s_chainToDomain;\\n  /// @notice The dynamic configuration.\\n  DynamicConfig private s_dynamicConfig;\\n\\n  constructor(\\n    ITokenMessenger tokenMessenger,\\n    CCTPMessageTransmitterProxy messageTransmitterProxy,\\n    IERC20 usdcToken,\\n    string memory storageLocation,\\n    DynamicConfig memory dynamicConfig\\n  ) BaseVerifier(storageLocation) {\\n    if (\\n      address(tokenMessenger) == address(0) || address(messageTransmitterProxy) == address(0)\\n        || address(usdcToken) == address(0)\\n    ) revert ZeroAddressNotAllowed();\\n\\n    // Ensure that the token messenger is for CCTP.\\n    uint32 tokenMessengerVersion = tokenMessenger.messageBodyVersion();\\n    if (tokenMessengerVersion != SUPPORTED_CCTP_VERSION) {\\n      revert InvalidTokenMessengerVersion(SUPPORTED_CCTP_VERSION, tokenMessengerVersion);\\n    }\\n\\n    // Ensure that the message transmitter is for CCTP.\\n    IMessageTransmitter messageTransmitter = IMessageTransmitter(tokenMessenger.localMessageTransmitter());\\n    uint32 messageTransmitterVersion = messageTransmitter.version();\\n    if (messageTransmitterVersion != SUPPORTED_CCTP_VERSION) {\\n      revert InvalidMessageTransmitterVersion(SUPPORTED_CCTP_VERSION, messageTransmitterVersion);\\n    }\\n\\n    // Ensure that the message transmitter on the proxy is the same as the message transmitter on the token messenger.\\n    address messageTransmitterOnProxy = address(messageTransmitterProxy.i_cctpTransmitter());\\n    if (messageTransmitterOnProxy != address(messageTransmitter)) {\\n      revert InvalidMessageTransmitterOnProxy(address(messageTransmitter), messageTransmitterOnProxy);\\n    }\\n\\n    // Set the immutable state variables.\\n    i_tokenMessenger = tokenMessenger;\\n    i_messageTransmitterProxy = messageTransmitterProxy;\\n    i_localDomainIdentifier = messageTransmitter.localDomain();\\n    i_usdcToken = usdcToken;\\n\\n    // Approve the token messenger to burn the USDC token on behalf of this contract.\\n    // The USDC token pool will be responsible for forwarding USDC it receives from the router to this contract.\\n    i_usdcToken.safeIncreaseAllowance(address(i_tokenMessenger), type(uint256).max);\\n\\n    emit StaticConfigSet(\\n      address(i_tokenMessenger), address(i_messageTransmitterProxy), address(i_usdcToken), i_localDomainIdentifier\\n    );\\n\\n    _setDynamicConfig(dynamicConfig);\\n  }\\n\\n  /// @inheritdoc ICrossChainVerifierV1\\n  function forwardToVerifier(\\n    MessageV1Codec.MessageV1 calldata message,\\n    bytes32 messageId,\\n    address, // feeToken\\n    uint256, // feeTokenAmount\\n    bytes calldata // verifierArgs\\n  ) external returns (bytes memory verifierReturnData) {\\n    // For EVM, sender is expected to be 20 bytes.\\n    _assertSenderIsAllowed(message.destChainSelector, address(bytes20(message.sender)));\\n\\n    Domain storage domain = s_chainToDomain[message.destChainSelector];\\n    if (!domain.enabled) revert UnknownDomain(message.destChainSelector);\\n\\n    // We expect exactly one token transfer per message.\\n    if (message.tokenTransfer.length != 1) revert InvalidTokenTransferLength(message.tokenTransfer.length);\\n\\n    MessageV1Codec.TokenTransferV1 memory tokenTransfer = message.tokenTransfer[0];\\n    // The address of the token transferred must correspond to USDC.\\n    if (address(bytes20(tokenTransfer.sourceTokenAddress)) != address(i_usdcToken)) {\\n      revert InvalidToken(tokenTransfer.sourceTokenAddress);\\n    }\\n\\n    if (tokenTransfer.tokenReceiver.length \\u003e 32) {\\n      revert InvalidReceiver(tokenTransfer.tokenReceiver);\\n    }\\n\\n    bytes32 decodedReceiver;\\n    // For EVM chains, the mintRecipient is not used.\\n    // Solana requires it, as the mintRecipient will be a PDA owned by the pool.\\n    // The PDA will forward the tokens to their final destination after minting.\\n    if (domain.mintRecipientOnDest != bytes32(0)) {\\n      decodedReceiver = domain.mintRecipientOnDest;\\n    } else {\\n      decodedReceiver =\\n        bytes32(uint256(bytes32(tokenTransfer.tokenReceiver)) \\u003e\\u003e (256 - tokenTransfer.tokenReceiver.length * 8));\\n    }\\n\\n    DepositForBurnParams memory params = DepositForBurnParams({\\n      messageId: messageId,\\n      finality: message.finality,\\n      finalityThreshold: CCTP_STANDARD_FINALITY_THRESHOLD\\n    });\\n\\n    uint256 maxFee;\\n    if (params.finality != 0) {\\n      params.finalityThreshold = CCTP_FAST_FINALITY_THRESHOLD;\\n\\n      // The maximum fee, taken on destination, is a percentage of the total amount transferred.\\n      // We use bps to calculate the smallest possible value that we can set as the max fee.\\n      // The bps values configured for each finality threshold on this chain must mirror those used by CCTP.\\n      // CCTP defines different bps values for each chain.\\n      maxFee = tokenTransfer.amount * s_dynamicConfig.fastFinalityBps / BPS_DIVIDER;\\n      if (maxFee \\u003e type(uint32).max) revert MaxFeeExceedsUint32(maxFee);\\n    }\\n\\n    i_tokenMessenger.depositForBurnWithHook(\\n      tokenTransfer.amount,\\n      domain.domainIdentifier,\\n      decodedReceiver,\\n      address(i_usdcToken),\\n      domain.allowedCallerOnDest,\\n      uint32(maxFee),\\n      params.finalityThreshold,\\n      // The hook data includes the version tag and the message ID.\\n      // The version tag allows the destination verifier entity to route the message to the correct implementation.\\n      // Inclusion of the message ID ensures that the contents of the CCIP message can't be tampered with on destination.\\n      bytes.concat(VERSION_TAG_V1_7_0, params.messageId)\\n    );\\n\\n    // We do not return the verifier version here.\\n    // Offchain verifier is expected to pull verifier version from the hook data \\u0026 prefix the ccvData with it.\\n    return \\\"\\\";\\n  }\\n\\n  /// @inheritdoc ICrossChainVerifierV1\\n  function verifyMessage(MessageV1Codec.MessageV1 memory message, bytes32 messageHash, bytes calldata ccvData) external {\\n    if (ccvData.length \\u003c MINIMUM_CCV_DATA_SIZE) revert InvalidCCVData();\\n\\n    bytes4 versionPrefix = bytes4(ccvData[:VERIFIER_VERSION_SIZE]);\\n    if (versionPrefix != VERSION_TAG_V1_7_0) revert InvalidCCVVersion(VERSION_TAG_V1_7_0, versionPrefix);\\n\\n    // The attested version is the first 4 bytes of the hook data, which occupies the last 36 bytes of the CCTP message.\\n    // We exclude the last 32 bytes of the hook data, which contains the message ID, to get the version.\\n    bytes4 attestedVersion = bytes4(ccvData[VERIFIER_VERSION_START:VERIFIER_VERSION_START + VERIFIER_VERSION_SIZE]);\\n    if (attestedVersion != VERSION_TAG_V1_7_0) revert InvalidCCVVersion(VERSION_TAG_V1_7_0, attestedVersion);\\n\\n    // The attested message ID should match the hash passed into this function.\\n    // If not, there is a mismatch between what was attested and what was computed within this transaction.\\n    bytes32 messageId = bytes32(ccvData[MESSAGE_ID_START:MESSAGE_ID_START + 32]);\\n    if (messageHash != messageId) revert InvalidMessageId(messageHash, messageId);\\n\\n    Domain storage sourceDomain = s_chainToDomain[message.sourceChainSelector];\\n    if (!sourceDomain.enabled) revert UnknownDomain(message.sourceChainSelector);\\n\\n    // The messageSender property of the messageBody must align with the allowedCallerOnSource.\\n    // This check is critical to ensure that CCIP is unable to process burn messages generated by other systems.\\n    bytes32 messageSender = bytes32(ccvData[MESSAGE_SENDER_START:MESSAGE_SENDER_START + 32]);\\n    if (messageSender != sourceDomain.allowedCallerOnSource) {\\n      revert InvalidMessageSender(sourceDomain.allowedCallerOnSource, messageSender);\\n    }\\n\\n    // Call into CCTP via the message transmitter proxy.\\n    // CCTP will validate signatures against the message before minting USDC.\\n    // Attestation occupies all bytes following the CCTP message.\\n    if (\\n      !i_messageTransmitterProxy.receiveMessage(\\n        ccvData[VERIFIER_VERSION_SIZE:VERIFIER_VERSION_SIZE + CCTP_MESSAGE_SIZE],\\n        ccvData[VERIFIER_VERSION_SIZE + CCTP_MESSAGE_SIZE:]\\n      )\\n    ) {\\n      revert ReceiveMessageCallFailed();\\n    }\\n  }\\n\\n  // ================================================================\\n  // │                           Config                             │\\n  // ================================================================\\n\\n  /// @notice Returns the static configuration.\\n  /// @return staticConfig The static configuration.\\n  function getStaticConfig() external view returns (StaticConfig memory staticConfig) {\\n    return StaticConfig({\\n      tokenMessenger: address(i_tokenMessenger),\\n      messageTransmitterProxy: address(i_messageTransmitterProxy),\\n      usdcToken: address(i_usdcToken),\\n      localDomainIdentifier: i_localDomainIdentifier\\n    });\\n  }\\n\\n  /// @notice Returns the dynamic configuration.\\n  /// @return dynamicConfig The dynamic configuration.\\n  function getDynamicConfig() external view returns (DynamicConfig memory dynamicConfig) {\\n    return s_dynamicConfig;\\n  }\\n\\n  /// @notice Sets the dynamic configuration.\\n  /// @param dynamicConfig The dynamic configuration.\\n  function setDynamicConfig(\\n    DynamicConfig memory dynamicConfig\\n  ) external onlyOwner {\\n    _setDynamicConfig(dynamicConfig);\\n  }\\n\\n  /// @notice Sets the dynamic configuration.\\n  /// @param dynamicConfig The dynamic configuration.\\n  function _setDynamicConfig(\\n    DynamicConfig memory dynamicConfig\\n  ) private {\\n    if (dynamicConfig.feeAggregator == address(0)) revert ZeroAddressNotAllowed();\\n    if (dynamicConfig.fastFinalityBps == 0 || dynamicConfig.fastFinalityBps \\u003e BPS_DIVIDER) {\\n      revert InvalidFastFinalityBps(dynamicConfig.fastFinalityBps);\\n    }\\n\\n    s_dynamicConfig = dynamicConfig;\\n\\n    emit DynamicConfigSet(dynamicConfig);\\n  }\\n\\n  /// @notice Gets the CCTP domain for a given CCIP chain selector.\\n  /// @param chainSelector The CCIP chain selector corresponding to the domain.\\n  /// @return domain The CCTP domain corresponding to the given chain selector.\\n  function getDomain(\\n    uint64 chainSelector\\n  ) external view returns (Domain memory) {\\n    return s_chainToDomain[chainSelector];\\n  }\\n\\n  /// @notice Sets the CCTP domain for a CCIP chain selector.\\n  /// @param domains The array of SetDomainArgs structs to set.\\n  /// @dev Must validate mapping of selectors -\\u003e (domain, caller) prior to calling this function.\\n  function setDomains(\\n    SetDomainArgs[] calldata domains\\n  ) external onlyOwner {\\n    for (uint256 i = 0; i \\u003c domains.length; ++i) {\\n      SetDomainArgs memory domain = domains[i];\\n      if (\\n        domain.allowedCallerOnDest == bytes32(0) || domain.allowedCallerOnSource == bytes32(0)\\n          || domain.chainSelector == 0\\n      ) {\\n        revert InvalidSetDomainArgs(domain);\\n      }\\n\\n      s_chainToDomain[domain.chainSelector] = Domain({\\n        allowedCallerOnDest: domain.allowedCallerOnDest,\\n        allowedCallerOnSource: domain.allowedCallerOnSource,\\n        mintRecipientOnDest: domain.mintRecipientOnDest,\\n        domainIdentifier: domain.domainIdentifier,\\n        enabled: domain.enabled\\n      });\\n    }\\n\\n    emit DomainsSet(domains);\\n  }\\n\\n  /// @notice Updates destination chain configurations.\\n  /// @param destChainConfigArgs Array of destination chain configurations.\\n  function applyDestChainConfigUpdates(\\n    DestChainConfigArgs[] calldata destChainConfigArgs\\n  ) external onlyOwner {\\n    _applyDestChainConfigUpdates(destChainConfigArgs);\\n  }\\n\\n  /// @notice Updates senders that are allowed to use this verifier.\\n  /// @param allowlistConfigArgsItems Array of AllowListConfigArgs, where each item is for a destChainSelector.\\n  function applyAllowlistUpdates(\\n    AllowlistConfigArgs[] calldata allowlistConfigArgsItems\\n  ) external {\\n    if (msg.sender != owner()) {\\n      if (msg.sender != s_dynamicConfig.allowlistAdmin) {\\n        revert OnlyCallableByOwnerOrAllowlistAdmin();\\n      }\\n    }\\n\\n    _applyAllowlistUpdates(allowlistConfigArgsItems);\\n  }\\n\\n  /// @notice Updates the storage location identifier.\\n  /// @param newLocation The new storage location identifier.\\n  function updateStorageLocation(\\n    string memory newLocation\\n  ) external onlyOwner {\\n    _setStorageLocation(newLocation);\\n  }\\n\\n  /// @notice Exposes the version tag.\\n  function versionTag() public pure returns (bytes4) {\\n    return VERSION_TAG_V1_7_0;\\n  }\\n\\n  // ================================================================\\n  // │                             Fees                             │\\n  // ================================================================\\n\\n  /// @notice Withdraws the outstanding fee token balances to the fee aggregator.\\n  /// @dev This function can be permissionless as just transfers tokens to a trusted address.\\n  /// @param feeTokens The fee tokens to withdraw.\\n  function withdrawFeeTokens(\\n    address[] calldata feeTokens\\n  ) external {\\n    _withdrawFeeTokens(feeTokens, s_dynamicConfig.feeAggregator);\\n  }\\n}\\n\"},\"contracts/ccvs/components/BaseVerifier.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\nimport {ICrossChainVerifierV1} from \\\"../../interfaces/ICrossChainVerifierV1.sol\\\";\\nimport {IRMNRemote} from \\\"../../interfaces/IRMNRemote.sol\\\";\\nimport {IRouter} from \\\"../../interfaces/IRouter.sol\\\";\\nimport {ITypeAndVersion} from \\\"@chainlink/contracts/src/v0.8/shared/interfaces/ITypeAndVersion.sol\\\";\\n\\nimport {Client} from \\\"../../libraries/Client.sol\\\";\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts@4.8.3/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts@4.8.3/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {IERC165} from \\\"@openzeppelin/contracts@5.0.2/utils/introspection/IERC165.sol\\\";\\nimport {EnumerableSet} from \\\"@openzeppelin/contracts@5.0.2/utils/structs/EnumerableSet.sol\\\";\\n\\nabstract contract BaseVerifier is ICrossChainVerifierV1, ITypeAndVersion {\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n  using SafeERC20 for IERC20;\\n\\n  error CursedByRMN(uint64 destChainSelector);\\n  error InvalidDestChainConfig(uint64 destChainSelector);\\n  error DestGasCannotBeZero(uint64 destChainSelector);\\n  error InvalidAllowListRequest(uint64 destChainSelector);\\n  error SenderNotAllowed(address sender);\\n  error CallerIsNotARampOnRouter(address caller);\\n  error DestinationNotSupported(uint64 destChainSelector);\\n\\n  event FeeTokenWithdrawn(address indexed receiver, address indexed feeToken, uint256 amount);\\n  event DestChainConfigSet(uint64 indexed destChainSelector, address router, bool allowlistEnabled);\\n  event AllowListSendersAdded(uint64 indexed destChainSelector, address[] senders);\\n  event AllowListSendersRemoved(uint64 indexed destChainSelector, address[] senders);\\n  event StorageLocationUpdated(string oldLocation, string newLocation);\\n\\n  struct DestChainConfig {\\n    IRouter router; // ──────────╮ Local router to use for messages going to this dest chain.\\n    uint16 feeUSDCents; //       │ The fee in US dollar cents for messages to this dest chain. [0, $655.35]\\n    uint32 gasForVerification; //│ The gas to reserve for verification of messages on the dest chain.\\n    uint32 payloadSizeBytes; //  │ The size of the verification payload on the dest chain.\\n    bool allowlistEnabled; // ───╯ True if the allowlist is enabled.\\n    EnumerableSet.AddressSet allowedSendersList; // The list of addresses allowed to send messages.\\n  }\\n\\n  struct DestChainConfigArgs {\\n    IRouter router; // ──────────╮ Local router to use for messages going to this dest chain.\\n    uint64 destChainSelector; // │ Destination chain selector.\\n    bool allowlistEnabled; //    │ True if the allowlist is enabled.\\n    uint16 feeUSDCents; // ──────╯ The fee in US dollar cents for messages to this dest chain.\\n    uint32 gasForVerification; // ─╮ The gas to reserve for verification of messages on the dest chain.\\n    uint32 payloadSizeBytes; // ───╯ The size of the verification payload on the dest chain.\\n  }\\n\\n  /// @dev Struct to hold the allowlist configuration args per dest chain.\\n  struct AllowlistConfigArgs {\\n    uint64 destChainSelector; // ─╮ Destination chain selector.\\n    bool allowlistEnabled; // ────╯ True if the allowlist is enabled.\\n    address[] addedAllowlistedSenders; // list of senders to be added to the allowedSendersList.\\n    address[] removedAllowlistedSenders; // list of senders to be removed from the allowedSendersList.\\n  }\\n\\n  /// @dev The rmn contract.\\n  IRMNRemote internal immutable i_rmnRemote;\\n\\n  /// @dev The destination chain specific configs.\\n  mapping(uint64 destChainSelector =\\u003e DestChainConfig destChainConfig) private s_destChainConfigs;\\n\\n  /// @dev The storage location for off-chain components to read from. Implementations of the BaseVerifier should\\n  /// implement a way to update this value if needed.\\n  string internal s_storageLocation;\\n\\n  constructor(\\n    string memory storageLocation\\n  ) {\\n    _setStorageLocation(storageLocation);\\n  }\\n\\n  /// @notice Updates the storage location.\\n  /// @param storageLocation The new storage location.\\n  function _setStorageLocation(\\n    string memory storageLocation\\n  ) internal {\\n    string memory oldLocation = s_storageLocation;\\n    s_storageLocation = storageLocation;\\n    emit StorageLocationUpdated(oldLocation, storageLocation);\\n  }\\n\\n  /// @inheritdoc ICrossChainVerifierV1\\n  function getStorageLocation() external view virtual override returns (string memory) {\\n    return s_storageLocation;\\n  }\\n\\n  /// @notice get ChainConfig configured for the DestinationChainSelector.\\n  /// @param destChainSelector The destination chain selector.\\n  /// @return allowlistEnabled boolean indicator to specify if allowlist check is enabled.\\n  /// @return router address of the local router.\\n  /// @return allowedSendersList list of addresses that are allowed to send messages to the destination chain.\\n  function getDestChainConfig(\\n    uint64 destChainSelector\\n  ) external view virtual returns (bool allowlistEnabled, address router, address[] memory allowedSendersList) {\\n    DestChainConfig storage config = _getDestChainConfig(destChainSelector);\\n    allowlistEnabled = config.allowlistEnabled;\\n    router = address(config.router);\\n    allowedSendersList = config.allowedSendersList.values();\\n    return (allowlistEnabled, router, allowedSendersList);\\n  }\\n\\n  function _getDestChainConfig(\\n    uint64 destChainSelector\\n  ) internal view virtual returns (DestChainConfig storage) {\\n    return s_destChainConfigs[destChainSelector];\\n  }\\n\\n  /// @notice Internal version of applyDestChainConfigUpdates.\\n  /// @dev the function that calls this has to ensure proper access control is in place.\\n  function _applyDestChainConfigUpdates(\\n    DestChainConfigArgs[] memory destChainConfigArgs\\n  ) internal virtual {\\n    for (uint256 i = 0; i \\u003c destChainConfigArgs.length; ++i) {\\n      DestChainConfigArgs memory destChainConfigArg = destChainConfigArgs[i];\\n      uint64 destChainSelector = destChainConfigArgs[i].destChainSelector;\\n\\n      if (destChainSelector == 0) {\\n        revert InvalidDestChainConfig(destChainSelector);\\n      }\\n\\n      DestChainConfig storage destChainConfig = s_destChainConfigs[destChainSelector];\\n      // The router can be zero to pause the destination chain\\n      destChainConfig.router = destChainConfigArg.router;\\n      destChainConfig.allowlistEnabled = destChainConfigArg.allowlistEnabled;\\n      destChainConfig.feeUSDCents = destChainConfigArg.feeUSDCents;\\n      // The call can never cost 0 gas.\\n      if (destChainConfigArg.gasForVerification == 0) {\\n        revert DestGasCannotBeZero(destChainSelector);\\n      }\\n      destChainConfig.gasForVerification = destChainConfigArg.gasForVerification;\\n      // The payload could be zero bytes if no offchain data is required.\\n      destChainConfig.payloadSizeBytes = destChainConfigArg.payloadSizeBytes;\\n\\n      emit DestChainConfigSet(destChainSelector, address(destChainConfigArg.router), destChainConfig.allowlistEnabled);\\n    }\\n  }\\n\\n  function _assertSenderIsAllowed(uint64 destChainSelector, address sender) internal view virtual {\\n    DestChainConfig storage destChainConfig = _getDestChainConfig(destChainSelector);\\n    if (address(destChainConfig.router) == address(0)) {\\n      revert DestinationNotSupported(destChainSelector);\\n    }\\n    // CCVs should query the OnRamp address from the router, this allows for OnRamp updates without touching CCVs\\n    // OnRamp address may be zero intentionally to pause, which should stop all messages.\\n    if (msg.sender != destChainConfig.router.getOnRamp(destChainSelector)) {\\n      revert CallerIsNotARampOnRouter(msg.sender);\\n    }\\n\\n    if (destChainConfig.allowlistEnabled) {\\n      if (!destChainConfig.allowedSendersList.contains(sender)) {\\n        revert SenderNotAllowed(sender);\\n      }\\n    }\\n  }\\n\\n  /// @notice Updates the allowlist for the destination chain.\\n  /// @param allowlistConfigArgsItems Array of AllowlistConfigArguments where each item is for a destChainSelector.\\n  function _applyAllowlistUpdates(\\n    AllowlistConfigArgs[] calldata allowlistConfigArgsItems\\n  ) internal virtual {\\n    for (uint256 i = 0; i \\u003c allowlistConfigArgsItems.length; ++i) {\\n      AllowlistConfigArgs memory allowlistConfigArgs = allowlistConfigArgsItems[i];\\n\\n      DestChainConfig storage destChainConfig = s_destChainConfigs[allowlistConfigArgs.destChainSelector];\\n      destChainConfig.allowlistEnabled = allowlistConfigArgs.allowlistEnabled;\\n\\n      if (allowlistConfigArgs.addedAllowlistedSenders.length \\u003e 0) {\\n        if (allowlistConfigArgs.allowlistEnabled) {\\n          for (uint256 j = 0; j \\u003c allowlistConfigArgs.addedAllowlistedSenders.length; ++j) {\\n            address toAdd = allowlistConfigArgs.addedAllowlistedSenders[j];\\n            if (toAdd == address(0)) {\\n              revert InvalidAllowListRequest(allowlistConfigArgs.destChainSelector);\\n            }\\n            destChainConfig.allowedSendersList.add(toAdd);\\n          }\\n\\n          emit AllowListSendersAdded(allowlistConfigArgs.destChainSelector, allowlistConfigArgs.addedAllowlistedSenders);\\n        } else {\\n          revert InvalidAllowListRequest(allowlistConfigArgs.destChainSelector);\\n        }\\n      }\\n\\n      for (uint256 j = 0; j \\u003c allowlistConfigArgs.removedAllowlistedSenders.length; ++j) {\\n        destChainConfig.allowedSendersList.remove(allowlistConfigArgs.removedAllowlistedSenders[j]);\\n      }\\n\\n      if (allowlistConfigArgs.removedAllowlistedSenders.length \\u003e 0) {\\n        emit AllowListSendersRemoved(\\n          allowlistConfigArgs.destChainSelector, allowlistConfigArgs.removedAllowlistedSenders\\n        );\\n      }\\n    }\\n  }\\n\\n  /// @inheritdoc ICrossChainVerifierV1\\n  function getFee(\\n    uint64 destChainSelector,\\n    Client.EVM2AnyMessage memory, // message\\n    bytes memory, // extraArgs\\n    uint16 // blockConfirmations\\n  ) external view virtual returns (uint16 feeUSDCents, uint32 gasForVerification, uint32 payloadSizeBytes) {\\n    if (s_destChainConfigs[destChainSelector].router == IRouter(address(0))) {\\n      revert DestinationNotSupported(destChainSelector);\\n    }\\n    return (\\n      s_destChainConfigs[destChainSelector].feeUSDCents,\\n      s_destChainConfigs[destChainSelector].gasForVerification,\\n      s_destChainConfigs[destChainSelector].payloadSizeBytes\\n    );\\n  }\\n\\n  /// @notice Withdraws the outstanding fee token balances to the fee aggregator.\\n  /// @param feeTokens The fee tokens to withdraw.\\n  /// @param feeAggregator The address to withdraw the fee tokens to.\\n  function _withdrawFeeTokens(address[] calldata feeTokens, address feeAggregator) internal virtual {\\n    for (uint256 i = 0; i \\u003c feeTokens.length; ++i) {\\n      IERC20 feeToken = IERC20(feeTokens[i]);\\n      uint256 feeTokenBalance = feeToken.balanceOf(address(this));\\n\\n      if (feeTokenBalance \\u003e 0) {\\n        feeToken.safeTransfer(feeAggregator, feeTokenBalance);\\n\\n        emit FeeTokenWithdrawn(feeAggregator, address(feeToken), feeTokenBalance);\\n      }\\n    }\\n  }\\n\\n  /// @inheritdoc IERC165\\n  function supportsInterface(\\n    bytes4 interfaceId\\n  ) external pure virtual override returns (bool) {\\n    return interfaceId == type(ICrossChainVerifierV1).interfaceId || interfaceId == type(IERC165).interfaceId;\\n  }\\n}\\n\"},\"contracts/interfaces/ICrossChainVerifierV1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {Client} from \\\"../libraries/Client.sol\\\";\\nimport {MessageV1Codec} from \\\"../libraries/MessageV1Codec.sol\\\";\\n\\nimport {IERC165} from \\\"@openzeppelin/contracts@5.0.2/utils/introspection/IERC165.sol\\\";\\n\\ninterface ICrossChainVerifierV1 is IERC165 {\\n  /// @notice Verification of the message, in any way the OffRamp wants. This could be using a signature, a quorum\\n  /// of signatures, using native interop, or some ZK light client. Any proof required for the verification is supplied\\n  /// through the verifierResults parameter.\\n  /// @param message The message to be verified. For efficiency, the messageID is also supplied, which acts as a small\\n  /// payload that once verified means the entire message is verified. Every component of the message is part of the\\n  /// message ID through hashing the struct. The entire message is provided to be able to act differently for different\\n  /// message properties.\\n  /// @param messageId A convenient 32 byte hash of the entire message. It can be recomputed from the passed in message\\n  /// at the cost of a not-insignificant amount of gas. Any CCV MUST include the messageID or the entire message struct\\n  /// as part of its proof.\\n  /// @param verifierResults All the data that is specific to the CCV. This often means it contains some sort of proof, but it\\n  /// can also contain certain metadata like a nonce that's specific to the CCV. If any metadata like that exists and is\\n  /// important to the security of the CCV, it MUST be verified as well using the proof. A recommended way to do this is\\n  /// to encode a proof and the metadata separately in the verifierResults and then concatenate the messageId with this metadata\\n  /// to get the payload that will be verified. In the case of a simple signature verification this means that the CCV\\n  /// offchain system must sign the concatenated (messageId, ccvMetaData) and not just the messageId. If no metadata\\n  /// is required, simply signing the messageId is enough.\\n  function verifyMessage(\\n    MessageV1Codec.MessageV1 memory message,\\n    bytes32 messageId,\\n    bytes memory verifierResults\\n  ) external;\\n\\n  /// @notice Quotes the fee, including gas and calldata bytes, for a CCIP message to a destination chain.\\n  /// @dev This takes EVM2AnyMessage (instead of MessageV1) because the router client API that user contracts interact\\n  /// with exposes EVM2AnyMessage. The onRamp can translate to MessageV1 internally where required (e.g., verifier or\\n  /// executor hooks), but using EVM2AnyMessage here keeps the interface aligned with what clients construct and pass to\\n  /// the router.\\n  /// @param destChainSelector The destination chain selector of the message.\\n  /// @param message The message to be sent.\\n  /// @param extraArgs Opaque extra args that can be used by the fee quoter,\\n  /// @param blockConfirmations The user requested number of block confirmations.\\n  function getFee(\\n    uint64 destChainSelector,\\n    Client.EVM2AnyMessage memory message,\\n    bytes memory extraArgs,\\n    uint16 blockConfirmations\\n  ) external view returns (uint16 feeUSDCents, uint32 gasForVerification, uint32 payloadSizeBytes);\\n\\n  /// @notice Message sending, verifier hook.\\n  /// @param message Decoded MessageV1 structure for the message being sent.\\n  /// @param messageId The message ID of the message being sent.\\n  /// @param feeToken Fee token used for this message.\\n  /// @param feeTokenAmount Amount of fee token provided.\\n  /// @param verifierArgs Opaque verifier-specific arguments from the sender.\\n  /// @return verifierData Verifier-specific return data blob.\\n  function forwardToVerifier(\\n    MessageV1Codec.MessageV1 calldata message,\\n    bytes32 messageId,\\n    address feeToken,\\n    uint256 feeTokenAmount,\\n    bytes calldata verifierArgs\\n  ) external returns (bytes memory verifierData);\\n\\n  /// @notice Returns the storage location identifier for this CCV. This is a string that uniquely identifies the\\n  /// storage location. This can be an address, a URL, or any other identifier that makes sense for the CCV. The format\\n  /// of the string is up to the CCV implementer, but it should be something that can be easily parsed and used by the\\n  /// integrator. This is used by the executor(s) to know where to look for the proof data that the CCV has produced.\\n  function getStorageLocation() external view returns (string memory);\\n}\\n\"},\"contracts/interfaces/IRMNRemote.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {Internal} from \\\"../libraries/Internal.sol\\\";\\n\\n/// @notice This interface contains the only RMN-related functions that might be used on-chain by other CCIP contracts.\\ninterface IRMNRemote {\\n  /// @notice signature components from RMN nodes.\\n  struct Signature {\\n    bytes32 r;\\n    bytes32 s;\\n  }\\n\\n  /// @notice Verifies signatures of RMN nodes, on dest lane updates as provided in the CommitReport.\\n  /// @param offRampAddress is not inferred by msg.sender, in case the call is made through RMNProxy.\\n  /// @param merkleRoots must be well formed, and is a representation of the CommitReport received from the oracles.\\n  /// @param signatures rmnNodes ECDSA sigs, only r \\u0026 s, must be sorted in ascending order by signer address.\\n  /// @dev Will revert if verification fails.\\n  function verify(\\n    address offRampAddress,\\n    Internal.MerkleRoot[] memory merkleRoots,\\n    Signature[] memory signatures\\n  ) external view;\\n\\n  /// @notice gets the current set of cursed subjects.\\n  /// @return subjects the list of cursed subjects.\\n  function getCursedSubjects() external view returns (bytes16[] memory subjects);\\n\\n  /// @notice If there is an active global or legacy curse, this function returns true.\\n  /// @return bool true if there is an active global curse.\\n  function isCursed() external view returns (bool);\\n\\n  /// @notice If there is an active global curse, or an active curse for `subject`, this function returns true.\\n  /// @param subject To check whether a particular chain is cursed, set to bytes16(uint128(chainSelector)).\\n  /// @return bool true if the provided subject is cured *or* if there is an active global curse.\\n  function isCursed(\\n    bytes16 subject\\n  ) external view returns (bool);\\n}\\n\"},\"contracts/interfaces/IRouter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {Client} from \\\"../libraries/Client.sol\\\";\\n\\ninterface IRouter {\\n  error OnlyOffRamp();\\n\\n  /// @notice Route the message to its intended receiver contract.\\n  /// @param message Client.Any2EVMMessage struct.\\n  /// @param gasForCallExactCheck of params for exec.\\n  /// @param gasLimit set of params for exec.\\n  /// @param receiver set of params for exec.\\n  /// @dev if the receiver is a contracts that signals support for CCIP execution through EIP-165.\\n  /// the contract is called. If not, only tokens are transferred.\\n  /// @return success A boolean value indicating whether the ccip message was received without errors.\\n  /// @return retBytes A bytes array containing return data form CCIP receiver.\\n  /// @return gasUsed the gas used by the external customer call. Does not include any overhead.\\n  function routeMessage(\\n    Client.Any2EVMMessage calldata message,\\n    uint16 gasForCallExactCheck,\\n    uint256 gasLimit,\\n    address receiver\\n  ) external returns (bool success, bytes memory retBytes, uint256 gasUsed);\\n\\n  /// @notice Returns the configured onRamp for a specific destination chain.\\n  /// @param destChainSelector The destination chain Id to get the onRamp for.\\n  /// @return onRampAddress The address of the onRamp.\\n  function getOnRamp(\\n    uint64 destChainSelector\\n  ) external view returns (address onRampAddress);\\n\\n  /// @notice Return true if the given offRamp is a configured offRamp for the given source chain.\\n  /// @param sourceChainSelector The source chain selector to check.\\n  /// @param offRamp The address of the offRamp to check.\\n  function isOffRamp(uint64 sourceChainSelector, address offRamp) external view returns (bool isOffRamp);\\n}\\n\"},\"contracts/libraries/Client.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// End consumer library.\\nlibrary Client {\\n  struct EVMTokenAmount {\\n    address token; // token address on the local chain.\\n    uint256 amount; // Amount of tokens.\\n  }\\n\\n  struct Any2EVMMessage {\\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\\n    uint64 sourceChainSelector; // Source chain selector.\\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\\n    bytes data; // payload sent in original message.\\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\\n  }\\n\\n  // If extraArgs is empty bytes, the default is 200k gas limit.\\n  struct EVM2AnyMessage {\\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains.\\n    bytes data; // Data payload.\\n    EVMTokenAmount[] tokenAmounts; // Token transfers.\\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV3).\\n  }\\n\\n  /// @notice Tag to indicate no execution on the destination chain. Execution will need to be done manually.\\n  /// @dev Preimage for this tag is: keccak256(\\\"NO_EXECUTION_TAG\\\")[:4]\\n  bytes4 public constant NO_EXECUTION_TAG = 0xeba517d2;\\n  address public constant NO_EXECUTION_ADDRESS = address(bytes20(NO_EXECUTION_TAG));\\n\\n  // ================================================================\\n  // │                           Legacy                             │\\n  // ================================================================\\n\\n  // Tag to indicate only a gas limit. Only usable for EVM as destination chain.\\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\\n\\n  struct EVMExtraArgsV1 {\\n    uint256 gasLimit;\\n  }\\n\\n  function _argsToBytes(\\n    EVMExtraArgsV1 memory extraArgs\\n  ) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\\n  }\\n\\n  // Tag to indicate a gas limit (or dest chain equivalent processing units) and Out Of Order Execution. This tag is\\n  // available for multiple chain families. If there is no chain family specific tag, this is the default available\\n  // for a chain.\\n  // Note: not available for Solana or Sui VM based chains.\\n  bytes4 public constant GENERIC_EXTRA_ARGS_V2_TAG = 0x181dcf10;\\n\\n  /// @param gasLimit: gas limit for the callback on the destination chain.\\n  /// @param allowOutOfOrderExecution: if true, it indicates that the message can be executed in any order relative to\\n  /// other messages from the same sender. This value's default varies by chain. On some chains, a particular value is\\n  /// enforced, meaning if the expected value is not set, the message request will revert.\\n  /// @dev Fully compatible with the previously existing EVMExtraArgsV2.\\n  struct GenericExtraArgsV2 {\\n    uint256 gasLimit;\\n    bool allowOutOfOrderExecution;\\n  }\\n\\n  // Extra args tag for chains that use the Sui VM.\\n  bytes4 public constant SUI_EXTRA_ARGS_V1_TAG = 0x21ea4ca9;\\n\\n  // Extra args tag for chains that use the Solana VM.\\n  bytes4 public constant SVM_EXTRA_ARGS_V1_TAG = 0x1f3b3aba;\\n\\n  struct SVMExtraArgsV1 {\\n    uint32 computeUnits;\\n    uint64 accountIsWritableBitmap;\\n    bool allowOutOfOrderExecution;\\n    bytes32 tokenReceiver;\\n    // Additional accounts needed for execution of CCIP receiver. Must be empty if message.receiver is zero.\\n    // Token transfer related accounts are specified in the token pool lookup table on SVM.\\n    bytes32[] accounts;\\n  }\\n\\n  /// @dev The maximum number of accounts that can be passed in SVMExtraArgs.\\n  uint256 public constant SVM_EXTRA_ARGS_MAX_ACCOUNTS = 64;\\n\\n  /// @dev The expected static payload size of a token transfer when Borsh encoded and submitted to SVM.\\n  /// TokenPool extra data and offchain data sizes are dynamic, and should be accounted for separately.\\n  uint256 public constant SVM_TOKEN_TRANSFER_DATA_OVERHEAD = (4 + 32) // source_pool\\n    + 32 // token_address\\n    + 4 // gas_amount\\n    + 4 // extra_data overhead\\n    + 32 // amount\\n    + 32 // size of the token lookup table account\\n    + 32 // token-related accounts in the lookup table, over-estimated to 32, typically between 11 - 13\\n    + 32 // token account belonging to the token receiver, e.g ATA, not included in the token lookup table\\n    + 32 // per-chain token pool config, not included in the token lookup table\\n    + 32 // per-chain token billing config, not always included in the token lookup table\\n    + 32; // OffRamp pool signer PDA, not included in the token lookup table\\n\\n  /// @dev Number of overhead accounts needed for message execution on SVM.\\n  /// @dev These are message.receiver, and the OffRamp Signer PDA specific to the receiver.\\n  uint256 public constant SVM_MESSAGING_ACCOUNTS_OVERHEAD = 2;\\n\\n  /// @dev The size of each SVM account address in bytes.\\n  uint256 public constant SVM_ACCOUNT_BYTE_SIZE = 32;\\n\\n  struct SuiExtraArgsV1 {\\n    uint256 gasLimit;\\n    bool allowOutOfOrderExecution;\\n    bytes32 tokenReceiver;\\n    bytes32[] receiverObjectIds;\\n  }\\n\\n  /// @dev The expected static payload size of a token transfer when BCS encoded and submitted to SUI.\\n  /// TokenPool extra data and offchain data sizes are dynamic, and should be accounted for separately.\\n  uint256 public constant SUI_TOKEN_TRANSFER_DATA_OVERHEAD = (4 + 32) // source_pool, 4 bytes for length, 32 bytes for address\\n    + 32 // dest_token_address\\n    + 4 // dest_gas_amount\\n    + 4 // extra_data length, the contents are calculated separately\\n    + 32; // amount\\n\\n  /// @dev Number of overhead accounts needed for message execution on SUI.\\n  /// @dev This is the message.receiver.\\n  uint256 public constant SUI_MESSAGING_ACCOUNTS_OVERHEAD = 1;\\n\\n  /// @dev The maximum number of receiver object ids that can be passed in SuiExtraArgs.\\n  uint256 public constant SUI_EXTRA_ARGS_MAX_RECEIVER_OBJECT_IDS = 64;\\n\\n  /// @dev The size of each SUI account address in bytes.\\n  uint256 public constant SUI_ACCOUNT_BYTE_SIZE = 32;\\n\\n  function _argsToBytes(\\n    GenericExtraArgsV2 memory extraArgs\\n  ) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(GENERIC_EXTRA_ARGS_V2_TAG, extraArgs);\\n  }\\n\\n  function _svmArgsToBytes(\\n    SVMExtraArgsV1 memory extraArgs\\n  ) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(SVM_EXTRA_ARGS_V1_TAG, extraArgs);\\n  }\\n\\n  function _suiArgsToBytes(\\n    SuiExtraArgsV1 memory extraArgs\\n  ) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(SUI_EXTRA_ARGS_V1_TAG, extraArgs);\\n  }\\n}\\n\"},\"contracts/libraries/Internal.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for CCIP internal definitions common to multiple contracts.\\n/// @dev The following is a non-exhaustive list of \\\"known issues\\\" for CCIP:\\n/// - We could implement yield claiming for Blast. This is not worth the custom code path on non-blast chains.\\n/// - uint32 is used for timestamps, which will overflow in 2106. This is not a concern for the current use case, as we\\n/// expect to have migrated to a new version by then.\\nlibrary Internal {\\n  // bytes4(keccak256(\\\"CCIP ChainFamilySelector EVM\\\"));\\n  bytes4 public constant CHAIN_FAMILY_SELECTOR_EVM = 0x2812d52c;\\n\\n  // bytes4(keccak256(\\\"CCIP ChainFamilySelector SVM\\\"));\\n  bytes4 public constant CHAIN_FAMILY_SELECTOR_SVM = 0x1e10bdc4;\\n\\n  // bytes4(keccak256(\\\"CCIP ChainFamilySelector APTOS\\\"));\\n  bytes4 public constant CHAIN_FAMILY_SELECTOR_APTOS = 0xac77ffec;\\n\\n  // bytes4(keccak256(\\\"CCIP ChainFamilySelector SUI\\\"));\\n  bytes4 public constant CHAIN_FAMILY_SELECTOR_SUI = 0xc4e05953;\\n\\n  // byte4(keccak256(\\\"CCIP ChainFamilySelector TVM\\\"));\\n  bytes4 public constant CHAIN_FAMILY_SELECTOR_TVM = 0x647e2ba9;\\n\\n  error InvalidEVMAddress(bytes encodedAddress);\\n  error Invalid32ByteAddress(bytes encodedAddress);\\n  error InvalidTVMAddress(bytes encodedAddress);\\n\\n  /// @dev We limit return data to a selector plus 4 words. This is to avoid malicious contracts from returning\\n  /// large amounts of data and causing repeated out-of-gas scenarios.\\n  uint16 internal constant MAX_RET_BYTES = 4 + 4 * 32;\\n\\n  /// @dev The address used to send calls for gas estimation.\\n  /// You only need to use this address if the minimum gas limit specified by the user is not actually enough to execute the\\n  /// given message and you're attempting to estimate the actual necessary gas limit\\n  address public constant GAS_ESTIMATION_SENDER = address(0xC11C11C11C11C11C11C11C11C11C11C11C11C1);\\n\\n  /// @notice A collection of token price and gas price updates.\\n  struct PriceUpdates {\\n    TokenPriceUpdate[] tokenPriceUpdates;\\n    GasPriceUpdate[] gasPriceUpdates;\\n  }\\n\\n  /// @notice Token price in USD.\\n  struct TokenPriceUpdate {\\n    address sourceToken; // Source token.\\n    uint224 usdPerToken; // 1e18 USD per 1e18 of the smallest token denomination.\\n  }\\n\\n  /// @notice Gas price for a given chain in USD, its value may contain tightly packed fields.\\n  struct GasPriceUpdate {\\n    uint64 destChainSelector; // Destination chain selector.\\n    uint224 usdPerUnitGas; // 1e18 USD per smallest unit (e.g. wei) of destination chain gas.\\n  }\\n\\n  /// @notice A timestamped uint224 value that can contain several tightly packed fields.\\n  struct TimestampedPackedUint224 {\\n    uint224 value; // ────╮ Value in uint224, packed.\\n    uint32 timestamp; // ─╯ Timestamp of the most recent price update.\\n  }\\n\\n  /// @dev Gas price is stored in 112-bit unsigned int. uint224 can pack 2 prices.\\n  /// When packing L1 and L2 gas prices, L1 gas price is left-shifted to the higher-order bits.\\n  /// Using uint8 type, which cannot be higher than other bit shift operands, to avoid shift operand type warning.\\n  uint8 public constant GAS_PRICE_BITS = 112;\\n\\n  struct SourceTokenData {\\n    // The source pool address, abi encoded. This value is trusted as it was obtained through the onRamp. It can be\\n    // relied upon by the destination pool to validate the source pool.\\n    bytes sourcePoolAddress;\\n    // The address of the destination token, abi encoded in the case of EVM chains.\\n    // This value is UNTRUSTED as any pool owner can return whatever value they want.\\n    bytes destTokenAddress;\\n    // Optional pool data to be transferred to the destination chain. Be default this is capped at\\n    // CCIP_LOCK_OR_BURN_V1_RET_BYTES bytes. If more data is required, the TokenTransferFeeConfig.destBytesOverhead\\n    // has to be set for the specific token.\\n    bytes extraData;\\n    uint32 destGasAmount; // The amount of gas available for the releaseOrMint and balanceOf calls on the offRamp\\n  }\\n\\n  /// @dev We disallow the first 1024 addresses to avoid calling into a range known for hosting precompiles. Calling\\n  /// into precompiles probably won't cause any issues, but to be safe we can disallow this range. It is extremely\\n  /// unlikely that anyone would ever be able to generate an address in this range. There is no official range of\\n  /// precompiles, but EIP-7587 proposes to reserve the range 0x100 to 0x1ff. Our range is more conservative, even\\n  /// though it might not be exhaustive for all chains, which is OK. We also disallow the zero address, which is a\\n  /// common practice.\\n  uint256 public constant EVM_PRECOMPILE_SPACE = 1024;\\n\\n  // According to the Aptos docs, the first 0xa addresses are reserved for precompiles.\\n  // https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-framework/doc/account.md#function-create_framework_reserved_account-1\\n  uint256 public constant APTOS_PRECOMPILE_SPACE = 0x0b;\\n\\n  // According to the Sui docs, a set of non-contiguous addresses below 0xdee9 are reserved for system use.\\n  // https://github.com/MystenLabs/sui/blob/54ae98508569804127bd73d84aa2fb816bdea402/crates/sui-types/src/lib.rs#L141\\n  uint256 public constant SUI_PRECOMPILE_SPACE = 0xdee9;\\n\\n  /// @notice This methods provides validation for parsing abi encoded addresses by ensuring the address is within the\\n  /// EVM address space. If it isn't it will revert with an InvalidEVMAddress error, which we can catch and handle\\n  /// more gracefully than a revert from abi.decode.\\n  function _validateEVMAddress(\\n    bytes memory encodedAddress\\n  ) internal pure {\\n    if (encodedAddress.length != 32) revert InvalidEVMAddress(encodedAddress);\\n    uint256 encodedAddressUint = abi.decode(encodedAddress, (uint256));\\n    if (encodedAddressUint \\u003e type(uint160).max || encodedAddressUint \\u003c EVM_PRECOMPILE_SPACE) {\\n      revert InvalidEVMAddress(encodedAddress);\\n    }\\n  }\\n\\n  /// @notice This methods provides validation for parsing abi encoded addresses by ensuring the address is within the\\n  /// bounds of [minValue, uint256.max]. If it isn't it will revert with an Invalid32ByteAddress error.\\n  function _validate32ByteAddress(bytes memory encodedAddress, uint256 minValue) internal pure {\\n    if (encodedAddress.length != 32) revert Invalid32ByteAddress(encodedAddress);\\n    if (minValue \\u003e 0) {\\n      if (abi.decode(encodedAddress, (uint256)) \\u003c minValue) {\\n        revert Invalid32ByteAddress(encodedAddress);\\n      }\\n    }\\n  }\\n\\n  /// @notice This methods provides validation for TON User-friendly addresses by ensuring the address is 36 bytes long.\\n  /// @dev The encodedAddress is expected to be the 36-byte raw representation:\\n  /// - 1 byte: flags (isBounceable, isTestnetOnly, etc.)\\n  /// - 1 byte: workchain_id (0x00 for BaseChain, 0xff for MasterChain)\\n  /// - 32 bytes: account_id\\n  /// - 2 bytes: CRC16 checksum(computationally heavy, validation omitted for simplicity)\\n  /// @param encodedAddress The 36-byte TON address.\\n  function _validateTVMAddress(\\n    bytes memory encodedAddress\\n  ) internal pure {\\n    if (encodedAddress.length != 36) revert InvalidTVMAddress(encodedAddress);\\n    bytes32 accountId;\\n    assembly {\\n      accountId := mload(add(encodedAddress, 0x22)) // 0x22 = 0x20 (data start) + 2 (offset for account_id)\\n    }\\n    if (accountId == bytes32(0)) revert InvalidTVMAddress(encodedAddress);\\n  }\\n\\n  /// @notice Enum listing the possible message execution states within the offRamp contract.\\n  /// UNTOUCHED never executed.\\n  /// IN_PROGRESS currently being executed, used a replay protection.\\n  /// SUCCESS successfully executed. End state.\\n  /// FAILURE unsuccessfully executed, manual execution is now enabled.\\n  enum MessageExecutionState {\\n    UNTOUCHED,\\n    IN_PROGRESS,\\n    SUCCESS,\\n    FAILURE\\n  }\\n\\n  struct EVM2AnyTokenTransfer {\\n    // The source pool EVM address. This value is trusted as it was obtained through the onRamp. It can be relied\\n    // upon by the destination pool to validate the source pool.\\n    address sourcePoolAddress;\\n    // The EVM address of the destination token.\\n    // This value is UNTRUSTED as any pool owner can return whatever value they want.\\n    bytes destTokenAddress;\\n    // Optional pool data to be transferred to the destination chain. Be default this is capped at\\n    // CCIP_LOCK_OR_BURN_V1_RET_BYTES bytes. If more data is required, the TokenTransferFeeConfig.destBytesOverhead\\n    // has to be set for the specific token.\\n    bytes extraData;\\n    uint256 amount; // Amount of tokens.\\n    // Destination chain data used to execute the token transfer on the destination chain. For an EVM destination, it\\n    // consists of the amount of gas available for the releaseOrMint and transfer calls made by the offRamp.\\n    bytes destExecData;\\n  }\\n\\n  /// @dev Holds a merkle root and interval for a source chain so that an array of these can be passed in the CommitReport.\\n  /// @dev Inefficient struct packing intentionally chosen to maintain order of specificity. Not a storage struct so impact is minimal.\\n  // solhint-disable-next-line gas-struct-packing\\n  struct MerkleRoot {\\n    uint64 sourceChainSelector; // Remote source chain selector that the Merkle Root is scoped to\\n    bytes onRampAddress; //        Generic onRamp address, to support arbitrary sources; for EVM, use abi.encode\\n    uint64 minSeqNr; // ─────────╮ Minimum sequence number, inclusive\\n    uint64 maxSeqNr; // ─────────╯ Maximum sequence number, inclusive\\n    bytes32 merkleRoot; //         Merkle root covering the interval \\u0026 source chain messages\\n  }\\n}\\n\"},\"contracts/libraries/MessageV1Codec.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for CCIP MessageV1 encoding/decoding operations.\\n/// @dev This library handles the complete V1 message format protocol including:\\n/// - MessageV1 and TokenTransferV1 struct definitions.\\n/// - Encoding/decoding functions with comprehensive error handling.\\n/// - Detailed error location tracking for debugging.\\nlibrary MessageV1Codec {\\n  error InvalidDataLength(EncodingErrorLocation location);\\n  error InvalidEncodingVersion(uint8 version);\\n\\n  uint256 public constant MAX_NUMBER_OF_TOKENS = 1;\\n  // Base size of a MessageV1 without variable length fields.\\n  // 1 (version) + 8 (sourceChain) + 8 (destChain) + 8 (seqNum) + 4 (executionGasLimit) +\\n  // 4 (ccipReceiveGasLimit) + 2 (finality) + 32 (ccvAndExecutorHash) + 1 (onRampLen) + 1 (offRampLen) +\\n  // 1 (senderLen) + 1 (receiverLen) + 2 (destBlobLen) + 2 (tokenTransferLen) + 2 (dataLen) = 77.\\n  uint256 public constant MESSAGE_V1_BASE_SIZE = 1 + 8 + 8 + 8 + 4 + 4 + 2 + 32 + 1 + 1 + 1 + 1 + 2 + 2 + 2;\\n  // The base size plus 20 bytes for sender and 20 bytes for onRamp addresses.\\n  // To be added:\\n  // - receiver, offRamp and destBlob are dest chain specific.\\n  // - data is user specified.\\n  // - token transfer is optional and has variable size fields.\\n  uint256 public constant MESSAGE_V1_EVM_SOURCE_BASE_SIZE = MESSAGE_V1_BASE_SIZE + 20 + 20;\\n  uint256 public constant MESSAGE_V1_REMOTE_CHAIN_ADDRESSES = 2;\\n\\n  // Base size of a TokenTransferV1 without variable length fields.\\n  // 1 (version) + 32 (amount) + 1 (sourcePoolLen) + 1 (sourceTokenLen) + 1 (destTokenLen) +\\n  // 1 (tokenReceiverLen) + 2 (extraDataLen).\\n  uint256 public constant TOKEN_TRANSFER_V1_BASE_SIZE = 1 + 32 + 1 + 1 + 1 + 1 + 2;\\n  // The base size plus 20 bytes for sourcePool, 20 bytes for sourceToken.\\n  // To be added:\\n  // - destToken is dest chain specific.\\n  // - extraData is a variable length field that is billed separately.\\n  uint256 public constant TOKEN_TRANSFER_V1_EVM_SOURCE_BASE_SIZE = TOKEN_TRANSFER_V1_BASE_SIZE + 20 + 20;\\n\\n  enum EncodingErrorLocation {\\n    // Message-level components.\\n    MESSAGE_MIN_SIZE,\\n    MESSAGE_ONRAMP_ADDRESS_CONTENT,\\n    MESSAGE_OFFRAMP_ADDRESS_LENGTH,\\n    MESSAGE_OFFRAMP_ADDRESS_CONTENT,\\n    MESSAGE_FINALITY,\\n    MESSAGE_EXECUTION_GAS_LIMIT,\\n    MESSAGE_CALLBACK_GAS_LIMIT,\\n    MESSAGE_SENDER_LENGTH,\\n    MESSAGE_SENDER_CONTENT,\\n    MESSAGE_RECEIVER_LENGTH,\\n    MESSAGE_RECEIVER_CONTENT,\\n    MESSAGE_DEST_BLOB_LENGTH,\\n    MESSAGE_DEST_BLOB_CONTENT,\\n    MESSAGE_TOKEN_TRANSFER_LENGTH,\\n    MESSAGE_TOKEN_TRANSFER_CONTENT,\\n    MESSAGE_DATA_LENGTH,\\n    MESSAGE_DATA_CONTENT,\\n    MESSAGE_FINAL_OFFSET,\\n    // Token transfer components.\\n    TOKEN_TRANSFER_VERSION,\\n    TOKEN_TRANSFER_AMOUNT,\\n    TOKEN_TRANSFER_SOURCE_POOL_LENGTH,\\n    TOKEN_TRANSFER_SOURCE_POOL_CONTENT,\\n    TOKEN_TRANSFER_SOURCE_TOKEN_LENGTH,\\n    TOKEN_TRANSFER_SOURCE_TOKEN_CONTENT,\\n    TOKEN_TRANSFER_DEST_TOKEN_LENGTH,\\n    TOKEN_TRANSFER_DEST_TOKEN_CONTENT,\\n    TOKEN_TRANSFER_TOKEN_RECEIVER_LENGTH,\\n    TOKEN_TRANSFER_TOKEN_RECEIVER_CONTENT,\\n    TOKEN_TRANSFER_EXTRA_DATA_LENGTH,\\n    TOKEN_TRANSFER_EXTRA_DATA_CONTENT,\\n    // Encoding validation components.\\n    ENCODE_ONRAMP_ADDRESS_LENGTH,\\n    ENCODE_OFFRAMP_ADDRESS_LENGTH,\\n    ENCODE_SENDER_LENGTH,\\n    ENCODE_RECEIVER_LENGTH,\\n    ENCODE_DEST_BLOB_LENGTH,\\n    ENCODE_TOKEN_TRANSFER_ARRAY_LENGTH,\\n    ENCODE_DATA_LENGTH,\\n    ENCODE_TOKEN_SOURCE_POOL_LENGTH,\\n    ENCODE_TOKEN_SOURCE_TOKEN_LENGTH,\\n    ENCODE_TOKEN_DEST_TOKEN_LENGTH,\\n    ENCODE_TOKEN_TOKEN_RECEIVER_LENGTH,\\n    ENCODE_TOKEN_EXTRA_DATA_LENGTH\\n  }\\n\\n  /// @notice Message format used in the v1 protocol.\\n  /// Static length fields.\\n  ///   uint8 version;              Version, for future use and backwards compatibility.\\n  ///   uint64 sourceChainSelector; Source Chain Selector.\\n  ///   uint64 destChainSelector;   Destination Chain Selector.\\n  ///   uint64 sequenceNumber;      Auto-incrementing sequence number for the message.\\n  ///   uint32 executionGasLimit;   Gas limit for message execution on the destination chain.\\n  ///   uint32 ccipReceiveGasLimit;    Gas limit for the user callback on the destination chain.\\n  ///   uint16 finality;            Configurable per-message finality value.\\n  ///   bytes32 ccvAndExecutorHash; Hash of the verifiers and executor addresses.\\n  ///\\n  /// Variable length fields.\\n  ///\\n  ///   uint8 onRampAddressLength;  Length of the onRamp Address in bytes.\\n  ///   bytes onRampAddress;        Source Chain OnRamp as unpadded bytes.\\n  ///   uint8 offRampAddressLength; Length of the offRamp Address in bytes.\\n  ///   bytes offRampAddress;       Destination Chain OffRamp as unpadded bytes.\\n  ///   uint8 senderLength;         Length of the Sender Address in bytes.\\n  ///   bytes sender;               Sender address as unpadded bytes.\\n  ///   uint8 receiverLength;       Length of the Receiver Address in bytes.\\n  ///   bytes receiver;             Receiver address on the destination chain as unpadded bytes.\\n  ///   uint16 destBlobLength;      Length of the Destination Blob in bytes.\\n  ///   bytes destBlob;             Destination chain-specific blob that contains data required for execution e.g.\\n  ///                               Solana accounts.\\n  ///   uint16 tokenTransferLength; Length of the Token Transfer structure in bytes.\\n  ///   bytes tokenTransfer;        Byte representation of the token transfer structure.\\n  ///   uint16 dataLength;          Length of the user specified data payload.\\n  ///   bytes data;                 Arbitrary data payload supplied by the message sender that is passed to the receiver.\\n  ///\\n  /// @dev None of the fields are abi encoded as this storage layout is used for non-EVMs as well. That means if the\\n  /// receiver is an EVM address, it is stored as 20 bytes without any padding.\\n  /// @dev Inefficient struct packing does not matter as this is not a storage struct, and it it would ever be written\\n  /// to storage it would be in its encoded form.\\n  // solhint-disable-next-line gas-struct-packing\\n  struct MessageV1 {\\n    /// @notice Source Chain Selector.\\n    uint64 sourceChainSelector;\\n    /// @notice Destination Chain Selector.\\n    uint64 destChainSelector;\\n    /// @notice Per-lane-unique sequence number for the message. When faster-than-finality is used the guarantee that\\n    /// this value is unique no longer holds. After a re-org, a message could end up with a different sequence number.\\n    /// Messages that are older than the chain finality delay should all have unique per-lane sequence numbers.\\n    uint64 sequenceNumber;\\n    // Gas limit for message execution on the destination chain.\\n    uint32 executionGasLimit;\\n    // Gas limit for the user callback on the destination chain.\\n    uint32 ccipReceiveGasLimit;\\n    // Configurable per-message finality value.\\n    uint16 finality;\\n    // A hash of the verifiers and executor addresses. This is used by the offchain systems to validate the list of CCVs\\n    // and executor that should be used for this message.\\n    bytes32 ccvAndExecutorHash;\\n    // Variable length fields - must match wire format order.\\n    // Source chain onRamp, NOT abi encoded but raw bytes. This means for EVM chains it is 20 bytes.\\n    bytes onRampAddress;\\n    // Destination chain offRamp, NOT abi encoded but raw bytes. This means for EVM chains it is 20 bytes.\\n    bytes offRampAddress;\\n    // Source chain sender address, NOT abi encoded but raw bytes. This means for EVM chains it is 20 bytes.\\n    bytes sender;\\n    // Destination chain receiver address, NOT abi encoded but raw bytes. This means for EVM chains it is 20 bytes.\\n    bytes receiver;\\n    // Destination specific blob that contains chain-family specific data.\\n    bytes destBlob;\\n    // Contains either 0 or 1 token transfer structs. It is encoded as an array for gas efficiency.\\n    TokenTransferV1[] tokenTransfer;\\n    // Arbitrary data payload supplied by the message sender.\\n    bytes data;\\n  }\\n\\n  struct TokenTransferV1 {\\n    uint256 amount; // Number of tokens.\\n    // This can be relied upon by the destination pool to validate the source pool. NOT abi encoded but raw bytes. This\\n    // means for EVM chains it is 20 bytes.\\n    bytes sourcePoolAddress;\\n    bytes sourceTokenAddress; // Address of source token, NOT abi encoded but raw bytes.\\n    bytes destTokenAddress; // Address of destination token, NOT abi encoded but raw bytes.\\n    // Token receiver address on the destination chain, NOT abi encoded but raw bytes. This means for EVM chains it is 20 bytes.\\n    bytes tokenReceiver;\\n    // Optional pool data to be transferred to the destination chain. Be default this is capped at\\n    // CCIP_LOCK_OR_BURN_V1_RET_BYTES bytes. If more data is required, the TokenTransferFeeConfig.destBytesOverhead\\n    // has to be set for the specific token.\\n    bytes extraData;\\n  }\\n\\n  /// @notice Computes the hash of CCVs and executor addresses, prefixed with a length byte. This length byte ensures\\n  /// the use of unpadded encoding is safe. Because EVM addresses are always 20 bytes, the length is hard-coded.\\n  /// @dev Without the length byte, an array of two addresses [A, B] would hash the same as [AB] (concatenated). That\\n  /// would allow for potential misreporting of CCVs/executor unless the offchain system knows the address lengths for\\n  /// all chains it supports.\\n  /// @param ccvs Array of CCV (Cross-Chain Verifier) addresses.\\n  /// @param executor Address of the executor.\\n  /// @return hash The keccak256 hash of the encoded CCVs and executor.\\n  function _computeCCVAndExecutorHash(address[] memory ccvs, address executor) internal pure returns (bytes32) {\\n    uint256 encodedLength = 1 + ccvs.length * 20 + 20;\\n    // We overprovision the bytes array to avoid out of bounds writes. Since we write EVM addresses which are 20 bytes,\\n    // and the size of a write is 32 bytes, the maximum out of bounds we can have is 12 bytes.\\n    bytes memory encoded = new bytes(encodedLength + 12);\\n    encoded[0] = bytes1(uint8(20));\\n\\n    // Skip length (32 bytes) and address length byte (1 byte).\\n    uint256 offset = 33;\\n    for (uint256 i = 0; i \\u003c ccvs.length; ++i) {\\n      address ccvsAddress = ccvs[i];\\n\\n      // Any overshoot here is safe due to the writing of the executor address below.\\n      assembly {\\n        mstore(add(encoded, offset), shl(96, ccvsAddress))\\n        offset := add(offset, 20)\\n      }\\n    }\\n    assembly {\\n      // Overshoot here is also safe due to overallocation of the bytes array.\\n      mstore(add(encoded, offset), shl(96, executor))\\n      mstore(encoded, encodedLength)\\n    }\\n\\n    return keccak256(encoded);\\n  }\\n\\n  /// @notice Encodes a TokenTransferV1 struct into bytes.\\n  /// @param tokenTransfer The TokenTransferV1 struct to encode.\\n  /// @return encoded The encoded token transfer as bytes.\\n  function _encodeTokenTransferV1(\\n    TokenTransferV1 memory tokenTransfer\\n  ) internal pure returns (bytes memory) {\\n    // Validate field lengths fit in their respective size limits.\\n    if (tokenTransfer.sourcePoolAddress.length \\u003e type(uint8).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_TOKEN_SOURCE_POOL_LENGTH);\\n    }\\n    if (tokenTransfer.sourceTokenAddress.length \\u003e type(uint8).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_TOKEN_SOURCE_TOKEN_LENGTH);\\n    }\\n    if (tokenTransfer.destTokenAddress.length \\u003e type(uint8).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_TOKEN_DEST_TOKEN_LENGTH);\\n    }\\n    if (tokenTransfer.tokenReceiver.length \\u003e type(uint8).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_TOKEN_TOKEN_RECEIVER_LENGTH);\\n    }\\n    if (tokenTransfer.extraData.length \\u003e type(uint16).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_TOKEN_EXTRA_DATA_LENGTH);\\n    }\\n\\n    return abi.encodePacked(\\n      uint8(1), // version.\\n      tokenTransfer.amount,\\n      uint8(tokenTransfer.sourcePoolAddress.length),\\n      tokenTransfer.sourcePoolAddress,\\n      uint8(tokenTransfer.sourceTokenAddress.length),\\n      tokenTransfer.sourceTokenAddress,\\n      uint8(tokenTransfer.destTokenAddress.length),\\n      tokenTransfer.destTokenAddress,\\n      uint8(tokenTransfer.tokenReceiver.length),\\n      tokenTransfer.tokenReceiver,\\n      uint16(tokenTransfer.extraData.length),\\n      tokenTransfer.extraData\\n    );\\n  }\\n\\n  /// @notice Decodes bytes into a TokenTransferV1 struct.\\n  /// @param encoded The encoded token transfer bytes to decode.\\n  /// @param offset The starting offset in the encoded bytes.\\n  /// @return tokenTransfer The decoded TokenTransferV1 struct.\\n  /// @return newOffset The new offset after decoding.\\n  function _decodeTokenTransferV1(\\n    bytes calldata encoded,\\n    uint256 offset\\n  ) internal pure returns (TokenTransferV1 memory tokenTransfer, uint256 newOffset) {\\n    // Unchecked is safe because the offset is only incremented with validated lengths.\\n    unchecked {\\n      // version (1 byte).\\n      if (offset \\u003e= encoded.length) revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_VERSION);\\n      uint8 version = uint8(encoded[offset++]);\\n      if (version != 1) revert InvalidEncodingVersion(version);\\n\\n      // amount (32 bytes).\\n      if (offset + 32 \\u003e encoded.length) revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_AMOUNT);\\n      tokenTransfer.amount = uint256(bytes32(encoded[offset:offset + 32]));\\n      offset += 32;\\n\\n      // sourcePoolAddressLength and sourcePoolAddress.\\n      if (offset \\u003e= encoded.length) revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_SOURCE_POOL_LENGTH);\\n      uint8 sourcePoolAddressLength = uint8(encoded[offset++]);\\n      if (offset + sourcePoolAddressLength \\u003e encoded.length) {\\n        revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_SOURCE_POOL_CONTENT);\\n      }\\n\\n      tokenTransfer.sourcePoolAddress = encoded[offset:offset + sourcePoolAddressLength];\\n      offset += sourcePoolAddressLength;\\n\\n      // sourceTokenAddressLength and sourceTokenAddress.\\n      if (offset \\u003e= encoded.length) revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_SOURCE_TOKEN_LENGTH);\\n      uint8 sourceTokenAddressLength = uint8(encoded[offset++]);\\n      if (offset + sourceTokenAddressLength \\u003e encoded.length) {\\n        revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_SOURCE_TOKEN_CONTENT);\\n      }\\n\\n      tokenTransfer.sourceTokenAddress = encoded[offset:offset + sourceTokenAddressLength];\\n      offset += sourceTokenAddressLength;\\n\\n      // destTokenAddressLength and destTokenAddress.\\n      if (offset \\u003e= encoded.length) revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_DEST_TOKEN_LENGTH);\\n      uint8 destTokenAddressLength = uint8(encoded[offset++]);\\n      if (offset + destTokenAddressLength \\u003e encoded.length) {\\n        revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_DEST_TOKEN_CONTENT);\\n      }\\n\\n      tokenTransfer.destTokenAddress = encoded[offset:offset + destTokenAddressLength];\\n      offset += destTokenAddressLength;\\n\\n      // tokenReceiverLength and tokenReceiver.\\n      if (offset \\u003e= encoded.length) {\\n        revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_TOKEN_RECEIVER_LENGTH);\\n      }\\n      uint8 tokenReceiverLength = uint8(encoded[offset++]);\\n      if (offset + tokenReceiverLength \\u003e encoded.length) {\\n        revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_TOKEN_RECEIVER_CONTENT);\\n      }\\n\\n      tokenTransfer.tokenReceiver = encoded[offset:offset + tokenReceiverLength];\\n      offset += tokenReceiverLength;\\n\\n      // extraDataLength and extraData.\\n      if (offset + 2 \\u003e encoded.length) revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_EXTRA_DATA_LENGTH);\\n      uint16 extraDataLength = uint16(bytes2(encoded[offset:offset + 2]));\\n      offset += 2;\\n      if (offset + extraDataLength \\u003e encoded.length) {\\n        revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_EXTRA_DATA_CONTENT);\\n      }\\n\\n      tokenTransfer.extraData = encoded[offset:offset + extraDataLength];\\n      offset += extraDataLength;\\n    }\\n    return (tokenTransfer, offset);\\n  }\\n\\n  /// @notice Encodes a MessageV1 struct into bytes following the v1 protocol format.\\n  /// @param message The MessageV1 struct to encode.\\n  /// @return encoded The encoded message as bytes.\\n  function _encodeMessageV1(\\n    MessageV1 memory message\\n  ) internal pure returns (bytes memory) {\\n    // Validate field lengths fit in their respective size limits.\\n    if (message.onRampAddress.length \\u003e type(uint8).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_ONRAMP_ADDRESS_LENGTH);\\n    }\\n    if (message.offRampAddress.length \\u003e type(uint8).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_OFFRAMP_ADDRESS_LENGTH);\\n    }\\n    if (message.sender.length \\u003e type(uint8).max) revert InvalidDataLength(EncodingErrorLocation.ENCODE_SENDER_LENGTH);\\n    if (message.receiver.length \\u003e type(uint8).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_RECEIVER_LENGTH);\\n    }\\n    if (message.destBlob.length \\u003e type(uint16).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_DEST_BLOB_LENGTH);\\n    }\\n    if (message.tokenTransfer.length \\u003e MAX_NUMBER_OF_TOKENS) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_TOKEN_TRANSFER_ARRAY_LENGTH);\\n    }\\n    if (message.data.length \\u003e type(uint16).max) revert InvalidDataLength(EncodingErrorLocation.ENCODE_DATA_LENGTH);\\n\\n    // We need to partially encode it in three parts to avoid stack too deep issues.\\n    bytes memory staticLengthSection = abi.encodePacked(\\n      uint8(1), // version.\\n      message.sourceChainSelector,\\n      message.destChainSelector,\\n      message.sequenceNumber,\\n      message.executionGasLimit,\\n      message.ccipReceiveGasLimit,\\n      message.finality,\\n      message.ccvAndExecutorHash\\n    );\\n\\n    bytes memory dynamicLengthPart1 = abi.encodePacked(\\n      uint8(message.onRampAddress.length),\\n      message.onRampAddress,\\n      uint8(message.offRampAddress.length),\\n      message.offRampAddress,\\n      uint8(message.sender.length),\\n      message.sender\\n    );\\n\\n    // Encode token the transfer if present. We checked above that there is at most 1 token transfer.\\n    // We define it below the partial encoding to avoid stack too deep errors.\\n    bytes memory encodedTokenTransfers;\\n    if (message.tokenTransfer.length \\u003e 0) {\\n      encodedTokenTransfers = _encodeTokenTransferV1(message.tokenTransfer[0]);\\n    }\\n\\n    return abi.encodePacked(\\n      staticLengthSection,\\n      dynamicLengthPart1,\\n      abi.encodePacked(\\n        uint8(message.receiver.length),\\n        message.receiver,\\n        uint16(message.destBlob.length),\\n        message.destBlob,\\n        uint16(encodedTokenTransfers.length),\\n        encodedTokenTransfers,\\n        uint16(message.data.length),\\n        message.data\\n      )\\n    );\\n  }\\n\\n  /// @notice Decodes bytes into a MessageV1 struct following the v1 protocol format.\\n  /// @param encoded The encoded message bytes to decode.\\n  /// @return message The decoded MessageV1 struct.\\n  function _decodeMessageV1(\\n    bytes calldata encoded\\n  ) internal pure returns (MessageV1 memory message) {\\n    // Unchecked is safe because the offset is only incremented with validated lengths.\\n    unchecked {\\n      if (encoded.length \\u003c MESSAGE_V1_BASE_SIZE) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_MIN_SIZE);\\n\\n      uint8 version = uint8(encoded[0]);\\n      if (version != 1) revert InvalidEncodingVersion(version);\\n\\n      // sourceChainSelector (8 bytes, big endian).\\n      message.sourceChainSelector = uint64(bytes8(encoded[1:9]));\\n\\n      // destChainSelector (8 bytes, big endian).\\n      message.destChainSelector = uint64(bytes8(encoded[9:17]));\\n\\n      // sequenceNumber (8 bytes, big endian).\\n      message.sequenceNumber = uint64(bytes8(encoded[17:25]));\\n\\n      // executionGasLimit (4 bytes, big endian).\\n      message.executionGasLimit = uint32(bytes4(encoded[25:29]));\\n\\n      // ccipReceiveGasLimit (4 bytes, big endian).\\n      message.ccipReceiveGasLimit = uint32(bytes4(encoded[29:33]));\\n\\n      // finality (2 bytes, big endian).\\n      message.finality = uint16(bytes2(encoded[33:35]));\\n\\n      message.ccvAndExecutorHash = bytes32(encoded[35:67]);\\n\\n      // onRampAddressLength and onRampAddress.\\n      uint256 offset = 67;\\n      if (offset \\u003e= encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_ONRAMP_ADDRESS_CONTENT);\\n      uint8 onRampAddressLength = uint8(encoded[offset++]);\\n      if (offset + onRampAddressLength \\u003e encoded.length) {\\n        revert InvalidDataLength(EncodingErrorLocation.MESSAGE_ONRAMP_ADDRESS_CONTENT);\\n      }\\n\\n      message.onRampAddress = encoded[offset:offset + onRampAddressLength];\\n      offset += onRampAddressLength;\\n\\n      // offRampAddressLength and offRampAddress.\\n      if (offset \\u003e= encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_OFFRAMP_ADDRESS_LENGTH);\\n      uint8 offRampAddressLength = uint8(encoded[offset++]);\\n      if (offset + offRampAddressLength \\u003e encoded.length) {\\n        revert InvalidDataLength(EncodingErrorLocation.MESSAGE_OFFRAMP_ADDRESS_CONTENT);\\n      }\\n\\n      message.offRampAddress = encoded[offset:offset + offRampAddressLength];\\n      offset += offRampAddressLength;\\n\\n      // senderLength and sender.\\n      if (offset \\u003e= encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_SENDER_LENGTH);\\n      uint8 senderLength = uint8(encoded[offset++]);\\n      if (offset + senderLength \\u003e encoded.length) {\\n        revert InvalidDataLength(EncodingErrorLocation.MESSAGE_SENDER_CONTENT);\\n      }\\n\\n      message.sender = encoded[offset:offset + senderLength];\\n      offset += senderLength;\\n\\n      // receiverLength and receiver.\\n      if (offset \\u003e= encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_RECEIVER_LENGTH);\\n      uint8 receiverLength = uint8(encoded[offset++]);\\n      if (offset + receiverLength \\u003e encoded.length) {\\n        revert InvalidDataLength(EncodingErrorLocation.MESSAGE_RECEIVER_CONTENT);\\n      }\\n\\n      message.receiver = encoded[offset:offset + receiverLength];\\n      offset += receiverLength;\\n\\n      // destBlobLength and destBlob.\\n      if (offset + 2 \\u003e encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_DEST_BLOB_LENGTH);\\n      uint16 destBlobLength = uint16(bytes2(encoded[offset:offset + 2]));\\n      offset += 2;\\n      if (offset + destBlobLength \\u003e encoded.length) {\\n        revert InvalidDataLength(EncodingErrorLocation.MESSAGE_DEST_BLOB_CONTENT);\\n      }\\n\\n      message.destBlob = encoded[offset:offset + destBlobLength];\\n      offset += destBlobLength;\\n\\n      // tokenTransferLength and tokenTransfer.\\n      if (offset + 2 \\u003e encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_TOKEN_TRANSFER_LENGTH);\\n      uint16 tokenTransferLength = uint16(bytes2(encoded[offset:offset + 2]));\\n      offset += 2;\\n\\n      // Decode token transfer, which is either 0 or 1.\\n      if (tokenTransferLength == 0) {\\n        message.tokenTransfer = new TokenTransferV1[](0);\\n      } else {\\n        message.tokenTransfer = new TokenTransferV1[](1);\\n        uint256 expectedEnd = offset + tokenTransferLength;\\n        (message.tokenTransfer[0], offset) = _decodeTokenTransferV1(encoded, offset);\\n        if (offset != expectedEnd) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_TOKEN_TRANSFER_CONTENT);\\n      }\\n\\n      // dataLength and data.\\n      if (offset + 2 \\u003e encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_DATA_LENGTH);\\n      uint16 dataLength = uint16(bytes2(encoded[offset:offset + 2]));\\n      offset += 2;\\n      if (offset + dataLength \\u003e encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_DATA_CONTENT);\\n\\n      message.data = encoded[offset:offset + dataLength];\\n      offset += dataLength;\\n\\n      // Ensure we've consumed all bytes.\\n      if (offset != encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_FINAL_OFFSET);\\n    }\\n    return message;\\n  }\\n}\\n\"},\"contracts/pools/USDC/CCTPMessageTransmitterProxy.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\nimport {IMessageTransmitter} from \\\"./interfaces/IMessageTransmitter.sol\\\";\\nimport {ITokenMessenger} from \\\"./interfaces/ITokenMessenger.sol\\\";\\n\\nimport {Ownable2StepMsgSender} from \\\"@chainlink/contracts/src/v0.8/shared/access/Ownable2StepMsgSender.sol\\\";\\nimport {ITypeAndVersion} from \\\"@chainlink/contracts/src/v0.8/shared/interfaces/ITypeAndVersion.sol\\\";\\nimport {EnumerableSet} from \\\"@openzeppelin/contracts@5.0.2/utils/structs/EnumerableSet.sol\\\";\\n\\n/// @title CCTP Message Transmitter Proxy\\n/// @notice A proxy contract for handling messages transmitted via the Cross Chain Transfer Protocol (CCTP).\\n/// @dev This contract is responsible for sending messages to the `IMessageTransmitter` and ensuring only allowed callers can invoke it.\\ncontract CCTPMessageTransmitterProxy is Ownable2StepMsgSender, ITypeAndVersion {\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n\\n  /// @notice Error thrown when a function is called by an unauthorized address.\\n  error Unauthorized(address caller);\\n\\n  /// @notice Emitted when an allowed caller is added.\\n  event AllowedCallerAdded(address indexed caller);\\n  /// @notice Emitted when an allowed caller is removed.\\n  event AllowedCallerRemoved(address indexed caller);\\n\\n  string public constant override typeAndVersion = \\\"CCTPMessageTransmitterProxy 1.6.2\\\";\\n\\n  struct AllowedCallerConfigArgs {\\n    address caller;\\n    bool allowed;\\n  }\\n\\n  /// @notice Immutable reference to the `IMessageTransmitter` contract.\\n  IMessageTransmitter public immutable i_cctpTransmitter;\\n\\n  /// @notice Enumerable set of addresses allowed to call `receiveMessage`.\\n  EnumerableSet.AddressSet private s_allowedCallers;\\n\\n  /// @notice One-time cyclic dependency between TokenPool and MessageTransmitter.\\n  constructor(\\n    ITokenMessenger tokenMessenger\\n  ) {\\n    i_cctpTransmitter = IMessageTransmitter(tokenMessenger.localMessageTransmitter());\\n  }\\n\\n  /// @notice Receives a message from the `IMessageTransmitter` contract and validates it.\\n  /// @dev Can only be called by an allowed caller to process incoming messages.\\n  /// @param message The payload of the message being received.\\n  /// @param attestation The cryptographic proof validating the message.\\n  /// @return success A boolean indicating if the message was successfully processed.\\n  function receiveMessage(bytes calldata message, bytes calldata attestation) external returns (bool success) {\\n    if (!s_allowedCallers.contains(msg.sender)) {\\n      revert Unauthorized(msg.sender);\\n    }\\n    return i_cctpTransmitter.receiveMessage(message, attestation);\\n  }\\n\\n  /// @notice Configures the allowed callers for the `receiveMessage` function.\\n  /// @param configArgs An array of `AllowedCallerConfigArgs` structs.\\n  function configureAllowedCallers(\\n    AllowedCallerConfigArgs[] calldata configArgs\\n  ) external onlyOwner {\\n    for (uint256 i = 0; i \\u003c configArgs.length; ++i) {\\n      if (configArgs[i].allowed) {\\n        if (s_allowedCallers.add(configArgs[i].caller)) {\\n          emit AllowedCallerAdded(configArgs[i].caller);\\n        }\\n      } else {\\n        if (s_allowedCallers.remove(configArgs[i].caller)) {\\n          emit AllowedCallerRemoved(configArgs[i].caller);\\n        }\\n      }\\n    }\\n  }\\n\\n  /// @notice Checks if the caller is allowed to call the `receiveMessage` function.\\n  /// @param caller The address to check.\\n  /// @return allowed A boolean indicating if the caller is allowed.\\n  function isAllowedCaller(\\n    address caller\\n  ) external view returns (bool allowed) {\\n    return s_allowedCallers.contains(caller);\\n  }\\n\\n  /// @notice Returns an array of all allowed callers.\\n  /// @return allowedCallers An array of allowed caller addresses.\\n  function getAllowedCallers() external view returns (address[] memory allowedCallers) {\\n    return s_allowedCallers.values();\\n  }\\n}\\n\"},\"contracts/pools/USDC/interfaces/IMessageTransmitter.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n/*\\n * Copyright (c) 2022, Circle Internet Financial Limited.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n * http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\npragma solidity ^0.8.0;\\n\\ninterface IMessageTransmitter {\\n  /// @notice Unlocks USDC tokens on the destination chain\\n  /// @param message The original message on the source chain\\n  ///     * Message format:\\n  ///     * Field                 Bytes      Type       Index\\n  ///     * version               4          uint32     0\\n  ///     * sourceDomain          4          uint32     4\\n  ///     * destinationDomain     4          uint32     8\\n  ///     * nonce                 8          uint64     12\\n  ///     * sender                32         bytes32    20\\n  ///     * recipient             32         bytes32    52\\n  ///     * destinationCaller     32         bytes32    84\\n  ///     * messageBody           dynamic    bytes      116\\n  /// param attestation A valid attestation is the concatenated 65-byte signature(s) of\\n  /// exactly `thresholdSignature` signatures, in increasing order of attester address.\\n  /// ***If the attester addresses recovered from signatures are not in increasing order,\\n  /// signature verification will fail.***\\n  /// If incorrect number of signatures or duplicate signatures are supplied,\\n  /// signature verification will fail.\\n  function receiveMessage(bytes calldata message, bytes calldata attestation) external returns (bool success);\\n\\n  /// Returns domain of chain on which the contract is deployed.\\n  /// @dev immutable\\n  function localDomain() external view returns (uint32);\\n\\n  /// Returns message format version.\\n  /// @dev immutable\\n  function version() external view returns (uint32);\\n}\\n\"},\"contracts/pools/USDC/interfaces/ITokenMessenger.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n/*\\n * Copyright (c) 2022, Circle Internet Financial Limited.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n * http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\npragma solidity ^0.8.0;\\n\\ninterface ITokenMessenger {\\n  /// @notice Emitted when a DepositForBurn message is sent\\n  /// @param nonce Unique nonce reserved by message\\n  /// @param burnToken Address of token burnt on source domain\\n  /// @param amount Deposit amount\\n  /// @param depositor Address where deposit is transferred from\\n  /// @param mintRecipient Address receiving minted tokens on destination domain as bytes32\\n  /// @param destinationDomain Destination domain\\n  /// @param destinationTokenMessenger Address of TokenMessenger on destination domain as bytes32\\n  /// @param destinationCaller Authorized caller as bytes32 of receiveMessage() on destination domain,\\n  /// if not equal to bytes32(0). If equal to bytes32(0), any address can call receiveMessage().\\n  event DepositForBurn(\\n    uint64 indexed nonce,\\n    address indexed burnToken,\\n    uint256 amount,\\n    address indexed depositor,\\n    bytes32 mintRecipient,\\n    uint32 destinationDomain,\\n    bytes32 destinationTokenMessenger,\\n    bytes32 destinationCaller\\n  );\\n\\n  /// @notice Burns the tokens on the source side to produce a nonce through\\n  /// Circles Cross Chain Transfer Protocol.\\n  /// @param amount Amount of tokens to deposit and burn.\\n  /// @param destinationDomain Destination domain identifier.\\n  /// @param mintRecipient Address of mint recipient on destination domain.\\n  /// @param burnToken Address of contract to burn deposited tokens, on local domain.\\n  /// @param destinationCaller Caller on the destination domain, as bytes32.\\n  /// @return nonce The unique nonce used in unlocking the funds on the destination chain.\\n  /// @dev emits DepositForBurn\\n  function depositForBurnWithCaller(\\n    uint256 amount,\\n    uint32 destinationDomain,\\n    bytes32 mintRecipient,\\n    address burnToken,\\n    bytes32 destinationCaller\\n  ) external returns (uint64 nonce);\\n\\n  /// @notice Emitted when a DepositForBurn message is sent on CCTP V2\\n  /// @notice Emitted when a DepositForBurn message is sent\\n  /// @param burnToken address of token burnt on source domain\\n  /// @param amount deposit amount\\n  /// @param depositor address where deposit is transferred from\\n  /// @param mintRecipient address receiving minted tokens on destination domain as bytes32\\n  /// @param destinationDomain destination domain\\n  /// @param destinationTokenMessenger address of TokenMessenger on destination domain as bytes32\\n  /// @param destinationCaller authorized caller as bytes32 of receiveMessage() on destination domain.\\n  /// If equal to bytes32(0), any address can broadcast the message.\\n  /// @param maxFee maximum fee to pay on destination domain, in units of burnToken\\n  /// @param minFinalityThreshold the minimum finality at which the message should be attested to.\\n  /// @param hookData optional hook for execution on destination domain\\n  event DepositForBurn(\\n    address indexed burnToken,\\n    uint256 amount,\\n    address indexed depositor,\\n    bytes32 mintRecipient,\\n    uint32 destinationDomain,\\n    bytes32 destinationTokenMessenger,\\n    bytes32 destinationCaller,\\n    uint32 maxFee,\\n    uint32 indexed minFinalityThreshold,\\n    bytes hookData\\n  );\\n\\n  /// @notice Burns the tokens on the source side through Circles Cross Chain Transfer Protocol V2.\\n  /// @param amount Amount of tokens to deposit and burn.\\n  /// @param destinationDomain Destination domain identifier.\\n  /// @param mintRecipient Address of mint recipient on destination domain.\\n  /// @param burnToken Address of contract to burn deposited tokens, on local domain.\\n  /// @param destinationCaller Caller on the destination domain, as bytes32.\\n  /// @param maxFee Maximum fee to be paid for fast burn, specified in burnToken. Should be 0 when using non-fast mode.\\n  /// @param minFinalityThreshold Minimum finality threshold at which the burn will be attested\\n  /// should be 2000 for Standard, 1000 for Fast.\\n  /// @dev This function is only available for CCTP V2.\\n  function depositForBurn(\\n    uint256 amount,\\n    uint32 destinationDomain,\\n    bytes32 mintRecipient,\\n    address burnToken,\\n    bytes32 destinationCaller,\\n    uint32 maxFee,\\n    uint32 minFinalityThreshold\\n  ) external;\\n\\n  /// @notice Burns USDC on source through Circle's Cross Chain Transfer Protocol V2.\\n  /// Custom hook data is included within the message body, which gets attested to along with the rest of the message.\\n  /// @dev This function is only available for CCTP V2.\\n  /// @param amount Amount of tokens to deposit and burn.\\n  /// @param destinationDomain Destination domain identifier.\\n  /// @param mintRecipient Address of mint recipient on destination domain.\\n  /// @param burnToken The address of the token being burned.\\n  /// @param destinationCaller Allowed caller of receiveMessage() on the destination domain as bytes32.\\n  /// @param maxFee Maximum fee to pay on destination for fast transfer, specified in units of burnToken. Should be 0 when using standard transfer.\\n  /// @param minFinalityThreshold Minimum finality threshold at which the burn will be attested (2000 for standard, 1000 for fast).\\n  /// @param hookData Additional data to attest and process on destination.\\n  function depositForBurnWithHook(\\n    uint256 amount,\\n    uint32 destinationDomain,\\n    bytes32 mintRecipient,\\n    address burnToken,\\n    bytes32 destinationCaller,\\n    uint32 maxFee,\\n    uint32 minFinalityThreshold,\\n    bytes calldata hookData\\n  ) external;\\n\\n  /// Returns the version of the message body format.\\n  /// @dev immutable\\n  function messageBodyVersion() external view returns (uint32);\\n\\n  /// Returns local Message Transmitter responsible for sending and receiving messages\\n  /// to/from remote domainsmessage transmitter for this token messenger.\\n  /// @dev immutable\\n  function localMessageTransmitter() external view returns (address);\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2Step.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {IOwnable} from \\\"../interfaces/IOwnable.sol\\\";\\n\\n/// @notice A minimal contract that implements 2-step ownership transfer and nothing more. It's made to be minimal\\n/// to reduce the impact of the bytecode size on any contract that inherits from it.\\ncontract Ownable2Step is IOwnable {\\n  /// @notice The pending owner is the address to which ownership may be transferred.\\n  address private s_pendingOwner;\\n  /// @notice The owner is the current owner of the contract.\\n  /// @dev The owner is the second storage variable so any implementing contract could pack other state with it\\n  /// instead of the much less used s_pendingOwner.\\n  address private s_owner;\\n\\n  error OwnerCannotBeZero();\\n  error MustBeProposedOwner();\\n  error CannotTransferToSelf();\\n  error OnlyCallableByOwner();\\n\\n  event OwnershipTransferRequested(address indexed from, address indexed to);\\n  event OwnershipTransferred(address indexed from, address indexed to);\\n\\n  constructor(address newOwner, address pendingOwner) {\\n    if (newOwner == address(0)) {\\n      revert OwnerCannotBeZero();\\n    }\\n\\n    s_owner = newOwner;\\n    if (pendingOwner != address(0)) {\\n      _transferOwnership(pendingOwner);\\n    }\\n  }\\n\\n  /// @notice Get the current owner\\n  function owner() public view override returns (address) {\\n    return s_owner;\\n  }\\n\\n  /// @notice Allows an owner to begin transferring ownership to a new address. The new owner needs to call\\n  /// `acceptOwnership` to accept the transfer before any permissions are changed.\\n  /// @param to The address to which ownership will be transferred.\\n  function transferOwnership(\\n    address to\\n  ) public override onlyOwner {\\n    _transferOwnership(to);\\n  }\\n\\n  /// @notice validate, transfer ownership, and emit relevant events\\n  /// @param to The address to which ownership will be transferred.\\n  function _transferOwnership(\\n    address to\\n  ) private {\\n    if (to == msg.sender) {\\n      revert CannotTransferToSelf();\\n    }\\n\\n    s_pendingOwner = to;\\n\\n    emit OwnershipTransferRequested(s_owner, to);\\n  }\\n\\n  /// @notice Allows an ownership transfer to be completed by the recipient.\\n  function acceptOwnership() external override {\\n    if (msg.sender != s_pendingOwner) {\\n      revert MustBeProposedOwner();\\n    }\\n\\n    address oldOwner = s_owner;\\n    s_owner = msg.sender;\\n    s_pendingOwner = address(0);\\n\\n    emit OwnershipTransferred(oldOwner, msg.sender);\\n  }\\n\\n  /// @notice validate access\\n  function _validateOwnership() internal view {\\n    if (msg.sender != s_owner) {\\n      revert OnlyCallableByOwner();\\n    }\\n  }\\n\\n  /// @notice Reverts if called by anyone other than the contract owner.\\n  modifier onlyOwner() {\\n    _validateOwnership();\\n    _;\\n  }\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2StepMsgSender.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {Ownable2Step} from \\\"./Ownable2Step.sol\\\";\\n\\n/// @notice Sets the msg.sender to be the owner of the contract and does not set a pending owner.\\ncontract Ownable2StepMsgSender is Ownable2Step {\\n  constructor() Ownable2Step(msg.sender, address(0)) {}\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/IOwnable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IOwnable {\\n  function owner() external returns (address);\\n\\n  function transferOwnership(\\n    address recipient\\n  ) external;\\n\\n  function acceptOwnership() external;\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/ITypeAndVersion.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ITypeAndVersion {\\n  function typeAndVersion() external pure returns (string memory);\\n}\\n\"},\"node_modules/@openzeppelin/contracts-4.8.3/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"},\"node_modules/@openzeppelin/contracts-4.8.3/token/ERC20/extensions/draft-IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"},\"node_modules/@openzeppelin/contracts-4.8.3/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance \\u003e= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length \\u003e 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"},\"node_modules/@openzeppelin/contracts-4.8.3/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length \\u003e 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length \\u003e 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.0.2/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.0.2/utils/structs/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position is the index of the value in the `values` array plus 1.\\n        // Position 0 is used to mean a value is not in the set.\\n        mapping(bytes32 value =\\u003e uint256) _positions;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._positions[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We cache the value's position to prevent multiple reads from the same storage slot\\n        uint256 position = set._positions[value];\\n\\n        if (position != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 valueIndex = position - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (valueIndex != lastIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the lastValue to the index where the value to delete is\\n                set._values[valueIndex] = lastValue;\\n                // Update the tracked position of the lastValue (that was just moved)\\n                set._positions[lastValue] = position;\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the tracked position for the deleted slot\\n            delete set._positions[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._positions[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"}}}"
