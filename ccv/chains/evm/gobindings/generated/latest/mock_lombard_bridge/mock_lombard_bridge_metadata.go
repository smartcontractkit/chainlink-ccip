// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package mock_lombard_bridge

var SolidityStandardInput = "{\"version\":\"v0.8.26+commit.8a97fa7a\",\"language\":\"Solidity\",\"settings\":{\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"appendCBOR\":true,\"bytecodeHash\":\"none\",\"useLiteralContent\":false},\"optimizer\":{\"enabled\":true,\"runs\":80000},\"outputSelection\":{\"contracts/interfaces/lombard/IBridgeV2.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/interfaces/lombard/IBridgeV3.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/interfaces/lombard/IMailbox.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/test/mocks/MockLombardBridge.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/test/mocks/MockLombardMailbox.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/token/ERC20/IERC20.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]}},\"remappings\":[\"forge-std/=node_modules/@chainlink/contracts/src/v0.8/vendor/forge-std/src/\",\"@chainlink/ace/policy-management/=node_modules/@chainlink/ace/packages/policy-management/src/\",\"@chainlink/contracts/=node_modules/@chainlink/contracts/\",\"@openzeppelin/contracts@4.8.3/=node_modules/@openzeppelin/contracts-4.8.3/\",\"@openzeppelin/contracts@5.3.0/=node_modules/@openzeppelin/contracts-5.3.0/\"],\"viaIR\":true},\"sources\":{\"contracts/interfaces/lombard/IBridgeV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\n\\n/// @custom:security-contact legal@lombard.finance\\ninterface IBridgeV2 {\\n  function mailbox() external view returns (address);\\n\\n  function MSG_VERSION() external view returns (uint8);\\n\\n  function deposit(\\n    bytes32 destinationChain,\\n    address token,\\n    address sender,\\n    bytes32 recipient,\\n    uint256 amount,\\n    bytes32 destinationCaller\\n  ) external payable returns (uint256, bytes32);\\n\\n  function getAllowedDestinationToken(\\n    bytes32 destinationChain,\\n    address sourceToken\\n  ) external view returns (bytes32);\\n}\\n\"},\"contracts/interfaces/lombard/IBridgeV3.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\n\\nimport {IBridgeV2} from \\\"./IBridgeV2.sol\\\";\\n\\n/// @custom:security-contact legal@lombard.finance\\ninterface IBridgeV3 is IBridgeV2 {\\n  function deposit(\\n    bytes32 destinationChain,\\n    address token,\\n    address sender,\\n    bytes32 recipient,\\n    uint256 amount,\\n    bytes32 destinationCaller,\\n    // Optional bytes field that is forwarded to the destination chain and is included in the message proof.\\n    bytes calldata optionalMessage\\n  ) external payable returns (uint256, bytes32);\\n}\\n\"},\"contracts/interfaces/lombard/IMailbox.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\n\\ninterface IMailbox {\\n  function deliverAndHandle(\\n    bytes calldata rawPayload,\\n    bytes calldata proof\\n  ) external returns (bytes32, bool executed, bytes memory optionalMessage);\\n}\\n\"},\"contracts/test/mocks/MockLombardBridge.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\n\\nimport {IBridgeV3} from \\\"../../interfaces/lombard/IBridgeV3.sol\\\";\\nimport {MockLombardMailbox} from \\\"./MockLombardMailbox.sol\\\";\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts@5.3.0/token/ERC20/IERC20.sol\\\";\\n\\ncontract MockLombardBridge is IBridgeV3 {\\n  address public s_mailbox;\\n  bytes32 public s_lastPayloadHash;\\n\\n  mapping(bytes32 destinationChain =\\u003e mapping(address sourceToken =\\u003e bytes32 destinationToken)) internal\\n    s_allowedDestinationTokens;\\n\\n  constructor() {\\n    s_mailbox = address(new MockLombardMailbox());\\n  }\\n\\n  function mailbox() external view override returns (address) {\\n    return s_mailbox;\\n  }\\n\\n  function setMailbox(\\n    address mailbox_\\n  ) external {\\n    s_mailbox = mailbox_;\\n  }\\n\\n  // solhint-disable-next-line func-name-mixedcase\\n  function MSG_VERSION() external pure override returns (uint8) {\\n    return 1;\\n  }\\n\\n  function deposit(\\n    bytes32,\\n    address token,\\n    address,\\n    bytes32,\\n    uint256 amount,\\n    bytes32,\\n    bytes calldata optionalMessage\\n  ) external payable override returns (uint256, bytes32) {\\n    IERC20(token).transferFrom(msg.sender, address(this), amount);\\n    s_lastPayloadHash = keccak256(abi.encode(block.timestamp, optionalMessage));\\n\\n    MockLombardMailbox(s_mailbox).setMessageId(optionalMessage);\\n\\n    return (0, s_lastPayloadHash);\\n  }\\n\\n  function deposit(\\n    bytes32, // destinationChain\\n    address token,\\n    address, // sender\\n    bytes32, // recipient\\n    uint256 amount,\\n    bytes32 // destinationCaller\\n  ) external payable returns (uint256 nonce, bytes32 payloadHash) {\\n    IERC20(token).transferFrom(msg.sender, address(this), amount);\\n    return (1, keccak256(abi.encodePacked(block.timestamp, token)));\\n  }\\n\\n  function getAllowedDestinationToken(\\n    bytes32 destinationChain,\\n    address sourceToken\\n  ) external view returns (bytes32) {\\n    return s_allowedDestinationTokens[destinationChain][sourceToken];\\n  }\\n\\n  function setAllowedDestinationToken(\\n    bytes32 destinationChain,\\n    address sourceToken,\\n    bytes32 destinationToken\\n  ) external {\\n    s_allowedDestinationTokens[destinationChain][sourceToken] = destinationToken;\\n  }\\n}\\n\"},\"contracts/test/mocks/MockLombardMailbox.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\n\\nimport {IMailbox} from \\\"../../interfaces/lombard/IMailbox.sol\\\";\\n\\ncontract MockLombardMailbox is IMailbox {\\n  bytes32 internal s_payloadHash;\\n  bool internal s_executed = true;\\n  bytes internal s_executionResult;\\n\\n  bytes public s_lastRawPayload;\\n\\n  function setResult(\\n    bytes32 payloadHash,\\n    bool executed,\\n    bytes calldata executionResult\\n  ) external {\\n    s_payloadHash = payloadHash;\\n    s_executed = executed;\\n    s_executionResult = executionResult;\\n  }\\n\\n  /// @dev Alias used by MockLombardBridge to set the execution result (optional message).\\n  function setMessageId(\\n    bytes calldata optionalMessage\\n  ) external {\\n    s_executionResult = optionalMessage;\\n  }\\n\\n  function setShouldSucceed(\\n    bool shouldSucceed\\n  ) external {\\n    s_executed = shouldSucceed;\\n  }\\n\\n  function deliverAndHandle(\\n    bytes calldata rawPayload,\\n    bytes calldata\\n  ) external returns (bytes32, bool, bytes memory) {\\n    s_lastRawPayload = rawPayload;\\n    // It means that the bridge did not set any expectations for the payload, so we return a hash of the raw payload and\\n    // the raw payload itself as the optional message.\\n    if (s_payloadHash == bytes32(0) \\u0026\\u0026 s_executionResult.length == 0) {\\n      return (keccak256(rawPayload), true, rawPayload);\\n    }\\n\\n    bytes32 payloadHash = s_payloadHash != bytes32(0) ? s_payloadHash : keccak256(rawPayload);\\n    return (payloadHash, s_executed, s_executionResult);\\n  }\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-20 standard as defined in the ERC.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"}}}"
