// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.


package usdc_token_pool_proxy

var SolidityStandardInput = "{\"version\":\"v0.8.26+commit.8a97fa7a\",\"language\":\"Solidity\",\"settings\":{\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"appendCBOR\":true,\"bytecodeHash\":\"none\",\"useLiteralContent\":false},\"optimizer\":{\"enabled\":true,\"runs\":50000},\"outputSelection\":{\"contracts/interfaces/ICrossChainVerifierResolver.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/interfaces/IPool.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/interfaces/IPoolV1V2.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/interfaces/IPoolV2.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/interfaces/IRouter.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/libraries/Client.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/libraries/FeeTokenHandler.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/libraries/Pool.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/libraries/USDCSourcePoolDataCodec.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/pools/USDC/USDCTokenPoolProxy.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2Step.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2StepMsgSender.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/IOwnable.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/ITypeAndVersion.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/interfaces/IERC1363.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/interfaces/IERC165.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/interfaces/IERC20.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/token/ERC20/IERC20.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/token/ERC20/utils/SafeERC20.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/utils/introspection/ERC165Checker.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/utils/introspection/IERC165.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]}},\"remappings\":[\"forge-std/=node_modules/@chainlink/contracts/src/v0.8/vendor/forge-std/src/\",\"@chainlink/policy-management/=node_modules/@chainlink/ace/packages/policy-management/src/\",\"@chainlink/contracts/=node_modules/@chainlink/contracts/\",\"@openzeppelin/contracts@4.8.3/=node_modules/@openzeppelin/contracts-4.8.3/\",\"@openzeppelin/contracts@5.3.0/=node_modules/@openzeppelin/contracts-5.3.0/\"],\"viaIR\":true},\"sources\":{\"contracts/interfaces/ICrossChainVerifierResolver.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\n/// @notice Resolves and returns the appropriate verifier contract for the given outbound / inbound traffic.\\ninterface ICrossChainVerifierResolver {\\n  /// @notice Returns the appropriate verifier contract based on the given verifierResults.\\n  /// @dev The OffRamp is responsible for calling this function using the verifierResults it receives from the executor.\\n  /// If the verifier specified by the executor is actually a resolver, the OffRamp will call this function to get the actual verifier contract.\\n  /// Verifiers can build resolvers that process the verifierResults in accordance with how their verifier forms verifierResults. For example, their verifier may\\n  /// prefix the verifierResults with a version identifier, which the resolver can parse to determine the correct verifier contract.\\n  /// @param verifierResults The verifierResults formed by the verifier.\\n  /// @return verifierAddress The address of the verifier contract.\\n  function getInboundImplementation(\\n    bytes calldata verifierResults\\n  ) external view returns (address);\\n\\n  /// @notice Returns the appropriate verifier contract based on the given destChainSelector.\\n  /// @dev The OnRamp is responsible for calling this function using the destChainSelector specified by the sender.\\n  /// If the verifier specified by the sender is actually a resolver, the OnRamp will call this function to get the actual verifier contract.\\n  /// For example, resolvers can maintain a simple mapping of destChainSelector to verifier contract address.\\n  /// @param destChainSelector The destChainSelector for a message.\\n  /// @param extraArgs Extra arguments that can be used by the resolver to determine the correct verifier contract.\\n  /// @return verifierAddress The address of the verifier contract.\\n  function getOutboundImplementation(\\n    uint64 destChainSelector,\\n    bytes memory extraArgs\\n  ) external view returns (address);\\n}\\n\"},\"contracts/interfaces/IPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {Pool} from \\\"../libraries/Pool.sol\\\";\\n\\nimport {IERC165} from \\\"@openzeppelin/contracts@5.3.0/utils/introspection/IERC165.sol\\\";\\n\\n/// @notice Shared public interface for multiple V1 pool types.\\n/// Each pool type handles a different child token model e.g. lock/unlock, mint/burn.\\ninterface IPoolV1 is IERC165 {\\n  /// @notice Lock tokens into the pool or burn the tokens.\\n  /// @param lockOrBurnIn Encoded data fields for the processing of tokens on the source chain.\\n  /// @return lockOrBurnOut Encoded data fields for the processing of tokens on the destination chain.\\n  function lockOrBurn(\\n    Pool.LockOrBurnInV1 calldata lockOrBurnIn\\n  ) external returns (Pool.LockOrBurnOutV1 memory lockOrBurnOut);\\n\\n  /// @notice Releases or mints tokens to the receiver address.\\n  /// @param releaseOrMintIn All data required to release or mint tokens.\\n  /// @return releaseOrMintOut The amount of tokens released or minted on the local chain, denominated\\n  /// in the local token's decimals.\\n  /// @dev The offRamp asserts that the balanceOf of the receiver has been incremented by exactly the number\\n  /// of tokens that is returned in ReleaseOrMintOutV1.destinationAmount. If the amounts do not match, the tx reverts.\\n  function releaseOrMint(\\n    Pool.ReleaseOrMintInV1 calldata releaseOrMintIn\\n  ) external returns (Pool.ReleaseOrMintOutV1 memory);\\n\\n  /// @notice Checks whether a remote chain is supported in the token pool.\\n  /// @param remoteChainSelector The selector of the remote chain.\\n  /// @return true if the given chain is a permissioned remote chain.\\n  function isSupportedChain(\\n    uint64 remoteChainSelector\\n  ) external view returns (bool);\\n\\n  /// @notice Returns if the token pool supports the given token.\\n  /// @param token The address of the token.\\n  /// @return true if the token is supported by the pool.\\n  function isSupportedToken(\\n    address token\\n  ) external view returns (bool);\\n}\\n\"},\"contracts/interfaces/IPoolV1V2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {IPoolV1} from \\\"./IPool.sol\\\";\\nimport {IPoolV2} from \\\"./IPoolV2.sol\\\";\\n\\ninterface IPoolV1V2 is IPoolV1, IPoolV2 {}\\n\"},\"contracts/interfaces/IPoolV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {Pool} from \\\"../libraries/Pool.sol\\\";\\n\\nimport {IERC165} from \\\"@openzeppelin/contracts@5.3.0/utils/introspection/IERC165.sol\\\";\\n\\n/// @notice Shared public interface for multiple V2 pool types.\\n/// Each pool type handles a different child token model e.g. lock/release, mint/burn.\\ninterface IPoolV2 is IERC165 {\\n  struct TokenTransferFeeConfig {\\n    uint32 destGasOverhead; // ───────────────────────╮ Gas charged to execute the token transfer on the destination chain.\\n    uint32 destBytesOverhead; //                      │ Data availability bytes.\\n    uint32 defaultBlockConfirmationFeeUSDCents; //    │ Fee to charge for token transfer with default block confirmation, multiples of 0.01 USD.\\n    uint32 customBlockConfirmationFeeUSDCents; //     │ Fee to charge for token transfer with custom block confirmation, multiples of 0.01 USD.\\n    //                                                │ The following two fee is deducted from the transferred asset, not added on top.\\n    uint16 defaultBlockConfirmationTransferFeeBps; // │ Fee in basis points for default finality transfers [0-10_000].\\n    uint16 customBlockConfirmationTransferFeeBps; //  │ Fee in basis points for custom finality transfers [0-10_000].\\n    bool isEnabled; // ───────────────────────────────╯ Whether this config is enabled.\\n  }\\n\\n  enum MessageDirection {\\n    Outbound,\\n    Inbound\\n  }\\n\\n  /// @notice Lock tokens into the pool or burn the tokens.\\n  /// @param lockOrBurnIn Encoded data fields for the processing of tokens on the source chain.\\n  /// @param blockConfirmationRequested Requested block confirmation.\\n  /// @param tokenArgs Additional token arguments.\\n  /// @return lockOrBurnOut Encoded data fields for the processing of tokens on the destination chain.\\n  /// @return destTokenAmount The amount of tokens that will be set in TokenTransferV1.amount to be released/mint on destination.\\n  function lockOrBurn(\\n    Pool.LockOrBurnInV1 calldata lockOrBurnIn,\\n    uint16 blockConfirmationRequested,\\n    bytes calldata tokenArgs\\n  ) external returns (Pool.LockOrBurnOutV1 memory lockOrBurnOut, uint256 destTokenAmount);\\n\\n  /// @notice Releases or mints tokens on the destination chain.\\n  /// @param releaseOrMintIn Encoded data fields for the processing of tokens on the destination chain.\\n  /// @param blockConfirmationRequested Requested block confirmation.\\n  /// @return releaseOrMintOut Encoded data fields describing the result of the release or mint.\\n  function releaseOrMint(\\n    Pool.ReleaseOrMintInV1 calldata releaseOrMintIn,\\n    uint16 blockConfirmationRequested\\n  ) external returns (Pool.ReleaseOrMintOutV1 memory releaseOrMintOut);\\n\\n  /// @notice Returns the set of required CCVs for transfers in a given direction.\\n  /// @param localToken The address of the local token.\\n  /// @param remoteChainSelector The chain selector of the remote chain.\\n  /// @param amount The amount of tokens to be transferred.\\n  /// @param blockConfirmationRequested Requested block confirmation.\\n  /// @param extraData Direction-specific payload forwarded by the caller (e.g. token args or source pool data).\\n  /// @param direction Whether CCVs are required for outbound (source -\\u003e remote) or inbound (remote -\\u003e destination) transfers.\\n  /// @return requiredCCVs A set of addresses representing the required CCVs.\\n  function getRequiredCCVs(\\n    address localToken,\\n    uint64 remoteChainSelector,\\n    uint256 amount,\\n    uint16 blockConfirmationRequested,\\n    bytes calldata extraData,\\n    MessageDirection direction\\n  ) external view returns (address[] memory requiredCCVs);\\n\\n  /// @notice Returns the fee overrides for transferring the pool's token to a destination chain.\\n  /// @param localToken The address of the local token.\\n  /// @param destChainSelector The chain selector of the destination chain.\\n  /// @param blockConfirmationRequested Requested block confirmation.\\n  /// @param tokenArgs Additional token argument from the CCIP message.\\n  /// @return feeConfig the fee configuration for transferring the token to the destination chain.\\n  function getTokenTransferFeeConfig(\\n    address localToken,\\n    uint64 destChainSelector,\\n    uint16 blockConfirmationRequested,\\n    bytes calldata tokenArgs\\n  ) external view returns (TokenTransferFeeConfig memory feeConfig);\\n\\n  /// @notice Returns the pool fee parameters that will apply to a transfer.\\n  /// @param localToken The local asset being transferred.\\n  /// @param destChainSelector The destination lane selector.\\n  /// @param amount The amount of tokens being bridged on this lane.\\n  /// @param feeToken The token used to pay feeUSDCents.\\n  /// @param blockConfirmationRequested Requested block confirmation.\\n  /// @param tokenArgs Opaque token arguments supplied by the caller.\\n  /// @return feeUSDCents Flat fee charged in USD cents (crumbs) for this transfer.\\n  /// @return destGasOverhead Destination gas charged for accounting in the cost model.\\n  /// @return destBytesOverhead Destination calldata size attributed to the transfer.\\n  /// @return tokenFeeBps Bps charged in token units. Value of zero implies no in-token fee.\\n  /// @return isEnabled Whether the pool's fee config is enabled. If false, OnRamp should use FeeQuoter defaults.\\n  function getFee(\\n    address localToken,\\n    uint64 destChainSelector,\\n    uint256 amount,\\n    address feeToken,\\n    uint16 blockConfirmationRequested,\\n    bytes calldata tokenArgs\\n  )\\n    external\\n    view\\n    returns (uint256 feeUSDCents, uint32 destGasOverhead, uint32 destBytesOverhead, uint16 tokenFeeBps, bool isEnabled);\\n\\n  /// @notice Gets the token address on the remote chain.\\n  /// @param remoteChainSelector Remote chain selector.\\n  /// @dev To support non-evm chains, this value is encoded into bytes.\\n  function getRemoteToken(\\n    uint64 remoteChainSelector\\n  ) external view returns (bytes memory);\\n}\\n\"},\"contracts/interfaces/IRouter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {Client} from \\\"../libraries/Client.sol\\\";\\n\\ninterface IRouter {\\n  error OnlyOffRamp();\\n\\n  /// @notice Route the message to its intended receiver contract.\\n  /// @param message Client.Any2EVMMessage struct.\\n  /// @param gasForCallExactCheck of params for exec.\\n  /// @param gasLimit set of params for exec.\\n  /// @param receiver set of params for exec.\\n  /// @dev if the receiver is a contracts that signals support for CCIP execution through EIP-165.\\n  /// the contract is called. If not, only tokens are transferred.\\n  /// @return success A boolean value indicating whether the ccip message was received without errors.\\n  /// @return retBytes A bytes array containing return data form CCIP receiver.\\n  /// @return gasUsed the gas used by the external customer call. Does not include any overhead.\\n  function routeMessage(\\n    Client.Any2EVMMessage calldata message,\\n    uint16 gasForCallExactCheck,\\n    uint256 gasLimit,\\n    address receiver\\n  ) external returns (bool success, bytes memory retBytes, uint256 gasUsed);\\n\\n  /// @notice Returns the configured onRamp for a specific destination chain.\\n  /// @param destChainSelector The destination chain Id to get the onRamp for.\\n  /// @return onRampAddress The address of the onRamp.\\n  function getOnRamp(\\n    uint64 destChainSelector\\n  ) external view returns (address onRampAddress);\\n\\n  /// @notice Return true if the given offRamp is a configured offRamp for the given source chain.\\n  /// @param sourceChainSelector The source chain selector to check.\\n  /// @param offRamp The address of the offRamp to check.\\n  function isOffRamp(\\n    uint64 sourceChainSelector,\\n    address offRamp\\n  ) external view returns (bool isOffRamp);\\n}\\n\"},\"contracts/libraries/Client.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// End consumer library.\\nlibrary Client {\\n  struct EVMTokenAmount {\\n    address token; // token address on the local chain.\\n    uint256 amount; // Amount of tokens.\\n  }\\n\\n  struct Any2EVMMessage {\\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\\n    uint64 sourceChainSelector; // Source chain selector.\\n    bytes sender; // abi.encode(address) on EVM source chains; abi.decode(sender, (address)) to recover.\\n    bytes data; // payload sent in original message.\\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\\n  }\\n\\n  // If extraArgs is empty bytes, the default is 200k gas limit.\\n  struct EVM2AnyMessage {\\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains.\\n    bytes data; // Data payload.\\n    EVMTokenAmount[] tokenAmounts; // Token transfers.\\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV3).\\n  }\\n\\n  /// @notice Tag to indicate no execution on the destination chain. Execution will need to be done manually.\\n  /// @dev Preimage for this tag is: keccak256(\\\"NO_EXECUTION_TAG\\\")[:4]\\n  bytes4 public constant NO_EXECUTION_TAG = 0xeba517d2;\\n  address public constant NO_EXECUTION_ADDRESS = address(bytes20(NO_EXECUTION_TAG));\\n\\n  // ================================================================\\n  // │                           Legacy                             │\\n  // ================================================================\\n\\n  // Tag to indicate only a gas limit. Only usable for EVM as destination chain.\\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\\n\\n  struct EVMExtraArgsV1 {\\n    uint256 gasLimit;\\n  }\\n\\n  function _argsToBytes(\\n    EVMExtraArgsV1 memory extraArgs\\n  ) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\\n  }\\n\\n  // Tag to indicate a gas limit (or dest chain equivalent processing units) and Out Of Order Execution. This tag is\\n  // available for multiple chain families. If there is no chain family specific tag, this is the default available\\n  // for a chain.\\n  // Note: not available for Solana or Sui VM based chains.\\n  bytes4 public constant GENERIC_EXTRA_ARGS_V2_TAG = 0x181dcf10;\\n\\n  /// @param gasLimit: gas limit for the callback on the destination chain.\\n  /// @param allowOutOfOrderExecution: if true, it indicates that the message can be executed in any order relative to\\n  /// other messages from the same sender. This value's default varies by chain. On some chains, a particular value is\\n  /// enforced, meaning if the expected value is not set, the message request will revert.\\n  /// @dev Fully compatible with the previously existing EVMExtraArgsV2.\\n  struct GenericExtraArgsV2 {\\n    uint256 gasLimit;\\n    bool allowOutOfOrderExecution;\\n  }\\n\\n  // Extra args tag for chains that use the Sui VM.\\n  bytes4 public constant SUI_EXTRA_ARGS_V1_TAG = 0x21ea4ca9;\\n\\n  // Extra args tag for chains that use the Solana VM.\\n  bytes4 public constant SVM_EXTRA_ARGS_V1_TAG = 0x1f3b3aba;\\n\\n  struct SVMExtraArgsV1 {\\n    uint32 computeUnits;\\n    uint64 accountIsWritableBitmap;\\n    bool allowOutOfOrderExecution;\\n    bytes32 tokenReceiver;\\n    // Additional accounts needed for execution of CCIP receiver. Must be empty if message.receiver is zero.\\n    // Token transfer related accounts are specified in the token pool lookup table on SVM.\\n    bytes32[] accounts;\\n  }\\n\\n  /// @dev The maximum number of accounts that can be passed in SVMExtraArgs.\\n  uint256 public constant SVM_EXTRA_ARGS_MAX_ACCOUNTS = 64;\\n\\n  /// @dev The expected static payload size of a token transfer when Borsh encoded and submitted to SVM.\\n  /// TokenPool extra data and offchain data sizes are dynamic, and should be accounted for separately.\\n  uint256 public constant SVM_TOKEN_TRANSFER_DATA_OVERHEAD = (4 + 32) // source_pool\\n    + 32 // token_address\\n    + 4 // gas_amount\\n    + 4 // extra_data overhead\\n    + 32 // amount\\n    + 32 // size of the token lookup table account\\n    + 32 // token-related accounts in the lookup table, over-estimated to 32, typically between 11 - 13\\n    + 32 // token account belonging to the token receiver, e.g ATA, not included in the token lookup table\\n    + 32 // per-chain token pool config, not included in the token lookup table\\n    + 32 // per-chain token billing config, not always included in the token lookup table\\n    + 32; // OffRamp pool signer PDA, not included in the token lookup table\\n\\n  /// @dev Number of overhead accounts needed for message execution on SVM.\\n  /// @dev These are message.receiver, and the OffRamp Signer PDA specific to the receiver.\\n  uint256 public constant SVM_MESSAGING_ACCOUNTS_OVERHEAD = 2;\\n\\n  /// @dev The size of each SVM account address in bytes.\\n  uint256 public constant SVM_ACCOUNT_BYTE_SIZE = 32;\\n\\n  struct SuiExtraArgsV1 {\\n    uint256 gasLimit;\\n    bool allowOutOfOrderExecution;\\n    bytes32 tokenReceiver;\\n    bytes32[] receiverObjectIds;\\n  }\\n\\n  /// @dev The expected static payload size of a token transfer when BCS encoded and submitted to SUI.\\n  /// TokenPool extra data and offchain data sizes are dynamic, and should be accounted for separately.\\n  uint256 public constant SUI_TOKEN_TRANSFER_DATA_OVERHEAD = (4 + 32) // source_pool, 4 bytes for length, 32 bytes for address\\n    + 32 // dest_token_address\\n    + 4 // dest_gas_amount\\n    + 4 // extra_data length, the contents are calculated separately\\n    + 32; // amount\\n\\n  /// @dev Number of overhead accounts needed for message execution on SUI.\\n  /// @dev This is the message.receiver.\\n  uint256 public constant SUI_MESSAGING_ACCOUNTS_OVERHEAD = 1;\\n\\n  /// @dev The maximum number of receiver object ids that can be passed in SuiExtraArgs.\\n  uint256 public constant SUI_EXTRA_ARGS_MAX_RECEIVER_OBJECT_IDS = 64;\\n\\n  /// @dev The size of each SUI account address in bytes.\\n  uint256 public constant SUI_ACCOUNT_BYTE_SIZE = 32;\\n\\n  function _argsToBytes(\\n    GenericExtraArgsV2 memory extraArgs\\n  ) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(GENERIC_EXTRA_ARGS_V2_TAG, extraArgs);\\n  }\\n\\n  function _svmArgsToBytes(\\n    SVMExtraArgsV1 memory extraArgs\\n  ) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(SVM_EXTRA_ARGS_V1_TAG, extraArgs);\\n  }\\n\\n  function _suiArgsToBytes(\\n    SuiExtraArgsV1 memory extraArgs\\n  ) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(SUI_EXTRA_ARGS_V1_TAG, extraArgs);\\n  }\\n}\\n\"},\"contracts/libraries/FeeTokenHandler.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts@5.3.0/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts@5.3.0/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nlibrary FeeTokenHandler {\\n  using SafeERC20 for IERC20;\\n\\n  error ZeroAddressNotAllowed();\\n\\n  event FeeTokenWithdrawn(address indexed receiver, address indexed feeToken, uint256 amount);\\n\\n  /// @notice Withdraws the outstanding fee token balances to the fee aggregator.\\n  /// @param feeTokens The fee tokens to withdraw.\\n  /// @param feeAggregator The address to withdraw the fee tokens to, cannot be the zero address.\\n  function _withdrawFeeTokens(\\n    address[] calldata feeTokens,\\n    address feeAggregator\\n  ) internal {\\n    if (feeAggregator == address(0)) revert ZeroAddressNotAllowed();\\n\\n    for (uint256 i = 0; i \\u003c feeTokens.length; ++i) {\\n      IERC20 feeToken = IERC20(feeTokens[i]);\\n      uint256 feeTokenBalance = feeToken.balanceOf(address(this));\\n\\n      if (feeTokenBalance \\u003e 0) {\\n        feeToken.safeTransfer(feeAggregator, feeTokenBalance);\\n\\n        emit FeeTokenWithdrawn(feeAggregator, address(feeToken), feeTokenBalance);\\n      }\\n    }\\n  }\\n}\\n\"},\"contracts/libraries/Pool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice This library contains various token pool functions to aid constructing the return data.\\nlibrary Pool {\\n  // The tag used to signal support for the pool v1 standard.\\n  // bytes4(keccak256(\\\"CCIP_POOL_V1\\\"))\\n  bytes4 public constant CCIP_POOL_V1 = 0xaff2afbf;\\n\\n  // The number of bytes in the return data for a pool v1 releaseOrMint call.\\n  // This should match the size of the ReleaseOrMintOutV1 struct.\\n  uint16 public constant CCIP_POOL_V1_RET_BYTES = 32;\\n\\n  // The default max number of bytes in the return data for a pool v1 lockOrBurn call.\\n  // This data can be used to send information to the destination chain token pool. Can be overwritten\\n  // in the TokenTransferFeeConfig.destBytesOverhead if more data is required.\\n  uint32 public constant CCIP_LOCK_OR_BURN_V1_RET_BYTES = 32;\\n\\n  struct LockOrBurnInV1 {\\n    bytes receiver; //  The recipient of the tokens on the destination chain. For EVM source chains, this is abi-encoded (32 bytes).\\n    uint64 remoteChainSelector; // ─╮ The chain ID of the destination chain.\\n    address originalSender; // ─────╯ The original sender of the tx on the source chain.\\n    uint256 amount; //  The amount of tokens to lock or burn, denominated in the source token's decimals.\\n    address localToken; // The address on this chain of the token to lock or burn.\\n  }\\n\\n  struct LockOrBurnOutV1 {\\n    // The address of the destination token, abi encoded in the case of EVM chains.\\n    // This value is UNTRUSTED as any pool owner can return whatever value they want.\\n    bytes destTokenAddress;\\n    // Optional pool data to be transferred to the destination chain. Be default this is capped at\\n    // CCIP_LOCK_OR_BURN_V1_RET_BYTES bytes. If more data is required, the TokenTransferFeeConfig.destBytesOverhead\\n    // has to be set for the specific token.\\n    bytes destPoolData;\\n  }\\n\\n  struct ReleaseOrMintInV1 {\\n    bytes originalSender; //            The original sender of the tx on the source chain.\\n    uint64 remoteChainSelector; // ───╮ The chain ID of the source chain.\\n    address receiver; // ─────────────╯ The recipient of the tokens on the destination chain.\\n    uint256 sourceDenominatedAmount; // The amount of tokens to release or mint, denominated in the source token's decimals.\\n    address localToken; //              The address on this chain of the token to release or mint.\\n    /// @dev WARNING: sourcePoolAddress should be checked prior to any processing of funds. Make sure it matches the\\n    /// expected pool address for the given remoteChainSelector.\\n    bytes sourcePoolAddress; //         The address of the source pool, abi encoded in the case of EVM chains.\\n    bytes sourcePoolData; //            The data received from the source pool to process the release or mint.\\n    /// @dev WARNING: offchainTokenData is untrusted data.\\n    bytes offchainTokenData; //         The offchain data to process the release or mint.\\n  }\\n\\n  struct ReleaseOrMintOutV1 {\\n    // The number of tokens released or minted on the destination chain, denominated in the local token's decimals.\\n    // This value is expected to be equal to the ReleaseOrMintInV1.amount in the case where the source and destination\\n    // chain have the same number of decimals.\\n    uint256 destinationAmount;\\n  }\\n}\\n\"},\"contracts/libraries/USDCSourcePoolDataCodec.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\nlibrary USDCSourcePoolDataCodec {\\n  /// @dev The flag used to indicate that the source pool data is coming from a chain that does not have CCTP Support,\\n  /// and so the lock release pool should be used. The BurnMintWithLockReleaseTokenPool uses this flag as its source pool\\n  /// data to indicate that the tokens should be released from the lock release pool rather than attempting to be minted\\n  /// through CCTP.\\n  /// @dev The preimage is bytes4(keccak256(\\\"NO_CCTP_USE_LOCK_RELEASE\\\")).\\n  bytes4 public constant LOCK_RELEASE_FLAG = 0xfa7c07de;\\n\\n  /// @dev There are two different tags for CCTP V2 to allow for CCIP V1.7 Compatibility which will enable fast transfers.\\n  /// Both tags will route to the same CCTP V2 pool, but will allow for pools to identify the type of transfer (slow or fast).\\n\\n  /// @dev The preimage is bytes4(keccak256(\\\"CCTP_V2\\\"))\\n  bytes4 public constant CCTP_VERSION_2_TAG = 0xb148ea5f;\\n\\n  /// @dev The preimage is bytes4(keccak256(\\\"CCTP_V2_CCV\\\"))\\n  bytes4 public constant CCTP_VERSION_2_CCV_TAG = 0x3047587c;\\n}\\n\"},\"contracts/pools/USDC/USDCTokenPoolProxy.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\nimport {ICrossChainVerifierResolver} from \\\"../../interfaces/ICrossChainVerifierResolver.sol\\\";\\nimport {IPoolV1, IPoolV1V2, IPoolV2} from \\\"../../interfaces/IPoolV1V2.sol\\\";\\nimport {IRouter} from \\\"../../interfaces/IRouter.sol\\\";\\nimport {ITypeAndVersion} from \\\"@chainlink/contracts/src/v0.8/shared/interfaces/ITypeAndVersion.sol\\\";\\n\\nimport {FeeTokenHandler} from \\\"../../libraries/FeeTokenHandler.sol\\\";\\nimport {Pool} from \\\"../../libraries/Pool.sol\\\";\\nimport {USDCSourcePoolDataCodec} from \\\"../../libraries/USDCSourcePoolDataCodec.sol\\\";\\nimport {Ownable2StepMsgSender} from \\\"@chainlink/contracts/src/v0.8/shared/access/Ownable2StepMsgSender.sol\\\";\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts@5.3.0/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts@5.3.0/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {ERC165Checker} from \\\"@openzeppelin/contracts@5.3.0/utils/introspection/ERC165Checker.sol\\\";\\nimport {IERC165} from \\\"@openzeppelin/contracts@5.3.0/utils/introspection/IERC165.sol\\\";\\n\\n/// @notice A token pool proxy for USDC that allows for routing of messages to the correct pool based on the correct\\n/// lock or burn mechanism. This includes CCTP v1, CCTP v2, CCTP v2 with CCV, and lock release.\\n/// @dev This contract will be listed in the Token Admin Registry as a token pool. All of the child pools which\\n/// receive the messages should have this contract set as an authorized caller. It does not inherit from the base\\n/// TokenPool contract but still implements the IPoolV2 interface.\\ncontract USDCTokenPoolProxy is Ownable2StepMsgSender, IPoolV1V2, ITypeAndVersion {\\n  using SafeERC20 for IERC20;\\n  using ERC165Checker for address;\\n\\n  error AddressCannotBeZero();\\n  error ChainNotSupportedByVerifier(uint64 remoteChainSelector);\\n  error InvalidLockOrBurnMechanism(LockOrBurnMechanism mechanism);\\n  error InvalidMessageVersion(bytes4 version);\\n  error MismatchedArrayLengths();\\n  error NoLockOrBurnMechanismSet(uint64 remoteChainSelector);\\n  error CallerIsNotARampOnRouter(address caller);\\n  error TokenPoolUnsupported(address pool);\\n  error MustSetPoolForMechanism(uint64 remoteChainSelector, LockOrBurnMechanism mechanism);\\n\\n  event LockOrBurnMechanismUpdated(uint64 indexed remoteChainSelector, LockOrBurnMechanism mechanism);\\n  event PoolAddressesUpdated(PoolAddresses pools);\\n\\n  struct PoolAddresses {\\n    address cctpV1Pool;\\n    address cctpV2Pool;\\n    address cctpV2PoolWithCCV;\\n    address siloedLockReleasePool;\\n  }\\n\\n  enum LockOrBurnMechanism {\\n    INVALID_MECHANISM,\\n    CCTP_V1,\\n    CCTP_V2,\\n    LOCK_RELEASE,\\n    CCV\\n  }\\n\\n  string public constant override typeAndVersion = \\\"USDCTokenPoolProxy 2.0.0-dev\\\";\\n\\n  /// @dev Constant representing the default finality.\\n  uint16 internal constant WAIT_FOR_FINALITY = 0;\\n\\n  IERC20 internal immutable i_token;\\n  IRouter internal immutable i_router;\\n  ICrossChainVerifierResolver private immutable i_cctpVerifier;\\n\\n  mapping(uint64 remoteChainSelector =\\u003e LockOrBurnMechanism mechanism) internal s_lockOrBurnMechanism;\\n\\n  /// @dev This token pool should have minimal state, as it is only used to route messages to the correct\\n  /// pool. If more mechanisms are needed, such as a new CCTP version, then this contract should be updated\\n  /// to include the proper routing logic and reference the appropriate child pool.\\n  /// On/OffRamp\\n  ///     ↓\\n  /// USDCPoolProxy\\n  ///     ├──→ CCTPV1Pool → MessageTransmitterProxy/TokenMessenger V1 → CCTPV1\\n  ///     ├──→ CCTPV2Pool → MessageTransmitterProxy/TokenMessenger V2 → CCTPV2\\n  ///     ├──→ cctpV2PoolWithCCV → CCTPVerifier → MessageTransmitterProxy/TokenMessenger V2 → CCTPV2\\n  ///     └──→ siloedLockReleasePool → ERC20LockBox\\n  address internal s_cctpV1Pool;\\n  address internal s_cctpV2Pool;\\n  address internal s_cctpV2PoolWithCCV;\\n  address internal s_siloedLockReleasePool;\\n\\n  /// @notice The address that receives withdrawn fee tokens.\\n  address internal s_feeAggregator;\\n\\n  constructor(\\n    IERC20 token,\\n    PoolAddresses memory pools,\\n    address router,\\n    address cctpVerifier\\n  ) {\\n    // Note: It is not required that every pool address be set, as this proxy may be deployed on a chain which does not support a specific version of CCTP.\\n    // As a result only the token, router, and cctpVerifier are enforced to be non-zero.\\n    if (address(token) == address(0) || router == address(0) || cctpVerifier == address(0)) {\\n      revert AddressCannotBeZero();\\n    }\\n\\n    i_token = token;\\n    i_router = IRouter(router);\\n    i_cctpVerifier = ICrossChainVerifierResolver(cctpVerifier);\\n\\n    _updatePoolAddresses(pools);\\n  }\\n\\n  /// @inheritdoc IPoolV1\\n  /// @dev If the outgoing mechanism is not set for a chain, then the chain is not supported because there cannot be a\\n  /// lock or burn operation.\\n  function isSupportedChain(\\n    uint64 remoteChainSelector\\n  ) external view returns (bool) {\\n    return s_lockOrBurnMechanism[remoteChainSelector] != LockOrBurnMechanism.INVALID_MECHANISM;\\n  }\\n\\n  /// @inheritdoc IPoolV1\\n  function isSupportedToken(\\n    address token\\n  ) external view returns (bool) {\\n    return address(i_token) == token;\\n  }\\n\\n  /// @inheritdoc IPoolV1\\n  /// @notice Lock or burn outgoing tokens to the correct pool based on the lock or burn mechanism.\\n  /// @param lockOrBurnIn Encoded data fields for the processing of tokens on the source chain.\\n  function lockOrBurn(\\n    Pool.LockOrBurnInV1 calldata lockOrBurnIn\\n  ) public virtual override returns (Pool.LockOrBurnOutV1 memory) {\\n    // Since this contract does not inherit from the TokenPool contract, it must manually validate the caller as an onRamp.\\n    if (i_router.getOnRamp(lockOrBurnIn.remoteChainSelector) != msg.sender) {\\n      revert CallerIsNotARampOnRouter(msg.sender);\\n    }\\n    LockOrBurnMechanism mechanism = s_lockOrBurnMechanism[lockOrBurnIn.remoteChainSelector];\\n\\n    // The child pool which will perform the lock/burn operation.\\n    address pool;\\n\\n    // For a IPoolV1 call, only CCTP v1/v2 and Lock/Release are supported.\\n    if (mechanism == LockOrBurnMechanism.CCTP_V2) {\\n      pool = s_cctpV2Pool;\\n    } else if (mechanism == LockOrBurnMechanism.CCTP_V1) {\\n      pool = s_cctpV1Pool;\\n    } else if (mechanism == LockOrBurnMechanism.LOCK_RELEASE) {\\n      pool = s_siloedLockReleasePool;\\n    } else {\\n      revert InvalidLockOrBurnMechanism(mechanism);\\n    }\\n\\n    if (pool == address(0)) {\\n      revert NoLockOrBurnMechanismSet(lockOrBurnIn.remoteChainSelector);\\n    }\\n\\n    // Transfer the tokens to the correct address, as this contract is only a proxy and will not perform the lock/burn itself.\\n    i_token.safeTransfer(pool, lockOrBurnIn.amount);\\n\\n    return IPoolV1(pool).lockOrBurn(lockOrBurnIn);\\n  }\\n\\n  /// @inheritdoc IPoolV2\\n  /// @notice Lock or burn outgoing tokens to the correct pool based on the lock or burn mechanism.\\n  /// @param lockOrBurnIn Encoded data fields for the processing of tokens on the source chain.\\n  /// @param blockConfirmationRequested Requested block confirmation.\\n  /// @param tokenArgs Additional token arguments.\\n  function lockOrBurn(\\n    Pool.LockOrBurnInV1 calldata lockOrBurnIn,\\n    uint16 blockConfirmationRequested,\\n    bytes memory tokenArgs\\n  ) public virtual returns (Pool.LockOrBurnOutV1 memory lockOrBurnOut, uint256 destTokenAmount) {\\n    // Since this contract does not inherit from the TokenPool contract, it must manually validate the caller as an onRamp.\\n    if (i_router.getOnRamp(lockOrBurnIn.remoteChainSelector) != msg.sender) {\\n      revert CallerIsNotARampOnRouter(msg.sender);\\n    }\\n\\n    LockOrBurnMechanism mechanism = s_lockOrBurnMechanism[lockOrBurnIn.remoteChainSelector];\\n\\n    // If a mechanism has not been configured for the remote chain selector, revert.\\n    if (mechanism == LockOrBurnMechanism.INVALID_MECHANISM) {\\n      revert InvalidLockOrBurnMechanism(mechanism);\\n    }\\n\\n    address pool;\\n\\n    // For a IPoolV2 call, only CCTP with CCV and Lock/Release are supported.\\n    if (mechanism == LockOrBurnMechanism.CCV) {\\n      pool = s_cctpV2PoolWithCCV;\\n      if (pool == address(0)) {\\n        revert NoLockOrBurnMechanismSet(lockOrBurnIn.remoteChainSelector);\\n      }\\n      // If using the CCTP verifier, transfer funds to the verifier instead of the pool.\\n      // First ensure that the chain is supported by the verifier.\\n      address verifierImpl = i_cctpVerifier.getOutboundImplementation(lockOrBurnIn.remoteChainSelector, tokenArgs);\\n      if (verifierImpl == address(0)) {\\n        revert ChainNotSupportedByVerifier(lockOrBurnIn.remoteChainSelector);\\n      }\\n      i_token.safeTransfer(verifierImpl, lockOrBurnIn.amount);\\n    } else if (mechanism == LockOrBurnMechanism.LOCK_RELEASE) {\\n      pool = s_siloedLockReleasePool;\\n      if (pool == address(0)) {\\n        revert NoLockOrBurnMechanismSet(lockOrBurnIn.remoteChainSelector);\\n      }\\n      i_token.safeTransfer(pool, lockOrBurnIn.amount);\\n    } else {\\n      revert InvalidLockOrBurnMechanism(mechanism);\\n    }\\n\\n    return IPoolV2(pool).lockOrBurn(lockOrBurnIn, blockConfirmationRequested, tokenArgs);\\n  }\\n\\n  /// @inheritdoc IPoolV1\\n  /// @param releaseOrMintIn Encoded data fields for the processing of tokens on the destination chain.\\n  function releaseOrMint(\\n    Pool.ReleaseOrMintInV1 calldata releaseOrMintIn\\n  ) public virtual override returns (Pool.ReleaseOrMintOutV1 memory) {\\n    // Since this proxy does not inherit from the TokenPool contract, it must manually validate the caller as an offRamp.\\n    if (!i_router.isOffRamp(releaseOrMintIn.remoteChainSelector, msg.sender)) {\\n      revert CallerIsNotARampOnRouter(msg.sender);\\n    }\\n\\n    // The first 4 bytes of source pool data are the version which can be extracted directly and cast into a uint32.\\n    bytes4 version = bytes4(releaseOrMintIn.sourcePoolData[:4]);\\n\\n    if (version == USDCSourcePoolDataCodec.LOCK_RELEASE_FLAG) {\\n      return IPoolV1(s_siloedLockReleasePool).releaseOrMint(releaseOrMintIn);\\n    }\\n    if (version == USDCSourcePoolDataCodec.CCTP_VERSION_2_TAG) {\\n      return IPoolV1(s_cctpV2Pool).releaseOrMint(releaseOrMintIn);\\n    }\\n\\n    // In the CCTP v1 USDCTokenPool, `sourcePoolData` is produced as: abi.encode(USDCSourcePoolDataCodec.SourceTokenDataPayloadV1({nonce, sourceDomain}))\\n    // ABI encoding places each static value into a full 32-byte word, so the payload is: 2 words * 32 bytes = 64 bytes\\n    // Therefore, a 64-byte `sourcePoolData` with no 4-byte version/tag prefix indicates the legacy CCTP v1 payload format and must be routed to the CCTP v1 pool.\\n    // Note: It is possible for a future version of the source pool data to also be 64 bytes long. However, any future\\n    // version will have a version number in the first 4 bytes and will be routed to the proper pool before this check\\n    // is reached. Therefore this branch will only be triggered for messages using the legacy source pool data format.\\n    if (releaseOrMintIn.sourcePoolData.length == 64) {\\n      // Since the CCTP v1 pool will have this contract set as an allowed caller, no additional configurations are\\n      // needed to route the message to the v1 pool.\\n      return IPoolV1(s_cctpV1Pool).releaseOrMint(releaseOrMintIn);\\n    }\\n\\n    revert InvalidMessageVersion(version);\\n  }\\n\\n  /// @inheritdoc IPoolV2\\n  /// @param releaseOrMintIn Encoded data fields for the processing of tokens on the destination chain.\\n  /// @param blockConfirmationRequested Requested block confirmation.\\n  function releaseOrMint(\\n    Pool.ReleaseOrMintInV1 calldata releaseOrMintIn,\\n    uint16 blockConfirmationRequested\\n  ) public virtual returns (Pool.ReleaseOrMintOutV1 memory) {\\n    // Since this proxy does not inherit from the TokenPool contract, it must manually validate the caller as an offRamp.\\n    if (!i_router.isOffRamp(releaseOrMintIn.remoteChainSelector, msg.sender)) {\\n      revert CallerIsNotARampOnRouter(msg.sender);\\n    }\\n\\n    // The first 4 bytes of source pool data are the version which can be extracted directly and cast into a uint32.\\n    bytes4 version = bytes4(releaseOrMintIn.sourcePoolData[:4]);\\n\\n    // If the source pool data is the lock release flag, use the lock release pool set for the remote chain selector.\\n    if (version == USDCSourcePoolDataCodec.LOCK_RELEASE_FLAG) {\\n      return IPoolV2(s_siloedLockReleasePool).releaseOrMint(releaseOrMintIn, blockConfirmationRequested);\\n    }\\n    if (version == USDCSourcePoolDataCodec.CCTP_VERSION_2_CCV_TAG) {\\n      return IPoolV2(s_cctpV2PoolWithCCV).releaseOrMint(releaseOrMintIn, blockConfirmationRequested);\\n    }\\n\\n    revert InvalidMessageVersion(version);\\n  }\\n\\n  function updatePoolAddresses(\\n    PoolAddresses calldata pools\\n  ) external onlyOwner {\\n    _updatePoolAddresses(pools);\\n  }\\n\\n  /// @notice Update the pool addresses that this token pool will route a message to.\\n  /// @param pools The new pool addresses to update the token pool proxy with. Since the pool variants may not be\\n  /// used, the zero address is a valid input and therefore input sanitization for it is not required.\\n  /// @dev The owner is responsible for ensuring no pool is set to address(0) if there's any non-zero number of lanes\\n  /// using that pool's mechanism. If it does happen, transactions can be stuck until the pool is updated again.\\n  function _updatePoolAddresses(\\n    PoolAddresses memory pools\\n  ) internal {\\n    if (pools.cctpV1Pool != address(0) \\u0026\\u0026 !pools.cctpV1Pool.supportsInterface(type(IPoolV1).interfaceId)) {\\n      revert TokenPoolUnsupported(pools.cctpV1Pool);\\n    }\\n\\n    if (pools.cctpV2Pool != address(0) \\u0026\\u0026 !pools.cctpV2Pool.supportsInterface(type(IPoolV1).interfaceId)) {\\n      revert TokenPoolUnsupported(pools.cctpV2Pool);\\n    }\\n\\n    if (pools.cctpV2PoolWithCCV != address(0) \\u0026\\u0026 !pools.cctpV2PoolWithCCV.supportsInterface(type(IPoolV2).interfaceId))\\n    {\\n      revert TokenPoolUnsupported(pools.cctpV2PoolWithCCV);\\n    }\\n\\n    if (\\n      pools.siloedLockReleasePool != address(0)\\n        \\u0026\\u0026 !pools.siloedLockReleasePool.supportsInterface(type(IPoolV1).interfaceId)\\n        \\u0026\\u0026 !pools.siloedLockReleasePool.supportsInterface(type(IPoolV2).interfaceId)\\n    ) {\\n      revert TokenPoolUnsupported(pools.siloedLockReleasePool);\\n    }\\n\\n    s_cctpV1Pool = pools.cctpV1Pool;\\n    s_cctpV2Pool = pools.cctpV2Pool;\\n    s_cctpV2PoolWithCCV = pools.cctpV2PoolWithCCV;\\n    s_siloedLockReleasePool = pools.siloedLockReleasePool;\\n\\n    emit PoolAddressesUpdated(pools);\\n  }\\n\\n  /// @notice Get the current pool addresses that this token pool will route a message to.\\n  /// @return The current pool addresses that this token pool will route a message to.\\n  function getPools() public view returns (PoolAddresses memory) {\\n    return PoolAddresses({\\n      cctpV1Pool: s_cctpV1Pool,\\n      cctpV2Pool: s_cctpV2Pool,\\n      cctpV2PoolWithCCV: s_cctpV2PoolWithCCV,\\n      siloedLockReleasePool: s_siloedLockReleasePool\\n    });\\n  }\\n\\n  /// @notice Get the lock or burn mechanism for a given remote chain selector.\\n  /// @param remoteChainSelector The remote chain selector to get the mechanism for.\\n  /// @return The lock or burn mechanism for the given remote chain selector, including CCTP V1/V2 and Lock/Release\\n  function getLockOrBurnMechanism(\\n    uint64 remoteChainSelector\\n  ) public view returns (LockOrBurnMechanism) {\\n    return s_lockOrBurnMechanism[remoteChainSelector];\\n  }\\n\\n  /// @notice Update the lock or burn mechanism for a list of remote chain selectors.\\n  /// @param remoteChainSelectors The remote chain selectors to update the lock or burn mechanism for.\\n  /// @param mechanisms The new lock or burn mechanisms for the given remote chain selectors.\\n  /// @dev If a mechanism is set to LOCK_RELEASE, CCTP_V1, CCTP_V2, or CCV, the corresponding pool address\\n  /// must be set, otherwise the update will revert.\\n  /// @dev Only callable by the owner.\\n  function updateLockOrBurnMechanisms(\\n    uint64[] calldata remoteChainSelectors,\\n    LockOrBurnMechanism[] calldata mechanisms\\n  ) external onlyOwner {\\n    if (remoteChainSelectors.length != mechanisms.length) {\\n      revert MismatchedArrayLengths();\\n    }\\n\\n    for (uint256 i = 0; i \\u003c remoteChainSelectors.length; ++i) {\\n      LockOrBurnMechanism mechanism = mechanisms[i];\\n      s_lockOrBurnMechanism[remoteChainSelectors[i]] = mechanism;\\n\\n      if (mechanism == LockOrBurnMechanism.LOCK_RELEASE \\u0026\\u0026 s_siloedLockReleasePool == address(0)) {\\n        revert MustSetPoolForMechanism(remoteChainSelectors[i], mechanism);\\n      }\\n      if (mechanism == LockOrBurnMechanism.CCTP_V1 \\u0026\\u0026 s_cctpV1Pool == address(0)) {\\n        revert MustSetPoolForMechanism(remoteChainSelectors[i], mechanism);\\n      }\\n      if (mechanism == LockOrBurnMechanism.CCTP_V2 \\u0026\\u0026 s_cctpV2Pool == address(0)) {\\n        revert MustSetPoolForMechanism(remoteChainSelectors[i], mechanism);\\n      }\\n      if (mechanism == LockOrBurnMechanism.CCV \\u0026\\u0026 s_cctpV2PoolWithCCV == address(0)) {\\n        revert MustSetPoolForMechanism(remoteChainSelectors[i], mechanism);\\n      }\\n\\n      emit LockOrBurnMechanismUpdated(remoteChainSelectors[i], mechanism);\\n    }\\n  }\\n\\n  /// @inheritdoc IPoolV2\\n  /// @param localToken The local asset being transferred.\\n  /// @param destChainSelector The destination lane selector.\\n  /// @param amount The amount of tokens being bridged on this lane.\\n  /// @param feeToken The token used to pay feeUSDCents.\\n  /// @param blockConfirmationRequested Requested block confirmation.\\n  /// @param tokenArgs Opaque token arguments supplied by the caller.\\n  // solhint-disable-next-line chainlink-solidity/explicit-returns\\n  function getFee(\\n    address localToken,\\n    uint64 destChainSelector,\\n    uint256 amount,\\n    address feeToken,\\n    uint16 blockConfirmationRequested,\\n    bytes calldata tokenArgs\\n  )\\n    external\\n    view\\n    returns (uint256 feeUSDCents, uint32 destGasOverhead, uint32 destBytesOverhead, uint16 tokenFeeBps, bool isEnabled)\\n  {\\n    (address pool, bool isPoolV2) = _getPoolForMechanism(destChainSelector);\\n\\n    if (isPoolV2) {\\n      return\\n        IPoolV2(pool).getFee(localToken, destChainSelector, amount, feeToken, blockConfirmationRequested, tokenArgs);\\n    }\\n\\n    // If an old mechanism is set, or none at all, revert.\\n    revert InvalidLockOrBurnMechanism(s_lockOrBurnMechanism[destChainSelector]);\\n  }\\n\\n  /// @inheritdoc IPoolV2\\n  /// @param localToken The local asset being transferred.\\n  /// @param destChainSelector The chain selector of the destination chain.\\n  /// @param blockConfirmationRequested Requested block confirmation.\\n  /// @param tokenArgs Additional token argument from the CCIP message.\\n  function getTokenTransferFeeConfig(\\n    address localToken,\\n    uint64 destChainSelector,\\n    uint16 blockConfirmationRequested,\\n    bytes calldata tokenArgs\\n  ) external view returns (TokenTransferFeeConfig memory feeConfig) {\\n    (address pool, bool isPoolV2) = _getPoolForMechanism(destChainSelector);\\n\\n    if (isPoolV2) {\\n      return\\n        IPoolV2(pool).getTokenTransferFeeConfig(localToken, destChainSelector, blockConfirmationRequested, tokenArgs);\\n    }\\n\\n    // For any other mechanism, return default empty config.\\n    return feeConfig;\\n  }\\n\\n  /// @notice Get the pool address for a given remote chain selector.\\n  /// @param remoteChainSelector The remote chain selector to get the pool address for.\\n  /// @return pool The pool address for the given remote chain selector.\\n  /// @return isPoolV2 Whether the pool is a V2 pool.\\n  function _getPoolForMechanism(\\n    uint64 remoteChainSelector\\n  ) internal view returns (address pool, bool isPoolV2) {\\n    LockOrBurnMechanism mechanism = s_lockOrBurnMechanism[remoteChainSelector];\\n    if (mechanism == LockOrBurnMechanism.INVALID_MECHANISM) {\\n      revert InvalidLockOrBurnMechanism(mechanism);\\n    }\\n\\n    if (mechanism == LockOrBurnMechanism.CCV) {\\n      pool = s_cctpV2PoolWithCCV;\\n      isPoolV2 = true;\\n    } else if (mechanism == LockOrBurnMechanism.CCTP_V2) {\\n      pool = s_cctpV2Pool;\\n    } else if (mechanism == LockOrBurnMechanism.CCTP_V1) {\\n      pool = s_cctpV1Pool;\\n    } else if (mechanism == LockOrBurnMechanism.LOCK_RELEASE) {\\n      pool = s_siloedLockReleasePool;\\n      isPoolV2 = true;\\n    }\\n\\n    if (pool == address(0)) {\\n      revert MustSetPoolForMechanism(remoteChainSelector, mechanism);\\n    }\\n    return (pool, isPoolV2);\\n  }\\n\\n  /// @inheritdoc IPoolV2\\n  /// @param remoteChainSelector Remote chain selector.\\n  function getRemoteToken(\\n    uint64 remoteChainSelector\\n  ) external view returns (bytes memory) {\\n    (address pool,) = _getPoolForMechanism(remoteChainSelector);\\n\\n    return IPoolV2(pool).getRemoteToken(remoteChainSelector);\\n  }\\n\\n  /// @inheritdoc IPoolV2\\n  /// @dev Instead of calling the pool, we take a shortcut and return the CCTPVerifier as required directly.\\n  function getRequiredCCVs(\\n    address, // localToken\\n    uint64 remoteChainSelector,\\n    uint256, // amount\\n    uint16, // blockConfirmationRequested\\n    bytes calldata, // extraData\\n    MessageDirection // direction\\n  ) external view returns (address[] memory requiredCCVs) {\\n    if (s_lockOrBurnMechanism[remoteChainSelector] == LockOrBurnMechanism.INVALID_MECHANISM) {\\n      revert NoLockOrBurnMechanismSet(remoteChainSelector);\\n    }\\n\\n    // Common case: The lockOrBurn mechanism is CCTP V2 with CCV.\\n    // In this case, we simply need to return the CCTP CCV.\\n    address[] memory ccvs = new address[](1);\\n    if (s_lockOrBurnMechanism[remoteChainSelector] == LockOrBurnMechanism.CCV) {\\n      ccvs[0] = address(i_cctpVerifier);\\n      return ccvs;\\n    }\\n\\n    // If using lock-release, we can't specify CCTP because CCTP won't ultimately be called.\\n    // Other CCTP mechanisms will never rely on CCVs and have no impact on the return value.\\n    // Therefore, we return address(0) to indicate that default CCVs should be used for the lock-release mechanism.\\n    return ccvs;\\n  }\\n\\n  /// @inheritdoc IERC165\\n  function supportsInterface(\\n    bytes4 interfaceId\\n  ) public pure override returns (bool) {\\n    return interfaceId == type(IPoolV2).interfaceId || interfaceId == type(IPoolV1).interfaceId\\n      || interfaceId == Pool.CCIP_POOL_V1 || interfaceId == type(IERC165).interfaceId;\\n  }\\n\\n  // ================================================================\\n  // │                     Fee token withdrawal                     │\\n  // ================================================================\\n\\n  function getFeeAggregator() external view returns (address) {\\n    return s_feeAggregator;\\n  }\\n\\n  /// @notice Sets the address of the fee aggregator.\\n  /// @param feeAggregator The address of the new fee aggregator contract.\\n  /// @dev FeeTokenHandler will revert if feeAggregator is zero when withdrawing fees.\\n  /// @dev A zero address fee aggregator is valid, and intentionally reverts calls to withdraw fee tokens.\\n  function setFeeAggregator(\\n    address feeAggregator\\n  ) external onlyOwner {\\n    s_feeAggregator = feeAggregator;\\n  }\\n\\n  /// @notice Withdraws the outstanding fee token balances to the fee aggregator.\\n  /// @param feeTokens The fee tokens to withdraw.\\n  function withdrawFeeTokens(\\n    address[] calldata feeTokens\\n  ) external virtual {\\n    FeeTokenHandler._withdrawFeeTokens(feeTokens, s_feeAggregator);\\n  }\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2Step.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {IOwnable} from \\\"../interfaces/IOwnable.sol\\\";\\n\\n/// @notice A minimal contract that implements 2-step ownership transfer and nothing more. It's made to be minimal\\n/// to reduce the impact of the bytecode size on any contract that inherits from it.\\ncontract Ownable2Step is IOwnable {\\n  /// @notice The pending owner is the address to which ownership may be transferred.\\n  address private s_pendingOwner;\\n  /// @notice The owner is the current owner of the contract.\\n  /// @dev The owner is the second storage variable so any implementing contract could pack other state with it\\n  /// instead of the much less used s_pendingOwner.\\n  address private s_owner;\\n\\n  error OwnerCannotBeZero();\\n  error MustBeProposedOwner();\\n  error CannotTransferToSelf();\\n  error OnlyCallableByOwner();\\n\\n  event OwnershipTransferRequested(address indexed from, address indexed to);\\n  event OwnershipTransferred(address indexed from, address indexed to);\\n\\n  constructor(address newOwner, address pendingOwner) {\\n    if (newOwner == address(0)) {\\n      revert OwnerCannotBeZero();\\n    }\\n\\n    s_owner = newOwner;\\n    if (pendingOwner != address(0)) {\\n      _transferOwnership(pendingOwner);\\n    }\\n  }\\n\\n  /// @notice Get the current owner\\n  function owner() public view override returns (address) {\\n    return s_owner;\\n  }\\n\\n  /// @notice Allows an owner to begin transferring ownership to a new address. The new owner needs to call\\n  /// `acceptOwnership` to accept the transfer before any permissions are changed.\\n  /// @param to The address to which ownership will be transferred.\\n  function transferOwnership(\\n    address to\\n  ) public override onlyOwner {\\n    _transferOwnership(to);\\n  }\\n\\n  /// @notice validate, transfer ownership, and emit relevant events\\n  /// @param to The address to which ownership will be transferred.\\n  function _transferOwnership(\\n    address to\\n  ) private {\\n    if (to == msg.sender) {\\n      revert CannotTransferToSelf();\\n    }\\n\\n    s_pendingOwner = to;\\n\\n    emit OwnershipTransferRequested(s_owner, to);\\n  }\\n\\n  /// @notice Allows an ownership transfer to be completed by the recipient.\\n  function acceptOwnership() external override {\\n    if (msg.sender != s_pendingOwner) {\\n      revert MustBeProposedOwner();\\n    }\\n\\n    address oldOwner = s_owner;\\n    s_owner = msg.sender;\\n    s_pendingOwner = address(0);\\n\\n    emit OwnershipTransferred(oldOwner, msg.sender);\\n  }\\n\\n  /// @notice validate access\\n  function _validateOwnership() internal view {\\n    if (msg.sender != s_owner) {\\n      revert OnlyCallableByOwner();\\n    }\\n  }\\n\\n  /// @notice Reverts if called by anyone other than the contract owner.\\n  modifier onlyOwner() {\\n    _validateOwnership();\\n    _;\\n  }\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2StepMsgSender.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {Ownable2Step} from \\\"./Ownable2Step.sol\\\";\\n\\n/// @notice Sets the msg.sender to be the owner of the contract and does not set a pending owner.\\ncontract Ownable2StepMsgSender is Ownable2Step {\\n  constructor() Ownable2Step(msg.sender, address(0)) {}\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/IOwnable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IOwnable {\\n  function owner() external returns (address);\\n\\n  function transferOwnership(\\n    address recipient\\n  ) external;\\n\\n  function acceptOwnership() external;\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/ITypeAndVersion.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ITypeAndVersion {\\n  function typeAndVersion() external pure returns (string memory);\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/interfaces/IERC1363.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1363.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @title IERC1363\\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\\n *\\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\\n */\\ninterface IERC1363 is IERC20, IERC165 {\\n    /*\\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\\n     * 0xb0202a11 ===\\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\\n     */\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferAndCall(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @param data Additional data with no specified format, sent in call to `to`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param from The address which you want to send tokens from.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param from The address which you want to send tokens from.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @param data Additional data with no specified format, sent in call to `to`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function approveAndCall(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     * @param data Additional data with no specified format, sent in call to `spender`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../utils/introspection/IERC165.sol\\\";\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../token/ERC20/IERC20.sol\\\";\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-20 standard as defined in the ERC.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\nimport {IERC1363} from \\\"../../../interfaces/IERC1363.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    /**\\n     * @dev An operation with an ERC-20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Indicates a failed `decreaseAllowance` request.\\n     */\\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\\n     */\\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\\n     */\\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     *\\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \\\"client\\\"\\n     * smart contract uses ERC-7674 to set temporary allowances, then the \\\"client\\\" smart contract should avoid using\\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\\n     * value, non-reverting calls are assumed to be successful.\\n     *\\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \\\"client\\\"\\n     * smart contract uses ERC-7674 to set temporary allowances, then the \\\"client\\\" smart contract should avoid using\\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance \\u003c requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     *\\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\\n     * only sets the \\\"standard\\\" allowance. Any temporary allowance will remain active, in addition to the value being\\n     * set here.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\\n        if (to.code.length == 0) {\\n            safeTransfer(token, to, value);\\n        } else if (!token.transferAndCall(to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function transferFromAndCallRelaxed(\\n        IERC1363 token,\\n        address from,\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal {\\n        if (to.code.length == 0) {\\n            safeTransferFrom(token, from, to, value);\\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\\n     * once without retrying, and relies on the returned value to be true.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\\n        if (to.code.length == 0) {\\n            forceApprove(token, to, value);\\n        } else if (!token.approveAndCall(to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly (\\\"memory-safe\\\") {\\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\\n            // bubble errors\\n            if iszero(success) {\\n                let ptr := mload(0x40)\\n                returndatacopy(ptr, 0, returndatasize())\\n                revert(ptr, returndatasize())\\n            }\\n            returnSize := returndatasize()\\n            returnValue := mload(0)\\n        }\\n\\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly (\\\"memory-safe\\\") {\\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\\n            returnSize := returndatasize()\\n            returnValue := mload(0)\\n        }\\n        return success \\u0026\\u0026 (returnSize == 0 ? address(token).code.length \\u003e 0 : returnValue == 1);\\n    }\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/utils/introspection/ERC165Checker.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165Checker.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165Checker {\\n    // As per the ERC-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface.\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC-165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return\\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) \\u0026\\u0026\\n            !supportsERC165InterfaceUnchecked(account, INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // query support of both ERC-165 as per the spec and support of _interfaceId\\n        return supportsERC165(account) \\u0026\\u0026 supportsERC165InterfaceUnchecked(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they're supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function getSupportedInterfaces(\\n        address account,\\n        bytes4[] memory interfaceIds\\n    ) internal view returns (bool[] memory) {\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\n\\n        // query support of ERC-165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i = 0; i \\u003c interfaceIds.length; i++) {\\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\\n            }\\n        }\\n\\n        return interfaceIdsSupported;\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\n        // query support of ERC-165 itself\\n        if (!supportsERC165(account)) {\\n            return false;\\n        }\\n\\n        // query support of each interface in interfaceIds\\n        for (uint256 i = 0; i \\u003c interfaceIds.length; i++) {\\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\\n                return false;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC-165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC-165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     *\\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\\n     * should be exercised when using this function.\\n     *\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // prepare call\\n        bytes memory encodedParams = abi.encodeCall(IERC165.supportsInterface, (interfaceId));\\n\\n        // perform static call\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly (\\\"memory-safe\\\") {\\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\\n            returnSize := returndatasize()\\n            returnValue := mload(0x00)\\n        }\\n\\n        return success \\u0026\\u0026 returnSize \\u003e= 0x20 \\u0026\\u0026 returnValue \\u003e 0;\\n    }\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"}}}"
