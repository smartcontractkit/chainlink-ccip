// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.


package onramp

var SolidityStandardInput = "{\"version\":\"v0.8.26+commit.8a97fa7a\",\"language\":\"Solidity\",\"settings\":{\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"appendCBOR\":true,\"bytecodeHash\":\"none\",\"useLiteralContent\":false},\"optimizer\":{\"enabled\":true,\"runs\":1500},\"outputSelection\":{\"contracts/interfaces/ICrossChainVerifierResolver.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/interfaces/ICrossChainVerifierV1.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/interfaces/IEVM2AnyOnRampClient.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/interfaces/IExecutor.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/interfaces/IFeeQuoter.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/interfaces/IPool.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/interfaces/IPoolV2.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/interfaces/IRMNRemote.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/interfaces/IRouter.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/interfaces/ITokenAdminRegistry.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/libraries/CCVConfigValidation.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/libraries/Client.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/libraries/ExtraArgsCodec.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/libraries/FeeTokenHandler.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/libraries/Internal.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/libraries/MessageV1Codec.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/libraries/Pool.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/libraries/USDPriceWith18Decimals.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/onRamp/OnRamp.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2Step.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2StepMsgSender.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/IOwnable.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/ITypeAndVersion.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/interfaces/IERC1363.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/interfaces/IERC165.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/interfaces/IERC20.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/token/ERC20/IERC20.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/token/ERC20/utils/SafeERC20.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/utils/Arrays.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/utils/Comparators.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/utils/Panic.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/utils/SlotDerivation.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/utils/StorageSlot.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/utils/introspection/IERC165.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/utils/math/Math.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/utils/math/SafeCast.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/utils/structs/EnumerableSet.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]}},\"remappings\":[\"forge-std/=node_modules/@chainlink/contracts/src/v0.8/vendor/forge-std/src/\",\"@chainlink/policy-management/=node_modules/@chainlink/ace/packages/policy-management/src/\",\"@chainlink/contracts/=node_modules/@chainlink/contracts/\",\"@openzeppelin/contracts@4.8.3/=node_modules/@openzeppelin/contracts-4.8.3/\",\"@openzeppelin/contracts@5.3.0/=node_modules/@openzeppelin/contracts-5.3.0/\"],\"viaIR\":true},\"sources\":{\"contracts/interfaces/ICrossChainVerifierResolver.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\n/// @notice Resolves and returns the appropriate verifier contract for the given outbound / inbound traffic.\\ninterface ICrossChainVerifierResolver {\\n  /// @notice Returns the appropriate verifier contract based on the given verifierResults.\\n  /// @dev The OffRamp is responsible for calling this function using the verifierResults it receives from the executor.\\n  /// If the verifier specified by the executor is actually a resolver, the OffRamp will call this function to get the actual verifier contract.\\n  /// Verifiers can build resolvers that process the verifierResults in accordance with how their verifier forms verifierResults. For example, their verifier may\\n  /// prefix the verifierResults with a version identifier, which the resolver can parse to determine the correct verifier contract.\\n  /// @param verifierResults The verifierResults formed by the verifier.\\n  /// @return verifierAddress The address of the verifier contract.\\n  function getInboundImplementation(\\n    bytes calldata verifierResults\\n  ) external view returns (address);\\n\\n  /// @notice Returns the appropriate verifier contract based on the given destChainSelector.\\n  /// @dev The OnRamp is responsible for calling this function using the destChainSelector specified by the sender.\\n  /// If the verifier specified by the sender is actually a resolver, the OnRamp will call this function to get the actual verifier contract.\\n  /// For example, resolvers can maintain a simple mapping of destChainSelector to verifier contract address.\\n  /// @param destChainSelector The destChainSelector for a message.\\n  /// @param extraArgs Extra arguments that can be used by the resolver to determine the correct verifier contract.\\n  /// @return verifierAddress The address of the verifier contract.\\n  function getOutboundImplementation(\\n    uint64 destChainSelector,\\n    bytes memory extraArgs\\n  ) external view returns (address);\\n}\\n\"},\"contracts/interfaces/ICrossChainVerifierV1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {Client} from \\\"../libraries/Client.sol\\\";\\nimport {MessageV1Codec} from \\\"../libraries/MessageV1Codec.sol\\\";\\n\\nimport {IERC165} from \\\"@openzeppelin/contracts@5.3.0/utils/introspection/IERC165.sol\\\";\\n\\ninterface ICrossChainVerifierV1 is IERC165 {\\n  /// @notice Verification of the message, in any way the verifier wants. This could be using a signature, a quorum\\n  /// of signatures, using native interop, or some ZK light client. Any proof required for the verification is supplied\\n  /// through the verifierResults parameter.\\n  /// @param message The message to be verified. For efficiency, the messageID is also supplied, which acts as a small\\n  /// payload that once verified means the entire message is verified. Every component of the message is part of the\\n  /// message ID through hashing the struct. The entire message is provided to be able to act differently for different\\n  /// message properties.\\n  /// @param messageId A convenient 32 byte hash of the entire message. It can be recomputed from the passed in message\\n  /// at the cost of a not-insignificant amount of gas. Any CCV MUST include the messageID or the entire message struct\\n  /// as part of its proof.\\n  /// @param verifierResults All the data that is specific to the CCV. This often means it contains some sort of proof, but it\\n  /// can also contain certain metadata like a nonce that's specific to the CCV. If any metadata like that exists and is\\n  /// important to the security of the CCV, it MUST be verified as well using the proof. A recommended way to do this is\\n  /// to encode a proof and the metadata separately in the verifierResults and then concatenate the messageId with this metadata\\n  /// to get the payload that will be verified. In the case of a simple signature verification this means that the CCV\\n  /// offchain system must sign the concatenated (messageId, ccvMetaData) and not just the messageId. If no metadata\\n  /// is required, simply signing the messageId is enough.\\n  function verifyMessage(\\n    MessageV1Codec.MessageV1 memory message,\\n    bytes32 messageId,\\n    bytes memory verifierResults\\n  ) external;\\n\\n  /// @notice Quotes the fee, including gas and calldata bytes, for a CCIP message to a destination chain.\\n  /// @dev This takes EVM2AnyMessage (instead of MessageV1) because the router client API that user contracts interact\\n  /// with exposes EVM2AnyMessage. The onRamp can translate to MessageV1 internally where required (e.g., verifier or\\n  /// executor hooks), but using EVM2AnyMessage here keeps the interface aligned with what clients construct and pass to\\n  /// the router.\\n  /// @param destChainSelector The destination chain selector of the message.\\n  /// @param message The message to be sent.\\n  /// @param extraArgs Opaque extra args that can be used by the fee quoter,\\n  /// @param blockConfirmations The user requested number of block confirmations.\\n  function getFee(\\n    uint64 destChainSelector,\\n    Client.EVM2AnyMessage memory message,\\n    bytes memory extraArgs,\\n    uint16 blockConfirmations\\n  ) external view returns (uint16 feeUSDCents, uint32 gasForVerification, uint32 payloadSizeBytes);\\n\\n  /// @notice Message sending, verifier hook.\\n  /// @param message Decoded MessageV1 structure for the message being sent.\\n  /// @dev message.sender is expected to be abi encoded.\\n  /// @param messageId The message ID of the message being sent.\\n  /// @param feeToken Fee token used for this message.\\n  /// @param feeTokenAmount Amount of fee token provided.\\n  /// @param verifierArgs Opaque verifier-specific arguments from the sender.\\n  /// @return verifierData Verifier-specific return data blob.\\n  function forwardToVerifier(\\n    MessageV1Codec.MessageV1 calldata message,\\n    bytes32 messageId,\\n    address feeToken,\\n    uint256 feeTokenAmount,\\n    bytes calldata verifierArgs\\n  ) external returns (bytes memory verifierData);\\n\\n  /// @notice Returns the storage location identifiers for this CCV. Each entry uniquely identifies a storage location.\\n  /// This can be an address, a URL, or any other identifier that makes sense for the CCV. The format of the strings is\\n  /// up to the CCV implementer, but it should be something that can be easily parsed and used by the integrator. This\\n  /// is used by the executor(s) to know where to look for the proof data that the CCV has produced.\\n  function getStorageLocations() external view returns (string[] memory);\\n}\\n\"},\"contracts/interfaces/IEVM2AnyOnRampClient.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {IPoolV1} from \\\"./IPool.sol\\\";\\n\\nimport {Client} from \\\"../libraries/Client.sol\\\";\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts@5.3.0/token/ERC20/IERC20.sol\\\";\\n\\ninterface IEVM2AnyOnRampClient {\\n  /// @notice Get the fee for a given ccip message.\\n  /// @param destChainSelector The destination chain selector.\\n  /// @param message The message to calculate the cost for.\\n  /// @return fee The calculated fee.\\n  function getFee(\\n    uint64 destChainSelector,\\n    Client.EVM2AnyMessage calldata message\\n  ) external view returns (uint256 fee);\\n\\n  /// @notice Get the pool for a specific token.\\n  /// @param destChainSelector The destination chain selector.\\n  /// @param sourceToken The source chain token to get the pool for.\\n  /// @return pool Token pool.\\n  function getPoolBySourceToken(\\n    uint64 destChainSelector,\\n    IERC20 sourceToken\\n  ) external view returns (IPoolV1);\\n\\n  /// @notice Gets a list of all supported source chain tokens.\\n  /// @param destChainSelector The destination chain selector.\\n  /// @return tokens The addresses of all tokens that this onRamp supports the given destination chain.\\n  function getSupportedTokens(\\n    uint64 destChainSelector\\n  ) external view returns (address[] memory tokens);\\n\\n  /// @notice Send a message to the remote chain.\\n  /// @dev only callable by the Router.\\n  /// @dev if the contract is paused, this function will revert.\\n  /// @param destChainSelector The destination chain selector.\\n  /// @param message Message struct to send.\\n  /// @param feeTokenAmount Amount of fee tokens for payment.\\n  /// @param originalSender The original initiator of the CCIP request.\\n  /// @return messageId The message id.\\n  function forwardFromRouter(\\n    uint64 destChainSelector,\\n    Client.EVM2AnyMessage memory message,\\n    uint256 feeTokenAmount,\\n    address originalSender\\n  ) external returns (bytes32);\\n}\\n\"},\"contracts/interfaces/IExecutor.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IExecutor {\\n  /// @notice Returns the minimum number of block confirmations that's allowed to be requested. The actual waiting for\\n  /// the block confirmations is handled by the CCVs. This value is only here to gate the value a user can request from\\n  /// a verifier.\\n  function getMinBlockConfirmations() external view returns (uint16);\\n\\n  /// @notice Validates whether or not the executor can process the message and returns the fee required to do so.\\n  /// @param destChainSelector The destination chain selector.\\n  /// @param requestedBlockDepth The requested block depth for finality.\\n  /// @param ccvAddresses Array of CCV addresses that will be used for the message.\\n  /// @param extraArgs Extra arguments for the executor.\\n  function getFee(\\n    uint64 destChainSelector,\\n    uint16 requestedBlockDepth,\\n    address[] memory ccvAddresses,\\n    bytes memory extraArgs,\\n    address feeToken\\n  ) external view returns (uint16 usdCents);\\n}\\n\"},\"contracts/interfaces/IFeeQuoter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {Internal} from \\\"../libraries/Internal.sol\\\";\\n\\ninterface IFeeQuoter {\\n  /// @notice Get the list of fee tokens.\\n  /// @return feeTokens The tokens set as fee tokens.\\n  function getFeeTokens() external view returns (address[] memory);\\n\\n  /// @notice Get the `tokenPrice` for a given token.\\n  /// @param token The token to get the price for.\\n  /// @return tokenPrice The tokenPrice for the given token.\\n  function getTokenPrice(\\n    address token\\n  ) external view returns (Internal.TimestampedPackedUint224 memory);\\n\\n  /// @notice Get the `tokenPrice` for a given token, checks if the price is valid.\\n  /// @param token The token to get the price for.\\n  /// @return tokenPrice The tokenPrice for the given token if it exists and is valid.\\n  function getValidatedTokenPrice(\\n    address token\\n  ) external view returns (uint224);\\n\\n  /// @notice Get the `tokenPrice` for an array of tokens.\\n  /// @param tokens The tokens to get prices for.\\n  /// @return tokenPrices The tokenPrices for the given tokens.\\n  function getTokenPrices(\\n    address[] calldata tokens\\n  ) external view returns (Internal.TimestampedPackedUint224[] memory);\\n\\n  /// @notice Update the price for given tokens and gas prices for given chains.\\n  /// @param priceUpdates The price updates to apply.\\n  function updatePrices(\\n    Internal.PriceUpdates memory priceUpdates\\n  ) external;\\n\\n  /// @notice Get an encoded `gasPrice` for a given destination chain ID.\\n  /// The 224-bit result encodes necessary gas price components.\\n  /// On L1 chains like Ethereum or Avax, the only component is the gas price.\\n  /// On Optimistic Rollups, there are two components - the L2 gas price, and L1 base fee for data availability.\\n  /// On future chains, there could be more or differing price components.\\n  /// @param destChainSelector The destination chain to get the price for.\\n  /// @return gasPrice The encoded gasPrice for the given destination chain ID.\\n  function getDestinationChainGasPrice(\\n    uint64 destChainSelector\\n  ) external view returns (Internal.TimestampedPackedUint224 memory);\\n\\n  // ================================================================\\n  // │                 Not needed for new 1.7 chains                │\\n  // ================================================================\\n\\n  /// @notice Gets the resolved token transfer fee components for a token transfer.\\n  /// @dev This function will check token-specific config first, then fall back to destination chain defaults.\\n  /// @param destChainSelector The destination chain selector.\\n  /// @param token The token address.\\n  /// @return feeUSDCents The fee in USD cents (multiples of 0.01 USD).\\n  /// @return destGasOverhead The gas charged to execute the token transfer on the destination chain.\\n  /// @return destBytesOverhead The bytes overhead for the token transfer on the destination chain.\\n  function getTokenTransferFee(\\n    uint64 destChainSelector,\\n    address token\\n  ) external view returns (uint32 feeUSDCents, uint32 destGasOverhead, uint32 destBytesOverhead);\\n\\n  /// @notice Quotes the total gas and gas cost in USD cents.\\n  /// @param destChainSelector The destination chain selector.\\n  /// @param nonCalldataGas The non-calldata gas to be used for the message.\\n  /// @param calldataSize The size of the calldata in bytes.\\n  /// @param feeToken The fee token address.\\n  /// @return totalGas The total gas needed for the message.\\n  /// @return gasCostInUsdCents The gas cost in USD cents, taking into account the calldata cost as well.\\n  /// @return feeTokenPrice The price of the fee token in 1e18 USD.\\n  /// @return premiumPercentMultiplier The premium in percent.\\n  function quoteGasForExec(\\n    uint64 destChainSelector,\\n    uint32 nonCalldataGas,\\n    uint32 calldataSize,\\n    address feeToken\\n  )\\n    external\\n    view\\n    returns (uint32 totalGas, uint256 gasCostInUsdCents, uint256 feeTokenPrice, uint256 premiumPercentMultiplier);\\n\\n  /// @notice Resolves legacy extra args for backward compatibility. Only has to support EVM, SVM, Aptos and SUI chain\\n  /// families as all future families have to use the new extraArgs format.\\n  /// @param destChainSelector The destination chain selector.\\n  /// @param extraArgs The extra args bytes.\\n  /// @return tokenReceiver The token receiver address encoded as bytes. Always length 32 or 0.\\n  /// @return gasLimit The gas limit to use for the message.\\n  /// @return executorArgs The executor args encoded as bytes. These are transformed into the new format.\\n  function resolveLegacyArgs(\\n    uint64 destChainSelector,\\n    bytes calldata extraArgs\\n  ) external view returns (bytes memory tokenReceiver, uint32 gasLimit, bytes memory executorArgs);\\n}\\n\"},\"contracts/interfaces/IPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {Pool} from \\\"../libraries/Pool.sol\\\";\\n\\nimport {IERC165} from \\\"@openzeppelin/contracts@5.3.0/utils/introspection/IERC165.sol\\\";\\n\\n/// @notice Shared public interface for multiple V1 pool types.\\n/// Each pool type handles a different child token model e.g. lock/unlock, mint/burn.\\ninterface IPoolV1 is IERC165 {\\n  /// @notice Lock tokens into the pool or burn the tokens.\\n  /// @param lockOrBurnIn Encoded data fields for the processing of tokens on the source chain.\\n  /// @return lockOrBurnOut Encoded data fields for the processing of tokens on the destination chain.\\n  function lockOrBurn(\\n    Pool.LockOrBurnInV1 calldata lockOrBurnIn\\n  ) external returns (Pool.LockOrBurnOutV1 memory lockOrBurnOut);\\n\\n  /// @notice Releases or mints tokens to the receiver address.\\n  /// @param releaseOrMintIn All data required to release or mint tokens.\\n  /// @return releaseOrMintOut The amount of tokens released or minted on the local chain, denominated\\n  /// in the local token's decimals.\\n  /// @dev The offRamp asserts that the balanceOf of the receiver has been incremented by exactly the number\\n  /// of tokens that is returned in ReleaseOrMintOutV1.destinationAmount. If the amounts do not match, the tx reverts.\\n  function releaseOrMint(\\n    Pool.ReleaseOrMintInV1 calldata releaseOrMintIn\\n  ) external returns (Pool.ReleaseOrMintOutV1 memory);\\n\\n  /// @notice Checks whether a remote chain is supported in the token pool.\\n  /// @param remoteChainSelector The selector of the remote chain.\\n  /// @return true if the given chain is a permissioned remote chain.\\n  function isSupportedChain(\\n    uint64 remoteChainSelector\\n  ) external view returns (bool);\\n\\n  /// @notice Returns if the token pool supports the given token.\\n  /// @param token The address of the token.\\n  /// @return true if the token is supported by the pool.\\n  function isSupportedToken(\\n    address token\\n  ) external view returns (bool);\\n}\\n\"},\"contracts/interfaces/IPoolV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {Pool} from \\\"../libraries/Pool.sol\\\";\\n\\nimport {IERC165} from \\\"@openzeppelin/contracts@5.3.0/utils/introspection/IERC165.sol\\\";\\n\\n/// @notice Shared public interface for multiple V2 pool types.\\n/// Each pool type handles a different child token model e.g. lock/release, mint/burn.\\ninterface IPoolV2 is IERC165 {\\n  struct TokenTransferFeeConfig {\\n    uint32 destGasOverhead; // ───────────────────────╮ Gas charged to execute the token transfer on the destination chain.\\n    uint32 destBytesOverhead; //                      │ Data availability bytes.\\n    uint32 defaultBlockConfirmationFeeUSDCents; //    │ Fee to charge for token transfer with default block confirmation, multiples of 0.01 USD.\\n    uint32 customBlockConfirmationFeeUSDCents; //     │ Fee to charge for token transfer with custom block confirmation, multiples of 0.01 USD.\\n    //                                                │ The following two fee is deducted from the transferred asset, not added on top.\\n    uint16 defaultBlockConfirmationTransferFeeBps; // │ Fee in basis points for default finality transfers [0-10_000].\\n    uint16 customBlockConfirmationTransferFeeBps; //  │ Fee in basis points for custom finality transfers [0-10_000].\\n    bool isEnabled; // ───────────────────────────────╯ Whether this config is enabled.\\n  }\\n\\n  enum MessageDirection {\\n    Outbound,\\n    Inbound\\n  }\\n\\n  /// @notice Lock tokens into the pool or burn the tokens.\\n  /// @param lockOrBurnIn Encoded data fields for the processing of tokens on the source chain.\\n  /// @param blockConfirmationRequested Requested block confirmation.\\n  /// @param tokenArgs Additional token arguments.\\n  /// @return lockOrBurnOut Encoded data fields for the processing of tokens on the destination chain.\\n  /// @return destTokenAmount The amount of tokens that will be set in TokenTransferV1.amount to be released/mint on destination.\\n  function lockOrBurn(\\n    Pool.LockOrBurnInV1 calldata lockOrBurnIn,\\n    uint16 blockConfirmationRequested,\\n    bytes calldata tokenArgs\\n  ) external returns (Pool.LockOrBurnOutV1 memory lockOrBurnOut, uint256 destTokenAmount);\\n\\n  /// @notice Releases or mints tokens on the destination chain.\\n  /// @param releaseOrMintIn Encoded data fields for the processing of tokens on the destination chain.\\n  /// @param blockConfirmationRequested Requested block confirmation.\\n  /// @return releaseOrMintOut Encoded data fields describing the result of the release or mint.\\n  function releaseOrMint(\\n    Pool.ReleaseOrMintInV1 calldata releaseOrMintIn,\\n    uint16 blockConfirmationRequested\\n  ) external returns (Pool.ReleaseOrMintOutV1 memory releaseOrMintOut);\\n\\n  /// @notice Returns the set of required CCVs for transfers in a given direction.\\n  /// @param localToken The address of the local token.\\n  /// @param remoteChainSelector The chain selector of the remote chain.\\n  /// @param amount The amount of tokens to be transferred.\\n  /// @param blockConfirmationRequested Requested block confirmation.\\n  /// @param extraData Direction-specific payload forwarded by the caller (e.g. token args or source pool data).\\n  /// @param direction Whether CCVs are required for outbound (source -\\u003e remote) or inbound (remote -\\u003e destination) transfers.\\n  /// @return requiredCCVs A set of addresses representing the required CCVs.\\n  function getRequiredCCVs(\\n    address localToken,\\n    uint64 remoteChainSelector,\\n    uint256 amount,\\n    uint16 blockConfirmationRequested,\\n    bytes calldata extraData,\\n    MessageDirection direction\\n  ) external view returns (address[] memory requiredCCVs);\\n\\n  /// @notice Returns the fee overrides for transferring the pool's token to a destination chain.\\n  /// @param localToken The address of the local token.\\n  /// @param destChainSelector The chain selector of the destination chain.\\n  /// @param blockConfirmationRequested Requested block confirmation.\\n  /// @param tokenArgs Additional token argument from the CCIP message.\\n  /// @return feeConfig the fee configuration for transferring the token to the destination chain.\\n  function getTokenTransferFeeConfig(\\n    address localToken,\\n    uint64 destChainSelector,\\n    uint16 blockConfirmationRequested,\\n    bytes calldata tokenArgs\\n  ) external view returns (TokenTransferFeeConfig memory feeConfig);\\n\\n  /// @notice Returns the pool fee parameters that will apply to a transfer.\\n  /// @param localToken The local asset being transferred.\\n  /// @param destChainSelector The destination lane selector.\\n  /// @param amount The amount of tokens being bridged on this lane.\\n  /// @param feeToken The token used to pay feeUSDCents.\\n  /// @param blockConfirmationRequested Requested block confirmation.\\n  /// @param tokenArgs Opaque token arguments supplied by the caller.\\n  /// @return feeUSDCents Flat fee charged in USD cents (crumbs) for this transfer.\\n  /// @return destGasOverhead Destination gas charged for accounting in the cost model.\\n  /// @return destBytesOverhead Destination calldata size attributed to the transfer.\\n  /// @return tokenFeeBps Bps charged in token units. Value of zero implies no in-token fee.\\n  /// @return isEnabled Whether the pool's fee config is enabled. If false, OnRamp should use FeeQuoter defaults.\\n  function getFee(\\n    address localToken,\\n    uint64 destChainSelector,\\n    uint256 amount,\\n    address feeToken,\\n    uint16 blockConfirmationRequested,\\n    bytes calldata tokenArgs\\n  )\\n    external\\n    view\\n    returns (uint256 feeUSDCents, uint32 destGasOverhead, uint32 destBytesOverhead, uint16 tokenFeeBps, bool isEnabled);\\n\\n  /// @notice Gets the token address on the remote chain.\\n  /// @param remoteChainSelector Remote chain selector.\\n  /// @dev To support non-evm chains, this value is encoded into bytes.\\n  function getRemoteToken(\\n    uint64 remoteChainSelector\\n  ) external view returns (bytes memory);\\n}\\n\"},\"contracts/interfaces/IRMNRemote.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {Internal} from \\\"../libraries/Internal.sol\\\";\\n\\n/// @notice This interface contains the only RMN-related functions that might be used on-chain by other CCIP contracts.\\ninterface IRMNRemote {\\n  /// @notice signature components from RMN nodes.\\n  struct Signature {\\n    bytes32 r;\\n    bytes32 s;\\n  }\\n\\n  /// @notice Verifies signatures of RMN nodes, on dest lane updates as provided in the CommitReport.\\n  /// @param offRampAddress is not inferred by msg.sender, in case the call is made through RMNProxy.\\n  /// @param merkleRoots must be well formed, and is a representation of the CommitReport received from the oracles.\\n  /// @param signatures rmnNodes ECDSA sigs, only r \\u0026 s, must be sorted in ascending order by signer address.\\n  /// @dev Will revert if verification fails.\\n  function verify(\\n    address offRampAddress,\\n    Internal.MerkleRoot[] memory merkleRoots,\\n    Signature[] memory signatures\\n  ) external view;\\n\\n  /// @notice gets the current set of cursed subjects.\\n  /// @return subjects the list of cursed subjects.\\n  function getCursedSubjects() external view returns (bytes16[] memory subjects);\\n\\n  /// @notice If there is an active global or legacy curse, this function returns true.\\n  /// @return bool true if there is an active global curse.\\n  function isCursed() external view returns (bool);\\n\\n  /// @notice If there is an active global curse, or an active curse for `subject`, this function returns true.\\n  /// @param subject To check whether a particular chain is cursed, set to bytes16(uint128(chainSelector)).\\n  /// @return bool true if the provided subject is cured *or* if there is an active global curse.\\n  function isCursed(\\n    bytes16 subject\\n  ) external view returns (bool);\\n}\\n\"},\"contracts/interfaces/IRouter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {Client} from \\\"../libraries/Client.sol\\\";\\n\\ninterface IRouter {\\n  error OnlyOffRamp();\\n\\n  /// @notice Route the message to its intended receiver contract.\\n  /// @param message Client.Any2EVMMessage struct.\\n  /// @param gasForCallExactCheck of params for exec.\\n  /// @param gasLimit set of params for exec.\\n  /// @param receiver set of params for exec.\\n  /// @dev if the receiver is a contracts that signals support for CCIP execution through EIP-165.\\n  /// the contract is called. If not, only tokens are transferred.\\n  /// @return success A boolean value indicating whether the ccip message was received without errors.\\n  /// @return retBytes A bytes array containing return data form CCIP receiver.\\n  /// @return gasUsed the gas used by the external customer call. Does not include any overhead.\\n  function routeMessage(\\n    Client.Any2EVMMessage calldata message,\\n    uint16 gasForCallExactCheck,\\n    uint256 gasLimit,\\n    address receiver\\n  ) external returns (bool success, bytes memory retBytes, uint256 gasUsed);\\n\\n  /// @notice Returns the configured onRamp for a specific destination chain.\\n  /// @param destChainSelector The destination chain Id to get the onRamp for.\\n  /// @return onRampAddress The address of the onRamp.\\n  function getOnRamp(\\n    uint64 destChainSelector\\n  ) external view returns (address onRampAddress);\\n\\n  /// @notice Return true if the given offRamp is a configured offRamp for the given source chain.\\n  /// @param sourceChainSelector The source chain selector to check.\\n  /// @param offRamp The address of the offRamp to check.\\n  function isOffRamp(\\n    uint64 sourceChainSelector,\\n    address offRamp\\n  ) external view returns (bool isOffRamp);\\n}\\n\"},\"contracts/interfaces/ITokenAdminRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ITokenAdminRegistry {\\n  /// @notice Returns the pool for the given token.\\n  function getPool(\\n    address token\\n  ) external view returns (address);\\n\\n  /// @notice Proposes an administrator for the given token as pending administrator.\\n  /// @param localToken The token to register the administrator for.\\n  /// @param administrator The administrator to register.\\n  function proposeAdministrator(\\n    address localToken,\\n    address administrator\\n  ) external;\\n\\n  /// @notice Accepts the administrator role for a token.\\n  /// @param localToken The token to accept the administrator role for.\\n  /// @dev This function can only be called by the pending administrator.\\n  function acceptAdminRole(\\n    address localToken\\n  ) external;\\n\\n  /// @notice Sets the pool for a token. Setting the pool to address(0) effectively delists the token\\n  /// from CCIP. Setting the pool to any other address enables the token on CCIP.\\n  /// @param localToken The token to set the pool for.\\n  /// @param pool The pool to set for the token.\\n  function setPool(\\n    address localToken,\\n    address pool\\n  ) external;\\n\\n  /// @notice Transfers the administrator role for a token to a new address with a 2-step process.\\n  /// @param localToken The token to transfer the administrator role for.\\n  /// @param newAdmin The address to transfer the administrator role to. Can be address(0) to cancel\\n  /// a pending transfer.\\n  /// @dev The new admin must call `acceptAdminRole` to accept the role.\\n  function transferAdminRole(\\n    address localToken,\\n    address newAdmin\\n  ) external;\\n}\\n\"},\"contracts/libraries/CCVConfigValidation.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice CCV config validation helpers.\\nlibrary CCVConfigValidation {\\n  error MustSpecifyDefaultOrRequiredCCVs();\\n  error DuplicateCCVNotAllowed(address ccvAddress);\\n  error ZeroAddressNotAllowed();\\n\\n  /// @notice Ensures at least one CCV combined, no zero addresses, no duplicates within or across both sets.\\n  /// @param defaultCCV The default CCVs.\\n  /// @param laneMandatedCCVs The mandated CCVs.\\n  function _validateDefaultAndMandatedCCVs(\\n    address[] memory defaultCCV,\\n    address[] memory laneMandatedCCVs\\n  ) internal pure {\\n    uint256 defaultLength = defaultCCV.length;\\n    uint256 mandatedLength = laneMandatedCCVs.length;\\n    uint256 totalLength = defaultLength + mandatedLength;\\n\\n    // There must always be at least one default or mandated CCV. This ensures that any receiver who does not specify\\n    // CCVs will always have at least one CCV to validate the message.\\n    if (totalLength == 0) revert MustSpecifyDefaultOrRequiredCCVs();\\n\\n    // We check for duplicates and zero addresses in the default and mandated CCVs. We need to check for duplicates\\n    // between the two sets of CCVs as well as within each set. Doing these checks here means we can assume there are\\n    // no duplicates or zero addresses in the rest of the code.\\n    for (uint256 combinedIndex = 0; combinedIndex \\u003c totalLength; ++combinedIndex) {\\n      address currentCCVAddress =\\n        combinedIndex \\u003c defaultLength ? defaultCCV[combinedIndex] : laneMandatedCCVs[combinedIndex - defaultLength];\\n      if (currentCCVAddress == address(0)) revert ZeroAddressNotAllowed();\\n\\n      for (uint256 nextIndex = combinedIndex + 1; nextIndex \\u003c totalLength; ++nextIndex) {\\n        address compareCCVAddress =\\n          nextIndex \\u003c defaultLength ? defaultCCV[nextIndex] : laneMandatedCCVs[nextIndex - defaultLength];\\n        if (currentCCVAddress == compareCCVAddress) revert DuplicateCCVNotAllowed(currentCCVAddress);\\n      }\\n    }\\n  }\\n\\n  function _assertNoDuplicates(\\n    address[] memory addresses\\n  ) internal pure {\\n    uint256 length = addresses.length;\\n    for (uint256 i = 0; i \\u003c length; ++i) {\\n      for (uint256 j = i + 1; j \\u003c length; ++j) {\\n        if (addresses[i] == addresses[j]) revert DuplicateCCVNotAllowed(addresses[i]);\\n      }\\n    }\\n  }\\n\\n  function _assertNoDuplicatedBetweenLists(\\n    address[] memory listA,\\n    address[] memory listB\\n  ) internal pure {\\n    uint256 lengthA = listA.length;\\n    uint256 lengthB = listB.length;\\n    for (uint256 i = 0; i \\u003c lengthA; ++i) {\\n      for (uint256 j = 0; j \\u003c lengthB; ++j) {\\n        if (listA[i] == listB[j]) revert DuplicateCCVNotAllowed(listA[i]);\\n      }\\n    }\\n  }\\n}\\n\"},\"contracts/libraries/Client.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// End consumer library.\\nlibrary Client {\\n  struct EVMTokenAmount {\\n    address token; // token address on the local chain.\\n    uint256 amount; // Amount of tokens.\\n  }\\n\\n  struct Any2EVMMessage {\\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\\n    uint64 sourceChainSelector; // Source chain selector.\\n    bytes sender; // abi.encode(address) on EVM source chains; abi.decode(sender, (address)) to recover.\\n    bytes data; // payload sent in original message.\\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\\n  }\\n\\n  // If extraArgs is empty bytes, the default is 200k gas limit.\\n  struct EVM2AnyMessage {\\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains.\\n    bytes data; // Data payload.\\n    EVMTokenAmount[] tokenAmounts; // Token transfers.\\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV3).\\n  }\\n\\n  /// @notice Tag to indicate no execution on the destination chain. Execution will need to be done manually.\\n  /// @dev Preimage for this tag is: keccak256(\\\"NO_EXECUTION_TAG\\\")[:4]\\n  bytes4 public constant NO_EXECUTION_TAG = 0xeba517d2;\\n  address public constant NO_EXECUTION_ADDRESS = address(bytes20(NO_EXECUTION_TAG));\\n\\n  // ================================================================\\n  // │                           Legacy                             │\\n  // ================================================================\\n\\n  // Tag to indicate only a gas limit. Only usable for EVM as destination chain.\\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\\n\\n  struct EVMExtraArgsV1 {\\n    uint256 gasLimit;\\n  }\\n\\n  function _argsToBytes(\\n    EVMExtraArgsV1 memory extraArgs\\n  ) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\\n  }\\n\\n  // Tag to indicate a gas limit (or dest chain equivalent processing units) and Out Of Order Execution. This tag is\\n  // available for multiple chain families. If there is no chain family specific tag, this is the default available\\n  // for a chain.\\n  // Note: not available for Solana or Sui VM based chains.\\n  bytes4 public constant GENERIC_EXTRA_ARGS_V2_TAG = 0x181dcf10;\\n\\n  /// @param gasLimit: gas limit for the callback on the destination chain.\\n  /// @param allowOutOfOrderExecution: if true, it indicates that the message can be executed in any order relative to\\n  /// other messages from the same sender. This value's default varies by chain. On some chains, a particular value is\\n  /// enforced, meaning if the expected value is not set, the message request will revert.\\n  /// @dev Fully compatible with the previously existing EVMExtraArgsV2.\\n  struct GenericExtraArgsV2 {\\n    uint256 gasLimit;\\n    bool allowOutOfOrderExecution;\\n  }\\n\\n  // Extra args tag for chains that use the Sui VM.\\n  bytes4 public constant SUI_EXTRA_ARGS_V1_TAG = 0x21ea4ca9;\\n\\n  // Extra args tag for chains that use the Solana VM.\\n  bytes4 public constant SVM_EXTRA_ARGS_V1_TAG = 0x1f3b3aba;\\n\\n  struct SVMExtraArgsV1 {\\n    uint32 computeUnits;\\n    uint64 accountIsWritableBitmap;\\n    bool allowOutOfOrderExecution;\\n    bytes32 tokenReceiver;\\n    // Additional accounts needed for execution of CCIP receiver. Must be empty if message.receiver is zero.\\n    // Token transfer related accounts are specified in the token pool lookup table on SVM.\\n    bytes32[] accounts;\\n  }\\n\\n  /// @dev The maximum number of accounts that can be passed in SVMExtraArgs.\\n  uint256 public constant SVM_EXTRA_ARGS_MAX_ACCOUNTS = 64;\\n\\n  /// @dev The expected static payload size of a token transfer when Borsh encoded and submitted to SVM.\\n  /// TokenPool extra data and offchain data sizes are dynamic, and should be accounted for separately.\\n  uint256 public constant SVM_TOKEN_TRANSFER_DATA_OVERHEAD = (4 + 32) // source_pool\\n    + 32 // token_address\\n    + 4 // gas_amount\\n    + 4 // extra_data overhead\\n    + 32 // amount\\n    + 32 // size of the token lookup table account\\n    + 32 // token-related accounts in the lookup table, over-estimated to 32, typically between 11 - 13\\n    + 32 // token account belonging to the token receiver, e.g ATA, not included in the token lookup table\\n    + 32 // per-chain token pool config, not included in the token lookup table\\n    + 32 // per-chain token billing config, not always included in the token lookup table\\n    + 32; // OffRamp pool signer PDA, not included in the token lookup table\\n\\n  /// @dev Number of overhead accounts needed for message execution on SVM.\\n  /// @dev These are message.receiver, and the OffRamp Signer PDA specific to the receiver.\\n  uint256 public constant SVM_MESSAGING_ACCOUNTS_OVERHEAD = 2;\\n\\n  /// @dev The size of each SVM account address in bytes.\\n  uint256 public constant SVM_ACCOUNT_BYTE_SIZE = 32;\\n\\n  struct SuiExtraArgsV1 {\\n    uint256 gasLimit;\\n    bool allowOutOfOrderExecution;\\n    bytes32 tokenReceiver;\\n    bytes32[] receiverObjectIds;\\n  }\\n\\n  /// @dev The expected static payload size of a token transfer when BCS encoded and submitted to SUI.\\n  /// TokenPool extra data and offchain data sizes are dynamic, and should be accounted for separately.\\n  uint256 public constant SUI_TOKEN_TRANSFER_DATA_OVERHEAD = (4 + 32) // source_pool, 4 bytes for length, 32 bytes for address\\n    + 32 // dest_token_address\\n    + 4 // dest_gas_amount\\n    + 4 // extra_data length, the contents are calculated separately\\n    + 32; // amount\\n\\n  /// @dev Number of overhead accounts needed for message execution on SUI.\\n  /// @dev This is the message.receiver.\\n  uint256 public constant SUI_MESSAGING_ACCOUNTS_OVERHEAD = 1;\\n\\n  /// @dev The maximum number of receiver object ids that can be passed in SuiExtraArgs.\\n  uint256 public constant SUI_EXTRA_ARGS_MAX_RECEIVER_OBJECT_IDS = 64;\\n\\n  /// @dev The size of each SUI account address in bytes.\\n  uint256 public constant SUI_ACCOUNT_BYTE_SIZE = 32;\\n\\n  function _argsToBytes(\\n    GenericExtraArgsV2 memory extraArgs\\n  ) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(GENERIC_EXTRA_ARGS_V2_TAG, extraArgs);\\n  }\\n\\n  function _svmArgsToBytes(\\n    SVMExtraArgsV1 memory extraArgs\\n  ) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(SVM_EXTRA_ARGS_V1_TAG, extraArgs);\\n  }\\n\\n  function _suiArgsToBytes(\\n    SuiExtraArgsV1 memory extraArgs\\n  ) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(SUI_EXTRA_ARGS_V1_TAG, extraArgs);\\n  }\\n}\\n\"},\"contracts/libraries/ExtraArgsCodec.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Gas-optimized assembly version of ExtraArgsCodec library.\\nlibrary ExtraArgsCodec {\\n  error InvalidDataLength(EncodingErrorLocation location, uint256 offset);\\n  error InvalidExtraArgsTag(bytes4 expected, bytes4 actual);\\n  error InvalidAddressLength(uint256 length);\\n  error CCVArrayLengthMismatch(uint256 ccvsLength, uint256 ccvArgsLength);\\n\\n  bytes4 public constant GENERIC_EXTRA_ARGS_V3_TAG = 0xa69dd4aa;\\n  bytes4 public constant SVM_EXECUTOR_ARGS_V1_TAG = 0x1a2b3c4d;\\n  bytes4 public constant SUI_EXECUTOR_ARGS_V1_TAG = 0x5e6f7a8b;\\n\\n  // Base size excludes all variable-length fields (CCV addresses/args, executor address, executorArgs, tokenReceiver,\\n  // tokenArgs).\\n  // Encoding order: tag(4) + gasLimit(4) + blockConfirmations(2) + ccvsLength(1) + executorLength(1) +\\n  // executorArgsLength(2) + tokenReceiverLength(1) + tokenArgsLength(2) = 17 bytes.\\n  uint256 public constant GENERIC_EXTRA_ARGS_V3_BASE_SIZE = 4 + 4 + 2 + 1 + 1 + 2 + 1 + 2;\\n  uint256 public constant GENERIC_EXTRA_ARGS_V3_STATIC_LENGTH_SIZE = 4 + 4 + 2 + 1;\\n  // Base size: tag(4) + useATA(1) + accountIsWritableBitmap(8) + accountsLength(1) = 14 bytes.\\n  uint256 public constant SVM_EXECUTOR_ARGS_V1_BASE_SIZE = 4 + 1 + 8 + 1;\\n  // Base size: tag(4) + objectIdsLength(1) = 5 bytes.\\n  uint256 public constant SUI_EXECUTOR_ARGS_V1_BASE_SIZE = 4 + 1;\\n\\n  // Enum to indicate specific error locations during encoding/decoding.\\n  enum EncodingErrorLocation {\\n    // Generic decoding errors (used in helper functions).\\n    DECODE_FIELD_LENGTH, // 0 - Error reading a field's length prefix.\\n    DECODE_FIELD_CONTENT, // 1 - Error reading a field's content/payload.\\n    // Specific decoding errors (used in main decoding functions).\\n    EXTRA_ARGS_STATIC_LENGTH_FIELDS, // 2\\n    EXTRA_ARGS_FINAL_OFFSET, // 3\\n    SVM_EXECUTOR_ACCOUNTS_CONTENT, // 4\\n    SVM_EXECUTOR_FINAL_OFFSET, // 5\\n    SUI_EXECUTOR_OBJECT_IDS_CONTENT, // 6\\n    SUI_EXECUTOR_FINAL_OFFSET, // 7\\n    // Encoding validation errors.\\n    ENCODE_CCVS_ARRAY_LENGTH, // 8\\n    ENCODE_CCV_ARGS_LENGTH, // 9\\n    ENCODE_EXECUTOR_ARGS_LENGTH, // 10\\n    ENCODE_TOKEN_RECEIVER_LENGTH, // 11\\n    ENCODE_TOKEN_ARGS_LENGTH, // 12\\n    ENCODE_SVM_ACCOUNTS_LENGTH, // 13\\n    ENCODE_SUI_OBJECT_IDS_LENGTH // 14\\n  }\\n\\n  /// @notice GenericExtraArgsV3 encoding format used for CCIP messages.\\n  /// Static length fields.\\n  ///   bytes4 tag;                     Version tag.\\n  ///   uint32 gasLimit;                Gas limit for the callback on the destination chain.\\n  ///   uint16 blockConfirmations;      Number of block confirmations to wait for (0 = default finality).\\n  ///   uint8 ccvsLength;               Number of cross-chain verifiers.\\n  ///\\n  /// Variable length fields (per CCV, repeated ccvsLength times).\\n  ///   uint8 ccvAddressLength;         Length of the CCV address in bytes (0 or 20 for EVM addresses).\\n  ///   bytes ccvAddress;               CCV address as unpadded bytes (20 bytes for EVM addresses if non-zero).\\n  ///   uint16 ccvArgsLength;           Length of the CCV-specific arguments in bytes.\\n  ///   bytes ccvArgs;                  CCV-specific arguments.\\n  ///\\n  /// Variable length fields (executor and token config).\\n  ///   uint8 executorLength;           Length of the executor address in bytes (0 or 20 for EVM addresses).\\n  ///   bytes executor;                 Executor address as unpadded bytes (20 bytes for EVM addresses if non-zero).\\n  ///   uint16 executorArgsLength;      Length of the executor arguments in bytes.\\n  ///   bytes executorArgs;             Destination chain family-specific executor arguments.\\n  ///   uint8 tokenReceiverLength;      Length of the token receiver address in bytes (0 or 20 for EVM addresses).\\n  ///   bytes tokenReceiver;            Token receiver address as unpadded bytes (20 bytes for EVM addresses if non-zero).\\n  ///   uint16 tokenArgsLength;         Length of the token arguments in bytes.\\n  ///   bytes tokenArgs;                Token pool-specific arguments.\\n  // solhint-disable-next-line gas-struct-packing\\n  struct GenericExtraArgsV3 {\\n    /// @notice Gas limit for the callback on the destination chain. If the gas limit is zero and the message data\\n    /// length is also zero, no callback will be performed, even if a receiver is specified. A gas limit of zero is\\n    /// useful when only token transfers are desired, or when the receiver is an EOA account instead of a contract.\\n    /// Besides this gasLimit check, there are other checks on the destination chain that may prevent the callback from\\n    /// being executed, depending on the destination chain family.\\n    /// @dev The sender is billed for the gas specified, not the gas actually used. Any unspent gas is not refunded.\\n    /// There are various ways to estimate the gas required for a callback on the destination chain, depending on the\\n    /// chain family. Please refer to the documentation for each chain for more details.\\n    uint32 gasLimit;\\n    /// @notice The number of block confirmations to wait for. 0 means the default finality that the CCV considers\\n    /// final. Any non-zero value means a block depth. CCVs, Pools and the executor may all reject this value by\\n    /// reverting the transaction on the source chain if they do not want to take on the risk of the block depth\\n    /// specified.\\n    /// @dev May be zero to indicate waiting for finality is desired.\\n    uint16 blockConfirmations;\\n    /// @notice An array of CCV addresses representing the cross-chain verifiers to be used for the message.\\n    /// @dev May be empty to specify the default verifier(s) should be used.\\n    address[] ccvs;\\n    /// @notice Optional arguments that are passed into the CCV without modification or inspection. CCIP itself does not\\n    /// interpret these arguments: they are encoded in whatever format the CCV has decided.\\n    /// @dev Must be the same length as the `ccvs` array. May have empty bytes as arguments.\\n    bytes[] ccvArgs;\\n    /// @notice Address of the executor contract on the source chain. The executor is responsible for executing the\\n    /// message on the destination chains once a quorum of CCVs have verified the message.\\n    /// @dev May be address(0) to indicate the default executor should be used.\\n    address executor;\\n    /// @notice Destination chain family specific arguments for the executor. This field is passed to the destination\\n    /// chain as part of the message itself and these args are therefore fully protected through the message ID. The\\n    /// format of this field is specific to each chain family and is not interpreted by CCIP itself, only by the\\n    /// executor. Things that may be included here are Solana accounts or Sui object IDs, which must be secured through\\n    /// the message ID as passing in incorrect values can lead to loss of funds.\\n    /// @dev May be empty depending on the destination chain.\\n    bytes executorArgs;\\n    /// @notice Address of the token receiver on the destination chain, in bytes format. If an empty bytes array is\\n    /// provided, the receiver address from the message itself is used for token transfers. This field allows for\\n    /// scenarios where the token receiver is different from the message receiver.\\n    /// @dev May be empty, the behavior differs depending on if there is a token transfer or not:\\n    /// - If there is a token transfer, the receiver from the message is used.\\n    /// - If there is no token transfer, this field should be empty.\\n    bytes tokenReceiver;\\n    /// @notice Additional arguments for token transfers. This field is passed into the token pool on the source chain\\n    /// and is not inspected by CCIP itself. The format of this field is therefore specific to the token pool being used\\n    /// and may vary between different pools.\\n    /// @dev May be empty depending on the token pool.\\n    bytes tokenArgs;\\n  }\\n\\n  /// @notice Creates a basic encoded GenericExtraArgsV3 with only gasLimit and blockConfirmations set.\\n  /// @param gasLimit The gas limit for the callback on the destination chain.\\n  /// @param blockConfirmations The user requested number of block confirmations.\\n  /// @return encoded The encoded extra args as bytes. These are ready to be passed into CCIP functions.\\n  function _getBasicEncodedExtraArgsV3(\\n    uint32 gasLimit,\\n    uint16 blockConfirmations\\n  ) internal pure returns (bytes memory) {\\n    return abi.encodePacked(GENERIC_EXTRA_ARGS_V3_TAG, gasLimit, blockConfirmations, bytes7(0));\\n  }\\n\\n  enum SVMTokenReceiverUsage {\\n    DERIVE_ATA_AND_CREATE,\\n    DERIVE_ATA_DONT_CREATE,\\n    USE_AS_IS\\n  }\\n\\n  struct SVMExecutorArgsV1 {\\n    SVMTokenReceiverUsage useATA;\\n    uint64 accountIsWritableBitmap;\\n    // Additional accounts needed for execution of CCIP receiver. Must be empty if message.receiver is zero.\\n    // Token transfer related accounts are specified in the token pool lookup table on SVM.\\n    bytes32[] accounts;\\n  }\\n\\n  struct SuiExecutorArgsV1 {\\n    bytes32[] receiverObjectIds;\\n  }\\n\\n  /// @notice Helper function to read a uint8 length prefix and an address from calldata.\\n  /// @dev Reads length as 1 byte followed by the address bytes (20 bytes if non-zero).\\n  /// @param encoded The encoded bytes to read from.\\n  /// @param offset The current offset in the encoded bytes.\\n  /// @return addr The address read from calldata (address(0) if length was 0).\\n  /// @return newOffset The updated offset after reading.\\n  function _readUint8PrefixedAddress(\\n    bytes calldata encoded,\\n    uint256 offset\\n  ) private pure returns (address addr, uint256 newOffset) {\\n    // Unchecked is safe as the offset can never approach type(uint256).max.\\n    unchecked {\\n      // Read address length (1 byte).\\n      if (offset + 1 \\u003e encoded.length) revert InvalidDataLength(EncodingErrorLocation.DECODE_FIELD_LENGTH, offset);\\n      uint256 addrLength;\\n      assembly (\\\"memory-safe\\\") {\\n        addrLength := byte(0, calldataload(add(encoded.offset, offset)))\\n      }\\n      newOffset = offset + 1;\\n\\n      // If the address is zero length, we are done and return address(0).\\n      if (addrLength == 0) {\\n        return (address(0), newOffset);\\n      }\\n\\n      // Validate address length 20 as these extraArgs are for EVM and the only valid address length is 20.\\n      if (addrLength != 20) {\\n        revert InvalidAddressLength(addrLength);\\n      }\\n\\n      // Read address content, unchecked is safe as the offset can never approach type(uint256).max.\\n      if (newOffset + addrLength \\u003e encoded.length) {\\n        revert InvalidDataLength(EncodingErrorLocation.DECODE_FIELD_CONTENT, newOffset);\\n      }\\n\\n      assembly (\\\"memory-safe\\\") {\\n        let addrData := calldataload(add(encoded.offset, newOffset))\\n        addr := shr(96, addrData)\\n      }\\n      newOffset += addrLength;\\n    }\\n    return (addr, newOffset);\\n  }\\n\\n  /// @notice Helper function to read a uint16 length prefix and bytes data from calldata.\\n  /// @dev Reads length as 2 bytes (big endian) followed by the data bytes.\\n  /// @param encoded The encoded bytes to read from.\\n  /// @param offset The current offset in the encoded bytes.\\n  /// @return data The bytes data read from calldata.\\n  /// @return newOffset The updated offset after reading.\\n  function _readUint16PrefixedBytes(\\n    bytes calldata encoded,\\n    uint256 offset\\n  ) private pure returns (bytes calldata data, uint256 newOffset) {\\n    // Unchecked is safe as the offset can never approach type(uint256).max.\\n    unchecked {\\n      // Read length (2 bytes).\\n      if (offset + 2 \\u003e encoded.length) revert InvalidDataLength(EncodingErrorLocation.DECODE_FIELD_LENGTH, offset);\\n      uint256 dataLength;\\n      assembly (\\\"memory-safe\\\") {\\n        let lengthData := calldataload(add(encoded.offset, offset))\\n        dataLength := and(shr(240, lengthData), 0xFFFF)\\n      }\\n      newOffset = offset + 2;\\n\\n      if (newOffset + dataLength \\u003e encoded.length) {\\n        revert InvalidDataLength(EncodingErrorLocation.DECODE_FIELD_CONTENT, newOffset);\\n      }\\n\\n      // Read content.\\n      data = encoded[newOffset:newOffset + dataLength];\\n      newOffset += dataLength;\\n    }\\n    return (data, newOffset);\\n  }\\n\\n  /// @notice Helper function to read a uint8 length prefix and bytes data from calldata.\\n  /// @dev Reads length as 1 byte followed by the data bytes.\\n  /// @param encoded The encoded bytes to read from.\\n  /// @param offset The current offset in the encoded bytes.\\n  /// @return data The bytes data read from calldata.\\n  /// @return newOffset The updated offset after reading.\\n  function _readUint8PrefixedBytes(\\n    bytes calldata encoded,\\n    uint256 offset\\n  ) private pure returns (bytes calldata data, uint256 newOffset) {\\n    // Unchecked is safe as the offset can never approach type(uint256).max.\\n    unchecked {\\n      // Read length (1 byte).\\n      if (offset + 1 \\u003e encoded.length) revert InvalidDataLength(EncodingErrorLocation.DECODE_FIELD_LENGTH, offset);\\n      uint256 dataLength;\\n      assembly (\\\"memory-safe\\\") {\\n        dataLength := byte(0, calldataload(add(encoded.offset, offset)))\\n      }\\n      newOffset = offset + 1;\\n\\n      if (newOffset + dataLength \\u003e encoded.length) {\\n        revert InvalidDataLength(EncodingErrorLocation.DECODE_FIELD_CONTENT, newOffset);\\n      }\\n\\n      // Read content.\\n      data = encoded[newOffset:newOffset + dataLength];\\n      newOffset += dataLength;\\n    }\\n    return (data, newOffset);\\n  }\\n\\n  /// @notice Helper function to write a uint8 length prefix and an address. This function writes 12 bytes of overshoot\\n  /// to the pointer location. This must be handled by the caller.\\n  /// @dev Writes length as 1 byte followed by the address bytes (20 bytes if non-zero).\\n  /// @param ptr The memory pointer where to start writing.\\n  /// @param addr The address to write.\\n  /// @return newPtr The updated memory pointer after writing.\\n  function _writeUint8PrefixedAddress(\\n    uint256 ptr,\\n    address addr\\n  ) private pure returns (uint256 newPtr) {\\n    assembly {\\n      let addrLength := mul(iszero(iszero(addr)), 20)\\n      // Write address length (1 byte).\\n      mstore8(ptr, addrLength)\\n      newPtr := add(ptr, 1)\\n\\n      // Write address if non-zero.\\n      if gt(addrLength, 0) {\\n        mstore(newPtr, shl(96, addr))\\n        newPtr := add(newPtr, 20)\\n      }\\n    }\\n    return newPtr;\\n  }\\n\\n  /// @notice Helper function to write a uint16 length prefix and copy bytes data. This function can write overshoot\\n  /// to the pointer location of at most 31 bytes. This must be handled by the caller. The overshoot depends on the data\\n  /// length.\\n  /// @dev Writes length as 2 bytes (big endian) followed by the data bytes.\\n  /// @param ptr The memory pointer where to start writing.\\n  /// @param data The bytes data to write.\\n  /// @return newPtr The updated memory pointer after writing.\\n  function _writeUint16PrefixedBytes(\\n    uint256 ptr,\\n    bytes memory data\\n  ) private pure returns (uint256 newPtr) {\\n    uint256 dataLength = data.length;\\n    assembly {\\n      // Write length (2 bytes, big endian).\\n      mstore8(ptr, shr(8, dataLength))\\n      mstore8(add(ptr, 1), and(dataLength, 0xFF))\\n      newPtr := add(ptr, 2)\\n\\n      // Copy data.\\n      if gt(dataLength, 0) {\\n        let srcPtr := add(data, 32)\\n        for { let end := add(srcPtr, dataLength) } lt(srcPtr, end) { srcPtr := add(srcPtr, 32) } {\\n          mstore(newPtr, mload(srcPtr))\\n          newPtr := add(newPtr, 32)\\n        }\\n        // Adjust ptr if we overshot.\\n        newPtr := sub(newPtr, sub(and(add(dataLength, 31), not(31)), dataLength))\\n      }\\n    }\\n    return newPtr;\\n  }\\n\\n  /// @notice Helper function to write a uint8 length prefix and copy bytes data. This function can write overshoot\\n  /// to the pointer location of at most 31 bytes. This must be handled by the caller. The overshoot depends on the data\\n  /// length.\\n  /// @dev Writes length as 1 byte followed by the data bytes.\\n  /// @param ptr The memory pointer where to start writing.\\n  /// @param data The bytes data to write.\\n  /// @return newPtr The updated memory pointer after writing.\\n  function _writeUint8PrefixedBytes(\\n    uint256 ptr,\\n    bytes memory data\\n  ) private pure returns (uint256 newPtr) {\\n    uint256 dataLength = data.length;\\n    assembly {\\n      // Write length (1 byte).\\n      mstore8(ptr, dataLength)\\n      newPtr := add(ptr, 1)\\n\\n      // Copy data.\\n      if gt(dataLength, 0) {\\n        let srcPtr := add(data, 32)\\n        for { let end := add(srcPtr, dataLength) } lt(srcPtr, end) { srcPtr := add(srcPtr, 32) } {\\n          mstore(newPtr, mload(srcPtr))\\n          newPtr := add(newPtr, 32)\\n        }\\n        // Adjust ptr if we overshot.\\n        newPtr := sub(newPtr, sub(and(add(dataLength, 31), not(31)), dataLength))\\n      }\\n    }\\n    return newPtr;\\n  }\\n\\n  /// @notice Encodes a GenericExtraArgsV3 struct into bytes using assembly for gas efficiency.\\n  /// @param extraArgs The GenericExtraArgsV3 struct to encode.\\n  /// @return encoded The encoded extra args as bytes.\\n  function _encodeGenericExtraArgsV3(\\n    GenericExtraArgsV3 memory extraArgs\\n  ) internal pure returns (bytes memory encoded) {\\n    // Validate ccvs and ccvArgs arrays have the same length.\\n    uint256 ccvsLength = extraArgs.ccvs.length;\\n    if (ccvsLength != extraArgs.ccvArgs.length) {\\n      revert CCVArrayLengthMismatch(ccvsLength, extraArgs.ccvArgs.length);\\n    }\\n\\n    // Validate field lengths.\\n    if (ccvsLength \\u003e type(uint8).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_CCVS_ARRAY_LENGTH, 0);\\n    }\\n    uint256 executorArgsLength = extraArgs.executorArgs.length;\\n    if (executorArgsLength \\u003e type(uint16).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_EXECUTOR_ARGS_LENGTH, 0);\\n    }\\n    uint256 tokenReceiverLength = extraArgs.tokenReceiver.length;\\n    if (tokenReceiverLength \\u003e type(uint8).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_TOKEN_RECEIVER_LENGTH, 0);\\n    }\\n    uint256 tokenArgsLength = extraArgs.tokenArgs.length;\\n    if (tokenArgsLength \\u003e type(uint16).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_TOKEN_ARGS_LENGTH, 0);\\n    }\\n\\n    // Calculate executor length.\\n    uint256 executorLength = extraArgs.executor == address(0) ? 0 : 20;\\n\\n    // Calculate total CCV encoded size and validate.\\n    uint256 ccvsEncodedSize = 0;\\n    for (uint256 i = 0; i \\u003c ccvsLength; ++i) {\\n      uint256 ccvAddrLength = extraArgs.ccvs[i] == address(0) ? 0 : 20;\\n\\n      uint256 ccvArgLength = extraArgs.ccvArgs[i].length;\\n      if (ccvArgLength \\u003e type(uint16).max) {\\n        revert InvalidDataLength(EncodingErrorLocation.ENCODE_CCV_ARGS_LENGTH, 0);\\n      }\\n\\n      // 1 byte for address length + address bytes + 2 bytes for args length + args bytes.\\n      ccvsEncodedSize += 1 + ccvAddrLength + 2 + ccvArgLength;\\n    }\\n\\n    // Allocate memory.\\n    // GENERIC_EXTRA_ARGS_V3_BASE_SIZE + all variable-length fields + 32 bytes to account for any potential overshoot\\n    // that comes from writing 32-byte blocks of data.\\n    encoded = new bytes(\\n      GENERIC_EXTRA_ARGS_V3_BASE_SIZE + ccvsEncodedSize + executorLength + executorArgsLength + tokenReceiverLength\\n        + tokenArgsLength + 32\\n    );\\n\\n    bytes memory staticFields =\\n      abi.encodePacked(GENERIC_EXTRA_ARGS_V3_TAG, extraArgs.gasLimit, extraArgs.blockConfirmations, uint8(ccvsLength));\\n\\n    uint256 ptr;\\n    // This block is memory safe because it only writes to the allocated `encoded` bytes.\\n    assembly (\\\"memory-safe\\\") {\\n      ptr := add(encoded, 32) // Skip length prefix.\\n\\n      // Write static-length fields.\\n      mstore(ptr, mload(add(staticFields, 32)))\\n      ptr := add(ptr, GENERIC_EXTRA_ARGS_V3_STATIC_LENGTH_SIZE)\\n    }\\n\\n    // Write CCVs data.\\n    for (uint256 i = 0; i \\u003c ccvsLength; ++i) {\\n      ptr = _writeUint8PrefixedAddress(ptr, extraArgs.ccvs[i]);\\n      ptr = _writeUint16PrefixedBytes(ptr, extraArgs.ccvArgs[i]);\\n    }\\n\\n    // Write executor, executorArgs, tokenReceiver, tokenArgs.\\n    ptr = _writeUint8PrefixedAddress(ptr, extraArgs.executor);\\n    ptr = _writeUint16PrefixedBytes(ptr, extraArgs.executorArgs);\\n    ptr = _writeUint8PrefixedBytes(ptr, extraArgs.tokenReceiver);\\n    ptr = _writeUint16PrefixedBytes(ptr, extraArgs.tokenArgs);\\n\\n    // Verify that we've exactly filled the allocated bytes. We load the data offset of the bytes array to be able to\\n    // compare with ptr.\\n    uint256 encodedDataOffset;\\n    assembly (\\\"memory-safe\\\") {\\n      mstore(encoded, sub(mload(encoded), 32)) // Set correct length as we overprovisioned for overshoot.\\n      encodedDataOffset := encoded\\n    }\\n    // The pointer should be at the end of the allocated data (data offset + length + 32 bytes for length prefix).\\n    if (ptr != encodedDataOffset + encoded.length + 32) {\\n      revert InvalidDataLength(EncodingErrorLocation.EXTRA_ARGS_FINAL_OFFSET, ptr - encodedDataOffset);\\n    }\\n\\n    return encoded;\\n  }\\n\\n  /// @notice Decodes bytes into a GenericExtraArgsV3 struct using assembly for gas efficiency.\\n  /// @param encoded The encoded bytes to decode.\\n  /// @return extraArgs The decoded GenericExtraArgsV3 struct.\\n  function _decodeGenericExtraArgsV3(\\n    bytes calldata encoded\\n  ) internal pure returns (GenericExtraArgsV3 memory extraArgs) {\\n    // Check if encodedLength is at least the minimum size.\\n    if (encoded.length \\u003c GENERIC_EXTRA_ARGS_V3_BASE_SIZE) {\\n      revert InvalidDataLength(EncodingErrorLocation.EXTRA_ARGS_STATIC_LENGTH_FIELDS, encoded.length);\\n    }\\n\\n    // Check tag.\\n    bytes4 tag;\\n    assembly (\\\"memory-safe\\\") {\\n      tag := calldataload(encoded.offset)\\n    }\\n\\n    if (tag != GENERIC_EXTRA_ARGS_V3_TAG) {\\n      revert InvalidExtraArgsTag(GENERIC_EXTRA_ARGS_V3_TAG, tag);\\n    }\\n\\n    uint256 ccvsLength;\\n    // Read static-length fields.\\n    assembly (\\\"memory-safe\\\") {\\n      // Read gas limit (4 bytes).\\n      let gasLimit := calldataload(add(encoded.offset, 4))\\n      mstore(extraArgs, and(shr(224, gasLimit), 0xFFFFFFFF))\\n\\n      // Read block confirmations (2 bytes).\\n      let blockConfirmations := calldataload(add(encoded.offset, 8))\\n      mstore(add(extraArgs, 32), and(shr(240, blockConfirmations), 0xFFFF))\\n\\n      // Read ccvs length (1 byte).\\n      ccvsLength := byte(0, calldataload(add(encoded.offset, 10)))\\n    }\\n\\n    uint256 offset = GENERIC_EXTRA_ARGS_V3_STATIC_LENGTH_SIZE; // Skip tag, gasLimit, blockConfirmations, ccvsLength.\\n\\n    // Allocate arrays for CCVs.\\n    extraArgs.ccvs = new address[](ccvsLength);\\n    extraArgs.ccvArgs = new bytes[](ccvsLength);\\n\\n    // Decode CCVs and args.\\n    for (uint256 i = 0; i \\u003c ccvsLength; ++i) {\\n      (extraArgs.ccvs[i], offset) = _readUint8PrefixedAddress(encoded, offset);\\n      (extraArgs.ccvArgs[i], offset) = _readUint16PrefixedBytes(encoded, offset);\\n    }\\n\\n    // Read executor, executorArgs, tokenReceiver, and tokenArgs.\\n    (extraArgs.executor, offset) = _readUint8PrefixedAddress(encoded, offset);\\n    (extraArgs.executorArgs, offset) = _readUint16PrefixedBytes(encoded, offset);\\n    (extraArgs.tokenReceiver, offset) = _readUint8PrefixedBytes(encoded, offset);\\n    (extraArgs.tokenArgs, offset) = _readUint16PrefixedBytes(encoded, offset);\\n\\n    // Ensure we've consumed all bytes.\\n    if (offset != encoded.length) revert InvalidDataLength(EncodingErrorLocation.EXTRA_ARGS_FINAL_OFFSET, offset);\\n\\n    return extraArgs;\\n  }\\n\\n  /// @notice Encodes a SVMExecutorArgsV1 struct into bytes.\\n  /// @param executorArgs The SVMExecutorArgsV1 struct to encode.\\n  /// @return encoded The encoded executor args as bytes.\\n  function _encodeSVMExecutorArgsV1(\\n    SVMExecutorArgsV1 memory executorArgs\\n  ) internal pure returns (bytes memory encoded) {\\n    uint256 accountsLength = executorArgs.accounts.length;\\n    if (accountsLength \\u003e type(uint8).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_SVM_ACCOUNTS_LENGTH, 0);\\n    }\\n\\n    return abi.encodePacked(\\n      SVM_EXECUTOR_ARGS_V1_TAG,\\n      uint8(executorArgs.useATA),\\n      executorArgs.accountIsWritableBitmap,\\n      uint8(accountsLength),\\n      executorArgs.accounts\\n    );\\n  }\\n\\n  /// @notice Decodes bytes into a SVMExecutorArgsV1 struct using assembly.\\n  /// @param encoded The encoded bytes to decode.\\n  /// @return executorArgs The decoded SVMExecutorArgsV1 struct.\\n  function _decodeSVMExecutorArgsV1(\\n    bytes calldata encoded\\n  ) internal pure returns (SVMExecutorArgsV1 memory executorArgs) {\\n    // Unchecked is safe as the offset can never approach type(uint256).max.\\n    unchecked {\\n      if (encoded.length \\u003c SVM_EXECUTOR_ARGS_V1_BASE_SIZE) {\\n        revert InvalidDataLength(EncodingErrorLocation.EXTRA_ARGS_STATIC_LENGTH_FIELDS, encoded.length);\\n      }\\n\\n      // Check tag.\\n      bytes4 tag;\\n      assembly (\\\"memory-safe\\\") {\\n        tag := calldataload(encoded.offset)\\n      }\\n\\n      if (tag != SVM_EXECUTOR_ARGS_V1_TAG) {\\n        revert InvalidExtraArgsTag(SVM_EXECUTOR_ARGS_V1_TAG, tag);\\n      }\\n\\n      uint256 accountsLength;\\n      bytes1 useATA;\\n\\n      // Read static-length fields.\\n      assembly (\\\"memory-safe\\\") {\\n        // Read useATA (1 byte) - enum value.\\n        useATA := byte(0, calldataload(add(encoded.offset, 4)))\\n        mstore(executorArgs, useATA)\\n\\n        // Read accountIsWritableBitmap (8 bytes).\\n        let bitmap := calldataload(add(encoded.offset, 5))\\n        mstore(add(executorArgs, 32), and(shr(192, bitmap), 0xFFFFFFFFFFFFFFFF))\\n\\n        // Read accounts length (1 byte).\\n        accountsLength := byte(0, calldataload(add(encoded.offset, 13)))\\n      }\\n\\n      if (useATA \\u003e bytes1(uint8(SVMTokenReceiverUsage.USE_AS_IS))) {\\n        revert InvalidDataLength(EncodingErrorLocation.DECODE_FIELD_CONTENT, 4);\\n      }\\n\\n      uint256 offset = SVM_EXECUTOR_ARGS_V1_BASE_SIZE;\\n\\n      // Read accounts.\\n      if (offset + accountsLength * 32 \\u003e encoded.length) {\\n        revert InvalidDataLength(EncodingErrorLocation.SVM_EXECUTOR_ACCOUNTS_CONTENT, offset);\\n      }\\n\\n      executorArgs.accounts = new bytes32[](accountsLength);\\n      for (uint256 i = 0; i \\u003c accountsLength; ++i) {\\n        assembly (\\\"memory-safe\\\") {\\n          let data := calldataload(add(add(encoded.offset, offset), mul(i, 32)))\\n          let accountsArray := mload(add(executorArgs, 64))\\n          mstore(add(add(accountsArray, 32), mul(i, 32)), data)\\n        }\\n      }\\n      offset += accountsLength * 32;\\n\\n      // Ensure we've consumed all bytes.\\n      if (offset != encoded.length) revert InvalidDataLength(EncodingErrorLocation.SVM_EXECUTOR_FINAL_OFFSET, offset);\\n    }\\n    return executorArgs;\\n  }\\n\\n  /// @notice Encodes a SuiExecutorArgsV1 struct into bytes.\\n  /// @param executorArgs The SuiExecutorArgsV1 struct to encode.\\n  /// @return encoded The encoded executor args as bytes.\\n  function _encodeSuiExecutorArgsV1(\\n    SuiExecutorArgsV1 memory executorArgs\\n  ) internal pure returns (bytes memory encoded) {\\n    uint256 objectIdsLength = executorArgs.receiverObjectIds.length;\\n    if (objectIdsLength \\u003e type(uint8).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_SUI_OBJECT_IDS_LENGTH, 0);\\n    }\\n\\n    return abi.encodePacked(SUI_EXECUTOR_ARGS_V1_TAG, uint8(objectIdsLength), executorArgs.receiverObjectIds);\\n  }\\n\\n  /// @notice Decodes bytes into a SuiExecutorArgsV1 struct using assembly.\\n  /// @param encoded The encoded bytes to decode.\\n  /// @return executorArgs The decoded SuiExecutorArgsV1 struct.\\n  function _decodeSuiExecutorArgsV1(\\n    bytes calldata encoded\\n  ) internal pure returns (SuiExecutorArgsV1 memory executorArgs) {\\n    // Unchecked is safe as the offset can never approach type(uint256).max.\\n    unchecked {\\n      if (encoded.length \\u003c SUI_EXECUTOR_ARGS_V1_BASE_SIZE) {\\n        revert InvalidDataLength(EncodingErrorLocation.EXTRA_ARGS_STATIC_LENGTH_FIELDS, encoded.length);\\n      }\\n\\n      // Check tag.\\n      bytes4 tag;\\n      assembly (\\\"memory-safe\\\") {\\n        tag := calldataload(encoded.offset)\\n      }\\n\\n      if (tag != SUI_EXECUTOR_ARGS_V1_TAG) {\\n        revert InvalidExtraArgsTag(SUI_EXECUTOR_ARGS_V1_TAG, tag);\\n      }\\n\\n      // Read objectIds length.\\n      uint256 objectIdsLength;\\n      assembly (\\\"memory-safe\\\") {\\n        objectIdsLength := byte(0, calldataload(add(encoded.offset, 4)))\\n      }\\n\\n      uint256 offset = SUI_EXECUTOR_ARGS_V1_BASE_SIZE;\\n      // Read objectIds.\\n      if (offset + objectIdsLength * 32 \\u003e encoded.length) {\\n        revert InvalidDataLength(EncodingErrorLocation.SUI_EXECUTOR_OBJECT_IDS_CONTENT, offset);\\n      }\\n\\n      executorArgs.receiverObjectIds = new bytes32[](objectIdsLength);\\n      for (uint256 i = 0; i \\u003c objectIdsLength; ++i) {\\n        assembly (\\\"memory-safe\\\") {\\n          let data := calldataload(add(add(encoded.offset, offset), mul(i, 32)))\\n          let objectIdsArray := mload(executorArgs)\\n          mstore(add(add(objectIdsArray, 32), mul(i, 32)), data)\\n        }\\n      }\\n      offset += objectIdsLength * 32;\\n\\n      // Ensure we've consumed all bytes.\\n      if (offset != encoded.length) revert InvalidDataLength(EncodingErrorLocation.SUI_EXECUTOR_FINAL_OFFSET, offset);\\n    }\\n    return executorArgs;\\n  }\\n}\\n\"},\"contracts/libraries/FeeTokenHandler.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts@5.3.0/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts@5.3.0/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nlibrary FeeTokenHandler {\\n  using SafeERC20 for IERC20;\\n\\n  error ZeroAddressNotAllowed();\\n\\n  event FeeTokenWithdrawn(address indexed receiver, address indexed feeToken, uint256 amount);\\n\\n  /// @notice Withdraws the outstanding fee token balances to the fee aggregator.\\n  /// @param feeTokens The fee tokens to withdraw.\\n  /// @param feeAggregator The address to withdraw the fee tokens to, cannot be the zero address.\\n  function _withdrawFeeTokens(\\n    address[] calldata feeTokens,\\n    address feeAggregator\\n  ) internal {\\n    if (feeAggregator == address(0)) revert ZeroAddressNotAllowed();\\n\\n    for (uint256 i = 0; i \\u003c feeTokens.length; ++i) {\\n      IERC20 feeToken = IERC20(feeTokens[i]);\\n      uint256 feeTokenBalance = feeToken.balanceOf(address(this));\\n\\n      if (feeTokenBalance \\u003e 0) {\\n        feeToken.safeTransfer(feeAggregator, feeTokenBalance);\\n\\n        emit FeeTokenWithdrawn(feeAggregator, address(feeToken), feeTokenBalance);\\n      }\\n    }\\n  }\\n}\\n\"},\"contracts/libraries/Internal.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for CCIP internal definitions common to multiple contracts.\\n/// @dev The following is a non-exhaustive list of \\\"known issues\\\" for CCIP:\\n/// - We could implement yield claiming for Blast. This is not worth the custom code path on non-blast chains.\\n/// - uint32 is used for timestamps, which will overflow in 2106. This is not a concern for the current use case, as we\\n/// expect to have migrated to a new version by then.\\nlibrary Internal {\\n  // bytes4(keccak256(\\\"CCIP ChainFamilySelector EVM\\\"));\\n  bytes4 public constant CHAIN_FAMILY_SELECTOR_EVM = 0x2812d52c;\\n\\n  // bytes4(keccak256(\\\"CCIP ChainFamilySelector SVM\\\"));\\n  bytes4 public constant CHAIN_FAMILY_SELECTOR_SVM = 0x1e10bdc4;\\n\\n  // bytes4(keccak256(\\\"CCIP ChainFamilySelector APTOS\\\"));\\n  bytes4 public constant CHAIN_FAMILY_SELECTOR_APTOS = 0xac77ffec;\\n\\n  // bytes4(keccak256(\\\"CCIP ChainFamilySelector SUI\\\"));\\n  bytes4 public constant CHAIN_FAMILY_SELECTOR_SUI = 0xc4e05953;\\n\\n  // byte4(keccak256(\\\"CCIP ChainFamilySelector TVM\\\"));\\n  bytes4 public constant CHAIN_FAMILY_SELECTOR_TVM = 0x647e2ba9;\\n\\n  error InvalidEVMAddress(bytes encodedAddress);\\n  error Invalid32ByteAddress(bytes encodedAddress);\\n  error InvalidTVMAddress(bytes encodedAddress);\\n\\n  /// @dev We limit return data to a selector plus 4 words. This is to avoid malicious contracts from returning\\n  /// large amounts of data and causing repeated out-of-gas scenarios.\\n  uint16 internal constant MAX_RET_BYTES = 4 + 4 * 32;\\n\\n  /// @dev The address used to send calls for gas estimation.\\n  /// You only need to use this address if the minimum gas limit specified by the user is not actually enough to execute the\\n  /// given message and you're attempting to estimate the actual necessary gas limit\\n  address public constant GAS_ESTIMATION_SENDER = address(0xC11C11C11C11C11C11C11C11C11C11C11C11C1);\\n\\n  /// @notice A collection of token price and gas price updates.\\n  struct PriceUpdates {\\n    TokenPriceUpdate[] tokenPriceUpdates;\\n    GasPriceUpdate[] gasPriceUpdates;\\n  }\\n\\n  /// @notice Token price in USD.\\n  struct TokenPriceUpdate {\\n    address sourceToken; // Source token.\\n    uint224 usdPerToken; // 1e18 USD per 1e18 of the smallest token denomination.\\n  }\\n\\n  /// @notice Gas price for a given chain in USD, its value may contain tightly packed fields.\\n  struct GasPriceUpdate {\\n    uint64 destChainSelector; // Destination chain selector.\\n    uint224 usdPerUnitGas; // 1e18 USD per smallest unit (e.g. wei) of destination chain gas.\\n  }\\n\\n  /// @notice A timestamped uint224 value that can contain several tightly packed fields.\\n  struct TimestampedPackedUint224 {\\n    uint224 value; // ────╮ Value in uint224, packed.\\n    uint32 timestamp; // ─╯ Timestamp of the most recent price update.\\n  }\\n\\n  /// @dev Gas price is stored in 112-bit unsigned int. uint224 can pack 2 prices.\\n  /// When packing L1 and L2 gas prices, L1 gas price is left-shifted to the higher-order bits.\\n  /// Using uint8 type, which cannot be higher than other bit shift operands, to avoid shift operand type warning.\\n  uint8 public constant GAS_PRICE_BITS = 112;\\n\\n  struct SourceTokenData {\\n    // The source pool address, abi encoded. This value is trusted as it was obtained through the onRamp. It can be\\n    // relied upon by the destination pool to validate the source pool.\\n    bytes sourcePoolAddress;\\n    // The address of the destination token, abi encoded in the case of EVM chains.\\n    // This value is UNTRUSTED as any pool owner can return whatever value they want.\\n    bytes destTokenAddress;\\n    // Optional pool data to be transferred to the destination chain. Be default this is capped at\\n    // CCIP_LOCK_OR_BURN_V1_RET_BYTES bytes. If more data is required, the TokenTransferFeeConfig.destBytesOverhead\\n    // has to be set for the specific token.\\n    bytes extraData;\\n    uint32 destGasAmount; // The amount of gas available for the releaseOrMint and balanceOf calls on the offRamp\\n  }\\n\\n  /// @dev We disallow the first 1024 addresses to avoid calling into a range known for hosting precompiles. Calling\\n  /// into precompiles probably won't cause any issues, but to be safe we can disallow this range. It is extremely\\n  /// unlikely that anyone would ever be able to generate an address in this range. There is no official range of\\n  /// precompiles, but EIP-7587 proposes to reserve the range 0x100 to 0x1ff. Our range is more conservative, even\\n  /// though it might not be exhaustive for all chains, which is OK. We also disallow the zero address, which is a\\n  /// common practice.\\n  uint256 public constant EVM_PRECOMPILE_SPACE = 1024;\\n\\n  // According to the Aptos docs, the first 0xa addresses are reserved for precompiles.\\n  // https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-framework/doc/account.md#function-create_framework_reserved_account-1\\n  uint256 public constant APTOS_PRECOMPILE_SPACE = 0x0b;\\n\\n  // According to the Sui docs, a set of non-contiguous addresses below 0xdee9 are reserved for system use.\\n  // https://github.com/MystenLabs/sui/blob/54ae98508569804127bd73d84aa2fb816bdea402/crates/sui-types/src/lib.rs#L141\\n  uint256 public constant SUI_PRECOMPILE_SPACE = 0xdee9;\\n\\n  /// @notice This methods provides validation for parsing abi encoded addresses by ensuring the address is within the\\n  /// EVM address space. If it isn't it will revert with an InvalidEVMAddress error, which we can catch and handle\\n  /// more gracefully than a revert from abi.decode.\\n  function _validateEVMAddress(\\n    bytes memory encodedAddress\\n  ) internal pure {\\n    if (encodedAddress.length != 32) revert InvalidEVMAddress(encodedAddress);\\n    uint256 encodedAddressUint = abi.decode(encodedAddress, (uint256));\\n    if (encodedAddressUint \\u003e type(uint160).max || encodedAddressUint \\u003c EVM_PRECOMPILE_SPACE) {\\n      revert InvalidEVMAddress(encodedAddress);\\n    }\\n  }\\n\\n  /// @notice This method left-pads a byte array to 32 bytes. If the input data is longer than 32 bytes, it will\\n  /// revert with an Invalid32ByteAddress error.\\n  /// @param data The byte array to left-pad.\\n  /// @return The left-padded byte array.\\n  function _leftPadBytesToBytes32(\\n    bytes memory data\\n  ) internal pure returns (bytes32) {\\n    if (data.length \\u003e 32) {\\n      revert Invalid32ByteAddress(data);\\n    }\\n    return bytes32(uint256(bytes32(data)) \\u003e\\u003e (256 - data.length * 8));\\n  }\\n\\n  /// @notice This methods provides validation for parsing abi encoded addresses by ensuring the address is within the\\n  /// bounds of [minValue, uint256.max]. If it isn't it will revert with an Invalid32ByteAddress error.\\n  function _validate32ByteAddress(\\n    bytes memory encodedAddress,\\n    uint256 minValue\\n  ) internal pure {\\n    if (encodedAddress.length != 32) revert Invalid32ByteAddress(encodedAddress);\\n    if (minValue \\u003e 0) {\\n      if (abi.decode(encodedAddress, (uint256)) \\u003c minValue) {\\n        revert Invalid32ByteAddress(encodedAddress);\\n      }\\n    }\\n  }\\n\\n  /// @notice This methods provides validation for TON User-friendly addresses by ensuring the address is 36 bytes long.\\n  /// @dev The encodedAddress is expected to be the 36-byte raw representation:\\n  /// - 1 byte: flags (isBounceable, isTestnetOnly, etc.)\\n  /// - 1 byte: workchain_id (0x00 for BaseChain, 0xff for MasterChain)\\n  /// - 32 bytes: account_id (must be non-zero)\\n  /// - 2 bytes: CRC16 checksum(computationally heavy, validation omitted for simplicity)\\n  /// @param encodedAddress The 36-byte TON address.\\n  function _validateTVMAddress(\\n    bytes memory encodedAddress\\n  ) internal pure {\\n    if (encodedAddress.length != 36) revert InvalidTVMAddress(encodedAddress);\\n    bytes32 accountId;\\n    assembly {\\n      accountId := mload(add(encodedAddress, 0x22)) // 0x22 = 0x20 (data start) + 2 (offset for account_id)\\n    }\\n    if (accountId == bytes32(0)) revert InvalidTVMAddress(encodedAddress);\\n  }\\n\\n  /// @notice Enum listing the possible message execution states within the offRamp contract.\\n  /// UNTOUCHED never executed.\\n  /// IN_PROGRESS currently being executed, used a replay protection.\\n  /// SUCCESS successfully executed. End state.\\n  /// FAILURE unsuccessfully executed, manual execution is now enabled.\\n  enum MessageExecutionState {\\n    UNTOUCHED,\\n    IN_PROGRESS,\\n    SUCCESS,\\n    FAILURE\\n  }\\n\\n  struct EVM2AnyTokenTransfer {\\n    // The source pool EVM address. This value is trusted as it was obtained through the onRamp. It can be relied\\n    // upon by the destination pool to validate the source pool.\\n    address sourcePoolAddress;\\n    // The EVM address of the destination token.\\n    // This value is UNTRUSTED as any pool owner can return whatever value they want.\\n    bytes destTokenAddress;\\n    // Optional pool data to be transferred to the destination chain. Be default this is capped at\\n    // CCIP_LOCK_OR_BURN_V1_RET_BYTES bytes. If more data is required, the TokenTransferFeeConfig.destBytesOverhead\\n    // has to be set for the specific token.\\n    bytes extraData;\\n    uint256 amount; // Amount of tokens.\\n    // Destination chain data used to execute the token transfer on the destination chain. For an EVM destination, it\\n    // consists of the amount of gas available for the releaseOrMint and transfer calls made by the offRamp.\\n    bytes destExecData;\\n  }\\n\\n  /// @dev Holds a merkle root and interval for a source chain so that an array of these can be passed in the CommitReport.\\n  /// @dev Inefficient struct packing intentionally chosen to maintain order of specificity. Not a storage struct so impact is minimal.\\n  // solhint-disable-next-line gas-struct-packing\\n  struct MerkleRoot {\\n    uint64 sourceChainSelector; // Remote source chain selector that the Merkle Root is scoped to\\n    bytes onRampAddress; //        Generic onRamp address, to support arbitrary sources; for EVM, use abi.encode\\n    uint64 minSeqNr; // ─────────╮ Minimum sequence number, inclusive\\n    uint64 maxSeqNr; // ─────────╯ Maximum sequence number, inclusive\\n    bytes32 merkleRoot; //         Merkle root covering the interval \\u0026 source chain messages\\n  }\\n}\\n\"},\"contracts/libraries/MessageV1Codec.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for CCIP MessageV1 encoding/decoding operations. This format is fully chain agnostic and will be\\n/// used for all supported chains. All chains will be able to `keccak(encodedMessageV1)` to get a message ID.\\n/// @dev This library handles the complete V1 message format protocol including:\\n/// - MessageV1 and TokenTransferV1 struct definitions.\\n/// - Encoding/decoding functions with comprehensive error handling.\\n/// - Detailed error location tracking for debugging.\\nlibrary MessageV1Codec {\\n  error InvalidDataLength(EncodingErrorLocation location);\\n  error InvalidEncodingVersion(uint8 version);\\n\\n  uint256 public constant MAX_NUMBER_OF_TOKENS = 1;\\n  // Base size of a MessageV1 without variable length fields.\\n  // 1 (version) + 8 (sourceChain) + 8 (destChain) + 8 (msgNum) + 4 (executionGasLimit) +\\n  // 4 (ccipReceiveGasLimit) + 2 (finality) + 32 (ccvAndExecutorHash) + 1 (onRampLen) + 1 (offRampLen) +\\n  // 1 (senderLen) + 1 (receiverLen) + 2 (destBlobLen) + 2 (tokenTransferLen) + 2 (dataLen) = 77.\\n  uint256 public constant MESSAGE_V1_BASE_SIZE = 1 + 8 + 8 + 8 + 4 + 4 + 2 + 32 + 1 + 1 + 1 + 1 + 2 + 2 + 2;\\n  // The base size plus 32 bytes for abi.encoded(sender) and 32 bytes for abi.encoded(onRamp) addresses.\\n  // To be added:\\n  // - receiver, offRamp and destBlob are dest chain specific.\\n  // - data is user specified.\\n  // - token transfer is optional and has variable size fields.\\n  uint256 public constant MESSAGE_V1_EVM_SOURCE_BASE_SIZE = MESSAGE_V1_BASE_SIZE + 32 + 32;\\n  uint256 public constant MESSAGE_V1_REMOTE_CHAIN_ADDRESSES = 2;\\n\\n  // Base size of a TokenTransferV1 without variable length fields.\\n  // 1 (version) + 32 (amount) + 1 (sourcePoolLen) + 1 (sourceTokenLen) + 1 (destTokenLen) +\\n  // 1 (tokenReceiverLen) + 2 (extraDataLen).\\n  uint256 public constant TOKEN_TRANSFER_V1_BASE_SIZE = 1 + 32 + 1 + 1 + 1 + 1 + 2;\\n  // The base size plus 32 bytes for abi.encoded(sourcePool), 32 bytes for abi.encoded(sourceToken).\\n  // To be added:\\n  // - destToken is dest chain specific.\\n  // - extraData is a variable length field that is billed separately.\\n  uint256 public constant TOKEN_TRANSFER_V1_EVM_SOURCE_BASE_SIZE = TOKEN_TRANSFER_V1_BASE_SIZE + 32 + 32;\\n\\n  enum EncodingErrorLocation {\\n    // Message-level components.\\n    MESSAGE_MIN_SIZE,\\n    MESSAGE_ONRAMP_ADDRESS_LENGTH,\\n    MESSAGE_ONRAMP_ADDRESS_CONTENT,\\n    MESSAGE_OFFRAMP_ADDRESS_LENGTH,\\n    MESSAGE_OFFRAMP_ADDRESS_CONTENT,\\n    MESSAGE_FINALITY,\\n    MESSAGE_EXECUTION_GAS_LIMIT,\\n    MESSAGE_CALLBACK_GAS_LIMIT,\\n    MESSAGE_SENDER_LENGTH,\\n    MESSAGE_SENDER_CONTENT,\\n    MESSAGE_RECEIVER_LENGTH,\\n    MESSAGE_RECEIVER_CONTENT,\\n    MESSAGE_DEST_BLOB_LENGTH,\\n    MESSAGE_DEST_BLOB_CONTENT,\\n    MESSAGE_TOKEN_TRANSFER_LENGTH,\\n    MESSAGE_TOKEN_TRANSFER_CONTENT,\\n    MESSAGE_DATA_LENGTH,\\n    MESSAGE_DATA_CONTENT,\\n    MESSAGE_FINAL_OFFSET,\\n    // Token transfer components.\\n    TOKEN_TRANSFER_VERSION,\\n    TOKEN_TRANSFER_AMOUNT,\\n    TOKEN_TRANSFER_SOURCE_POOL_LENGTH,\\n    TOKEN_TRANSFER_SOURCE_POOL_CONTENT,\\n    TOKEN_TRANSFER_SOURCE_TOKEN_LENGTH,\\n    TOKEN_TRANSFER_SOURCE_TOKEN_CONTENT,\\n    TOKEN_TRANSFER_DEST_TOKEN_LENGTH,\\n    TOKEN_TRANSFER_DEST_TOKEN_CONTENT,\\n    TOKEN_TRANSFER_TOKEN_RECEIVER_LENGTH,\\n    TOKEN_TRANSFER_TOKEN_RECEIVER_CONTENT,\\n    TOKEN_TRANSFER_EXTRA_DATA_LENGTH,\\n    TOKEN_TRANSFER_EXTRA_DATA_CONTENT,\\n    // Encoding validation components.\\n    ENCODE_ONRAMP_ADDRESS_LENGTH,\\n    ENCODE_OFFRAMP_ADDRESS_LENGTH,\\n    ENCODE_SENDER_LENGTH,\\n    ENCODE_RECEIVER_LENGTH,\\n    ENCODE_DEST_BLOB_LENGTH,\\n    ENCODE_TOKEN_TRANSFER_ARRAY_LENGTH,\\n    ENCODE_TOKEN_TRANSFER_LENGTH,\\n    ENCODE_DATA_LENGTH,\\n    ENCODE_TOKEN_SOURCE_POOL_LENGTH,\\n    ENCODE_TOKEN_SOURCE_TOKEN_LENGTH,\\n    ENCODE_TOKEN_DEST_TOKEN_LENGTH,\\n    ENCODE_TOKEN_TOKEN_RECEIVER_LENGTH,\\n    ENCODE_TOKEN_EXTRA_DATA_LENGTH\\n  }\\n\\n  /// @notice Chain agnostic message format used in the v1 protocol.\\n  /// Static length fields.\\n  ///   uint8 version;              Version, for future use and backwards compatibility.\\n  ///   uint64 sourceChainSelector; Source Chain Selector.\\n  ///   uint64 destChainSelector;   Destination Chain Selector.\\n  ///   uint64 messageNumber;       Auto-incrementing number for the message.\\n  ///   uint32 executionGasLimit;   Gas limit for message execution on the destination chain.\\n  ///   uint32 ccipReceiveGasLimit; Gas limit for the user callback on the destination chain.\\n  ///   uint16 finality;            Configurable per-message finality value.\\n  ///   bytes32 ccvAndExecutorHash; Hash of the verifiers and executor addresses.\\n  ///\\n  /// Variable length fields.\\n  ///\\n  ///   uint8 onRampAddressLength;  Length of the padded onRamp Address in bytes.\\n  ///   bytes onRampAddress;        Source Chain OnRamp as padded bytes.\\n  ///   uint8 offRampAddressLength; Length of the unpadded offRamp Address in bytes.\\n  ///   bytes offRampAddress;       Destination Chain OffRamp as unpadded bytes.\\n  ///   uint8 senderLength;         Length of the padded Sender Address in bytes.\\n  ///   bytes sender;               Sender address as padded bytes.\\n  ///   uint8 receiverLength;       Length of the unpadded Receiver Address in bytes.\\n  ///   bytes receiver;             Receiver address on the destination chain as unpadded bytes.\\n  ///   uint16 destBlobLength;      Length of the Destination Blob in bytes.\\n  ///   bytes destBlob;             Destination chain-specific blob that contains data required for execution e.g.\\n  ///                               Solana accounts.\\n  ///   uint16 tokenTransferLength; Length of the Token Transfer structure in bytes.\\n  ///   bytes tokenTransfer;        Byte representation of the token transfer structure.\\n  ///   uint16 dataLength;          Length of the user specified data payload.\\n  ///   bytes data;                 Arbitrary data payload supplied by the message sender that is passed to the receiver.\\n  ///\\n  /// @dev Address encoding rules:\\n  ///      - Source-side EVM addresses (onRamp, sender, sourcePoolAddress, sourceTokenAddress) are abi.encode(address)\\n  ///        i.e. 32 bytes.\\n  ///      - Destination-side addresses (offRampAddress, receiver, destTokenAddress, tokenReceiver) are length-prefixed\\n  ///        and use the minimal bytes for the destination chain (20 bytes for EVM).\\n  ///      - Other chain families follow their native byte-length expectations.\\n  /// @dev Inefficient struct packing does not matter as this is not a storage struct, and if it were ever written to\\n  ///      storage it would be in its encoded form.\\n  // solhint-disable-next-line gas-struct-packing\\n  struct MessageV1 {\\n    /// @notice Source Chain Selector.\\n    uint64 sourceChainSelector;\\n    /// @notice Destination Chain Selector.\\n    uint64 destChainSelector;\\n    /// @notice Per-lane-unique number for the message. When faster-than-finality is used the guarantee that\\n    /// this value is unique no longer holds. After a re-org, a message could end up with a different message number.\\n    /// Messages that are older than the chain finality delay should all have unique per-lane message numbers.\\n    uint64 messageNumber;\\n    // Gas limit for message execution on the destination chain.\\n    uint32 executionGasLimit;\\n    // Gas limit for the user callback on the destination chain.\\n    uint32 ccipReceiveGasLimit;\\n    // Configurable per-message finality value.\\n    uint16 finality;\\n    // A hash of the verifiers and executor addresses. This is used by the offchain systems to validate the list of CCVs\\n    // and executor that should be used for this message. This has no meaning on the destination chain ans is not\\n    // checked against anything.\\n    bytes32 ccvAndExecutorHash;\\n    // Variable length fields - must match wire format order.\\n    // Source chain onRamp, abi encoded for EVM chains.\\n    bytes onRampAddress;\\n    // Destination chain offRamp, NOT abi encoded but raw bytes matching destination chains address byte length.\\n    // This means for EVM chains it is 20 bytes.\\n    bytes offRampAddress;\\n    // Source chain sender address, abi encoded for EVM chains.\\n    bytes sender;\\n    // Destination chain receiver address, NOT abi encoded but raw bytes matching destination chains address byte length.\\n    // This means for EVM chains it is 20 bytes.\\n    bytes receiver;\\n    // Destination specific blob that contains chain-family specific data.\\n    bytes destBlob;\\n    // Contains either 0 or 1 token transfer structs. It is encoded as an array for gas efficiency.\\n    TokenTransferV1[] tokenTransfer;\\n    // Arbitrary data payload supplied by the message sender.\\n    bytes data;\\n  }\\n\\n  struct TokenTransferV1 {\\n    uint256 amount; // Number of tokens.\\n    // This can be relied upon by the destination pool to validate the source pool. abi encoded for EVM chains.\\n    bytes sourcePoolAddress;\\n    bytes sourceTokenAddress; // Address of source token, abi encoded for EVM chains.\\n    // Address of destination token, NOT abi encoded but raw bytes matching destination chains address byte length.\\n    // This means for EVM chains it is 20 bytes.\\n    bytes destTokenAddress;\\n    // Token receiver address on the destination chain, NOT abi encoded but raw bytes matching destination chains address byte length.\\n    // This means for EVM chains it is 20 bytes.\\n    bytes tokenReceiver;\\n    // Optional pool data to be transferred to the destination chain. Be default this is capped at\\n    // CCIP_LOCK_OR_BURN_V1_RET_BYTES bytes. If more data is required, the TokenTransferFeeConfig.destBytesOverhead\\n    // has to be set for the specific token.\\n    bytes extraData;\\n  }\\n\\n  /// @notice Computes the hash of CCVs and executor addresses, prefixed with a length byte. This length byte ensures\\n  /// the use of unpadded encoding is safe. Because EVM addresses are always 20 bytes, the length is hard-coded.\\n  /// @dev Without the length byte, an array of two addresses [A, B] would hash the same as [AB] (concatenated). That\\n  /// would allow for potential misreporting of CCVs/executor unless the offchain system knows the address lengths for\\n  /// all chains it supports.\\n  /// @param ccvs Array of CCV (Cross-Chain Verifier) addresses.\\n  /// @param executor Address of the executor.\\n  /// @return hash The keccak256 hash of the encoded CCVs and executor.\\n  function _computeCCVAndExecutorHash(\\n    address[] memory ccvs,\\n    address executor\\n  ) internal pure returns (bytes32) {\\n    uint256 encodedLength = 1 + ccvs.length * 20 + 20;\\n    // We overprovision the bytes array to avoid out of bounds writes. Since we write EVM addresses which are 20 bytes,\\n    // and the size of a write is 32 bytes, the maximum out of bounds we can have is 12 bytes.\\n    bytes memory encoded = new bytes(encodedLength + 12);\\n    encoded[0] = bytes1(uint8(20));\\n\\n    // Skip length (32 bytes) and address length byte (1 byte).\\n    uint256 offset = 33;\\n    for (uint256 i = 0; i \\u003c ccvs.length; ++i) {\\n      address ccvsAddress = ccvs[i];\\n\\n      // Any overshoot here is safe due to the writing of the executor address below.\\n      assembly {\\n        mstore(add(encoded, offset), shl(96, ccvsAddress))\\n        offset := add(offset, 20)\\n      }\\n    }\\n    assembly {\\n      // Overshoot here is also safe due to overallocation of the bytes array.\\n      mstore(add(encoded, offset), shl(96, executor))\\n      mstore(encoded, encodedLength)\\n    }\\n\\n    return keccak256(encoded);\\n  }\\n\\n  /// @notice Encodes a TokenTransferV1 struct into bytes.\\n  /// @param tokenTransfer The TokenTransferV1 struct to encode.\\n  /// @return encoded The encoded token transfer as bytes.\\n  function _encodeTokenTransferV1(\\n    TokenTransferV1 memory tokenTransfer\\n  ) internal pure returns (bytes memory) {\\n    // Validate field lengths fit in their respective size limits.\\n    if (tokenTransfer.sourcePoolAddress.length \\u003e type(uint8).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_TOKEN_SOURCE_POOL_LENGTH);\\n    }\\n    if (tokenTransfer.sourceTokenAddress.length \\u003e type(uint8).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_TOKEN_SOURCE_TOKEN_LENGTH);\\n    }\\n    if (tokenTransfer.destTokenAddress.length \\u003e type(uint8).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_TOKEN_DEST_TOKEN_LENGTH);\\n    }\\n    if (tokenTransfer.tokenReceiver.length \\u003e type(uint8).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_TOKEN_TOKEN_RECEIVER_LENGTH);\\n    }\\n    if (tokenTransfer.extraData.length \\u003e type(uint16).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_TOKEN_EXTRA_DATA_LENGTH);\\n    }\\n\\n    return abi.encodePacked(\\n      uint8(1), // version.\\n      tokenTransfer.amount,\\n      uint8(tokenTransfer.sourcePoolAddress.length),\\n      tokenTransfer.sourcePoolAddress,\\n      uint8(tokenTransfer.sourceTokenAddress.length),\\n      tokenTransfer.sourceTokenAddress,\\n      uint8(tokenTransfer.destTokenAddress.length),\\n      tokenTransfer.destTokenAddress,\\n      uint8(tokenTransfer.tokenReceiver.length),\\n      tokenTransfer.tokenReceiver,\\n      uint16(tokenTransfer.extraData.length),\\n      tokenTransfer.extraData\\n    );\\n  }\\n\\n  /// @notice Decodes bytes into a TokenTransferV1 struct.\\n  /// @param encoded The encoded token transfer bytes to decode.\\n  /// @param offset The starting offset in the encoded bytes.\\n  /// @return tokenTransfer The decoded TokenTransferV1 struct.\\n  /// @return newOffset The new offset after decoding.\\n  function _decodeTokenTransferV1(\\n    bytes calldata encoded,\\n    uint256 offset\\n  ) internal pure returns (TokenTransferV1 memory tokenTransfer, uint256 newOffset) {\\n    // Unchecked is safe because the offset is only incremented with validated lengths.\\n    unchecked {\\n      // version (1 byte).\\n      if (offset \\u003e= encoded.length) revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_VERSION);\\n      uint8 version = uint8(encoded[offset++]);\\n      if (version != 1) revert InvalidEncodingVersion(version);\\n\\n      // amount (32 bytes).\\n      if (offset + 32 \\u003e encoded.length) revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_AMOUNT);\\n      tokenTransfer.amount = uint256(bytes32(encoded[offset:offset + 32]));\\n      offset += 32;\\n\\n      // sourcePoolAddressLength and sourcePoolAddress.\\n      if (offset \\u003e= encoded.length) revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_SOURCE_POOL_LENGTH);\\n      uint8 sourcePoolAddressLength = uint8(encoded[offset++]);\\n      if (offset + sourcePoolAddressLength \\u003e encoded.length) {\\n        revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_SOURCE_POOL_CONTENT);\\n      }\\n\\n      tokenTransfer.sourcePoolAddress = encoded[offset:offset + sourcePoolAddressLength];\\n      offset += sourcePoolAddressLength;\\n\\n      // sourceTokenAddressLength and sourceTokenAddress.\\n      if (offset \\u003e= encoded.length) revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_SOURCE_TOKEN_LENGTH);\\n      uint8 sourceTokenAddressLength = uint8(encoded[offset++]);\\n      if (offset + sourceTokenAddressLength \\u003e encoded.length) {\\n        revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_SOURCE_TOKEN_CONTENT);\\n      }\\n\\n      tokenTransfer.sourceTokenAddress = encoded[offset:offset + sourceTokenAddressLength];\\n      offset += sourceTokenAddressLength;\\n\\n      // destTokenAddressLength and destTokenAddress.\\n      if (offset \\u003e= encoded.length) revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_DEST_TOKEN_LENGTH);\\n      uint8 destTokenAddressLength = uint8(encoded[offset++]);\\n      if (offset + destTokenAddressLength \\u003e encoded.length) {\\n        revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_DEST_TOKEN_CONTENT);\\n      }\\n\\n      tokenTransfer.destTokenAddress = encoded[offset:offset + destTokenAddressLength];\\n      offset += destTokenAddressLength;\\n\\n      // tokenReceiverLength and tokenReceiver.\\n      if (offset \\u003e= encoded.length) {\\n        revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_TOKEN_RECEIVER_LENGTH);\\n      }\\n      uint8 tokenReceiverLength = uint8(encoded[offset++]);\\n      if (offset + tokenReceiverLength \\u003e encoded.length) {\\n        revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_TOKEN_RECEIVER_CONTENT);\\n      }\\n\\n      tokenTransfer.tokenReceiver = encoded[offset:offset + tokenReceiverLength];\\n      offset += tokenReceiverLength;\\n\\n      // extraDataLength and extraData.\\n      if (offset + 2 \\u003e encoded.length) {\\n        revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_EXTRA_DATA_LENGTH);\\n      }\\n      uint16 extraDataLength = uint16(bytes2(encoded[offset:offset + 2]));\\n      offset += 2;\\n      if (offset + extraDataLength \\u003e encoded.length) {\\n        revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_EXTRA_DATA_CONTENT);\\n      }\\n\\n      tokenTransfer.extraData = encoded[offset:offset + extraDataLength];\\n      offset += extraDataLength;\\n    }\\n    return (tokenTransfer, offset);\\n  }\\n\\n  /// @notice Encodes a MessageV1 struct into bytes following the v1 protocol format.\\n  /// @param message The MessageV1 struct to encode.\\n  /// @return encoded The encoded message as bytes.\\n  function _encodeMessageV1(\\n    MessageV1 memory message\\n  ) internal pure returns (bytes memory) {\\n    // Validate field lengths fit in their respective size limits.\\n    if (message.onRampAddress.length \\u003e type(uint8).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_ONRAMP_ADDRESS_LENGTH);\\n    }\\n    if (message.offRampAddress.length \\u003e type(uint8).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_OFFRAMP_ADDRESS_LENGTH);\\n    }\\n    if (message.sender.length \\u003e type(uint8).max) revert InvalidDataLength(EncodingErrorLocation.ENCODE_SENDER_LENGTH);\\n    if (message.receiver.length \\u003e type(uint8).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_RECEIVER_LENGTH);\\n    }\\n    if (message.destBlob.length \\u003e type(uint16).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_DEST_BLOB_LENGTH);\\n    }\\n    if (message.tokenTransfer.length \\u003e MAX_NUMBER_OF_TOKENS) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_TOKEN_TRANSFER_ARRAY_LENGTH);\\n    }\\n    if (message.data.length \\u003e type(uint16).max) revert InvalidDataLength(EncodingErrorLocation.ENCODE_DATA_LENGTH);\\n\\n    // Encode token the transfer if present. We checked above that there is at most 1 token transfer.\\n    // We define it below the partial encoding to avoid stack too deep errors.\\n    bytes memory encodedTokenTransfers;\\n    if (message.tokenTransfer.length \\u003e 0) {\\n      encodedTokenTransfers = _encodeTokenTransferV1(message.tokenTransfer[0]);\\n      if (encodedTokenTransfers.length \\u003e type(uint16).max) {\\n        revert InvalidDataLength(EncodingErrorLocation.ENCODE_TOKEN_TRANSFER_LENGTH);\\n      }\\n    }\\n\\n    // Encode in sections to avoid stack too deep errors.\\n    return abi.encodePacked(\\n      abi.encodePacked(\\n        uint8(1), // version.\\n        message.sourceChainSelector,\\n        message.destChainSelector,\\n        message.messageNumber,\\n        message.executionGasLimit,\\n        message.ccipReceiveGasLimit,\\n        message.finality,\\n        message.ccvAndExecutorHash\\n      ),\\n      abi.encodePacked(\\n        uint8(message.onRampAddress.length),\\n        message.onRampAddress,\\n        uint8(message.offRampAddress.length),\\n        message.offRampAddress,\\n        uint8(message.sender.length),\\n        message.sender\\n      ),\\n      abi.encodePacked(\\n        uint8(message.receiver.length),\\n        message.receiver,\\n        uint16(message.destBlob.length),\\n        message.destBlob,\\n        uint16(encodedTokenTransfers.length),\\n        encodedTokenTransfers,\\n        uint16(message.data.length),\\n        message.data\\n      )\\n    );\\n  }\\n\\n  /// @notice Decodes bytes into a MessageV1 struct following the v1 protocol format.\\n  /// @param encoded The encoded message bytes to decode.\\n  /// @return message The decoded MessageV1 struct.\\n  function _decodeMessageV1(\\n    bytes calldata encoded\\n  ) internal pure returns (MessageV1 memory message) {\\n    // Unchecked is safe because the offset is only incremented with validated lengths.\\n    unchecked {\\n      if (encoded.length \\u003c MESSAGE_V1_BASE_SIZE) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_MIN_SIZE);\\n\\n      uint8 version = uint8(encoded[0]);\\n      if (version != 1) revert InvalidEncodingVersion(version);\\n\\n      // sourceChainSelector (8 bytes, big endian).\\n      message.sourceChainSelector = uint64(bytes8(encoded[1:9]));\\n\\n      // destChainSelector (8 bytes, big endian).\\n      message.destChainSelector = uint64(bytes8(encoded[9:17]));\\n\\n      // messageNumber (8 bytes, big endian).\\n      message.messageNumber = uint64(bytes8(encoded[17:25]));\\n\\n      // executionGasLimit (4 bytes, big endian).\\n      message.executionGasLimit = uint32(bytes4(encoded[25:29]));\\n\\n      // ccipReceiveGasLimit (4 bytes, big endian).\\n      message.ccipReceiveGasLimit = uint32(bytes4(encoded[29:33]));\\n\\n      // finality (2 bytes, big endian).\\n      message.finality = uint16(bytes2(encoded[33:35]));\\n\\n      message.ccvAndExecutorHash = bytes32(encoded[35:67]);\\n\\n      // onRampAddressLength and onRampAddress.\\n      uint256 offset = 67;\\n      if (offset \\u003e= encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_ONRAMP_ADDRESS_LENGTH);\\n      uint8 onRampAddressLength = uint8(encoded[offset++]);\\n      if (offset + onRampAddressLength \\u003e encoded.length) {\\n        revert InvalidDataLength(EncodingErrorLocation.MESSAGE_ONRAMP_ADDRESS_CONTENT);\\n      }\\n\\n      message.onRampAddress = encoded[offset:offset + onRampAddressLength];\\n      offset += onRampAddressLength;\\n\\n      // offRampAddressLength and offRampAddress.\\n      if (offset \\u003e= encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_OFFRAMP_ADDRESS_LENGTH);\\n      uint8 offRampAddressLength = uint8(encoded[offset++]);\\n      if (offset + offRampAddressLength \\u003e encoded.length) {\\n        revert InvalidDataLength(EncodingErrorLocation.MESSAGE_OFFRAMP_ADDRESS_CONTENT);\\n      }\\n\\n      message.offRampAddress = encoded[offset:offset + offRampAddressLength];\\n      offset += offRampAddressLength;\\n\\n      // senderLength and sender.\\n      if (offset \\u003e= encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_SENDER_LENGTH);\\n      uint8 senderLength = uint8(encoded[offset++]);\\n      if (offset + senderLength \\u003e encoded.length) {\\n        revert InvalidDataLength(EncodingErrorLocation.MESSAGE_SENDER_CONTENT);\\n      }\\n\\n      message.sender = encoded[offset:offset + senderLength];\\n      offset += senderLength;\\n\\n      // receiverLength and receiver.\\n      if (offset \\u003e= encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_RECEIVER_LENGTH);\\n      uint8 receiverLength = uint8(encoded[offset++]);\\n      if (offset + receiverLength \\u003e encoded.length) {\\n        revert InvalidDataLength(EncodingErrorLocation.MESSAGE_RECEIVER_CONTENT);\\n      }\\n\\n      message.receiver = encoded[offset:offset + receiverLength];\\n      offset += receiverLength;\\n\\n      // destBlobLength and destBlob.\\n      if (offset + 2 \\u003e encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_DEST_BLOB_LENGTH);\\n      uint16 destBlobLength = uint16(bytes2(encoded[offset:offset + 2]));\\n      offset += 2;\\n      if (offset + destBlobLength \\u003e encoded.length) {\\n        revert InvalidDataLength(EncodingErrorLocation.MESSAGE_DEST_BLOB_CONTENT);\\n      }\\n\\n      message.destBlob = encoded[offset:offset + destBlobLength];\\n      offset += destBlobLength;\\n\\n      // tokenTransferLength and tokenTransfer.\\n      if (offset + 2 \\u003e encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_TOKEN_TRANSFER_LENGTH);\\n      uint16 tokenTransferLength = uint16(bytes2(encoded[offset:offset + 2]));\\n      offset += 2;\\n\\n      // Decode token transfer, which is either 0 or 1.\\n      if (tokenTransferLength == 0) {\\n        message.tokenTransfer = new TokenTransferV1[](0);\\n      } else {\\n        message.tokenTransfer = new TokenTransferV1[](1);\\n        uint256 expectedEnd = offset + tokenTransferLength;\\n        (message.tokenTransfer[0], offset) = _decodeTokenTransferV1(encoded, offset);\\n        if (offset != expectedEnd) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_TOKEN_TRANSFER_CONTENT);\\n      }\\n\\n      // dataLength and data.\\n      if (offset + 2 \\u003e encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_DATA_LENGTH);\\n      uint16 dataLength = uint16(bytes2(encoded[offset:offset + 2]));\\n      offset += 2;\\n      if (offset + dataLength \\u003e encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_DATA_CONTENT);\\n\\n      message.data = encoded[offset:offset + dataLength];\\n      offset += dataLength;\\n\\n      // Ensure we've consumed all bytes.\\n      if (offset != encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_FINAL_OFFSET);\\n    }\\n    return message;\\n  }\\n}\\n\"},\"contracts/libraries/Pool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice This library contains various token pool functions to aid constructing the return data.\\nlibrary Pool {\\n  // The tag used to signal support for the pool v1 standard.\\n  // bytes4(keccak256(\\\"CCIP_POOL_V1\\\"))\\n  bytes4 public constant CCIP_POOL_V1 = 0xaff2afbf;\\n\\n  // The number of bytes in the return data for a pool v1 releaseOrMint call.\\n  // This should match the size of the ReleaseOrMintOutV1 struct.\\n  uint16 public constant CCIP_POOL_V1_RET_BYTES = 32;\\n\\n  // The default max number of bytes in the return data for a pool v1 lockOrBurn call.\\n  // This data can be used to send information to the destination chain token pool. Can be overwritten\\n  // in the TokenTransferFeeConfig.destBytesOverhead if more data is required.\\n  uint32 public constant CCIP_LOCK_OR_BURN_V1_RET_BYTES = 32;\\n\\n  struct LockOrBurnInV1 {\\n    bytes receiver; //  The recipient of the tokens on the destination chain. For EVM source chains, this is abi-encoded (32 bytes).\\n    uint64 remoteChainSelector; // ─╮ The chain ID of the destination chain.\\n    address originalSender; // ─────╯ The original sender of the tx on the source chain.\\n    uint256 amount; //  The amount of tokens to lock or burn, denominated in the source token's decimals.\\n    address localToken; // The address on this chain of the token to lock or burn.\\n  }\\n\\n  struct LockOrBurnOutV1 {\\n    // The address of the destination token, abi encoded in the case of EVM chains.\\n    // This value is UNTRUSTED as any pool owner can return whatever value they want.\\n    bytes destTokenAddress;\\n    // Optional pool data to be transferred to the destination chain. Be default this is capped at\\n    // CCIP_LOCK_OR_BURN_V1_RET_BYTES bytes. If more data is required, the TokenTransferFeeConfig.destBytesOverhead\\n    // has to be set for the specific token.\\n    bytes destPoolData;\\n  }\\n\\n  struct ReleaseOrMintInV1 {\\n    bytes originalSender; //            The original sender of the tx on the source chain.\\n    uint64 remoteChainSelector; // ───╮ The chain ID of the source chain.\\n    address receiver; // ─────────────╯ The recipient of the tokens on the destination chain.\\n    uint256 sourceDenominatedAmount; // The amount of tokens to release or mint, denominated in the source token's decimals.\\n    address localToken; //              The address on this chain of the token to release or mint.\\n    /// @dev WARNING: sourcePoolAddress should be checked prior to any processing of funds. Make sure it matches the\\n    /// expected pool address for the given remoteChainSelector.\\n    bytes sourcePoolAddress; //         The address of the source pool, abi encoded in the case of EVM chains.\\n    bytes sourcePoolData; //            The data received from the source pool to process the release or mint.\\n    /// @dev WARNING: offchainTokenData is untrusted data.\\n    bytes offchainTokenData; //         The offchain data to process the release or mint.\\n  }\\n\\n  struct ReleaseOrMintOutV1 {\\n    // The number of tokens released or minted on the destination chain, denominated in the local token's decimals.\\n    // This value is expected to be equal to the ReleaseOrMintInV1.amount in the case where the source and destination\\n    // chain have the same number of decimals.\\n    uint256 destinationAmount;\\n  }\\n}\\n\"},\"contracts/libraries/USDPriceWith18Decimals.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nlibrary USDPriceWith18Decimals {\\n  /// @notice Takes a price in USD, with 18 decimals per 1e18 token amount, and amount of the smallest token\\n  /// denomination, calculates the value in USD with 18 decimals.\\n  /// @param tokenPrice The USD price of the token.\\n  /// @param tokenAmount Amount of the smallest token denomination.\\n  /// @return USD value with 18 decimals.\\n  /// @dev this function assumes that no more than 1e59 US dollar worth of token is passed in. If more is sent, this\\n  /// function will overflow and revert. Since there isn't even close to 1e59 dollars, this is ok for all legit tokens.\\n  function _calcUSDValueFromTokenAmount(\\n    uint224 tokenPrice,\\n    uint256 tokenAmount\\n  ) internal pure returns (uint256) {\\n    /// LINK Example:\\n    /// tokenPrice:         8e18 -\\u003e $8/LINK, as 1e18 token amount is 1 LINK, worth 8 USD, or 8e18 with 18 decimals\\n    /// tokenAmount:        2e18 -\\u003e 2 LINK\\n    /// result:             8e18 * 2e18 / 1e18 -\\u003e 16e18 with 18 decimals = $16\\n\\n    /// USDC Example:\\n    /// tokenPrice:         1e30 -\\u003e $1/USDC, as 1e18 token amount is 1e12 USDC, worth 1e12 USD, or 1e30 with 18 decimals\\n    /// tokenAmount:        5e6  -\\u003e 5 USDC\\n    /// result:             1e30 * 5e6 / 1e18 -\\u003e 5e18 with 18 decimals = $5\\n    return (tokenPrice * tokenAmount) / 1e18;\\n  }\\n\\n  /// @notice Takes a price in USD, with 18 decimals per 1e18 token amount, and USD value with 18 decimals, calculates\\n  /// amount of the smallest token denomination.\\n  /// @param tokenPrice The USD price of the token.\\n  /// @param usdValue USD value with 18 decimals.\\n  /// @return Amount of the smallest token denomination.\\n  function _calcTokenAmountFromUSDValue(\\n    uint224 tokenPrice,\\n    uint256 usdValue\\n  ) internal pure returns (uint256) {\\n    /// LINK Example:\\n    /// tokenPrice:          8e18 -\\u003e $8/LINK, as 1e18 token amount is 1 LINK, worth 8 USD, or 8e18 with 18 decimals\\n    /// usdValue:           16e18 -\\u003e $16\\n    /// result:             16e18 * 1e18 / 8e18 -\\u003e 2e18 = 2 LINK\\n\\n    /// USDC Example:\\n    /// tokenPrice:         1e30 -\\u003e $1/USDC, as 1e18 token amount is 1e12 USDC, worth 1e12 USD, or 1e30 with 18 decimals\\n    /// usdValue:           5e18 -\\u003e $5\\n    /// result:             5e18 * 1e18 / 1e30 -\\u003e 5e6 = 5 USDC\\n    return (usdValue * 1e18) / tokenPrice;\\n  }\\n}\\n\"},\"contracts/onRamp/OnRamp.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\nimport {ICrossChainVerifierResolver} from \\\"../interfaces/ICrossChainVerifierResolver.sol\\\";\\nimport {ICrossChainVerifierV1} from \\\"../interfaces/ICrossChainVerifierV1.sol\\\";\\nimport {IEVM2AnyOnRampClient} from \\\"../interfaces/IEVM2AnyOnRampClient.sol\\\";\\nimport {IExecutor} from \\\"../interfaces/IExecutor.sol\\\";\\nimport {IFeeQuoter} from \\\"../interfaces/IFeeQuoter.sol\\\";\\nimport {IPoolV1} from \\\"../interfaces/IPool.sol\\\";\\nimport {IPoolV2} from \\\"../interfaces/IPoolV2.sol\\\";\\nimport {IRMNRemote} from \\\"../interfaces/IRMNRemote.sol\\\";\\nimport {IRouter} from \\\"../interfaces/IRouter.sol\\\";\\nimport {ITokenAdminRegistry} from \\\"../interfaces/ITokenAdminRegistry.sol\\\";\\nimport {ITypeAndVersion} from \\\"@chainlink/contracts/src/v0.8/shared/interfaces/ITypeAndVersion.sol\\\";\\n\\nimport {CCVConfigValidation} from \\\"../libraries/CCVConfigValidation.sol\\\";\\nimport {Client} from \\\"../libraries/Client.sol\\\";\\nimport {ExtraArgsCodec} from \\\"../libraries/ExtraArgsCodec.sol\\\";\\nimport {FeeTokenHandler} from \\\"../libraries/FeeTokenHandler.sol\\\";\\nimport {MessageV1Codec} from \\\"../libraries/MessageV1Codec.sol\\\";\\nimport {Pool} from \\\"../libraries/Pool.sol\\\";\\nimport {USDPriceWith18Decimals} from \\\"../libraries/USDPriceWith18Decimals.sol\\\";\\nimport {Ownable2StepMsgSender} from \\\"@chainlink/contracts/src/v0.8/shared/access/Ownable2StepMsgSender.sol\\\";\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts@5.3.0/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts@5.3.0/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {IERC165} from \\\"@openzeppelin/contracts@5.3.0/utils/introspection/IERC165.sol\\\";\\nimport {EnumerableSet} from \\\"@openzeppelin/contracts@5.3.0/utils/structs/EnumerableSet.sol\\\";\\n\\ncontract OnRamp is IEVM2AnyOnRampClient, ITypeAndVersion, Ownable2StepMsgSender {\\n  using SafeERC20 for IERC20;\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n  using EnumerableSet for EnumerableSet.UintSet;\\n  using USDPriceWith18Decimals for uint224;\\n\\n  error CannotSendZeroTokens();\\n  error DestinationChainNotSupportedByCCV(address ccvAddress, uint64 destChainSelector);\\n  error UnsupportedToken(address token);\\n  error CanOnlySendOneTokenPerMessage();\\n  error MustBeCalledByRouter();\\n  error RouterMustSetOriginalSender();\\n  error InvalidConfig();\\n  error CursedByRMN(uint64 destChainSelector);\\n  error GetSupportedTokensFunctionalityRemovedCheckAdminRegistry();\\n  error InvalidDestChainConfig(uint64 destChainSelector);\\n  error ReentrancyGuardReentrantCall();\\n  error DestinationChainNotSupported(uint64 destChainSelector);\\n  error InvalidDestChainAddress(bytes destChainAddress);\\n  error CustomBlockConfirmationNotSupportedOnPoolV1();\\n  error TokenArgsNotSupportedOnPoolV1();\\n  error InsufficientFeeTokenAmount();\\n  error TokenReceiverNotAllowed(uint64 destChainSelector);\\n  error SourceTokenDataTooLarge(address token, uint256 actualLength, uint32 maxLength);\\n  error FeeExceedsMaxAllowed(uint256 feeUSDCents, uint32 maxUSDCentsPerMessage);\\n\\n  event ConfigSet(StaticConfig staticConfig, DynamicConfig dynamicConfig);\\n  event DestChainConfigSet(uint64 indexed destChainSelector, uint64 messageNumber, DestChainConfigArgs config);\\n  event CCIPMessageSent(\\n    uint64 indexed destChainSelector,\\n    address indexed sender,\\n    bytes32 indexed messageId,\\n    address feeToken,\\n    uint256 tokenAmountBeforeTokenPoolFees,\\n    bytes encodedMessage,\\n    Receipt[] receipts,\\n    bytes[] verifierBlobs\\n  );\\n\\n  /// @dev A helper struct that holds data for the CCIPMessageSent event to avoid stack too deep errors.\\n  struct CCIPMessageSentEventData {\\n    bytes encodedMessage;\\n    Receipt[] receipts;\\n    bytes[] verifierBlobs;\\n  }\\n\\n  /// @dev Struct that contains the static configuration.\\n  // solhint-disable-next-line gas-struct-packing\\n  struct StaticConfig {\\n    uint64 chainSelector; // ─────────╮ Local chain selector.\\n    IRMNRemote rmnRemote; //          │ RMN remote address.\\n    uint32 maxUSDCentsPerMessage; // ─╯ Maximum USD cent value per message.\\n    address tokenAdminRegistry; // Token admin registry address.\\n  }\\n\\n  /// @dev Struct that contains the dynamic configuration\\n  // solhint-disable-next-line gas-struct-packing\\n  struct DynamicConfig {\\n    address feeQuoter; // ───────────╮ FeeQuoter address.\\n    bool reentrancyGuardEntered; // ─╯ Reentrancy protection.\\n    address feeAggregator; // Fee aggregator address.\\n  }\\n\\n  /// @dev Struct to hold the configs for a single destination chain.\\n  struct DestChainConfig {\\n    IRouter router; // ───────────────────╮ Local router address  that is allowed to send messages to the destination chain.\\n    // The last used message number. This is zero in the case where no messages have yet been sent.\\n    // 0 is not a valid message number for any real transaction as this value will be incremented before use.\\n    uint64 messageNumber; //              │\\n    uint8 addressBytesLength; //          │ The length of an address on this chain in bytes, e.g. 20 for EVM, 32 for SVM.\\n    bool tokenReceiverAllowed; //         │ Whether specifying `tokenReceiver` in extraArgs is allowed. Must be set to false for all EVM chains.\\n    uint16 messageNetworkFeeUSDCents; // ─╯ Network fee in USD cents for messages without token transfers.\\n    uint16 tokenNetworkFeeUSDCents; // ─╮ Network fee in USD cents for messages with token transfers.\\n    uint32 baseExecutionGasCost; //     │ Base gas cost for executing a message on the destination chain.\\n    address defaultExecutor; // ────────╯ Default executor to use for messages to this destination chain.\\n    address[] laneMandatedCCVs; // Required CCVs to use for all messages to this destination chain.\\n    address[] defaultCCVs; // Default CCVs to use for messages to this destination chain.\\n    bytes offRamp; // Destination OffRamp address, NOT abi encoded but raw bytes.\\n  }\\n\\n  /// @dev Same as DestChainConfig but with the destChainSelector so that an array of these can be passed in the\\n  /// constructor and the applyDestChainConfigUpdates function.\\n  // solhint-disable gas-struct-packing\\n  struct DestChainConfigArgs {\\n    uint64 destChainSelector; // Destination chain selector.\\n    IRouter router; //  Source router address  that is allowed to send messages to the destination chain.\\n    uint8 addressBytesLength; // The length of an address on this chain in bytes, e.g. 20 for EVM, 32 for SVM.\\n    bool tokenReceiverAllowed; // Whether specifying `tokenReceiver` in extraArgs is allowed at all.\\n    uint16 messageNetworkFeeUSDCents; // Network fee in USD cents for messages without token transfers.\\n    uint16 tokenNetworkFeeUSDCents; // Network fee in USD cents for messages with token transfers.\\n    uint32 baseExecutionGasCost; // Base gas cost for executing a message on the destination chain.\\n    address[] defaultCCVs; // Default CCVs to use for messages to this destination chain.\\n    address[] laneMandatedCCVs; // Required CCVs to use for all messages to this destination chain.\\n    address defaultExecutor; // If no executor is specified in the extraArgs, this executor will be used.\\n    bytes offRamp; // Destination OffRamp address, NOT abi encoded but raw bytes.\\n  }\\n\\n  /// @notice Receipt structure used to record gas limits and fees for message processing.\\n  /// @dev The ordering of receipts in a message is as follows:\\n  /// - Verifier receipts in the order of the CCV list.\\n  /// - Token transfer receipt (if any tokens are being transferred).\\n  /// - Executor receipt.\\n  /// - Network fee receipt.\\n  struct Receipt {\\n    // The address of the entity that issued the receipt. For token receipts this is the token address, not the pool.\\n    // for verifiers and executors, this is the user specified value, even if the call is ultimately handled by some\\n    // underlying contract.\\n    address issuer; // ───────────╮\\n    uint32 destGasLimit; //       │ The gas limit for the actions taken on the destination chain for this entity.\\n    uint32 destBytesOverhead; // ─╯ The byte overhead for the actions taken on the destination chain for this entity.\\n    // The fee amount for this entity, in smallest denomination of the fee token.\\n    // NOTE: While building receipts in `_getReceipts`, this field is temporarily populated with a USD-cent value\\n    // (and converted to fee token amount later in the same function).\\n    uint256 feeTokenAmount;\\n    bytes extraArgs; // Extra args that have been passed in on the source chain. May be empty.\\n  }\\n\\n  // STATIC CONFIG\\n  string public constant override typeAndVersion = \\\"OnRamp 2.0.0-dev\\\";\\n  /// @dev The chain ID of the source chain that this contract is deployed to.\\n  uint64 private immutable i_localChainSelector;\\n  /// @dev The rmn contract.\\n  IRMNRemote private immutable i_rmnRemote;\\n  /// @dev The address of the token admin registry.\\n  address private immutable i_tokenAdminRegistry;\\n  /// @dev The maximum USD cent value per message. Used to reduce impact of potential misconfigurations.\\n  uint32 internal immutable i_maxUSDCentsPerMsg;\\n\\n  // DYNAMIC CONFIG\\n  /// @dev The dynamic config for the onRamp.\\n  DynamicConfig private s_dynamicConfig;\\n\\n  /// @notice Set of destination chain selectors.\\n  EnumerableSet.UintSet internal s_destChainSelectors;\\n\\n  /// @dev The destination chain specific configs.\\n  mapping(uint64 destChainSelector =\\u003e DestChainConfig destChainConfig) internal s_destChainConfigs;\\n\\n  constructor(\\n    StaticConfig memory staticConfig,\\n    DynamicConfig memory dynamicConfig\\n  ) {\\n    if (\\n      staticConfig.chainSelector == 0 || address(staticConfig.rmnRemote) == address(0)\\n        || staticConfig.tokenAdminRegistry == address(0) || staticConfig.maxUSDCentsPerMessage == 0\\n    ) {\\n      revert InvalidConfig();\\n    }\\n\\n    i_localChainSelector = staticConfig.chainSelector;\\n    i_rmnRemote = staticConfig.rmnRemote;\\n    i_tokenAdminRegistry = staticConfig.tokenAdminRegistry;\\n    i_maxUSDCentsPerMsg = staticConfig.maxUSDCentsPerMessage;\\n\\n    _setDynamicConfig(dynamicConfig);\\n  }\\n\\n  // ================================================================\\n  // │                          Messaging                           │\\n  // ================================================================\\n\\n  /// @notice Gets the next message number to be used in the onRamp.\\n  /// @param destChainSelector The destination chain selector.\\n  /// @return nextMessageNumber The next message number to be used.\\n  function getExpectedNextMessageNumber(\\n    uint64 destChainSelector\\n  ) external view returns (uint64) {\\n    return s_destChainConfigs[destChainSelector].messageNumber + 1;\\n  }\\n\\n  /// @inheritdoc IEVM2AnyOnRampClient\\n  /// @param destChainSelector The destination chain selector.\\n  /// @param message The message being sent.\\n  /// @param feeTokenAmount The amount of fee token provided by the router for this message.\\n  /// @param originalSender The original sender of the message on the source chain.\\n  function forwardFromRouter(\\n    uint64 destChainSelector,\\n    Client.EVM2AnyMessage calldata message,\\n    uint256 feeTokenAmount,\\n    address originalSender\\n  ) external returns (bytes32 messageId) {\\n    if (i_rmnRemote.isCursed(bytes16(uint128(destChainSelector)))) {\\n      revert CursedByRMN(destChainSelector);\\n    }\\n    // We rely on a reentrancy guard here due to the untrusted calls performed to the pools. This enables some\\n    // optimizations by not following the CEI pattern.\\n    if (s_dynamicConfig.reentrancyGuardEntered) revert ReentrancyGuardReentrantCall();\\n    s_dynamicConfig.reentrancyGuardEntered = true;\\n\\n    DestChainConfig storage destChainConfig = s_destChainConfigs[destChainSelector];\\n\\n    // NOTE: The router is expected to call `getFee` prior to `forwardFromRouter`.\\n    // This function still performs its own checks (e.g. router/originalSender, dest address validation, CCV list\\n    // finalization) but relies on the router's pre-checks to avoid duplicating validation work.\\n    // Validate originalSender is set and allowed. Not validated in `getFee` since it is not user-driven.\\n    if (originalSender == address(0)) revert RouterMustSetOriginalSender();\\n    // Router address may be zero intentionally to pause, which should stop all messages.\\n    if (msg.sender != address(destChainConfig.router)) revert MustBeCalledByRouter();\\n\\n    // 1. parse extraArgs.\\n\\n    ExtraArgsCodec.GenericExtraArgsV3 memory resolvedExtraArgs = _parseExtraArgsWithDefaults(\\n      destChainSelector,\\n      destChainConfig,\\n      message.extraArgs,\\n      (message.data.length == 0 \\u0026\\u0026 message.tokenAmounts.length \\u003e 0)\\n    );\\n\\n    MessageV1Codec.MessageV1 memory newMessage = MessageV1Codec.MessageV1({\\n      sourceChainSelector: i_localChainSelector,\\n      destChainSelector: destChainSelector,\\n      messageNumber: ++destChainConfig.messageNumber,\\n      executionGasLimit: 0, // Populated after getting receipts.\\n      ccipReceiveGasLimit: resolvedExtraArgs.gasLimit,\\n      finality: resolvedExtraArgs.blockConfirmations,\\n      ccvAndExecutorHash: bytes32(0), // Will be set after CCV list is finalized.\\n      onRampAddress: abi.encode(address(this)), // Source address, so abi encoded.\\n      offRampAddress: destChainConfig.offRamp, // Dest address, so unpadded bytes.\\n      sender: abi.encode(originalSender), // Source address, so abi encoded.\\n      receiver: _validateDestChainAddress(message.receiver, destChainConfig.addressBytesLength), // Dest address, so unpadded bytes.\\n      // Executor args hold security critical execution args, like Solana accounts or Sui object IDs. Because of this,\\n      // they have to be part of the message that is signed off on by the verifiers.\\n      destBlob: resolvedExtraArgs.executorArgs,\\n      tokenTransfer: new MessageV1Codec.TokenTransferV1[](message.tokenAmounts.length), //  values are populated with _lockOrBurnSingleToken.\\n      data: message.data\\n    });\\n\\n    // 2. get pool params, this potentially mutates the CCV list.\\n\\n    {\\n      address[] memory poolRequiredCCVs = new address[](0);\\n      if (message.tokenAmounts.length != 0) {\\n        if (message.tokenAmounts.length != 1) revert CanOnlySendOneTokenPerMessage();\\n        poolRequiredCCVs = _getCCVsForPool(\\n          destChainSelector,\\n          message.tokenAmounts[0].token,\\n          message.tokenAmounts[0].amount,\\n          resolvedExtraArgs.blockConfirmations,\\n          resolvedExtraArgs.tokenArgs\\n        );\\n      }\\n      (resolvedExtraArgs.ccvs, resolvedExtraArgs.ccvArgs) = _mergeCCVLists(\\n        resolvedExtraArgs.ccvs, resolvedExtraArgs.ccvArgs, destChainConfig.laneMandatedCCVs, poolRequiredCCVs\\n      );\\n    }\\n\\n    // Set the ccvAndExecutorHash now that the CCV list is finalized.\\n    newMessage.ccvAndExecutorHash =\\n      MessageV1Codec._computeCCVAndExecutorHash(resolvedExtraArgs.ccvs, resolvedExtraArgs.executor);\\n\\n    // 3. getFee on all verifiers, pool and executor.\\n\\n    CCIPMessageSentEventData memory eventData;\\n    {\\n      uint256 computedFeeTokenAmount;\\n      uint16 networkFeeUSDCents = message.tokenAmounts.length == 0\\n        ? destChainConfig.messageNetworkFeeUSDCents\\n        : destChainConfig.tokenNetworkFeeUSDCents;\\n      // Populate receipts for verifiers, pool (if applicable), executor and network fee in that order.\\n      (eventData.receipts, newMessage.executionGasLimit, computedFeeTokenAmount) =\\n        _getReceipts(destChainSelector, networkFeeUSDCents, message, resolvedExtraArgs);\\n\\n      // Any third party (ccv, pool, or executor) could theoretically return different values for getFee on every call.\\n      // Without this guard, the onRamp would pay until it ran out of funds, potentially using accrued protocol fees to\\n      // pay for further calls.\\n      if (computedFeeTokenAmount \\u003e feeTokenAmount) {\\n        revert InsufficientFeeTokenAmount();\\n      }\\n      _distributeFees(message, eventData.receipts);\\n    }\\n\\n    // 4. lockOrBurn.\\n\\n    if (message.tokenAmounts.length != 0) {\\n      newMessage.tokenTransfer[0] = _lockOrBurnSingleToken(\\n        message.tokenAmounts[0],\\n        destChainSelector,\\n        // At this point `resolvedExtraArgs.tokenReceiver` and `message.receiver` are the raw inputs provided by caller.\\n        // The receiver is passed as-is to the TokenPool (which expects abi-encoded format for EVM source chains),\\n        // then validated and trimmed to minimal bytes for destination chain encoding in the message.\\n        resolvedExtraArgs.tokenReceiver.length \\u003e 0 ? resolvedExtraArgs.tokenReceiver : message.receiver,\\n        originalSender,\\n        resolvedExtraArgs.blockConfirmations,\\n        resolvedExtraArgs.tokenArgs\\n      );\\n\\n      // Enforce that the token pool payload (`destPoolData` -\\u003e TokenTransferV1.extraData) is not larger than the\\n      // bytes overhead that was quoted and paid for in the token transfer receipt.\\n      uint32 maxExtraDataLength = eventData.receipts[resolvedExtraArgs.ccvs.length].destBytesOverhead;\\n      uint256 actualExtraDataLength = newMessage.tokenTransfer[0].extraData.length;\\n      if (actualExtraDataLength \\u003e maxExtraDataLength) {\\n        revert SourceTokenDataTooLarge(message.tokenAmounts[0].token, actualExtraDataLength, maxExtraDataLength);\\n      }\\n    }\\n\\n    // 5. encode message and calculate messageId.\\n\\n    eventData.encodedMessage = MessageV1Codec._encodeMessageV1(newMessage);\\n    messageId = keccak256(eventData.encodedMessage);\\n\\n    eventData.verifierBlobs = new bytes[](resolvedExtraArgs.ccvs.length);\\n\\n    // 6. call each verifier.\\n\\n    for (uint256 i = 0; i \\u003c resolvedExtraArgs.ccvs.length; ++i) {\\n      address implAddress = ICrossChainVerifierResolver(resolvedExtraArgs.ccvs[i])\\n        .getOutboundImplementation(destChainSelector, resolvedExtraArgs.ccvArgs[i]);\\n      if (implAddress == address(0)) {\\n        revert DestinationChainNotSupportedByCCV(resolvedExtraArgs.ccvs[i], destChainSelector);\\n      }\\n      // NOTE: this verifier blob is *not* the same as the verifier data that will be delivered to the destination chain.\\n      // This field is meant for the offchain verifier. The verifier *may* submit this data as part of the verifier data\\n      // on the destination chain, but it may also choose to submit different data or no data at all. This means there\\n      // should be no check on the length of this and the CCV bytes overhead, as there is no relationship between the two.\\n      eventData.verifierBlobs[i] = ICrossChainVerifierV1(implAddress)\\n        .forwardToVerifier(newMessage, messageId, message.feeToken, feeTokenAmount, resolvedExtraArgs.ccvArgs[i]);\\n    }\\n\\n    // 7. emit event.\\n\\n    emit CCIPMessageSent({\\n      destChainSelector: destChainSelector,\\n      sender: originalSender,\\n      messageId: messageId,\\n      feeToken: message.feeToken,\\n      tokenAmountBeforeTokenPoolFees: message.tokenAmounts.length != 0 ? message.tokenAmounts[0].amount : 0,\\n      encodedMessage: eventData.encodedMessage,\\n      receipts: eventData.receipts,\\n      verifierBlobs: eventData.verifierBlobs\\n    });\\n\\n    s_dynamicConfig.reentrancyGuardEntered = false;\\n\\n    return messageId;\\n  }\\n\\n  /// @notice Distributes the fee token to each receipt issuer.\\n  /// @dev Token pool receipt payments are routed to the pool only if it supports IPoolV2 interface.\\n  /// @param message The message containing the fee token and token transfer info.\\n  /// @param receipts The receipts to pay out, in protocol-defined order.\\n  function _distributeFees(\\n    Client.EVM2AnyMessage calldata message,\\n    Receipt[] memory receipts\\n  ) internal {\\n    IERC20 feeToken = IERC20(message.feeToken);\\n    uint256 tokenReceiptIndex = type(uint256).max;\\n    if (message.tokenAmounts.length \\u003e 0) {\\n      // Layout with tokens: verifiers..., token, executor, network fee.\\n      tokenReceiptIndex = receipts.length - 3;\\n      address tokenPool = receipts[tokenReceiptIndex].issuer;\\n      // In case the token pool supports the IPoolV2 interface, the pool receive the fee share as fee handling logic built in.\\n      // V1 pools intentionally leave the balance sitting on the OnRamp so it can be withdrawn later.\\n      if (IERC165(tokenPool).supportsInterface(type(IPoolV2).interfaceId)) {\\n        feeToken.safeTransfer(address(tokenPool), receipts[tokenReceiptIndex].feeTokenAmount);\\n      }\\n    }\\n    // We iterate up to receipts.length - 1 to skip the network fee receipt which must remain in the onRamp.\\n    uint256 networkFeeReceiptIndex = receipts.length - 1;\\n    for (uint256 i = 0; i \\u003c networkFeeReceiptIndex; ++i) {\\n      // We skip fee distribution if:\\n      // - The fee is 0.\\n      // - The receipt is the token receipt as that's handled above.\\n      // - The network fee receipt, as explained above.\\n      if (i == tokenReceiptIndex) continue;\\n      uint256 receiptFee = receipts[i].feeTokenAmount;\\n      if (receiptFee == 0) continue;\\n      feeToken.safeTransfer(receipts[i].issuer, receiptFee);\\n    }\\n  }\\n\\n  /// @notice Merges lane mandated and pool required CCVs with user-provided CCVs.\\n  /// @dev This function assumes there are no duplicates in the userRequestedOrDefaultCCVs list.\\n  /// @dev There is no protocol-level requirement on the ordering of CCVs in the final list, but for determinism we\\n  /// process user requested first, then lane-mandated second, pool-required last.\\n  /// @param userRequestedOrDefaultCCVs User-provided required CCV addresses. Can not be empty, as defaults are applied earlier if needed.\\n  /// @param userRequestedOrDefaultCCVArgs User-provided CCV arguments, parallel to userRequestedOrDefaultCCVs.\\n  /// @param laneMandatedCCVs Lane mandated CCVs are always added, regardless of what a user/pool chooses. Can be empty.\\n  /// @param poolRequiredCCVs Pool-specific required CCVs.\\n  /// @return ccvs Updated list of CCV addresses.\\n  /// @return ccvArgs Updated list of CCV arguments, parallel to ccvs.\\n  function _mergeCCVLists(\\n    address[] memory userRequestedOrDefaultCCVs,\\n    bytes[] memory userRequestedOrDefaultCCVArgs,\\n    address[] memory laneMandatedCCVs,\\n    address[] memory poolRequiredCCVs\\n  ) internal pure returns (address[] memory ccvs, bytes[] memory ccvArgs) {\\n    // Maximum possible CCVs: user + lane + pool.\\n    uint256 totalCCVs = userRequestedOrDefaultCCVs.length + laneMandatedCCVs.length + poolRequiredCCVs.length;\\n    ccvs = new address[](totalCCVs);\\n    ccvArgs = new bytes[](totalCCVs);\\n    uint256 toBeAddedIndex = 0;\\n\\n    // First add all user requested CCVs.\\n    for (uint256 i = 0; i \\u003c userRequestedOrDefaultCCVs.length; ++i) {\\n      ccvs[toBeAddedIndex] = userRequestedOrDefaultCCVs[i];\\n      ccvArgs[toBeAddedIndex++] = userRequestedOrDefaultCCVArgs[i];\\n    }\\n    // Add lane mandated CCVs, skipping duplicates.\\n    for (uint256 i = 0; i \\u003c laneMandatedCCVs.length; ++i) {\\n      address laneMandatedCCV = laneMandatedCCVs[i];\\n      bool found = false;\\n      for (uint256 j = 0; j \\u003c toBeAddedIndex; ++j) {\\n        if (ccvs[j] == laneMandatedCCV) {\\n          found = true;\\n          break;\\n        }\\n      }\\n      if (!found) {\\n        ccvs[toBeAddedIndex++] = laneMandatedCCV;\\n      }\\n    }\\n    // Add pool required CCVs, skipping duplicates.\\n    for (uint256 i = 0; i \\u003c poolRequiredCCVs.length; ++i) {\\n      address poolRequiredCCV = poolRequiredCCVs[i];\\n      bool found = false;\\n      for (uint256 j = 0; j \\u003c toBeAddedIndex; ++j) {\\n        if (ccvs[j] == poolRequiredCCV) {\\n          found = true;\\n          break;\\n        }\\n      }\\n      if (!found) {\\n        ccvs[toBeAddedIndex++] = poolRequiredCCV;\\n      }\\n    }\\n\\n    // Resize both arrays to the actual number of CCVs added.\\n    assembly {\\n      mstore(ccvs, toBeAddedIndex)\\n      mstore(ccvArgs, toBeAddedIndex)\\n    }\\n\\n    return (ccvs, ccvArgs);\\n  }\\n\\n  /// @notice Validates a destination-chain address and strips leading ABI padding for sub-32-byte addresses.\\n  /// @dev Assumes `addressBytesLength \\u003c 32` only in the padded branch; otherwise length must match exactly.\\n  /// @param rawAddress The address bytes (may be 32-byte ABI-encoded or exact-length raw bytes).\\n  /// @param addressBytesLength The expected address length on the destination chain.\\n  /// @return validatedAddress The validated address with any leading padding removed.\\n  function _validateDestChainAddress(\\n    bytes memory rawAddress,\\n    uint256 addressBytesLength\\n  ) internal pure returns (bytes memory validatedAddress) {\\n    uint256 len = rawAddress.length;\\n    if (addressBytesLength \\u003c 32 \\u0026\\u0026 len == 32) {\\n      uint256 word;\\n      // assembly equivalent: word = uint256(bytes32(rawAddress));\\n      assembly {\\n        word := mload(add(rawAddress, 32))\\n      }\\n      // Shift out the actual address bytes; any residue means non-zero padding.\\n      if (word \\u003e\\u003e (addressBytesLength * 8) != 0) {\\n        revert InvalidDestChainAddress(rawAddress);\\n      }\\n      validatedAddress = new bytes(addressBytesLength);\\n      // assembly equivalent:\\n      //  uint256 offset = 32 - addressBytesLength;\\n      //  for (uint256 i = 0; i \\u003c addressBytesLength; ++i) {\\n      //    validatedAddress[i] = rawAddress[offset + i];\\n      //  }\\n      assembly {\\n        let shift := mul(sub(32, addressBytesLength), 8)\\n        mstore(add(validatedAddress, 32), shl(shift, word))\\n      }\\n      return validatedAddress;\\n    }\\n\\n    if (len != addressBytesLength) {\\n      revert InvalidDestChainAddress(rawAddress);\\n    }\\n    return rawAddress;\\n  }\\n\\n  /// @notice Parses and validates extra arguments, applying defaults from destination chain configuration.\\n  /// The function ensures all messages have the required CCVs and executor needed for processing,\\n  /// even when users don't explicitly specify them.\\n  /// @dev `tokenReceiver` is NOT validated here, and is validated in `_lockOrBurnSingleToken`.\\n  /// @param destChainSelector The destination chain selector.\\n  /// @param destChainConfig Configuration for the destination chain including default values.\\n  /// @param extraArgs User-provided extra arguments in either V3 or legacy format.\\n  /// @param isTokenTransferWithoutData Indicates if the message has no data but includes a token transfer. This is meant to\\n  /// signal token-only transfers to avoid adding default CCVs when not needed.\\n  /// @return resolvedArgs Complete EVMExtraArgsV3 struct with all defaults applied.\\n  function _parseExtraArgsWithDefaults(\\n    uint64 destChainSelector,\\n    DestChainConfig memory destChainConfig,\\n    bytes calldata extraArgs,\\n    bool isTokenTransferWithoutData\\n  ) internal view returns (ExtraArgsCodec.GenericExtraArgsV3 memory resolvedArgs) {\\n    // If ExtraArgsV3 are provided, decode them.\\n    if (extraArgs.length \\u003e= 4 \\u0026\\u0026 bytes4(extraArgs[:4]) == ExtraArgsCodec.GENERIC_EXTRA_ARGS_V3_TAG) {\\n      resolvedArgs = ExtraArgsCodec._decodeGenericExtraArgsV3(extraArgs);\\n\\n      // We need to ensure no duplicate CCVs are present in the ccv list.\\n      CCVConfigValidation._assertNoDuplicates(resolvedArgs.ccvs);\\n    } else {\\n      // Populate the fields that could be present in legacy extraArgs.\\n      (resolvedArgs.tokenReceiver, resolvedArgs.gasLimit, resolvedArgs.executorArgs) =\\n        IFeeQuoter(s_dynamicConfig.feeQuoter).resolveLegacyArgs(destChainSelector, extraArgs);\\n    }\\n\\n    // We remove the need for sender/receiver CCVs if the transfer is a pure token transfer.\\n    //\\n    // A pure token transfer is defined as:\\n    // - receiver callback gas limit is 0\\n    // - the message has no data\\n    // - the message sends a token\\n    //\\n    // This has always existed in CCIP: the earliest versions skipped calling the receiver when this was true, and on\\n    // the destination chain also checked (via ERC165) whether the receiver is a contract and supports the required\\n    // interfaces. Those destination-side checks are not available on the source chain, so we use the three\\n    // conditions above as the source-chain definition of a pure token transfer.\\n    //\\n    // When a transfer is pure, we do not add sender/receiver (default) CCVs. This is safe because the only entity at\\n    // risk is the token issuer, who already defines their required CCVs (or falls back to defaults), so their risk is\\n    // not increased by omitting sender/receiver CCVs in this case. This enables token-only transfers to use\\n    // token-specific CCVs (e.g. CCTP) without the user having to know about CCVs or use the new extraArgs format.\\n    //\\n    // For example, token-only USDC transfers can use only CCTP (without committee verification), since CCTP is fully\\n    // trusted for that token flow.\\n    bool isTokenOnlyTransfer = isTokenTransferWithoutData \\u0026\\u0026 resolvedArgs.gasLimit == 0;\\n\\n    (resolvedArgs.ccvs, resolvedArgs.ccvArgs) = _resolveUserOrDefaultCCVs(\\n      resolvedArgs.ccvs, resolvedArgs.ccvArgs, destChainConfig.defaultCCVs, isTokenOnlyTransfer\\n    );\\n\\n    // Normalize and validate tokenReceiver if specified.\\n    if (resolvedArgs.tokenReceiver.length != 0) {\\n      // Some lanes disallow specifying tokenReceiver entirely.\\n      if (!destChainConfig.tokenReceiverAllowed) {\\n        revert TokenReceiverNotAllowed(destChainSelector);\\n      }\\n    }\\n\\n    // When users don't specify an executor, default executor is chosen.\\n    if (resolvedArgs.executor == address(0)) {\\n      resolvedArgs.executor = destChainConfig.defaultExecutor;\\n    }\\n\\n    return resolvedArgs;\\n  }\\n\\n  // ================================================================\\n  // │                           Config                             │\\n  // ================================================================\\n\\n  /// @notice Returns the static onRamp config.\\n  /// @return staticConfig the static configuration.\\n  function getStaticConfig() public view returns (StaticConfig memory) {\\n    return StaticConfig({\\n      chainSelector: i_localChainSelector,\\n      rmnRemote: i_rmnRemote,\\n      maxUSDCentsPerMessage: i_maxUSDCentsPerMsg,\\n      tokenAdminRegistry: i_tokenAdminRegistry\\n    });\\n  }\\n\\n  /// @notice Returns the dynamic onRamp config.\\n  /// @return dynamicConfig the dynamic configuration.\\n  function getDynamicConfig() external view returns (DynamicConfig memory dynamicConfig) {\\n    return s_dynamicConfig;\\n  }\\n\\n  /// @notice Sets the dynamic configuration.\\n  /// @param dynamicConfig The configuration.\\n  /// @dev FeeTokenHandler will revert if feeAggregator is zero when withdrawing fees.\\n  /// @dev A zero address fee aggregator is valid, and intentionally reverts calls to withdraw fee tokens.\\n  function setDynamicConfig(\\n    DynamicConfig memory dynamicConfig\\n  ) external onlyOwner {\\n    _setDynamicConfig(dynamicConfig);\\n  }\\n\\n  /// @notice Internal version of setDynamicConfig to allow for reuse in the constructor.\\n  /// @param dynamicConfig The configuration.\\n  /// @dev FeeTokenHandler will revert if feeAggregator is zero when withdrawing fees.\\n  /// @dev A zero address fee aggregator is valid, and intentionally reverts calls to withdraw fee tokens.\\n  function _setDynamicConfig(\\n    DynamicConfig memory dynamicConfig\\n  ) internal {\\n    if (dynamicConfig.feeQuoter == address(0) || dynamicConfig.reentrancyGuardEntered) revert InvalidConfig();\\n\\n    s_dynamicConfig = dynamicConfig;\\n\\n    emit ConfigSet(getStaticConfig(), dynamicConfig);\\n  }\\n\\n  /// @notice Updates destination chains specific configs.\\n  /// @param destChainConfigArgs Array of destination chain specific configs.\\n  function applyDestChainConfigUpdates(\\n    DestChainConfigArgs[] calldata destChainConfigArgs\\n  ) external onlyOwner {\\n    for (uint256 i = 0; i \\u003c destChainConfigArgs.length; ++i) {\\n      DestChainConfigArgs calldata destChainConfigArg = destChainConfigArgs[i];\\n      uint64 destChainSelector = destChainConfigArg.destChainSelector;\\n\\n      if (\\n        destChainSelector == 0 || destChainSelector == i_localChainSelector\\n          || destChainConfigArg.addressBytesLength == 0 || destChainConfigArg.baseExecutionGasCost == 0\\n      ) {\\n        revert InvalidDestChainConfig(destChainSelector);\\n      }\\n\\n      // Ensure at least one default or mandated CCV exists, and check for duplicates or zero addresses in both sets.\\n      CCVConfigValidation._validateDefaultAndMandatedCCVs(\\n        destChainConfigArg.defaultCCVs, destChainConfigArg.laneMandatedCCVs\\n      );\\n\\n      DestChainConfig storage destChainConfig = s_destChainConfigs[destChainSelector];\\n      // The router can be zero to pause the destination chain.\\n      destChainConfig.router = destChainConfigArg.router;\\n      destChainConfig.addressBytesLength = destChainConfigArg.addressBytesLength;\\n      destChainConfig.messageNetworkFeeUSDCents = destChainConfigArg.messageNetworkFeeUSDCents;\\n      destChainConfig.tokenNetworkFeeUSDCents = destChainConfigArg.tokenNetworkFeeUSDCents;\\n      destChainConfig.tokenReceiverAllowed = destChainConfigArg.tokenReceiverAllowed;\\n      destChainConfig.baseExecutionGasCost = destChainConfigArg.baseExecutionGasCost;\\n      destChainConfig.defaultCCVs = destChainConfigArg.defaultCCVs;\\n      destChainConfig.laneMandatedCCVs = destChainConfigArg.laneMandatedCCVs;\\n      // Require a default executor so messages that rely on older/defaulted args still resolve to a concrete\\n      // executor. A zero executor would break backward compatibility and cause otherwise-valid traffic to revert.\\n      if (destChainConfigArg.defaultExecutor == address(0)) revert InvalidConfig();\\n      destChainConfig.defaultExecutor = destChainConfigArg.defaultExecutor;\\n\\n      // Make sure that offRamp length matches addressBytesLength.\\n      if (destChainConfigArg.offRamp.length != destChainConfigArg.addressBytesLength) {\\n        revert InvalidDestChainAddress(destChainConfigArg.offRamp);\\n      }\\n      destChainConfig.offRamp = destChainConfigArg.offRamp;\\n\\n      // We don't need to check the return value, as inserting the item twice has no effect.\\n      s_destChainSelectors.add(destChainSelector);\\n\\n      emit DestChainConfigSet(destChainSelector, destChainConfig.messageNumber, destChainConfigArg);\\n    }\\n  }\\n\\n  /// @notice get ChainConfig configured for the DestinationChainSelector.\\n  /// @param destChainSelector The destination chain selector.\\n  /// @return destChainConfig The destination chain configuration.\\n  function getDestChainConfig(\\n    uint64 destChainSelector\\n  ) external view returns (DestChainConfig memory destChainConfig) {\\n    return s_destChainConfigs[destChainSelector];\\n  }\\n\\n  /// @notice Returns all destination chain configs.\\n  /// @return destChainSelectors The supported destination chain selectors.\\n  /// @return destChainConfigs The destination chain configs corresponding to all the supported chain selectors.\\n  function getAllDestChainConfigs() external view returns (uint64[] memory, DestChainConfig[] memory) {\\n    DestChainConfig[] memory destChainConfigs = new DestChainConfig[](s_destChainSelectors.length());\\n    uint64[] memory destChainSelectors = new uint64[](s_destChainSelectors.length());\\n    for (uint256 i = 0; i \\u003c s_destChainSelectors.length(); ++i) {\\n      destChainSelectors[i] = uint64(s_destChainSelectors.at(i));\\n      destChainConfigs[i] = s_destChainConfigs[destChainSelectors[i]];\\n    }\\n    return (destChainSelectors, destChainConfigs);\\n  }\\n\\n  // ================================================================\\n  // │                      Tokens and pools                        │\\n  // ================================================================\\n\\n  /// @inheritdoc IEVM2AnyOnRampClient\\n  /// @param sourceToken The source token.\\n  function getPoolBySourceToken(\\n    uint64,\\n    /*destChainSelector*/\\n    IERC20 sourceToken\\n  ) public view returns (IPoolV1) {\\n    return IPoolV1(ITokenAdminRegistry(i_tokenAdminRegistry).getPool(address(sourceToken)));\\n  }\\n\\n  /// @inheritdoc IEVM2AnyOnRampClient\\n  function getSupportedTokens(\\n    uint64 // destChainSelector\\n  ) external pure returns (address[] memory) {\\n    revert GetSupportedTokensFunctionalityRemovedCheckAdminRegistry();\\n  }\\n\\n  /// @notice Uses a pool to lock or burn a token and returns MessageV1 token transfer data.\\n  /// @param tokenAndAmount Token address and amount to lock or burn.\\n  /// @param destChainSelector Target destination chain selector of the message.\\n  /// @param receiver Message receiver in abi-encoded format (as expected by the pool on EVM source chains).\\n  /// @param originalSender Message sender.\\n  /// @param blockConfirmationRequested Requested block confirmation.\\n  /// @param tokenArgs Additional token arguments from the message.\\n  /// @return TokenTransferV1 token transfer encoding for MessageV1.\\n  function _lockOrBurnSingleToken(\\n    Client.EVMTokenAmount memory tokenAndAmount,\\n    uint64 destChainSelector,\\n    bytes memory receiver,\\n    address originalSender,\\n    uint16 blockConfirmationRequested,\\n    bytes memory tokenArgs\\n  ) internal returns (MessageV1Codec.TokenTransferV1 memory) {\\n    if (tokenAndAmount.amount == 0) revert CannotSendZeroTokens();\\n\\n    IPoolV1 sourcePool = getPoolBySourceToken(destChainSelector, IERC20(tokenAndAmount.token));\\n    // We don't have to check if it supports the pool version in a non-reverting way here because\\n    // if we revert here, there is no effect on CCIP. Therefore we directly call the supportsInterface\\n    // function and not through the ERC165Checker.\\n    if (!sourcePool.supportsInterface(Pool.CCIP_POOL_V1)) {\\n      revert UnsupportedToken(tokenAndAmount.token);\\n    }\\n\\n    // For v1 pools, the destination amount is set equal to the source amount.\\n    // For v2 pools, the destination amount may be modified in the following logic.\\n    uint256 destTokenAmount = tokenAndAmount.amount;\\n    Pool.LockOrBurnOutV1 memory poolReturnData;\\n\\n    {\\n      Pool.LockOrBurnInV1 memory lockOrBurnInput = Pool.LockOrBurnInV1({\\n        receiver: receiver,\\n        remoteChainSelector: destChainSelector,\\n        originalSender: originalSender,\\n        amount: tokenAndAmount.amount,\\n        localToken: tokenAndAmount.token\\n      });\\n\\n      // If the pool declares support for IPoolV2, it can handle `finality` and `tokenArgs`.\\n      // Use the V2 overload which returns a potentially adjusted destination amount.\\n      if (IERC165(address(sourcePool)).supportsInterface(type(IPoolV2).interfaceId)) {\\n        (poolReturnData, destTokenAmount) =\\n          IPoolV2(address(sourcePool)).lockOrBurn(lockOrBurnInput, blockConfirmationRequested, tokenArgs);\\n      } else {\\n        // V1 pools don't understand `blockConfirmationRequested`/`tokenArgs`.\\n        // We enforce default for `blockConfirmationRequested` and no `tokenArgs` to avoid silent mis-interpretation.\\n        if (blockConfirmationRequested != 0) {\\n          revert CustomBlockConfirmationNotSupportedOnPoolV1();\\n        }\\n        if (tokenArgs.length != 0) {\\n          revert TokenArgsNotSupportedOnPoolV1();\\n        }\\n        poolReturnData = sourcePool.lockOrBurn(lockOrBurnInput);\\n      }\\n    }\\n\\n    return MessageV1Codec.TokenTransferV1({\\n      amount: destTokenAmount,\\n      sourcePoolAddress: abi.encode(sourcePool), // Source address, so abi encoded.\\n      sourceTokenAddress: abi.encode(tokenAndAmount.token), // Source address, so abi encoded.\\n      destTokenAddress: _validateDestChainAddress(\\n        poolReturnData.destTokenAddress, s_destChainConfigs[destChainSelector].addressBytesLength\\n      ), // Dest address so unpadded bytes.\\n      tokenReceiver: _validateDestChainAddress(receiver, s_destChainConfigs[destChainSelector].addressBytesLength), // Dest address so unpadded bytes.\\n      extraData: poolReturnData.destPoolData\\n    });\\n  }\\n\\n  /// @notice Resolves the \\\"user requested or default\\\" CCV list for a message.\\n  /// @dev Users can request the defaults by either:\\n  /// - providing an empty CCV list, or\\n  /// - including `address(0)` as a placeholder (which is removed from the final list).\\n  /// @dev Default CCVs are never applied for pure token transfers (see `_parseExtraArgsWithDefaults`).\\n  /// @param userCCVs User-provided CCVs (may contain `address(0)` placeholders).\\n  /// @param userCCVArgs User-provided CCV arguments, parallel to userCCVs.\\n  /// @param defaultCCVs Destination-chain default CCVs.\\n  /// @param isTokenOnlyTransfer Whether this message is a token-only transfer, meaning it has no receiver callback on\\n  /// the destination chain.\\n  /// @return ccvs Final CCV list (user first, then defaults), with placeholders removed.\\n  /// @return ccvArgs Final CCV args (parallel to ccvs). Defaults use empty args.\\n  function _resolveUserOrDefaultCCVs(\\n    address[] memory userCCVs,\\n    bytes[] memory userCCVArgs,\\n    address[] memory defaultCCVs,\\n    bool isTokenOnlyTransfer\\n  ) internal pure returns (address[] memory ccvs, bytes[] memory ccvArgs) {\\n    // Fast path: no user CCVs provided.\\n    if (userCCVs.length == 0) {\\n      if (isTokenOnlyTransfer) {\\n        return (new address[](0), new bytes[](0));\\n      } else {\\n        return (defaultCCVs, new bytes[](defaultCCVs.length));\\n      }\\n    }\\n\\n    // If the user provided CCVs, ensure no duplicates.\\n    CCVConfigValidation._assertNoDuplicates(userCCVs);\\n\\n    uint256 userCCVsLength = userCCVs.length;\\n\\n    for (uint256 i = 0; i \\u003c userCCVsLength; ++i) {\\n      // If we find a placeholder, we need to build the final list.\\n      if (userCCVs[i] == address(0)) {\\n        // Since we replace a placeholder, the final list is at most (userCCVsLength - 1 + defaultCCVs.length). The list\\n        // could end up being smaller if there are duplicates between user CCVs and default CCVs.\\n        ccvs = new address[](userCCVsLength - 1 + defaultCCVs.length);\\n        ccvArgs = new bytes[](userCCVsLength - 1 + defaultCCVs.length);\\n\\n        uint256 finalCCVCount = 0;\\n        for (uint256 j = 0; j \\u003c userCCVsLength; ++j) {\\n          // We know there's at most one placeholder as we checked for duplicates earlier.\\n          if (j == i) continue;\\n          ccvs[finalCCVCount] = userCCVs[j];\\n          ccvArgs[finalCCVCount++] = userCCVArgs[j];\\n        }\\n\\n        for (uint256 k = 0; k \\u003c defaultCCVs.length; ++k) {\\n          bool isDuplicate = false;\\n          for (uint256 m = 0; m \\u003c finalCCVCount; ++m) {\\n            if (ccvs[m] == defaultCCVs[k]) {\\n              isDuplicate = true;\\n              break;\\n            }\\n          }\\n\\n          if (isDuplicate) continue;\\n          ccvs[finalCCVCount++] = defaultCCVs[k];\\n        }\\n        // Resize both arrays to the actual number of CCVs added.\\n        assembly {\\n          mstore(ccvs, finalCCVCount)\\n          mstore(ccvArgs, finalCCVCount)\\n        }\\n\\n        return (ccvs, ccvArgs);\\n      }\\n    }\\n\\n    return (userCCVs, userCCVArgs);\\n  }\\n\\n  /// @notice Gets the required CCVs from the pool for token transfers.\\n  /// @dev Resolves address(0) returned by the pool into the destination defaults.\\n  /// If the pool does not specify any CCVs, we fall back to the default CCVs.\\n  /// @param destChainSelector The destination chain selector.\\n  /// @param token The token address being transferred.\\n  /// @param amount The amount of tokens being transferred.\\n  /// @param finality The finality configuration from the message.\\n  /// @param tokenArgs Additional token arguments from the message.\\n  /// @return requiredCCVs The list of CCV addresses the pool requires with defaults expanded if requested.\\n  function _getCCVsForPool(\\n    uint64 destChainSelector,\\n    address token,\\n    uint256 amount,\\n    uint16 finality,\\n    bytes memory tokenArgs\\n  ) internal view returns (address[] memory requiredCCVs) {\\n    address[] storage defaultCCVs = s_destChainConfigs[destChainSelector].defaultCCVs;\\n    IPoolV1 pool = getPoolBySourceToken(destChainSelector, IERC20(token));\\n    if (address(pool) == address(0)) {\\n      revert UnsupportedToken(token);\\n    }\\n\\n    // Pool not specifying CCVs or lacking V2 support falls back to destination defaults so the lane still enforces a\\n    // minimum verifier set.\\n    if (!IERC165(pool).supportsInterface(type(IPoolV2).interfaceId)) {\\n      return defaultCCVs;\\n    }\\n\\n    requiredCCVs = IPoolV2(address(pool))\\n      .getRequiredCCVs(token, destChainSelector, amount, finality, tokenArgs, IPoolV2.MessageDirection.Outbound);\\n\\n    if (requiredCCVs.length == 0) {\\n      return defaultCCVs;\\n    }\\n\\n    address[] memory resolvedCCVs = new address[](requiredCCVs.length + defaultCCVs.length);\\n    uint256 writeIndex = 0;\\n    bool includeDefaults = false;\\n\\n    for (uint256 i = 0; i \\u003c requiredCCVs.length; ++i) {\\n      address poolCCV = requiredCCVs[i];\\n      if (poolCCV == address(0)) {\\n        includeDefaults = true;\\n        continue;\\n      }\\n      resolvedCCVs[writeIndex++] = poolCCV;\\n    }\\n\\n    if (includeDefaults) {\\n      for (uint256 i = 0; i \\u003c defaultCCVs.length; ++i) {\\n        resolvedCCVs[writeIndex++] = defaultCCVs[i];\\n      }\\n    }\\n\\n    assembly {\\n      mstore(resolvedCCVs, writeIndex)\\n    }\\n\\n    return resolvedCCVs;\\n  }\\n\\n  // ================================================================\\n  // │                             Fees                             │\\n  // ================================================================\\n\\n  /// @inheritdoc IEVM2AnyOnRampClient\\n  /// @dev getFee MUST revert if the feeToken is not listed in the fee token config, as the router assumes it does.\\n  /// @param destChainSelector The destination chain selector.\\n  /// @param message The message to price.\\n  /// @return feeTokenAmount The amount of fee token needed for the fee, in smallest denomination of the fee token.\\n  function getFee(\\n    uint64 destChainSelector,\\n    Client.EVM2AnyMessage calldata message\\n  ) external view returns (uint256 feeTokenAmount) {\\n    DestChainConfig storage destChainConfig = s_destChainConfigs[destChainSelector];\\n    if (address(destChainConfig.router) == address(0)) {\\n      revert DestinationChainNotSupported(destChainSelector);\\n    }\\n    if (message.tokenAmounts.length \\u003e 1) {\\n      revert CanOnlySendOneTokenPerMessage();\\n    }\\n\\n    ExtraArgsCodec.GenericExtraArgsV3 memory resolvedExtraArgs = _parseExtraArgsWithDefaults(\\n      destChainSelector,\\n      destChainConfig,\\n      message.extraArgs,\\n      (message.data.length == 0 \\u0026\\u0026 message.tokenAmounts.length \\u003e 0)\\n    );\\n    // Update the CCVs list to include lane mandated and pool required CCVs.\\n    address[] memory poolRequiredCCVs = new address[](0);\\n    if (message.tokenAmounts.length != 0) {\\n      poolRequiredCCVs = _getCCVsForPool(\\n        destChainSelector,\\n        message.tokenAmounts[0].token,\\n        message.tokenAmounts[0].amount,\\n        resolvedExtraArgs.blockConfirmations,\\n        resolvedExtraArgs.tokenArgs\\n      );\\n    }\\n    (resolvedExtraArgs.ccvs, resolvedExtraArgs.ccvArgs) = _mergeCCVLists(\\n      resolvedExtraArgs.ccvs, resolvedExtraArgs.ccvArgs, destChainConfig.laneMandatedCCVs, poolRequiredCCVs\\n    );\\n\\n    // We sum the fees for the verifier, executor and the pool (if any).\\n    uint16 networkFeeUSDCents = message.tokenAmounts.length == 0\\n      ? destChainConfig.messageNetworkFeeUSDCents\\n      : destChainConfig.tokenNetworkFeeUSDCents;\\n    (,, feeTokenAmount) = _getReceipts(destChainSelector, networkFeeUSDCents, message, resolvedExtraArgs);\\n\\n    return feeTokenAmount;\\n  }\\n\\n  /// @notice Gets the receipts for a message. The ordering of receipts is as follows:\\n  /// - Verifier receipts in the order of the CCV list.\\n  /// - Token transfer receipt if any tokens are being transferred.\\n  /// - Executor receipt.\\n  /// - Network fee receipt.\\n  /// @param destChainSelector The destination chain selector.\\n  /// @param networkFeeUSDCents The flat network fee charged in USD cents.\\n  /// @param message The message being sent.\\n  /// @param extraArgs The extra arguments for the message.\\n  /// @return receipts The list of receipts for verifiers, token transfer and executor.\\n  /// @return gasLimitSum The total gas limit required to execute the transaction on the destination chain.\\n  /// @return feeTokenAmount The total fee amount in fee token smallest denomination.\\n  function _getReceipts(\\n    uint64 destChainSelector,\\n    uint16 networkFeeUSDCents,\\n    Client.EVM2AnyMessage calldata message,\\n    ExtraArgsCodec.GenericExtraArgsV3 memory extraArgs\\n  ) internal view returns (Receipt[] memory receipts, uint32 gasLimitSum, uint256 feeTokenAmount) {\\n    // Preallocate receipts with room for: verifiers, token transfer (0 or 1), executor, and network fee.\\n    receipts = new Receipt[](extraArgs.ccvs.length + message.tokenAmounts.length + 2);\\n    uint32 bytesOverheadSum = 0;\\n\\n    for (uint256 i = 0; i \\u003c extraArgs.ccvs.length; ++i) {\\n      address implAddress = ICrossChainVerifierResolver(extraArgs.ccvs[i])\\n        .getOutboundImplementation(destChainSelector, extraArgs.ccvArgs[i]);\\n      if (implAddress == address(0)) {\\n        revert DestinationChainNotSupportedByCCV(extraArgs.ccvs[i], destChainSelector);\\n      }\\n\\n      (uint256 feeUSDCents, uint32 gasForVerification, uint32 ccvPayloadSizeBytes) = ICrossChainVerifierV1(implAddress)\\n        .getFee(destChainSelector, message, extraArgs.ccvArgs[i], extraArgs.blockConfirmations);\\n\\n      receipts[i] = Receipt({\\n        issuer: extraArgs.ccvs[i],\\n        destGasLimit: gasForVerification,\\n        destBytesOverhead: ccvPayloadSizeBytes,\\n        feeTokenAmount: feeUSDCents,\\n        extraArgs: extraArgs.ccvArgs[i]\\n      });\\n\\n      gasLimitSum += gasForVerification;\\n      bytesOverheadSum += ccvPayloadSizeBytes;\\n    }\\n\\n    if (message.tokenAmounts.length \\u003e 0) {\\n      IPoolV1 pool = getPoolBySourceToken(destChainSelector, IERC20(message.tokenAmounts[0].token));\\n      bool hasCustomFeeConfig = false;\\n\\n      // Since the ordering is known, we can directly calculate the index for the pool receipt.\\n      uint256 poolReceiptIndex = extraArgs.ccvs.length;\\n\\n      // issuer is set to the token pool address.\\n      receipts[poolReceiptIndex] = Receipt({\\n        issuer: address(pool), destGasLimit: 0, destBytesOverhead: 0, feeTokenAmount: 0, extraArgs: extraArgs.tokenArgs\\n      });\\n\\n      // Try to call `IPoolV2.getFee` to fetch fee components if the pool supports IPoolV2. If the specified pool is not\\n      // a contract, we want it to revert. Using `ERC165Checker` here would mean it doesn't revert, and it costs more\\n      // gas.\\n      if (pool.supportsInterface(type(IPoolV2).interfaceId)) {\\n        (\\n          receipts[poolReceiptIndex].feeTokenAmount,\\n          receipts[poolReceiptIndex].destGasLimit,\\n          receipts[poolReceiptIndex].destBytesOverhead,,\\n          hasCustomFeeConfig\\n        ) =\\n          IPoolV2(address(pool))\\n            .getFee(\\n              message.tokenAmounts[0].token,\\n              destChainSelector,\\n              message.tokenAmounts[0].amount,\\n              message.feeToken,\\n              extraArgs.blockConfirmations,\\n              extraArgs.tokenArgs\\n            );\\n      }\\n\\n      // If the pool doesn't support IPoolV2 or config is disabled, fall back to FeeQuoter.\\n      if (!hasCustomFeeConfig) {\\n        (\\n          receipts[poolReceiptIndex].feeTokenAmount,\\n          receipts[poolReceiptIndex].destGasLimit,\\n          receipts[poolReceiptIndex].destBytesOverhead\\n        ) = IFeeQuoter(s_dynamicConfig.feeQuoter).getTokenTransferFee(destChainSelector, message.tokenAmounts[0].token);\\n      }\\n\\n      gasLimitSum += receipts[poolReceiptIndex].destGasLimit;\\n      bytesOverheadSum += receipts[poolReceiptIndex].destBytesOverhead;\\n    }\\n\\n    uint256 executorIndex = receipts.length - 2;\\n    // This includes the user callback gas limit.\\n    receipts[executorIndex] = _getExecutionFee(\\n      destChainSelector, message.data.length, message.tokenAmounts.length, extraArgs, message.feeToken\\n    );\\n\\n    gasLimitSum += receipts[executorIndex].destGasLimit;\\n    bytesOverheadSum += receipts[executorIndex].destBytesOverhead;\\n\\n    // Tag the calling router as the network fee issuer so CCIPMessageSent surfaces which router forwarded the\\n    // message. Third-party verifiers can pin on the router address even though the flat network fee stays on\\n    // the onRamp for later aggregation.\\n    receipts[receipts.length - 1] = Receipt({\\n      issuer: msg.sender, destGasLimit: 0, destBytesOverhead: 0, feeTokenAmount: networkFeeUSDCents, extraArgs: \\\"\\\"\\n    });\\n\\n    (uint32 updatedGasLimitSum, uint256 execCostInUSDCents, uint256 feeTokenPrice, uint256 percentMultiplier) = IFeeQuoter(\\n        s_dynamicConfig.feeQuoter\\n      ).quoteGasForExec(destChainSelector, gasLimitSum, bytesOverheadSum, message.feeToken);\\n\\n    // Transform the USD based fees into fee token amounts \\u0026 sum them. For the executor, if the executor isn't\\n    // NO_EXECUTION_ADDRESS we also add the execution cost.\\n    for (uint256 i = 0; i \\u003c receipts.length; ++i) {\\n      // Example:\\n      // - feeTokenPrice = $15 = 15e18\\n      // - usdFeeCents = $1.50 = 150\\n      // - feeTokenAmount = 150 * 1e34 / 15e18 = 1e17 (0.1 tokens of the fee token)\\n      // Normally we'd multiple by 1e36, but since usdFeeCents has 2 decimals and bpsMultiplier has 2 decimals, we use\\n      // 1e32 here.\\n      receipts[i].feeTokenAmount *= percentMultiplier * 1e32 / feeTokenPrice;\\n\\n      if (i == executorIndex) {\\n        // Update the fee of the executor to include execution costs.\\n        if (extraArgs.executor != Client.NO_EXECUTION_ADDRESS) {\\n          // Add execution cost to the executor's fee. Execution cost should not be multiplied by bpsMultiplier.\\n          receipts[i].feeTokenAmount += execCostInUSDCents * 1e34 / feeTokenPrice;\\n        }\\n      }\\n\\n      feeTokenAmount += receipts[i].feeTokenAmount;\\n    }\\n\\n    // Enforce max fee per message.\\n    if (feeTokenAmount \\u003e (uint256(i_maxUSDCentsPerMsg) * 1e34) / feeTokenPrice) {\\n      revert FeeExceedsMaxAllowed(feeTokenAmount, i_maxUSDCentsPerMsg);\\n    }\\n\\n    return (receipts, updatedGasLimitSum, feeTokenAmount);\\n  }\\n\\n  /// @notice Gets the execution fee receipt. Takes into account specifying the NO_EXECUTION_ADDRESS.\\n  /// @param destChainSelector The destination chain selector.\\n  /// @param dataLength The length of the message data.\\n  /// @param numberOfTokens The number of tokens being transferred.\\n  /// @param extraArgs The extra arguments for the message.\\n  /// @return receipt The execution fee receipt.\\n  function _getExecutionFee(\\n    uint64 destChainSelector,\\n    uint256 dataLength,\\n    uint256 numberOfTokens,\\n    ExtraArgsCodec.GenericExtraArgsV3 memory extraArgs,\\n    address feeToken\\n  ) internal view returns (Receipt memory) {\\n    DestChainConfig storage destChainConfig = s_destChainConfigs[destChainSelector];\\n    uint8 remoteChainAddressLengthBytes = destChainConfig.addressBytesLength;\\n\\n    // Even if no automated execution is requested, we still need to fill out the receipt for proper accounting.\\n    // The gas limit and byte overhead are still relevant for estimating total message cost.\\n    return Receipt({\\n      issuer: extraArgs.executor,\\n      destGasLimit: destChainConfig.baseExecutionGasCost + extraArgs.gasLimit,\\n      // Since the message payload is the same on source and destination chains with the V1 codec, we can use the\\n      // same calculation for execBytes on destination.\\n      destBytesOverhead: uint32(\\n        MessageV1Codec.MESSAGE_V1_EVM_SOURCE_BASE_SIZE + dataLength + extraArgs.executorArgs.length\\n          + (MessageV1Codec.MESSAGE_V1_REMOTE_CHAIN_ADDRESSES * remoteChainAddressLengthBytes)\\n          + (numberOfTokens\\n            * (MessageV1Codec.TOKEN_TRANSFER_V1_EVM_SOURCE_BASE_SIZE + remoteChainAddressLengthBytes * 2))\\n      ),\\n      // Only bill a flat fee when automated execution is enabled.\\n      feeTokenAmount: extraArgs.executor == Client.NO_EXECUTION_ADDRESS\\n        ? 0\\n        : IExecutor(extraArgs.executor)\\n          .getFee(destChainSelector, extraArgs.blockConfirmations, extraArgs.ccvs, extraArgs.executorArgs, feeToken),\\n      extraArgs: extraArgs.executorArgs\\n    });\\n  }\\n\\n  /// @notice Withdraws the outstanding fee token balances to the fee aggregator.\\n  /// @param feeTokens The fee tokens to withdraw.\\n  /// @dev This function can be permissionless as it only transfers tokens to the fee aggregator which is a trusted address.\\n  function withdrawFeeTokens(\\n    address[] calldata feeTokens\\n  ) external {\\n    FeeTokenHandler._withdrawFeeTokens(feeTokens, s_dynamicConfig.feeAggregator);\\n  }\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2Step.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {IOwnable} from \\\"../interfaces/IOwnable.sol\\\";\\n\\n/// @notice A minimal contract that implements 2-step ownership transfer and nothing more. It's made to be minimal\\n/// to reduce the impact of the bytecode size on any contract that inherits from it.\\ncontract Ownable2Step is IOwnable {\\n  /// @notice The pending owner is the address to which ownership may be transferred.\\n  address private s_pendingOwner;\\n  /// @notice The owner is the current owner of the contract.\\n  /// @dev The owner is the second storage variable so any implementing contract could pack other state with it\\n  /// instead of the much less used s_pendingOwner.\\n  address private s_owner;\\n\\n  error OwnerCannotBeZero();\\n  error MustBeProposedOwner();\\n  error CannotTransferToSelf();\\n  error OnlyCallableByOwner();\\n\\n  event OwnershipTransferRequested(address indexed from, address indexed to);\\n  event OwnershipTransferred(address indexed from, address indexed to);\\n\\n  constructor(address newOwner, address pendingOwner) {\\n    if (newOwner == address(0)) {\\n      revert OwnerCannotBeZero();\\n    }\\n\\n    s_owner = newOwner;\\n    if (pendingOwner != address(0)) {\\n      _transferOwnership(pendingOwner);\\n    }\\n  }\\n\\n  /// @notice Get the current owner\\n  function owner() public view override returns (address) {\\n    return s_owner;\\n  }\\n\\n  /// @notice Allows an owner to begin transferring ownership to a new address. The new owner needs to call\\n  /// `acceptOwnership` to accept the transfer before any permissions are changed.\\n  /// @param to The address to which ownership will be transferred.\\n  function transferOwnership(\\n    address to\\n  ) public override onlyOwner {\\n    _transferOwnership(to);\\n  }\\n\\n  /// @notice validate, transfer ownership, and emit relevant events\\n  /// @param to The address to which ownership will be transferred.\\n  function _transferOwnership(\\n    address to\\n  ) private {\\n    if (to == msg.sender) {\\n      revert CannotTransferToSelf();\\n    }\\n\\n    s_pendingOwner = to;\\n\\n    emit OwnershipTransferRequested(s_owner, to);\\n  }\\n\\n  /// @notice Allows an ownership transfer to be completed by the recipient.\\n  function acceptOwnership() external override {\\n    if (msg.sender != s_pendingOwner) {\\n      revert MustBeProposedOwner();\\n    }\\n\\n    address oldOwner = s_owner;\\n    s_owner = msg.sender;\\n    s_pendingOwner = address(0);\\n\\n    emit OwnershipTransferred(oldOwner, msg.sender);\\n  }\\n\\n  /// @notice validate access\\n  function _validateOwnership() internal view {\\n    if (msg.sender != s_owner) {\\n      revert OnlyCallableByOwner();\\n    }\\n  }\\n\\n  /// @notice Reverts if called by anyone other than the contract owner.\\n  modifier onlyOwner() {\\n    _validateOwnership();\\n    _;\\n  }\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2StepMsgSender.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {Ownable2Step} from \\\"./Ownable2Step.sol\\\";\\n\\n/// @notice Sets the msg.sender to be the owner of the contract and does not set a pending owner.\\ncontract Ownable2StepMsgSender is Ownable2Step {\\n  constructor() Ownable2Step(msg.sender, address(0)) {}\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/IOwnable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IOwnable {\\n  function owner() external returns (address);\\n\\n  function transferOwnership(\\n    address recipient\\n  ) external;\\n\\n  function acceptOwnership() external;\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/ITypeAndVersion.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ITypeAndVersion {\\n  function typeAndVersion() external pure returns (string memory);\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/interfaces/IERC1363.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1363.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @title IERC1363\\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\\n *\\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\\n */\\ninterface IERC1363 is IERC20, IERC165 {\\n    /*\\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\\n     * 0xb0202a11 ===\\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\\n     */\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferAndCall(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @param data Additional data with no specified format, sent in call to `to`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param from The address which you want to send tokens from.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param from The address which you want to send tokens from.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @param data Additional data with no specified format, sent in call to `to`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function approveAndCall(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     * @param data Additional data with no specified format, sent in call to `spender`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../utils/introspection/IERC165.sol\\\";\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../token/ERC20/IERC20.sol\\\";\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-20 standard as defined in the ERC.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\nimport {IERC1363} from \\\"../../../interfaces/IERC1363.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    /**\\n     * @dev An operation with an ERC-20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Indicates a failed `decreaseAllowance` request.\\n     */\\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\\n     */\\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\\n     */\\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     *\\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \\\"client\\\"\\n     * smart contract uses ERC-7674 to set temporary allowances, then the \\\"client\\\" smart contract should avoid using\\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\\n     * value, non-reverting calls are assumed to be successful.\\n     *\\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \\\"client\\\"\\n     * smart contract uses ERC-7674 to set temporary allowances, then the \\\"client\\\" smart contract should avoid using\\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance \\u003c requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     *\\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\\n     * only sets the \\\"standard\\\" allowance. Any temporary allowance will remain active, in addition to the value being\\n     * set here.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\\n        if (to.code.length == 0) {\\n            safeTransfer(token, to, value);\\n        } else if (!token.transferAndCall(to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function transferFromAndCallRelaxed(\\n        IERC1363 token,\\n        address from,\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal {\\n        if (to.code.length == 0) {\\n            safeTransferFrom(token, from, to, value);\\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\\n     * once without retrying, and relies on the returned value to be true.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\\n        if (to.code.length == 0) {\\n            forceApprove(token, to, value);\\n        } else if (!token.approveAndCall(to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly (\\\"memory-safe\\\") {\\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\\n            // bubble errors\\n            if iszero(success) {\\n                let ptr := mload(0x40)\\n                returndatacopy(ptr, 0, returndatasize())\\n                revert(ptr, returndatasize())\\n            }\\n            returnSize := returndatasize()\\n            returnValue := mload(0)\\n        }\\n\\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly (\\\"memory-safe\\\") {\\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\\n            returnSize := returndatasize()\\n            returnValue := mload(0)\\n        }\\n        return success \\u0026\\u0026 (returnSize == 0 ? address(token).code.length \\u003e 0 : returnValue == 1);\\n    }\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/utils/Arrays.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Arrays.sol)\\n// This file was procedurally generated from scripts/generate/templates/Arrays.js.\\n\\npragma solidity ^0.8.20;\\n\\nimport {Comparators} from \\\"./Comparators.sol\\\";\\nimport {SlotDerivation} from \\\"./SlotDerivation.sol\\\";\\nimport {StorageSlot} from \\\"./StorageSlot.sol\\\";\\nimport {Math} from \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev Collection of functions related to array types.\\n */\\nlibrary Arrays {\\n    using SlotDerivation for bytes32;\\n    using StorageSlot for bytes32;\\n\\n    /**\\n     * @dev Sort an array of uint256 (in memory) following the provided comparator function.\\n     *\\n     * This function does the sorting \\\"in place\\\", meaning that it overrides the input. The object is returned for\\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\\n     *\\n     * NOTE: this function's cost is `O(n · log(n))` in average and `O(n²)` in the worst case, with n the length of the\\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\\n     * consume more gas than is available in a block, leading to potential DoS.\\n     *\\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\\n     */\\n    function sort(\\n        uint256[] memory array,\\n        function(uint256, uint256) pure returns (bool) comp\\n    ) internal pure returns (uint256[] memory) {\\n        _quickSort(_begin(array), _end(array), comp);\\n        return array;\\n    }\\n\\n    /**\\n     * @dev Variant of {sort} that sorts an array of uint256 in increasing order.\\n     */\\n    function sort(uint256[] memory array) internal pure returns (uint256[] memory) {\\n        sort(array, Comparators.lt);\\n        return array;\\n    }\\n\\n    /**\\n     * @dev Sort an array of address (in memory) following the provided comparator function.\\n     *\\n     * This function does the sorting \\\"in place\\\", meaning that it overrides the input. The object is returned for\\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\\n     *\\n     * NOTE: this function's cost is `O(n · log(n))` in average and `O(n²)` in the worst case, with n the length of the\\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\\n     * consume more gas than is available in a block, leading to potential DoS.\\n     *\\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\\n     */\\n    function sort(\\n        address[] memory array,\\n        function(address, address) pure returns (bool) comp\\n    ) internal pure returns (address[] memory) {\\n        sort(_castToUint256Array(array), _castToUint256Comp(comp));\\n        return array;\\n    }\\n\\n    /**\\n     * @dev Variant of {sort} that sorts an array of address in increasing order.\\n     */\\n    function sort(address[] memory array) internal pure returns (address[] memory) {\\n        sort(_castToUint256Array(array), Comparators.lt);\\n        return array;\\n    }\\n\\n    /**\\n     * @dev Sort an array of bytes32 (in memory) following the provided comparator function.\\n     *\\n     * This function does the sorting \\\"in place\\\", meaning that it overrides the input. The object is returned for\\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\\n     *\\n     * NOTE: this function's cost is `O(n · log(n))` in average and `O(n²)` in the worst case, with n the length of the\\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\\n     * consume more gas than is available in a block, leading to potential DoS.\\n     *\\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\\n     */\\n    function sort(\\n        bytes32[] memory array,\\n        function(bytes32, bytes32) pure returns (bool) comp\\n    ) internal pure returns (bytes32[] memory) {\\n        sort(_castToUint256Array(array), _castToUint256Comp(comp));\\n        return array;\\n    }\\n\\n    /**\\n     * @dev Variant of {sort} that sorts an array of bytes32 in increasing order.\\n     */\\n    function sort(bytes32[] memory array) internal pure returns (bytes32[] memory) {\\n        sort(_castToUint256Array(array), Comparators.lt);\\n        return array;\\n    }\\n\\n    /**\\n     * @dev Performs a quick sort of a segment of memory. The segment sorted starts at `begin` (inclusive), and stops\\n     * at end (exclusive). Sorting follows the `comp` comparator.\\n     *\\n     * Invariant: `begin \\u003c= end`. This is the case when initially called by {sort} and is preserved in subcalls.\\n     *\\n     * IMPORTANT: Memory locations between `begin` and `end` are not validated/zeroed. This function should\\n     * be used only if the limits are within a memory array.\\n     */\\n    function _quickSort(uint256 begin, uint256 end, function(uint256, uint256) pure returns (bool) comp) private pure {\\n        unchecked {\\n            if (end - begin \\u003c 0x40) return;\\n\\n            // Use first element as pivot\\n            uint256 pivot = _mload(begin);\\n            // Position where the pivot should be at the end of the loop\\n            uint256 pos = begin;\\n\\n            for (uint256 it = begin + 0x20; it \\u003c end; it += 0x20) {\\n                if (comp(_mload(it), pivot)) {\\n                    // If the value stored at the iterator's position comes before the pivot, we increment the\\n                    // position of the pivot and move the value there.\\n                    pos += 0x20;\\n                    _swap(pos, it);\\n                }\\n            }\\n\\n            _swap(begin, pos); // Swap pivot into place\\n            _quickSort(begin, pos, comp); // Sort the left side of the pivot\\n            _quickSort(pos + 0x20, end, comp); // Sort the right side of the pivot\\n        }\\n    }\\n\\n    /**\\n     * @dev Pointer to the memory location of the first element of `array`.\\n     */\\n    function _begin(uint256[] memory array) private pure returns (uint256 ptr) {\\n        assembly (\\\"memory-safe\\\") {\\n            ptr := add(array, 0x20)\\n        }\\n    }\\n\\n    /**\\n     * @dev Pointer to the memory location of the first memory word (32bytes) after `array`. This is the memory word\\n     * that comes just after the last element of the array.\\n     */\\n    function _end(uint256[] memory array) private pure returns (uint256 ptr) {\\n        unchecked {\\n            return _begin(array) + array.length * 0x20;\\n        }\\n    }\\n\\n    /**\\n     * @dev Load memory word (as a uint256) at location `ptr`.\\n     */\\n    function _mload(uint256 ptr) private pure returns (uint256 value) {\\n        assembly {\\n            value := mload(ptr)\\n        }\\n    }\\n\\n    /**\\n     * @dev Swaps the elements memory location `ptr1` and `ptr2`.\\n     */\\n    function _swap(uint256 ptr1, uint256 ptr2) private pure {\\n        assembly {\\n            let value1 := mload(ptr1)\\n            let value2 := mload(ptr2)\\n            mstore(ptr1, value2)\\n            mstore(ptr2, value1)\\n        }\\n    }\\n\\n    /// @dev Helper: low level cast address memory array to uint256 memory array\\n    function _castToUint256Array(address[] memory input) private pure returns (uint256[] memory output) {\\n        assembly {\\n            output := input\\n        }\\n    }\\n\\n    /// @dev Helper: low level cast bytes32 memory array to uint256 memory array\\n    function _castToUint256Array(bytes32[] memory input) private pure returns (uint256[] memory output) {\\n        assembly {\\n            output := input\\n        }\\n    }\\n\\n    /// @dev Helper: low level cast address comp function to uint256 comp function\\n    function _castToUint256Comp(\\n        function(address, address) pure returns (bool) input\\n    ) private pure returns (function(uint256, uint256) pure returns (bool) output) {\\n        assembly {\\n            output := input\\n        }\\n    }\\n\\n    /// @dev Helper: low level cast bytes32 comp function to uint256 comp function\\n    function _castToUint256Comp(\\n        function(bytes32, bytes32) pure returns (bool) input\\n    ) private pure returns (function(uint256, uint256) pure returns (bool) output) {\\n        assembly {\\n            output := input\\n        }\\n    }\\n\\n    /**\\n     * @dev Searches a sorted `array` and returns the first index that contains\\n     * a value greater or equal to `element`. If no such index exists (i.e. all\\n     * values in the array are strictly less than `element`), the array length is\\n     * returned. Time complexity O(log n).\\n     *\\n     * NOTE: The `array` is expected to be sorted in ascending order, and to\\n     * contain no repeated elements.\\n     *\\n     * IMPORTANT: Deprecated. This implementation behaves as {lowerBound} but lacks\\n     * support for repeated elements in the array. The {lowerBound} function should\\n     * be used instead.\\n     */\\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\\n        uint256 low = 0;\\n        uint256 high = array.length;\\n\\n        if (high == 0) {\\n            return 0;\\n        }\\n\\n        while (low \\u003c high) {\\n            uint256 mid = Math.average(low, high);\\n\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\n            // because Math.average rounds towards zero (it does integer division with truncation).\\n            if (unsafeAccess(array, mid).value \\u003e element) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\\n        if (low \\u003e 0 \\u0026\\u0026 unsafeAccess(array, low - 1).value == element) {\\n            return low - 1;\\n        } else {\\n            return low;\\n        }\\n    }\\n\\n    /**\\n     * @dev Searches an `array` sorted in ascending order and returns the first\\n     * index that contains a value greater or equal than `element`. If no such index\\n     * exists (i.e. all values in the array are strictly less than `element`), the array\\n     * length is returned. Time complexity O(log n).\\n     *\\n     * See C++'s https://en.cppreference.com/w/cpp/algorithm/lower_bound[lower_bound].\\n     */\\n    function lowerBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\\n        uint256 low = 0;\\n        uint256 high = array.length;\\n\\n        if (high == 0) {\\n            return 0;\\n        }\\n\\n        while (low \\u003c high) {\\n            uint256 mid = Math.average(low, high);\\n\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\n            // because Math.average rounds towards zero (it does integer division with truncation).\\n            if (unsafeAccess(array, mid).value \\u003c element) {\\n                // this cannot overflow because mid \\u003c high\\n                unchecked {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                high = mid;\\n            }\\n        }\\n\\n        return low;\\n    }\\n\\n    /**\\n     * @dev Searches an `array` sorted in ascending order and returns the first\\n     * index that contains a value strictly greater than `element`. If no such index\\n     * exists (i.e. all values in the array are strictly less than `element`), the array\\n     * length is returned. Time complexity O(log n).\\n     *\\n     * See C++'s https://en.cppreference.com/w/cpp/algorithm/upper_bound[upper_bound].\\n     */\\n    function upperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\\n        uint256 low = 0;\\n        uint256 high = array.length;\\n\\n        if (high == 0) {\\n            return 0;\\n        }\\n\\n        while (low \\u003c high) {\\n            uint256 mid = Math.average(low, high);\\n\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\n            // because Math.average rounds towards zero (it does integer division with truncation).\\n            if (unsafeAccess(array, mid).value \\u003e element) {\\n                high = mid;\\n            } else {\\n                // this cannot overflow because mid \\u003c high\\n                unchecked {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n\\n        return low;\\n    }\\n\\n    /**\\n     * @dev Same as {lowerBound}, but with an array in memory.\\n     */\\n    function lowerBoundMemory(uint256[] memory array, uint256 element) internal pure returns (uint256) {\\n        uint256 low = 0;\\n        uint256 high = array.length;\\n\\n        if (high == 0) {\\n            return 0;\\n        }\\n\\n        while (low \\u003c high) {\\n            uint256 mid = Math.average(low, high);\\n\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\n            // because Math.average rounds towards zero (it does integer division with truncation).\\n            if (unsafeMemoryAccess(array, mid) \\u003c element) {\\n                // this cannot overflow because mid \\u003c high\\n                unchecked {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                high = mid;\\n            }\\n        }\\n\\n        return low;\\n    }\\n\\n    /**\\n     * @dev Same as {upperBound}, but with an array in memory.\\n     */\\n    function upperBoundMemory(uint256[] memory array, uint256 element) internal pure returns (uint256) {\\n        uint256 low = 0;\\n        uint256 high = array.length;\\n\\n        if (high == 0) {\\n            return 0;\\n        }\\n\\n        while (low \\u003c high) {\\n            uint256 mid = Math.average(low, high);\\n\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\n            // because Math.average rounds towards zero (it does integer division with truncation).\\n            if (unsafeMemoryAccess(array, mid) \\u003e element) {\\n                high = mid;\\n            } else {\\n                // this cannot overflow because mid \\u003c high\\n                unchecked {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n\\n        return low;\\n    }\\n\\n    /**\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\n     *\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\n     */\\n    function unsafeAccess(address[] storage arr, uint256 pos) internal pure returns (StorageSlot.AddressSlot storage) {\\n        bytes32 slot;\\n        assembly (\\\"memory-safe\\\") {\\n            slot := arr.slot\\n        }\\n        return slot.deriveArray().offset(pos).getAddressSlot();\\n    }\\n\\n    /**\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\n     *\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\n     */\\n    function unsafeAccess(bytes32[] storage arr, uint256 pos) internal pure returns (StorageSlot.Bytes32Slot storage) {\\n        bytes32 slot;\\n        assembly (\\\"memory-safe\\\") {\\n            slot := arr.slot\\n        }\\n        return slot.deriveArray().offset(pos).getBytes32Slot();\\n    }\\n\\n    /**\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\n     *\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\n     */\\n    function unsafeAccess(uint256[] storage arr, uint256 pos) internal pure returns (StorageSlot.Uint256Slot storage) {\\n        bytes32 slot;\\n        assembly (\\\"memory-safe\\\") {\\n            slot := arr.slot\\n        }\\n        return slot.deriveArray().offset(pos).getUint256Slot();\\n    }\\n\\n    /**\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\n     *\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\n     */\\n    function unsafeMemoryAccess(address[] memory arr, uint256 pos) internal pure returns (address res) {\\n        assembly {\\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\\n        }\\n    }\\n\\n    /**\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\n     *\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\n     */\\n    function unsafeMemoryAccess(bytes32[] memory arr, uint256 pos) internal pure returns (bytes32 res) {\\n        assembly {\\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\\n        }\\n    }\\n\\n    /**\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\n     *\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\n     */\\n    function unsafeMemoryAccess(uint256[] memory arr, uint256 pos) internal pure returns (uint256 res) {\\n        assembly {\\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\\n        }\\n    }\\n\\n    /**\\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\\n     *\\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\\n     */\\n    function unsafeSetLength(address[] storage array, uint256 len) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(array.slot, len)\\n        }\\n    }\\n\\n    /**\\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\\n     *\\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\\n     */\\n    function unsafeSetLength(bytes32[] storage array, uint256 len) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(array.slot, len)\\n        }\\n    }\\n\\n    /**\\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\\n     *\\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\\n     */\\n    function unsafeSetLength(uint256[] storage array, uint256 len) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(array.slot, len)\\n        }\\n    }\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/utils/Comparators.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Comparators.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides a set of functions to compare values.\\n *\\n * _Available since v5.1._\\n */\\nlibrary Comparators {\\n    function lt(uint256 a, uint256 b) internal pure returns (bool) {\\n        return a \\u003c b;\\n    }\\n\\n    function gt(uint256 a, uint256 b) internal pure returns (bool) {\\n        return a \\u003e b;\\n    }\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/utils/Panic.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Helper library for emitting standardized panic codes.\\n *\\n * ```solidity\\n * contract Example {\\n *      using Panic for uint256;\\n *\\n *      // Use any of the declared internal constants\\n *      function foo() { Panic.GENERIC.panic(); }\\n *\\n *      // Alternatively\\n *      function foo() { Panic.panic(Panic.GENERIC); }\\n * }\\n * ```\\n *\\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\\n *\\n * _Available since v5.1._\\n */\\n// slither-disable-next-line unused-state\\nlibrary Panic {\\n    /// @dev generic / unspecified error\\n    uint256 internal constant GENERIC = 0x00;\\n    /// @dev used by the assert() builtin\\n    uint256 internal constant ASSERT = 0x01;\\n    /// @dev arithmetic underflow or overflow\\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\\n    /// @dev division or modulo by zero\\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\\n    /// @dev enum conversion error\\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\\n    /// @dev invalid encoding in storage\\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\\n    /// @dev empty array pop\\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\\n    /// @dev array out of bounds access\\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\\n    /// @dev resource error (too large allocation or too large array)\\n    uint256 internal constant RESOURCE_ERROR = 0x41;\\n    /// @dev calling invalid internal function\\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\\n\\n    /// @dev Reverts with a panic code. Recommended to use with\\n    /// the internal constants with predefined codes.\\n    function panic(uint256 code) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, 0x4e487b71)\\n            mstore(0x20, code)\\n            revert(0x1c, 0x24)\\n        }\\n    }\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/utils/SlotDerivation.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/SlotDerivation.sol)\\n// This file was procedurally generated from scripts/generate/templates/SlotDerivation.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for computing storage (and transient storage) locations from namespaces and deriving slots\\n * corresponding to standard patterns. The derivation method for array and mapping matches the storage layout used by\\n * the solidity language / compiler.\\n *\\n * See https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays[Solidity docs for mappings and dynamic arrays.].\\n *\\n * Example usage:\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using StorageSlot for bytes32;\\n *     using SlotDerivation for bytes32;\\n *\\n *     // Declare a namespace\\n *     string private constant _NAMESPACE = \\\"\\u003cnamespace\\u003e\\\"; // eg. OpenZeppelin.Slot\\n *\\n *     function setValueInNamespace(uint256 key, address newValue) internal {\\n *         _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value = newValue;\\n *     }\\n *\\n *     function getValueInNamespace(uint256 key) internal view returns (address) {\\n *         return _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value;\\n *     }\\n * }\\n * ```\\n *\\n * TIP: Consider using this library along with {StorageSlot}.\\n *\\n * NOTE: This library provides a way to manipulate storage locations in a non-standard way. Tooling for checking\\n * upgrade safety will ignore the slots accessed through this library.\\n *\\n * _Available since v5.1._\\n */\\nlibrary SlotDerivation {\\n    /**\\n     * @dev Derive an ERC-7201 slot from a string (namespace).\\n     */\\n    function erc7201Slot(string memory namespace) internal pure returns (bytes32 slot) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, sub(keccak256(add(namespace, 0x20), mload(namespace)), 1))\\n            slot := and(keccak256(0x00, 0x20), not(0xff))\\n        }\\n    }\\n\\n    /**\\n     * @dev Add an offset to a slot to get the n-th element of a structure or an array.\\n     */\\n    function offset(bytes32 slot, uint256 pos) internal pure returns (bytes32 result) {\\n        unchecked {\\n            return bytes32(uint256(slot) + pos);\\n        }\\n    }\\n\\n    /**\\n     * @dev Derive the location of the first element in an array from the slot where the length is stored.\\n     */\\n    function deriveArray(bytes32 slot) internal pure returns (bytes32 result) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, slot)\\n            result := keccak256(0x00, 0x20)\\n        }\\n    }\\n\\n    /**\\n     * @dev Derive the location of a mapping element from the key.\\n     */\\n    function deriveMapping(bytes32 slot, address key) internal pure returns (bytes32 result) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, and(key, shr(96, not(0))))\\n            mstore(0x20, slot)\\n            result := keccak256(0x00, 0x40)\\n        }\\n    }\\n\\n    /**\\n     * @dev Derive the location of a mapping element from the key.\\n     */\\n    function deriveMapping(bytes32 slot, bool key) internal pure returns (bytes32 result) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, iszero(iszero(key)))\\n            mstore(0x20, slot)\\n            result := keccak256(0x00, 0x40)\\n        }\\n    }\\n\\n    /**\\n     * @dev Derive the location of a mapping element from the key.\\n     */\\n    function deriveMapping(bytes32 slot, bytes32 key) internal pure returns (bytes32 result) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, key)\\n            mstore(0x20, slot)\\n            result := keccak256(0x00, 0x40)\\n        }\\n    }\\n\\n    /**\\n     * @dev Derive the location of a mapping element from the key.\\n     */\\n    function deriveMapping(bytes32 slot, uint256 key) internal pure returns (bytes32 result) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, key)\\n            mstore(0x20, slot)\\n            result := keccak256(0x00, 0x40)\\n        }\\n    }\\n\\n    /**\\n     * @dev Derive the location of a mapping element from the key.\\n     */\\n    function deriveMapping(bytes32 slot, int256 key) internal pure returns (bytes32 result) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, key)\\n            mstore(0x20, slot)\\n            result := keccak256(0x00, 0x40)\\n        }\\n    }\\n\\n    /**\\n     * @dev Derive the location of a mapping element from the key.\\n     */\\n    function deriveMapping(bytes32 slot, string memory key) internal pure returns (bytes32 result) {\\n        assembly (\\\"memory-safe\\\") {\\n            let length := mload(key)\\n            let begin := add(key, 0x20)\\n            let end := add(begin, length)\\n            let cache := mload(end)\\n            mstore(end, slot)\\n            result := keccak256(begin, add(length, 0x20))\\n            mstore(end, cache)\\n        }\\n    }\\n\\n    /**\\n     * @dev Derive the location of a mapping element from the key.\\n     */\\n    function deriveMapping(bytes32 slot, bytes memory key) internal pure returns (bytes32 result) {\\n        assembly (\\\"memory-safe\\\") {\\n            let length := mload(key)\\n            let begin := add(key, 0x20)\\n            let end := add(begin, length)\\n            let cache := mload(end)\\n            mstore(end, slot)\\n            result := keccak256(begin, add(length, 0x20))\\n            mstore(end, cache)\\n        }\\n    }\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/utils/StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC-1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(newImplementation.code.length \\u003e 0);\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * TIP: Consider using this library along with {SlotDerivation}.\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct Int256Slot {\\n        int256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `Int256Slot` with member `value` located at `slot`.\\n     */\\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Panic} from \\\"../Panic.sol\\\";\\nimport {SafeCast} from \\\"./SafeCast.sol\\\";\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Return the 512-bit addition of two uint256.\\n     *\\n     * The result is stored in two 256 variables such that sum = high * 2²⁵⁶ + low.\\n     */\\n    function add512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\\n        assembly (\\\"memory-safe\\\") {\\n            low := add(a, b)\\n            high := lt(low, a)\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the 512-bit multiplication of two uint256.\\n     *\\n     * The result is stored in two 256 variables such that product = high * 2²⁵⁶ + low.\\n     */\\n    function mul512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\\n        // 512-bit multiply [high low] = x * y. Compute the product mod 2²⁵⁶ and mod 2²⁵⁶ - 1, then use\\n        // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n        // variables such that product = high * 2²⁵⁶ + low.\\n        assembly (\\\"memory-safe\\\") {\\n            let mm := mulmod(a, b, not(0))\\n            low := mul(a, b)\\n            high := sub(sub(mm, low), lt(mm, low))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with a success flag (no overflow).\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n        unchecked {\\n            uint256 c = a + b;\\n            success = c \\u003e= a;\\n            result = c * SafeCast.toUint(success);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with a success flag (no overflow).\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n        unchecked {\\n            uint256 c = a - b;\\n            success = c \\u003c= a;\\n            result = c * SafeCast.toUint(success);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with a success flag (no overflow).\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n        unchecked {\\n            uint256 c = a * b;\\n            assembly (\\\"memory-safe\\\") {\\n                // Only true when the multiplication doesn't overflow\\n                // (c / a == b) || (a == 0)\\n                success := or(eq(div(c, a), b), iszero(a))\\n            }\\n            // equivalent to: success ? c : 0\\n            result = c * SafeCast.toUint(success);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n        unchecked {\\n            success = b \\u003e 0;\\n            assembly (\\\"memory-safe\\\") {\\n                // The `DIV` opcode returns zero when the denominator is 0.\\n                result := div(a, b)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n        unchecked {\\n            success = b \\u003e 0;\\n            assembly (\\\"memory-safe\\\") {\\n                // The `MOD` opcode returns zero when the denominator is 0.\\n                result := mod(a, b)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Unsigned saturating addition, bounds to `2²⁵⁶ - 1` instead of overflowing.\\n     */\\n    function saturatingAdd(uint256 a, uint256 b) internal pure returns (uint256) {\\n        (bool success, uint256 result) = tryAdd(a, b);\\n        return ternary(success, result, type(uint256).max);\\n    }\\n\\n    /**\\n     * @dev Unsigned saturating subtraction, bounds to zero instead of overflowing.\\n     */\\n    function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        (, uint256 result) = trySub(a, b);\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Unsigned saturating multiplication, bounds to `2²⁵⁶ - 1` instead of overflowing.\\n     */\\n    function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        (bool success, uint256 result) = tryMul(a, b);\\n        return ternary(success, result, type(uint256).max);\\n    }\\n\\n    /**\\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\\n     *\\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\\n     * one branch when needed, making this function more expensive.\\n     */\\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\\n        unchecked {\\n            // branchless ternary works because:\\n            // b ^ (a ^ b) == a\\n            // b ^ 0 == b\\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return ternary(a \\u003e b, a, b);\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return ternary(a \\u003c b, a, b);\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a \\u0026 b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            Panic.panic(Panic.DIVISION_BY_ZERO);\\n        }\\n\\n        // The following calculation ensures accurate ceiling division without overflow.\\n        // Since a is non-zero, (a - 1) / b will not overflow.\\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\\n        // when a = type(uint256).max and b = 1.\\n        unchecked {\\n            return SafeCast.toUint(a \\u003e 0) * ((a - 1) / b + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     *\\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            (uint256 high, uint256 low) = mul512(x, y);\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (high == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return low / denominator;\\n            }\\n\\n            // Make sure the result is less than 2²⁵⁶. Also prevents denominator == 0.\\n            if (denominator \\u003c= high) {\\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [high low].\\n            uint256 remainder;\\n            assembly (\\\"memory-safe\\\") {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                high := sub(high, gt(remainder, low))\\n                low := sub(low, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always \\u003e= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator \\u0026 (0 - denominator);\\n            assembly (\\\"memory-safe\\\") {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [high low] by twos.\\n                low := div(low, twos)\\n\\n                // Flip twos such that it is 2²⁵⁶ / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from high into low.\\n            low |= high * twos;\\n\\n            // Invert denominator mod 2²⁵⁶. Now that denominator is an odd number, it has an inverse modulo 2²⁵⁶ such\\n            // that denominator * inv ≡ 1 mod 2²⁵⁶. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv ≡ 1 mod 2⁴.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁸\\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹⁶\\n            inverse *= 2 - denominator * inverse; // inverse mod 2³²\\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁶⁴\\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹²⁸\\n            inverse *= 2 - denominator * inverse; // inverse mod 2²⁵⁶\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2²⁵⁶. Since the preconditions guarantee that the outcome is\\n            // less than 2²⁵⁶, this is the final result. We don't need to compute the high bits of the result and high\\n            // is no longer required.\\n            result = low * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) \\u0026\\u0026 mulmod(x, y, denominator) \\u003e 0);\\n    }\\n\\n    /**\\n     * @dev Calculates floor(x * y \\u003e\\u003e n) with full precision. Throws if result overflows a uint256.\\n     */\\n    function mulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {\\n        unchecked {\\n            (uint256 high, uint256 low) = mul512(x, y);\\n            if (high \\u003e= 1 \\u003c\\u003c n) {\\n                Panic.panic(Panic.UNDER_OVERFLOW);\\n            }\\n            return (high \\u003c\\u003c (256 - n)) | (low \\u003e\\u003e n);\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates x * y \\u003e\\u003e n with full precision, following the selected rounding direction.\\n     */\\n    function mulShr(uint256 x, uint256 y, uint8 n, Rounding rounding) internal pure returns (uint256) {\\n        return mulShr(x, y, n) + SafeCast.toUint(unsignedRoundsUp(rounding) \\u0026\\u0026 mulmod(x, y, 1 \\u003c\\u003c n) \\u003e 0);\\n    }\\n\\n    /**\\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\\n     *\\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\\n     *\\n     * If the input value is not inversible, 0 is returned.\\n     *\\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\\n     */\\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\\n        unchecked {\\n            if (n == 0) return 0;\\n\\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\\n            // ax + ny = 1\\n            // ax = 1 + (-y)n\\n            // ax ≡ 1 (mod n) # x is the inverse of a modulo n\\n\\n            // If the remainder is 0 the gcd is n right away.\\n            uint256 remainder = a % n;\\n            uint256 gcd = n;\\n\\n            // Therefore the initial coefficients are:\\n            // ax + ny = gcd(a, n) = n\\n            // 0a + 1n = n\\n            int256 x = 0;\\n            int256 y = 1;\\n\\n            while (remainder != 0) {\\n                uint256 quotient = gcd / remainder;\\n\\n                (gcd, remainder) = (\\n                    // The old remainder is the next gcd to try.\\n                    remainder,\\n                    // Compute the next remainder.\\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) \\u003c= gcd\\n                    // where gcd is at most n (capped to type(uint256).max)\\n                    gcd - remainder * quotient\\n                );\\n\\n                (x, y) = (\\n                    // Increment the coefficient of a.\\n                    y,\\n                    // Decrement the coefficient of n.\\n                    // Can overflow, but the result is casted to uint256 so that the\\n                    // next value of y is \\\"wrapped around\\\" to a value between 0 and n - 1.\\n                    x - y * int256(quotient)\\n                );\\n            }\\n\\n            if (gcd != 1) return 0; // No inverse exists.\\n            return ternary(x \\u003c 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\\n        }\\n    }\\n\\n    /**\\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\\n     *\\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\\n     * prime, then `a**(p-1) ≡ 1 mod p`. As a consequence, we have `a * a**(p-2) ≡ 1 mod p`, which means that\\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\\n     *\\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\\n     */\\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\\n        unchecked {\\n            return Math.modExp(a, p - 2, p);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\\n     *\\n     * Requirements:\\n     * - modulus can't be zero\\n     * - underlying staticcall to precompile must succeed\\n     *\\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\\n     * interpreted as 0.\\n     */\\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\\n        (bool success, uint256 result) = tryModExp(b, e, m);\\n        if (!success) {\\n            Panic.panic(Panic.DIVISION_BY_ZERO);\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\\n     * to operate modulo 0 or if the underlying precompile reverted.\\n     *\\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\\n     * of a revert, but the result may be incorrectly interpreted as 0.\\n     */\\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\\n        if (m == 0) return (false, 0);\\n        assembly (\\\"memory-safe\\\") {\\n            let ptr := mload(0x40)\\n            // | Offset    | Content    | Content (Hex)                                                      |\\n            // |-----------|------------|--------------------------------------------------------------------|\\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\\n            // | 0x60:0x7f | value of b | 0x\\u003c.............................................................b\\u003e |\\n            // | 0x80:0x9f | value of e | 0x\\u003c.............................................................e\\u003e |\\n            // | 0xa0:0xbf | value of m | 0x\\u003c.............................................................m\\u003e |\\n            mstore(ptr, 0x20)\\n            mstore(add(ptr, 0x20), 0x20)\\n            mstore(add(ptr, 0x40), 0x20)\\n            mstore(add(ptr, 0x60), b)\\n            mstore(add(ptr, 0x80), e)\\n            mstore(add(ptr, 0xa0), m)\\n\\n            // Given the result \\u003c m, it's guaranteed to fit in 32 bytes,\\n            // so we can use the memory scratch space located at offset 0.\\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /**\\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\\n     */\\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\\n        (bool success, bytes memory result) = tryModExp(b, e, m);\\n        if (!success) {\\n            Panic.panic(Panic.DIVISION_BY_ZERO);\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\\n     */\\n    function tryModExp(\\n        bytes memory b,\\n        bytes memory e,\\n        bytes memory m\\n    ) internal view returns (bool success, bytes memory result) {\\n        if (_zeroBytes(m)) return (false, new bytes(0));\\n\\n        uint256 mLen = m.length;\\n\\n        // Encode call args in result and move the free memory pointer\\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\\n\\n        assembly (\\\"memory-safe\\\") {\\n            let dataPtr := add(result, 0x20)\\n            // Write result on top of args to avoid allocating extra memory.\\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\\n            // Overwrite the length.\\n            // result.length \\u003e returndatasize() is guaranteed because returndatasize() == m.length\\n            mstore(result, mLen)\\n            // Set the memory pointer after the returned data.\\n            mstore(0x40, add(dataPtr, mLen))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether the provided byte array is zero.\\n     */\\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\\n        for (uint256 i = 0; i \\u003c byteArray.length; ++i) {\\n            if (byteArray[i] != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\\n     * using integer operations.\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        unchecked {\\n            // Take care of easy edge cases when a == 0 or a == 1\\n            if (a \\u003c= 1) {\\n                return a;\\n            }\\n\\n            // In this function, we use Newton's method to get a root of `f(x) := x² - a`. It involves building a\\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\\n            // the current value as `ε_n = | x_n - sqrt(a) |`.\\n            //\\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\\n            // of the target. (i.e. `2**(e-1) ≤ sqrt(a) \\u003c 2**e`). We know that `e ≤ 128` because `(2¹²⁸)² = 2²⁵⁶` is\\n            // bigger than any uint256.\\n            //\\n            // By noticing that\\n            // `2**(e-1) ≤ sqrt(a) \\u003c 2**e → (2**(e-1))² ≤ a \\u003c (2**e)² → 2**(2*e-2) ≤ a \\u003c 2**(2*e)`\\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\\n            // to the msb function.\\n            uint256 aa = a;\\n            uint256 xn = 1;\\n\\n            if (aa \\u003e= (1 \\u003c\\u003c 128)) {\\n                aa \\u003e\\u003e= 128;\\n                xn \\u003c\\u003c= 64;\\n            }\\n            if (aa \\u003e= (1 \\u003c\\u003c 64)) {\\n                aa \\u003e\\u003e= 64;\\n                xn \\u003c\\u003c= 32;\\n            }\\n            if (aa \\u003e= (1 \\u003c\\u003c 32)) {\\n                aa \\u003e\\u003e= 32;\\n                xn \\u003c\\u003c= 16;\\n            }\\n            if (aa \\u003e= (1 \\u003c\\u003c 16)) {\\n                aa \\u003e\\u003e= 16;\\n                xn \\u003c\\u003c= 8;\\n            }\\n            if (aa \\u003e= (1 \\u003c\\u003c 8)) {\\n                aa \\u003e\\u003e= 8;\\n                xn \\u003c\\u003c= 4;\\n            }\\n            if (aa \\u003e= (1 \\u003c\\u003c 4)) {\\n                aa \\u003e\\u003e= 4;\\n                xn \\u003c\\u003c= 2;\\n            }\\n            if (aa \\u003e= (1 \\u003c\\u003c 2)) {\\n                xn \\u003c\\u003c= 1;\\n            }\\n\\n            // We now have x_n such that `x_n = 2**(e-1) ≤ sqrt(a) \\u003c 2**e = 2 * x_n`. This implies ε_n ≤ 2**(e-1).\\n            //\\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to ε_n ≤ 2**(e-2).\\n            // This is going to be our x_0 (and ε_0)\\n            xn = (3 * xn) \\u003e\\u003e 1; // ε_0 := | x_0 - sqrt(a) | ≤ 2**(e-2)\\n\\n            // From here, Newton's method give us:\\n            // x_{n+1} = (x_n + a / x_n) / 2\\n            //\\n            // One should note that:\\n            // x_{n+1}² - a = ((x_n + a / x_n) / 2)² - a\\n            //              = ((x_n² + a) / (2 * x_n))² - a\\n            //              = (x_n⁴ + 2 * a * x_n² + a²) / (4 * x_n²) - a\\n            //              = (x_n⁴ + 2 * a * x_n² + a² - 4 * a * x_n²) / (4 * x_n²)\\n            //              = (x_n⁴ - 2 * a * x_n² + a²) / (4 * x_n²)\\n            //              = (x_n² - a)² / (2 * x_n)²\\n            //              = ((x_n² - a) / (2 * x_n))²\\n            //              ≥ 0\\n            // Which proves that for all n ≥ 1, sqrt(a) ≤ x_n\\n            //\\n            // This gives us the proof of quadratic convergence of the sequence:\\n            // ε_{n+1} = | x_{n+1} - sqrt(a) |\\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\\n            //         = | (x_n² + a - 2*x_n*sqrt(a)) / (2 * x_n) |\\n            //         = | (x_n - sqrt(a))² / (2 * x_n) |\\n            //         = | ε_n² / (2 * x_n) |\\n            //         = ε_n² / | (2 * x_n) |\\n            //\\n            // For the first iteration, we have a special case where x_0 is known:\\n            // ε_1 = ε_0² / | (2 * x_0) |\\n            //     ≤ (2**(e-2))² / (2 * (2**(e-1) + 2**(e-2)))\\n            //     ≤ 2**(2*e-4) / (3 * 2**(e-1))\\n            //     ≤ 2**(e-3) / 3\\n            //     ≤ 2**(e-3-log2(3))\\n            //     ≤ 2**(e-4.5)\\n            //\\n            // For the following iterations, we use the fact that, 2**(e-1) ≤ sqrt(a) ≤ x_n:\\n            // ε_{n+1} = ε_n² / | (2 * x_n) |\\n            //         ≤ (2**(e-k))² / (2 * 2**(e-1))\\n            //         ≤ 2**(2*e-2*k) / 2**e\\n            //         ≤ 2**(e-2*k)\\n            xn = (xn + a / xn) \\u003e\\u003e 1; // ε_1 := | x_1 - sqrt(a) | ≤ 2**(e-4.5)  -- special case, see above\\n            xn = (xn + a / xn) \\u003e\\u003e 1; // ε_2 := | x_2 - sqrt(a) | ≤ 2**(e-9)    -- general case with k = 4.5\\n            xn = (xn + a / xn) \\u003e\\u003e 1; // ε_3 := | x_3 - sqrt(a) | ≤ 2**(e-18)   -- general case with k = 9\\n            xn = (xn + a / xn) \\u003e\\u003e 1; // ε_4 := | x_4 - sqrt(a) | ≤ 2**(e-36)   -- general case with k = 18\\n            xn = (xn + a / xn) \\u003e\\u003e 1; // ε_5 := | x_5 - sqrt(a) | ≤ 2**(e-72)   -- general case with k = 36\\n            xn = (xn + a / xn) \\u003e\\u003e 1; // ε_6 := | x_6 - sqrt(a) | ≤ 2**(e-144)  -- general case with k = 72\\n\\n            // Because e ≤ 128 (as discussed during the first estimation phase), we know have reached a precision\\n            // ε_6 ≤ 2**(e-144) \\u003c 1. Given we're operating on integers, then we can ensure that xn is now either\\n            // sqrt(a) or sqrt(a) + 1.\\n            return xn - SafeCast.toUint(xn \\u003e a / xn);\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) \\u0026\\u0026 result * result \\u003c a);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 x) internal pure returns (uint256 r) {\\n        // If value has upper 128 bits set, log2 result is at least 128\\n        r = SafeCast.toUint(x \\u003e 0xffffffffffffffffffffffffffffffff) \\u003c\\u003c 7;\\n        // If upper 64 bits of 128-bit half set, add 64 to result\\n        r |= SafeCast.toUint((x \\u003e\\u003e r) \\u003e 0xffffffffffffffff) \\u003c\\u003c 6;\\n        // If upper 32 bits of 64-bit half set, add 32 to result\\n        r |= SafeCast.toUint((x \\u003e\\u003e r) \\u003e 0xffffffff) \\u003c\\u003c 5;\\n        // If upper 16 bits of 32-bit half set, add 16 to result\\n        r |= SafeCast.toUint((x \\u003e\\u003e r) \\u003e 0xffff) \\u003c\\u003c 4;\\n        // If upper 8 bits of 16-bit half set, add 8 to result\\n        r |= SafeCast.toUint((x \\u003e\\u003e r) \\u003e 0xff) \\u003c\\u003c 3;\\n        // If upper 4 bits of 8-bit half set, add 4 to result\\n        r |= SafeCast.toUint((x \\u003e\\u003e r) \\u003e 0xf) \\u003c\\u003c 2;\\n\\n        // Shifts value right by the current result and use it as an index into this lookup table:\\n        //\\n        // | x (4 bits) |  index  | table[index] = MSB position |\\n        // |------------|---------|-----------------------------|\\n        // |    0000    |    0    |        table[0] = 0         |\\n        // |    0001    |    1    |        table[1] = 0         |\\n        // |    0010    |    2    |        table[2] = 1         |\\n        // |    0011    |    3    |        table[3] = 1         |\\n        // |    0100    |    4    |        table[4] = 2         |\\n        // |    0101    |    5    |        table[5] = 2         |\\n        // |    0110    |    6    |        table[6] = 2         |\\n        // |    0111    |    7    |        table[7] = 2         |\\n        // |    1000    |    8    |        table[8] = 3         |\\n        // |    1001    |    9    |        table[9] = 3         |\\n        // |    1010    |   10    |        table[10] = 3        |\\n        // |    1011    |   11    |        table[11] = 3        |\\n        // |    1100    |   12    |        table[12] = 3        |\\n        // |    1101    |   13    |        table[13] = 3        |\\n        // |    1110    |   14    |        table[14] = 3        |\\n        // |    1111    |   15    |        table[15] = 3        |\\n        //\\n        // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.\\n        assembly (\\\"memory-safe\\\") {\\n            r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) \\u0026\\u0026 1 \\u003c\\u003c result \\u003c value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value \\u003e= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value \\u003e= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value \\u003e= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value \\u003e= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value \\u003e= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value \\u003e= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value \\u003e= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) \\u0026\\u0026 10 ** result \\u003c value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 x) internal pure returns (uint256 r) {\\n        // If value has upper 128 bits set, log2 result is at least 128\\n        r = SafeCast.toUint(x \\u003e 0xffffffffffffffffffffffffffffffff) \\u003c\\u003c 7;\\n        // If upper 64 bits of 128-bit half set, add 64 to result\\n        r |= SafeCast.toUint((x \\u003e\\u003e r) \\u003e 0xffffffffffffffff) \\u003c\\u003c 6;\\n        // If upper 32 bits of 64-bit half set, add 32 to result\\n        r |= SafeCast.toUint((x \\u003e\\u003e r) \\u003e 0xffffffff) \\u003c\\u003c 5;\\n        // If upper 16 bits of 32-bit half set, add 16 to result\\n        r |= SafeCast.toUint((x \\u003e\\u003e r) \\u003e 0xffff) \\u003c\\u003c 4;\\n        // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8\\n        return (r \\u003e\\u003e 3) | SafeCast.toUint((x \\u003e\\u003e r) \\u003e 0xff);\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) \\u0026\\u0026 1 \\u003c\\u003c (result \\u003c\\u003c 3) \\u003c value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/utils/math/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\\n\\n    /**\\n     * @dev An int value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedIntToUint(int256 value);\\n\\n    /**\\n     * @dev Value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\\n\\n    /**\\n     * @dev An uint value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedUintToInt(uint256 value);\\n\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        if (value \\u003e type(uint248).max) {\\n            revert SafeCastOverflowedUintDowncast(248, value);\\n        }\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        if (value \\u003e type(uint240).max) {\\n            revert SafeCastOverflowedUintDowncast(240, value);\\n        }\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        if (value \\u003e type(uint232).max) {\\n            revert SafeCastOverflowedUintDowncast(232, value);\\n        }\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        if (value \\u003e type(uint224).max) {\\n            revert SafeCastOverflowedUintDowncast(224, value);\\n        }\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        if (value \\u003e type(uint216).max) {\\n            revert SafeCastOverflowedUintDowncast(216, value);\\n        }\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        if (value \\u003e type(uint208).max) {\\n            revert SafeCastOverflowedUintDowncast(208, value);\\n        }\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        if (value \\u003e type(uint200).max) {\\n            revert SafeCastOverflowedUintDowncast(200, value);\\n        }\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        if (value \\u003e type(uint192).max) {\\n            revert SafeCastOverflowedUintDowncast(192, value);\\n        }\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        if (value \\u003e type(uint184).max) {\\n            revert SafeCastOverflowedUintDowncast(184, value);\\n        }\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        if (value \\u003e type(uint176).max) {\\n            revert SafeCastOverflowedUintDowncast(176, value);\\n        }\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        if (value \\u003e type(uint168).max) {\\n            revert SafeCastOverflowedUintDowncast(168, value);\\n        }\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        if (value \\u003e type(uint160).max) {\\n            revert SafeCastOverflowedUintDowncast(160, value);\\n        }\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        if (value \\u003e type(uint152).max) {\\n            revert SafeCastOverflowedUintDowncast(152, value);\\n        }\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        if (value \\u003e type(uint144).max) {\\n            revert SafeCastOverflowedUintDowncast(144, value);\\n        }\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        if (value \\u003e type(uint136).max) {\\n            revert SafeCastOverflowedUintDowncast(136, value);\\n        }\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        if (value \\u003e type(uint128).max) {\\n            revert SafeCastOverflowedUintDowncast(128, value);\\n        }\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        if (value \\u003e type(uint120).max) {\\n            revert SafeCastOverflowedUintDowncast(120, value);\\n        }\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        if (value \\u003e type(uint112).max) {\\n            revert SafeCastOverflowedUintDowncast(112, value);\\n        }\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        if (value \\u003e type(uint104).max) {\\n            revert SafeCastOverflowedUintDowncast(104, value);\\n        }\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        if (value \\u003e type(uint96).max) {\\n            revert SafeCastOverflowedUintDowncast(96, value);\\n        }\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        if (value \\u003e type(uint88).max) {\\n            revert SafeCastOverflowedUintDowncast(88, value);\\n        }\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        if (value \\u003e type(uint80).max) {\\n            revert SafeCastOverflowedUintDowncast(80, value);\\n        }\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        if (value \\u003e type(uint72).max) {\\n            revert SafeCastOverflowedUintDowncast(72, value);\\n        }\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        if (value \\u003e type(uint64).max) {\\n            revert SafeCastOverflowedUintDowncast(64, value);\\n        }\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        if (value \\u003e type(uint56).max) {\\n            revert SafeCastOverflowedUintDowncast(56, value);\\n        }\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        if (value \\u003e type(uint48).max) {\\n            revert SafeCastOverflowedUintDowncast(48, value);\\n        }\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        if (value \\u003e type(uint40).max) {\\n            revert SafeCastOverflowedUintDowncast(40, value);\\n        }\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        if (value \\u003e type(uint32).max) {\\n            revert SafeCastOverflowedUintDowncast(32, value);\\n        }\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        if (value \\u003e type(uint24).max) {\\n            revert SafeCastOverflowedUintDowncast(24, value);\\n        }\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        if (value \\u003e type(uint16).max) {\\n            revert SafeCastOverflowedUintDowncast(16, value);\\n        }\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        if (value \\u003e type(uint8).max) {\\n            revert SafeCastOverflowedUintDowncast(8, value);\\n        }\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        if (value \\u003c 0) {\\n            revert SafeCastOverflowedIntToUint(value);\\n        }\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(248, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(240, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(232, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(224, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(216, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(208, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(200, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(192, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(184, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(176, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(168, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(160, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(152, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(144, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(136, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(128, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(120, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(112, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(104, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(96, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(88, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(80, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(72, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(64, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(56, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(48, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(40, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(32, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(24, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(16, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(8, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        if (value \\u003e uint256(type(int256).max)) {\\n            revert SafeCastOverflowedUintToInt(value);\\n        }\\n        return int256(value);\\n    }\\n\\n    /**\\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\\n     */\\n    function toUint(bool b) internal pure returns (uint256 u) {\\n        assembly (\\\"memory-safe\\\") {\\n            u := iszero(iszero(b))\\n        }\\n    }\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/utils/structs/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.20;\\n\\nimport {Arrays} from \\\"../Arrays.sol\\\";\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n * - Set can be cleared (all elements removed) in O(n).\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position is the index of the value in the `values` array plus 1.\\n        // Position 0 is used to mean a value is not in the set.\\n        mapping(bytes32 value =\\u003e uint256) _positions;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._positions[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We cache the value's position to prevent multiple reads from the same storage slot\\n        uint256 position = set._positions[value];\\n\\n        if (position != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 valueIndex = position - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (valueIndex != lastIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the lastValue to the index where the value to delete is\\n                set._values[valueIndex] = lastValue;\\n                // Update the tracked position of the lastValue (that was just moved)\\n                set._positions[lastValue] = position;\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the tracked position for the deleted slot\\n            delete set._positions[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes all the values from a set. O(n).\\n     *\\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\\n     */\\n    function _clear(Set storage set) private {\\n        uint256 len = _length(set);\\n        for (uint256 i = 0; i \\u003c len; ++i) {\\n            delete set._positions[set._values[i]];\\n        }\\n        Arrays.unsafeSetLength(set._values, 0);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._positions[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes all the values from a set. O(n).\\n     *\\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\\n     */\\n    function clear(Bytes32Set storage set) internal {\\n        _clear(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        assembly (\\\"memory-safe\\\") {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes all the values from a set. O(n).\\n     *\\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\\n     */\\n    function clear(AddressSet storage set) internal {\\n        _clear(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        assembly (\\\"memory-safe\\\") {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes all the values from a set. O(n).\\n     *\\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\\n     */\\n    function clear(UintSet storage set) internal {\\n        _clear(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        assembly (\\\"memory-safe\\\") {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"}}}"
