// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package message_hasher

var SolidityStandardInput = "{\"version\":\"v0.8.26+commit.8a97fa7a\",\"language\":\"Solidity\",\"settings\":{\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"appendCBOR\":true,\"bytecodeHash\":\"none\",\"useLiteralContent\":false},\"optimizer\":{\"enabled\":true,\"runs\":80000},\"outputSelection\":{\"contracts/libraries/Client.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/libraries/ExtraArgsCodec.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/test/helpers/MessageHasher.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]}},\"remappings\":[\"forge-std/=node_modules/@chainlink/contracts/src/v0.8/vendor/forge-std/src/\",\"@chainlink/ace/policy-management/=node_modules/@chainlink/ace/packages/policy-management/src/\",\"@chainlink/contracts/=node_modules/@chainlink/contracts/\",\"@openzeppelin/contracts@4.8.3/=node_modules/@openzeppelin/contracts-4.8.3/\",\"@openzeppelin/contracts@5.3.0/=node_modules/@openzeppelin/contracts-5.3.0/\",\"@arbitrum/=node_modules/@arbitrum/\",\"@eth-optimism/=node_modules/@eth-optimism/\",\"@offchainlabs/=node_modules/@offchainlabs/\",\"@scroll-tech/=node_modules/@scroll-tech/\",\"@zksync.bak/=node_modules/@zksync.bak/\",\"hardhat/=node_modules/@zksync.bak/contracts/l1-contracts/node_modules/hardhat/\",\"solady/=node_modules/solady/\"],\"viaIR\":true},\"sources\":{\"contracts/libraries/Client.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// End consumer library.\\nlibrary Client {\\n  struct EVMTokenAmount {\\n    address token; // token address on the local chain.\\n    uint256 amount; // Amount of tokens.\\n  }\\n\\n  struct Any2EVMMessage {\\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\\n    uint64 sourceChainSelector; // Source chain selector.\\n    bytes sender; // abi.encode(address) on EVM source chains; abi.decode(sender, (address)) to recover.\\n    bytes data; // payload sent in original message.\\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\\n  }\\n\\n  // If extraArgs is empty bytes, the default is 200k gas limit.\\n  struct EVM2AnyMessage {\\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains.\\n    bytes data; // Data payload.\\n    EVMTokenAmount[] tokenAmounts; // Token transfers.\\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV3).\\n  }\\n\\n  /// @notice Tag to indicate no execution on the destination chain. Execution will need to be done manually.\\n  /// @dev Preimage for this tag is: keccak256(\\\"NO_EXECUTION_TAG\\\")[:4]\\n  bytes4 public constant NO_EXECUTION_TAG = 0xeba517d2;\\n  address public constant NO_EXECUTION_ADDRESS = address(bytes20(NO_EXECUTION_TAG));\\n\\n  // ================================================================\\n  // │                           Legacy                             │\\n  // ================================================================\\n\\n  // Tag to indicate only a gas limit. Only usable for EVM as destination chain.\\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\\n\\n  struct EVMExtraArgsV1 {\\n    uint256 gasLimit;\\n  }\\n\\n  function _argsToBytes(\\n    EVMExtraArgsV1 memory extraArgs\\n  ) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\\n  }\\n\\n  // Tag to indicate a gas limit (or dest chain equivalent processing units) and Out Of Order Execution. This tag is\\n  // available for multiple chain families. If there is no chain family specific tag, this is the default available\\n  // for a chain.\\n  // Note: not available for Solana or Sui VM based chains.\\n  bytes4 public constant GENERIC_EXTRA_ARGS_V2_TAG = 0x181dcf10;\\n\\n  /// @param gasLimit: gas limit for the callback on the destination chain.\\n  /// @param allowOutOfOrderExecution: if true, it indicates that the message can be executed in any order relative to\\n  /// other messages from the same sender. This value's default varies by chain. On some chains, a particular value is\\n  /// enforced, meaning if the expected value is not set, the message request will revert.\\n  /// @dev Fully compatible with the previously existing EVMExtraArgsV2.\\n  struct GenericExtraArgsV2 {\\n    uint256 gasLimit;\\n    bool allowOutOfOrderExecution;\\n  }\\n\\n  // Extra args tag for chains that use the Sui VM.\\n  bytes4 public constant SUI_EXTRA_ARGS_V1_TAG = 0x21ea4ca9;\\n\\n  // Extra args tag for chains that use the Solana VM.\\n  bytes4 public constant SVM_EXTRA_ARGS_V1_TAG = 0x1f3b3aba;\\n\\n  struct SVMExtraArgsV1 {\\n    uint32 computeUnits;\\n    uint64 accountIsWritableBitmap;\\n    bool allowOutOfOrderExecution;\\n    bytes32 tokenReceiver;\\n    // Additional accounts needed for execution of CCIP receiver. Must be empty if message.receiver is zero.\\n    // Token transfer related accounts are specified in the token pool lookup table on SVM.\\n    bytes32[] accounts;\\n  }\\n\\n  /// @dev The maximum number of accounts that can be passed in SVMExtraArgs.\\n  uint256 public constant SVM_EXTRA_ARGS_MAX_ACCOUNTS = 64;\\n\\n  /// @dev The expected static payload size of a token transfer when Borsh encoded and submitted to SVM.\\n  /// TokenPool extra data and offchain data sizes are dynamic, and should be accounted for separately.\\n  uint256 public constant SVM_TOKEN_TRANSFER_DATA_OVERHEAD = (4 + 32) // source_pool\\n    + 32 // token_address\\n    + 4 // gas_amount\\n    + 4 // extra_data overhead\\n    + 32 // amount\\n    + 32 // size of the token lookup table account\\n    + 32 // token-related accounts in the lookup table, over-estimated to 32, typically between 11 - 13\\n    + 32 // token account belonging to the token receiver, e.g ATA, not included in the token lookup table\\n    + 32 // per-chain token pool config, not included in the token lookup table\\n    + 32 // per-chain token billing config, not always included in the token lookup table\\n    + 32; // OffRamp pool signer PDA, not included in the token lookup table\\n\\n  /// @dev Number of overhead accounts needed for message execution on SVM.\\n  /// @dev These are message.receiver, and the OffRamp Signer PDA specific to the receiver.\\n  uint256 public constant SVM_MESSAGING_ACCOUNTS_OVERHEAD = 2;\\n\\n  /// @dev The size of each SVM account address in bytes.\\n  uint256 public constant SVM_ACCOUNT_BYTE_SIZE = 32;\\n\\n  struct SuiExtraArgsV1 {\\n    uint256 gasLimit;\\n    bool allowOutOfOrderExecution;\\n    bytes32 tokenReceiver;\\n    bytes32[] receiverObjectIds;\\n  }\\n\\n  /// @dev The expected static payload size of a token transfer when BCS encoded and submitted to SUI.\\n  /// TokenPool extra data and offchain data sizes are dynamic, and should be accounted for separately.\\n  uint256 public constant SUI_TOKEN_TRANSFER_DATA_OVERHEAD = (4 + 32) // source_pool, 4 bytes for length, 32 bytes for address\\n    + 32 // dest_token_address\\n    + 4 // dest_gas_amount\\n    + 4 // extra_data length, the contents are calculated separately\\n    + 32; // amount\\n\\n  /// @dev Number of overhead accounts needed for message execution on SUI.\\n  /// @dev This is the message.receiver.\\n  uint256 public constant SUI_MESSAGING_ACCOUNTS_OVERHEAD = 1;\\n\\n  /// @dev The maximum number of receiver object ids that can be passed in SuiExtraArgs.\\n  uint256 public constant SUI_EXTRA_ARGS_MAX_RECEIVER_OBJECT_IDS = 64;\\n\\n  /// @dev The size of each SUI account address in bytes.\\n  uint256 public constant SUI_ACCOUNT_BYTE_SIZE = 32;\\n\\n  function _argsToBytes(\\n    GenericExtraArgsV2 memory extraArgs\\n  ) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(GENERIC_EXTRA_ARGS_V2_TAG, extraArgs);\\n  }\\n\\n  function _svmArgsToBytes(\\n    SVMExtraArgsV1 memory extraArgs\\n  ) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(SVM_EXTRA_ARGS_V1_TAG, extraArgs);\\n  }\\n\\n  function _suiArgsToBytes(\\n    SuiExtraArgsV1 memory extraArgs\\n  ) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(SUI_EXTRA_ARGS_V1_TAG, extraArgs);\\n  }\\n}\\n\"},\"contracts/libraries/ExtraArgsCodec.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Gas-optimized assembly version of ExtraArgsCodec library.\\nlibrary ExtraArgsCodec {\\n  error InvalidDataLength(EncodingErrorLocation location, uint256 offset);\\n  error InvalidExtraArgsTag(bytes4 expected, bytes4 actual);\\n  error InvalidAddressLength(uint256 length);\\n  error CCVArrayLengthMismatch(uint256 ccvsLength, uint256 ccvArgsLength);\\n\\n  bytes4 public constant GENERIC_EXTRA_ARGS_V3_TAG = 0xa69dd4aa;\\n  bytes4 public constant SVM_EXECUTOR_ARGS_V1_TAG = 0x1a2b3c4d;\\n  bytes4 public constant SUI_EXECUTOR_ARGS_V1_TAG = 0x5e6f7a8b;\\n\\n  // Base size excludes all variable-length fields (CCV addresses/args, executor address, executorArgs, tokenReceiver,\\n  // tokenArgs).\\n  // Encoding order: tag(4) + gasLimit(4) + blockConfirmations(2) + ccvsLength(1) + executorLength(1) +\\n  // executorArgsLength(2) + tokenReceiverLength(1) + tokenArgsLength(2) = 17 bytes.\\n  uint256 public constant GENERIC_EXTRA_ARGS_V3_BASE_SIZE = 4 + 4 + 2 + 1 + 1 + 2 + 1 + 2;\\n  uint256 public constant GENERIC_EXTRA_ARGS_V3_STATIC_LENGTH_SIZE = 4 + 4 + 2 + 1;\\n  // Base size: tag(4) + useATA(1) + accountIsWritableBitmap(8) + accountsLength(1) = 14 bytes.\\n  uint256 public constant SVM_EXECUTOR_ARGS_V1_BASE_SIZE = 4 + 1 + 8 + 1;\\n  // Base size: tag(4) + objectIdsLength(1) = 5 bytes.\\n  uint256 public constant SUI_EXECUTOR_ARGS_V1_BASE_SIZE = 4 + 1;\\n\\n  // Enum to indicate specific error locations during encoding/decoding.\\n  enum EncodingErrorLocation {\\n    // Generic decoding errors (used in helper functions).\\n    DECODE_FIELD_LENGTH, // 0 - Error reading a field's length prefix.\\n    DECODE_FIELD_CONTENT, // 1 - Error reading a field's content/payload.\\n    // Specific decoding errors (used in main decoding functions).\\n    EXTRA_ARGS_STATIC_LENGTH_FIELDS, // 2\\n    EXTRA_ARGS_FINAL_OFFSET, // 3\\n    SVM_EXECUTOR_ACCOUNTS_CONTENT, // 4\\n    SVM_EXECUTOR_FINAL_OFFSET, // 5\\n    SUI_EXECUTOR_OBJECT_IDS_CONTENT, // 6\\n    SUI_EXECUTOR_FINAL_OFFSET, // 7\\n    // Encoding validation errors.\\n    ENCODE_CCVS_ARRAY_LENGTH, // 8\\n    ENCODE_CCV_ARGS_LENGTH, // 9\\n    ENCODE_EXECUTOR_ARGS_LENGTH, // 10\\n    ENCODE_TOKEN_RECEIVER_LENGTH, // 11\\n    ENCODE_TOKEN_ARGS_LENGTH, // 12\\n    ENCODE_SVM_ACCOUNTS_LENGTH, // 13\\n    ENCODE_SUI_OBJECT_IDS_LENGTH // 14\\n  }\\n\\n  /// @notice GenericExtraArgsV3 encoding format used for CCIP messages.\\n  /// Static length fields.\\n  ///   bytes4 tag;                     Version tag.\\n  ///   uint32 gasLimit;                Gas limit for the callback on the destination chain.\\n  ///   uint16 blockConfirmations;      Number of block confirmations to wait for (0 = default finality).\\n  ///   uint8 ccvsLength;               Number of cross-chain verifiers.\\n  ///\\n  /// Variable length fields (per CCV, repeated ccvsLength times).\\n  ///   uint8 ccvAddressLength;         Length of the CCV address in bytes (0 or 20 for EVM addresses).\\n  ///   bytes ccvAddress;               CCV address as unpadded bytes (20 bytes for EVM addresses if non-zero).\\n  ///   uint16 ccvArgsLength;           Length of the CCV-specific arguments in bytes.\\n  ///   bytes ccvArgs;                  CCV-specific arguments.\\n  ///\\n  /// Variable length fields (executor and token config).\\n  ///   uint8 executorLength;           Length of the executor address in bytes (0 or 20 for EVM addresses).\\n  ///   bytes executor;                 Executor address as unpadded bytes (20 bytes for EVM addresses if non-zero).\\n  ///   uint16 executorArgsLength;      Length of the executor arguments in bytes.\\n  ///   bytes executorArgs;             Destination chain family-specific executor arguments.\\n  ///   uint8 tokenReceiverLength;      Length of the token receiver address in bytes (0 or 20 for EVM addresses).\\n  ///   bytes tokenReceiver;            Token receiver address as unpadded bytes (20 bytes for EVM addresses if non-zero).\\n  ///   uint16 tokenArgsLength;         Length of the token arguments in bytes.\\n  ///   bytes tokenArgs;                Token pool-specific arguments.\\n  // solhint-disable-next-line gas-struct-packing\\n  struct GenericExtraArgsV3 {\\n    /// @notice Gas limit for the callback on the destination chain. If the gas limit is zero and the message data\\n    /// length is also zero, no callback will be performed, even if a receiver is specified. A gas limit of zero is\\n    /// useful when only token transfers are desired, or when the receiver is an EOA account instead of a contract.\\n    /// Besides this gasLimit check, there are other checks on the destination chain that may prevent the callback from\\n    /// being executed, depending on the destination chain family.\\n    /// @dev The sender is billed for the gas specified, not the gas actually used. Any unspent gas is not refunded.\\n    /// There are various ways to estimate the gas required for a callback on the destination chain, depending on the\\n    /// chain family. Please refer to the documentation for each chain for more details.\\n    uint32 gasLimit;\\n    /// @notice The number of block confirmations to wait for. 0 means the default finality that the CCV considers\\n    /// final. Any non-zero value means a block depth. CCVs, Pools and the executor may all reject this value by\\n    /// reverting the transaction on the source chain if they do not want to take on the risk of the block depth\\n    /// specified.\\n    /// @dev May be zero to indicate waiting for finality is desired.\\n    uint16 blockConfirmations;\\n    /// @notice An array of CCV addresses representing the cross-chain verifiers to be used for the message.\\n    /// @dev May be empty to specify the default verifier(s) should be used.\\n    address[] ccvs;\\n    /// @notice Optional arguments that are passed into the CCV without modification or inspection. CCIP itself does not\\n    /// interpret these arguments: they are encoded in whatever format the CCV has decided.\\n    /// @dev Must be the same length as the `ccvs` array. May have empty bytes as arguments.\\n    bytes[] ccvArgs;\\n    /// @notice Address of the executor contract on the source chain. The executor is responsible for executing the\\n    /// message on the destination chains once a quorum of CCVs have verified the message.\\n    /// @dev May be address(0) to indicate the default executor should be used.\\n    address executor;\\n    /// @notice Destination chain family specific arguments for the executor. This field is passed to the destination\\n    /// chain as part of the message itself and these args are therefore fully protected through the message ID. The\\n    /// format of this field is specific to each chain family and is not interpreted by CCIP itself, only by the\\n    /// executor. Things that may be included here are Solana accounts or Sui object IDs, which must be secured through\\n    /// the message ID as passing in incorrect values can lead to loss of funds.\\n    /// @dev May be empty depending on the destination chain.\\n    bytes executorArgs;\\n    /// @notice Address of the token receiver on the destination chain, in bytes format. If an empty bytes array is\\n    /// provided, the receiver address from the message itself is used for token transfers. This field allows for\\n    /// scenarios where the token receiver is different from the message receiver.\\n    /// @dev May be empty, the behavior differs depending on if there is a token transfer or not:\\n    /// - If there is a token transfer, the receiver from the message is used.\\n    /// - If there is no token transfer, this field should be empty.\\n    bytes tokenReceiver;\\n    /// @notice Additional arguments for token transfers. This field is passed into the token pool on the source chain\\n    /// and is not inspected by CCIP itself. The format of this field is therefore specific to the token pool being used\\n    /// and may vary between different pools.\\n    /// @dev May be empty depending on the token pool.\\n    bytes tokenArgs;\\n  }\\n\\n  /// @notice Creates a basic encoded GenericExtraArgsV3 with only gasLimit and blockConfirmations set.\\n  /// @param gasLimit The gas limit for the callback on the destination chain.\\n  /// @param blockConfirmations The user requested number of block confirmations.\\n  /// @return encoded The encoded extra args as bytes. These are ready to be passed into CCIP functions.\\n  function _getBasicEncodedExtraArgsV3(\\n    uint32 gasLimit,\\n    uint16 blockConfirmations\\n  ) internal pure returns (bytes memory) {\\n    return abi.encodePacked(GENERIC_EXTRA_ARGS_V3_TAG, gasLimit, blockConfirmations, bytes7(0));\\n  }\\n\\n  enum SVMTokenReceiverUsage {\\n    DERIVE_ATA_AND_CREATE,\\n    DERIVE_ATA_DONT_CREATE,\\n    USE_AS_IS\\n  }\\n\\n  struct SVMExecutorArgsV1 {\\n    SVMTokenReceiverUsage useATA;\\n    uint64 accountIsWritableBitmap;\\n    // Additional accounts needed for execution of CCIP receiver. Must be empty if message.receiver is zero.\\n    // Token transfer related accounts are specified in the token pool lookup table on SVM.\\n    bytes32[] accounts;\\n  }\\n\\n  struct SuiExecutorArgsV1 {\\n    bytes32[] receiverObjectIds;\\n  }\\n\\n  /// @notice Helper function to read a uint8 length prefix and an address from calldata.\\n  /// @dev Reads length as 1 byte followed by the address bytes (20 bytes if non-zero).\\n  /// @param encoded The encoded bytes to read from.\\n  /// @param offset The current offset in the encoded bytes.\\n  /// @return addr The address read from calldata (address(0) if length was 0).\\n  /// @return newOffset The updated offset after reading.\\n  function _readUint8PrefixedAddress(\\n    bytes calldata encoded,\\n    uint256 offset\\n  ) private pure returns (address addr, uint256 newOffset) {\\n    // Unchecked is safe as the offset can never approach type(uint256).max.\\n    unchecked {\\n      // Read address length (1 byte).\\n      if (offset + 1 \\u003e encoded.length) revert InvalidDataLength(EncodingErrorLocation.DECODE_FIELD_LENGTH, offset);\\n      uint256 addrLength;\\n      assembly (\\\"memory-safe\\\") {\\n        addrLength := byte(0, calldataload(add(encoded.offset, offset)))\\n      }\\n      newOffset = offset + 1;\\n\\n      // If the address is zero length, we are done and return address(0).\\n      if (addrLength == 0) {\\n        return (address(0), newOffset);\\n      }\\n\\n      // Validate address length 20 as these extraArgs are for EVM and the only valid address length is 20.\\n      if (addrLength != 20) {\\n        revert InvalidAddressLength(addrLength);\\n      }\\n\\n      // Read address content, unchecked is safe as the offset can never approach type(uint256).max.\\n      if (newOffset + addrLength \\u003e encoded.length) {\\n        revert InvalidDataLength(EncodingErrorLocation.DECODE_FIELD_CONTENT, newOffset);\\n      }\\n\\n      assembly (\\\"memory-safe\\\") {\\n        let addrData := calldataload(add(encoded.offset, newOffset))\\n        addr := shr(96, addrData)\\n      }\\n      newOffset += addrLength;\\n    }\\n    return (addr, newOffset);\\n  }\\n\\n  /// @notice Helper function to read a uint16 length prefix and bytes data from calldata.\\n  /// @dev Reads length as 2 bytes (big endian) followed by the data bytes.\\n  /// @param encoded The encoded bytes to read from.\\n  /// @param offset The current offset in the encoded bytes.\\n  /// @return data The bytes data read from calldata.\\n  /// @return newOffset The updated offset after reading.\\n  function _readUint16PrefixedBytes(\\n    bytes calldata encoded,\\n    uint256 offset\\n  ) private pure returns (bytes calldata data, uint256 newOffset) {\\n    // Unchecked is safe as the offset can never approach type(uint256).max.\\n    unchecked {\\n      // Read length (2 bytes).\\n      if (offset + 2 \\u003e encoded.length) revert InvalidDataLength(EncodingErrorLocation.DECODE_FIELD_LENGTH, offset);\\n      uint256 dataLength;\\n      assembly (\\\"memory-safe\\\") {\\n        let lengthData := calldataload(add(encoded.offset, offset))\\n        dataLength := and(shr(240, lengthData), 0xFFFF)\\n      }\\n      newOffset = offset + 2;\\n\\n      if (newOffset + dataLength \\u003e encoded.length) {\\n        revert InvalidDataLength(EncodingErrorLocation.DECODE_FIELD_CONTENT, newOffset);\\n      }\\n\\n      // Read content.\\n      data = encoded[newOffset:newOffset + dataLength];\\n      newOffset += dataLength;\\n    }\\n    return (data, newOffset);\\n  }\\n\\n  /// @notice Helper function to read a uint8 length prefix and bytes data from calldata.\\n  /// @dev Reads length as 1 byte followed by the data bytes.\\n  /// @param encoded The encoded bytes to read from.\\n  /// @param offset The current offset in the encoded bytes.\\n  /// @return data The bytes data read from calldata.\\n  /// @return newOffset The updated offset after reading.\\n  function _readUint8PrefixedBytes(\\n    bytes calldata encoded,\\n    uint256 offset\\n  ) private pure returns (bytes calldata data, uint256 newOffset) {\\n    // Unchecked is safe as the offset can never approach type(uint256).max.\\n    unchecked {\\n      // Read length (1 byte).\\n      if (offset + 1 \\u003e encoded.length) revert InvalidDataLength(EncodingErrorLocation.DECODE_FIELD_LENGTH, offset);\\n      uint256 dataLength;\\n      assembly (\\\"memory-safe\\\") {\\n        dataLength := byte(0, calldataload(add(encoded.offset, offset)))\\n      }\\n      newOffset = offset + 1;\\n\\n      if (newOffset + dataLength \\u003e encoded.length) {\\n        revert InvalidDataLength(EncodingErrorLocation.DECODE_FIELD_CONTENT, newOffset);\\n      }\\n\\n      // Read content.\\n      data = encoded[newOffset:newOffset + dataLength];\\n      newOffset += dataLength;\\n    }\\n    return (data, newOffset);\\n  }\\n\\n  /// @notice Helper function to write a uint8 length prefix and an address. This function writes 12 bytes of overshoot\\n  /// to the pointer location. This must be handled by the caller.\\n  /// @dev Writes length as 1 byte followed by the address bytes (20 bytes if non-zero).\\n  /// @param ptr The memory pointer where to start writing.\\n  /// @param addr The address to write.\\n  /// @return newPtr The updated memory pointer after writing.\\n  function _writeUint8PrefixedAddress(\\n    uint256 ptr,\\n    address addr\\n  ) private pure returns (uint256 newPtr) {\\n    assembly {\\n      let addrLength := mul(iszero(iszero(addr)), 20)\\n      // Write address length (1 byte).\\n      mstore8(ptr, addrLength)\\n      newPtr := add(ptr, 1)\\n\\n      // Write address if non-zero.\\n      if gt(addrLength, 0) {\\n        mstore(newPtr, shl(96, addr))\\n        newPtr := add(newPtr, 20)\\n      }\\n    }\\n    return newPtr;\\n  }\\n\\n  /// @notice Helper function to write a uint16 length prefix and copy bytes data. This function can write overshoot\\n  /// to the pointer location of at most 31 bytes. This must be handled by the caller. The overshoot depends on the data\\n  /// length.\\n  /// @dev Writes length as 2 bytes (big endian) followed by the data bytes.\\n  /// @param ptr The memory pointer where to start writing.\\n  /// @param data The bytes data to write.\\n  /// @return newPtr The updated memory pointer after writing.\\n  function _writeUint16PrefixedBytes(\\n    uint256 ptr,\\n    bytes memory data\\n  ) private pure returns (uint256 newPtr) {\\n    uint256 dataLength = data.length;\\n    assembly {\\n      // Write length (2 bytes, big endian).\\n      mstore8(ptr, shr(8, dataLength))\\n      mstore8(add(ptr, 1), and(dataLength, 0xFF))\\n      newPtr := add(ptr, 2)\\n\\n      // Copy data.\\n      if gt(dataLength, 0) {\\n        let srcPtr := add(data, 32)\\n        for { let end := add(srcPtr, dataLength) } lt(srcPtr, end) { srcPtr := add(srcPtr, 32) } {\\n          mstore(newPtr, mload(srcPtr))\\n          newPtr := add(newPtr, 32)\\n        }\\n        // Adjust ptr if we overshot.\\n        newPtr := sub(newPtr, sub(and(add(dataLength, 31), not(31)), dataLength))\\n      }\\n    }\\n    return newPtr;\\n  }\\n\\n  /// @notice Helper function to write a uint8 length prefix and copy bytes data. This function can write overshoot\\n  /// to the pointer location of at most 31 bytes. This must be handled by the caller. The overshoot depends on the data\\n  /// length.\\n  /// @dev Writes length as 1 byte followed by the data bytes.\\n  /// @param ptr The memory pointer where to start writing.\\n  /// @param data The bytes data to write.\\n  /// @return newPtr The updated memory pointer after writing.\\n  function _writeUint8PrefixedBytes(\\n    uint256 ptr,\\n    bytes memory data\\n  ) private pure returns (uint256 newPtr) {\\n    uint256 dataLength = data.length;\\n    assembly {\\n      // Write length (1 byte).\\n      mstore8(ptr, dataLength)\\n      newPtr := add(ptr, 1)\\n\\n      // Copy data.\\n      if gt(dataLength, 0) {\\n        let srcPtr := add(data, 32)\\n        for { let end := add(srcPtr, dataLength) } lt(srcPtr, end) { srcPtr := add(srcPtr, 32) } {\\n          mstore(newPtr, mload(srcPtr))\\n          newPtr := add(newPtr, 32)\\n        }\\n        // Adjust ptr if we overshot.\\n        newPtr := sub(newPtr, sub(and(add(dataLength, 31), not(31)), dataLength))\\n      }\\n    }\\n    return newPtr;\\n  }\\n\\n  /// @notice Encodes a GenericExtraArgsV3 struct into bytes using assembly for gas efficiency.\\n  /// @param extraArgs The GenericExtraArgsV3 struct to encode.\\n  /// @return encoded The encoded extra args as bytes.\\n  function _encodeGenericExtraArgsV3(\\n    GenericExtraArgsV3 memory extraArgs\\n  ) internal pure returns (bytes memory encoded) {\\n    // Validate ccvs and ccvArgs arrays have the same length.\\n    uint256 ccvsLength = extraArgs.ccvs.length;\\n    if (ccvsLength != extraArgs.ccvArgs.length) {\\n      revert CCVArrayLengthMismatch(ccvsLength, extraArgs.ccvArgs.length);\\n    }\\n\\n    // Validate field lengths.\\n    if (ccvsLength \\u003e type(uint8).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_CCVS_ARRAY_LENGTH, 0);\\n    }\\n    uint256 executorArgsLength = extraArgs.executorArgs.length;\\n    if (executorArgsLength \\u003e type(uint16).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_EXECUTOR_ARGS_LENGTH, 0);\\n    }\\n    uint256 tokenReceiverLength = extraArgs.tokenReceiver.length;\\n    if (tokenReceiverLength \\u003e type(uint8).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_TOKEN_RECEIVER_LENGTH, 0);\\n    }\\n    uint256 tokenArgsLength = extraArgs.tokenArgs.length;\\n    if (tokenArgsLength \\u003e type(uint16).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_TOKEN_ARGS_LENGTH, 0);\\n    }\\n\\n    // Calculate executor length.\\n    uint256 executorLength = extraArgs.executor == address(0) ? 0 : 20;\\n\\n    // Calculate total CCV encoded size and validate.\\n    uint256 ccvsEncodedSize = 0;\\n    for (uint256 i = 0; i \\u003c ccvsLength; ++i) {\\n      uint256 ccvAddrLength = extraArgs.ccvs[i] == address(0) ? 0 : 20;\\n\\n      uint256 ccvArgLength = extraArgs.ccvArgs[i].length;\\n      if (ccvArgLength \\u003e type(uint16).max) {\\n        revert InvalidDataLength(EncodingErrorLocation.ENCODE_CCV_ARGS_LENGTH, 0);\\n      }\\n\\n      // 1 byte for address length + address bytes + 2 bytes for args length + args bytes.\\n      ccvsEncodedSize += 1 + ccvAddrLength + 2 + ccvArgLength;\\n    }\\n\\n    // Allocate memory.\\n    // GENERIC_EXTRA_ARGS_V3_BASE_SIZE + all variable-length fields + 32 bytes to account for any potential overshoot\\n    // that comes from writing 32-byte blocks of data.\\n    encoded = new bytes(\\n      GENERIC_EXTRA_ARGS_V3_BASE_SIZE + ccvsEncodedSize + executorLength + executorArgsLength + tokenReceiverLength\\n        + tokenArgsLength + 32\\n    );\\n\\n    bytes memory staticFields =\\n      abi.encodePacked(GENERIC_EXTRA_ARGS_V3_TAG, extraArgs.gasLimit, extraArgs.blockConfirmations, uint8(ccvsLength));\\n\\n    uint256 ptr;\\n    // This block is memory safe because it only writes to the allocated `encoded` bytes.\\n    assembly (\\\"memory-safe\\\") {\\n      ptr := add(encoded, 32) // Skip length prefix.\\n\\n      // Write static-length fields.\\n      mstore(ptr, mload(add(staticFields, 32)))\\n      ptr := add(ptr, 11)\\n    }\\n\\n    // Write CCVs data.\\n    for (uint256 i = 0; i \\u003c ccvsLength; ++i) {\\n      ptr = _writeUint8PrefixedAddress(ptr, extraArgs.ccvs[i]);\\n      ptr = _writeUint16PrefixedBytes(ptr, extraArgs.ccvArgs[i]);\\n    }\\n\\n    // Write executor, executorArgs, tokenReceiver, tokenArgs.\\n    ptr = _writeUint8PrefixedAddress(ptr, extraArgs.executor);\\n    ptr = _writeUint16PrefixedBytes(ptr, extraArgs.executorArgs);\\n    ptr = _writeUint8PrefixedBytes(ptr, extraArgs.tokenReceiver);\\n    ptr = _writeUint16PrefixedBytes(ptr, extraArgs.tokenArgs);\\n\\n    // Verify that we've exactly filled the allocated bytes. We load the data offset of the bytes array to be able to\\n    // compare with ptr.\\n    uint256 encodedDataOffset;\\n    assembly (\\\"memory-safe\\\") {\\n      mstore(encoded, sub(mload(encoded), 32)) // Set correct length as we overprovisioned for overshoot.\\n      encodedDataOffset := encoded\\n    }\\n    // The pointer should be at the end of the allocated data (data offset + length + 32 bytes for length prefix).\\n    if (ptr != encodedDataOffset + encoded.length + 32) {\\n      revert InvalidDataLength(EncodingErrorLocation.EXTRA_ARGS_FINAL_OFFSET, ptr - encodedDataOffset);\\n    }\\n\\n    return encoded;\\n  }\\n\\n  /// @notice Decodes bytes into a GenericExtraArgsV3 struct using assembly for gas efficiency.\\n  /// @param encoded The encoded bytes to decode.\\n  /// @return extraArgs The decoded GenericExtraArgsV3 struct.\\n  function _decodeGenericExtraArgsV3(\\n    bytes calldata encoded\\n  ) internal pure returns (GenericExtraArgsV3 memory extraArgs) {\\n    // Check if encodedLength is at least the minimum size.\\n    if (encoded.length \\u003c GENERIC_EXTRA_ARGS_V3_BASE_SIZE) {\\n      revert InvalidDataLength(EncodingErrorLocation.EXTRA_ARGS_STATIC_LENGTH_FIELDS, encoded.length);\\n    }\\n\\n    // Check tag.\\n    bytes4 tag;\\n    assembly (\\\"memory-safe\\\") {\\n      tag := calldataload(encoded.offset)\\n    }\\n\\n    if (tag != GENERIC_EXTRA_ARGS_V3_TAG) {\\n      revert InvalidExtraArgsTag(GENERIC_EXTRA_ARGS_V3_TAG, tag);\\n    }\\n\\n    uint256 ccvsLength;\\n    // Read static-length fields.\\n    assembly (\\\"memory-safe\\\") {\\n      // Read gas limit (4 bytes).\\n      let gasLimit := calldataload(add(encoded.offset, 4))\\n      mstore(extraArgs, and(shr(224, gasLimit), 0xFFFFFFFF))\\n\\n      // Read block confirmations (2 bytes).\\n      let blockConfirmations := calldataload(add(encoded.offset, 8))\\n      mstore(add(extraArgs, 32), and(shr(240, blockConfirmations), 0xFFFF))\\n\\n      // Read ccvs length (1 byte).\\n      ccvsLength := byte(0, calldataload(add(encoded.offset, 10)))\\n    }\\n\\n    uint256 offset = GENERIC_EXTRA_ARGS_V3_STATIC_LENGTH_SIZE; // Skip tag, gasLimit, blockConfirmations, ccvsLength.\\n\\n    // Allocate arrays for CCVs.\\n    extraArgs.ccvs = new address[](ccvsLength);\\n    extraArgs.ccvArgs = new bytes[](ccvsLength);\\n\\n    // Decode CCVs and args.\\n    for (uint256 i = 0; i \\u003c ccvsLength; ++i) {\\n      (extraArgs.ccvs[i], offset) = _readUint8PrefixedAddress(encoded, offset);\\n      (extraArgs.ccvArgs[i], offset) = _readUint16PrefixedBytes(encoded, offset);\\n    }\\n\\n    // Read executor, executorArgs, tokenReceiver, and tokenArgs.\\n    (extraArgs.executor, offset) = _readUint8PrefixedAddress(encoded, offset);\\n    (extraArgs.executorArgs, offset) = _readUint16PrefixedBytes(encoded, offset);\\n    (extraArgs.tokenReceiver, offset) = _readUint8PrefixedBytes(encoded, offset);\\n    (extraArgs.tokenArgs, offset) = _readUint16PrefixedBytes(encoded, offset);\\n\\n    // Ensure we've consumed all bytes.\\n    if (offset != encoded.length) revert InvalidDataLength(EncodingErrorLocation.EXTRA_ARGS_FINAL_OFFSET, offset);\\n\\n    return extraArgs;\\n  }\\n\\n  /// @notice Encodes a SVMExecutorArgsV1 struct into bytes.\\n  /// @param executorArgs The SVMExecutorArgsV1 struct to encode.\\n  /// @return encoded The encoded executor args as bytes.\\n  function _encodeSVMExecutorArgsV1(\\n    SVMExecutorArgsV1 memory executorArgs\\n  ) internal pure returns (bytes memory encoded) {\\n    uint256 accountsLength = executorArgs.accounts.length;\\n    if (accountsLength \\u003e type(uint8).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_SVM_ACCOUNTS_LENGTH, 0);\\n    }\\n\\n    return abi.encodePacked(\\n      SVM_EXECUTOR_ARGS_V1_TAG,\\n      uint8(executorArgs.useATA),\\n      executorArgs.accountIsWritableBitmap,\\n      uint8(accountsLength),\\n      executorArgs.accounts\\n    );\\n  }\\n\\n  /// @notice Decodes bytes into a SVMExecutorArgsV1 struct using assembly.\\n  /// @param encoded The encoded bytes to decode.\\n  /// @return executorArgs The decoded SVMExecutorArgsV1 struct.\\n  function _decodeSVMExecutorArgsV1(\\n    bytes calldata encoded\\n  ) internal pure returns (SVMExecutorArgsV1 memory executorArgs) {\\n    // Unchecked is safe as the offset can never approach type(uint256).max.\\n    unchecked {\\n      if (encoded.length \\u003c SVM_EXECUTOR_ARGS_V1_BASE_SIZE) {\\n        revert InvalidDataLength(EncodingErrorLocation.EXTRA_ARGS_STATIC_LENGTH_FIELDS, encoded.length);\\n      }\\n\\n      // Check tag.\\n      bytes4 tag;\\n      assembly (\\\"memory-safe\\\") {\\n        tag := calldataload(encoded.offset)\\n      }\\n\\n      if (tag != SVM_EXECUTOR_ARGS_V1_TAG) {\\n        revert InvalidExtraArgsTag(SVM_EXECUTOR_ARGS_V1_TAG, tag);\\n      }\\n\\n      uint256 accountsLength;\\n\\n      // Read static-length fields.\\n      assembly (\\\"memory-safe\\\") {\\n        // Read useATA (1 byte) - enum value.\\n        let useATA := byte(0, calldataload(add(encoded.offset, 4)))\\n        mstore(executorArgs, useATA)\\n\\n        // Read accountIsWritableBitmap (8 bytes).\\n        let bitmap := calldataload(add(encoded.offset, 5))\\n        mstore(add(executorArgs, 32), and(shr(192, bitmap), 0xFFFFFFFFFFFFFFFF))\\n\\n        // Read accounts length (1 byte).\\n        accountsLength := byte(0, calldataload(add(encoded.offset, 13)))\\n      }\\n\\n      uint256 offset = SVM_EXECUTOR_ARGS_V1_BASE_SIZE;\\n\\n      // Read accounts.\\n      if (offset + accountsLength * 32 \\u003e encoded.length) {\\n        revert InvalidDataLength(EncodingErrorLocation.SVM_EXECUTOR_ACCOUNTS_CONTENT, offset);\\n      }\\n\\n      executorArgs.accounts = new bytes32[](accountsLength);\\n      for (uint256 i = 0; i \\u003c accountsLength; ++i) {\\n        assembly (\\\"memory-safe\\\") {\\n          let data := calldataload(add(add(encoded.offset, offset), mul(i, 32)))\\n          let accountsArray := mload(add(executorArgs, 64))\\n          mstore(add(add(accountsArray, 32), mul(i, 32)), data)\\n        }\\n      }\\n      offset += accountsLength * 32;\\n\\n      // Ensure we've consumed all bytes.\\n      if (offset != encoded.length) revert InvalidDataLength(EncodingErrorLocation.SVM_EXECUTOR_FINAL_OFFSET, offset);\\n    }\\n    return executorArgs;\\n  }\\n\\n  /// @notice Encodes a SuiExecutorArgsV1 struct into bytes.\\n  /// @param executorArgs The SuiExecutorArgsV1 struct to encode.\\n  /// @return encoded The encoded executor args as bytes.\\n  function _encodeSuiExecutorArgsV1(\\n    SuiExecutorArgsV1 memory executorArgs\\n  ) internal pure returns (bytes memory encoded) {\\n    uint256 objectIdsLength = executorArgs.receiverObjectIds.length;\\n    if (objectIdsLength \\u003e type(uint8).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_SUI_OBJECT_IDS_LENGTH, 0);\\n    }\\n\\n    return abi.encodePacked(SUI_EXECUTOR_ARGS_V1_TAG, uint8(objectIdsLength), executorArgs.receiverObjectIds);\\n  }\\n\\n  /// @notice Decodes bytes into a SuiExecutorArgsV1 struct using assembly.\\n  /// @param encoded The encoded bytes to decode.\\n  /// @return executorArgs The decoded SuiExecutorArgsV1 struct.\\n  function _decodeSuiExecutorArgsV1(\\n    bytes calldata encoded\\n  ) internal pure returns (SuiExecutorArgsV1 memory executorArgs) {\\n    // Unchecked is safe as the offset can never approach type(uint256).max.\\n    unchecked {\\n      if (encoded.length \\u003c SUI_EXECUTOR_ARGS_V1_BASE_SIZE) {\\n        revert InvalidDataLength(EncodingErrorLocation.EXTRA_ARGS_STATIC_LENGTH_FIELDS, encoded.length);\\n      }\\n\\n      // Check tag.\\n      bytes4 tag;\\n      assembly (\\\"memory-safe\\\") {\\n        tag := calldataload(encoded.offset)\\n      }\\n\\n      if (tag != SUI_EXECUTOR_ARGS_V1_TAG) {\\n        revert InvalidExtraArgsTag(SUI_EXECUTOR_ARGS_V1_TAG, tag);\\n      }\\n\\n      // Read objectIds length.\\n      uint256 objectIdsLength;\\n      assembly (\\\"memory-safe\\\") {\\n        objectIdsLength := byte(0, calldataload(add(encoded.offset, 4)))\\n      }\\n\\n      uint256 offset = SUI_EXECUTOR_ARGS_V1_BASE_SIZE;\\n      // Read objectIds.\\n      if (offset + objectIdsLength * 32 \\u003e encoded.length) {\\n        revert InvalidDataLength(EncodingErrorLocation.SUI_EXECUTOR_OBJECT_IDS_CONTENT, offset);\\n      }\\n\\n      executorArgs.receiverObjectIds = new bytes32[](objectIdsLength);\\n      for (uint256 i = 0; i \\u003c objectIdsLength; ++i) {\\n        assembly (\\\"memory-safe\\\") {\\n          let data := calldataload(add(add(encoded.offset, offset), mul(i, 32)))\\n          let objectIdsArray := mload(executorArgs)\\n          mstore(add(add(objectIdsArray, 32), mul(i, 32)), data)\\n        }\\n      }\\n      offset += objectIdsLength * 32;\\n\\n      // Ensure we've consumed all bytes.\\n      if (offset != encoded.length) revert InvalidDataLength(EncodingErrorLocation.SUI_EXECUTOR_FINAL_OFFSET, offset);\\n    }\\n    return executorArgs;\\n  }\\n}\\n\"},\"contracts/test/helpers/MessageHasher.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.4;\\n\\nimport {Client} from \\\"../../libraries/Client.sol\\\";\\nimport {ExtraArgsCodec} from \\\"../../libraries/ExtraArgsCodec.sol\\\";\\n\\ncontract MessageHasher {\\n  function encodeEVMExtraArgsV1(\\n    Client.EVMExtraArgsV1 memory extraArgs\\n  ) public pure returns (bytes memory) {\\n    return Client._argsToBytes(extraArgs);\\n  }\\n\\n  function encodeEVMExtraArgsV2(\\n    Client.GenericExtraArgsV2 memory extraArgs\\n  ) public pure returns (bytes memory) {\\n    return Client._argsToBytes(extraArgs);\\n  }\\n\\n  function encodeGenericExtraArgsV2(\\n    Client.GenericExtraArgsV2 memory extraArgs\\n  ) public pure returns (bytes memory) {\\n    return Client._argsToBytes(extraArgs);\\n  }\\n\\n  function encodeGenericExtraArgsV3(\\n    ExtraArgsCodec.GenericExtraArgsV3 memory extraArgs\\n  ) public pure returns (bytes memory) {\\n    return ExtraArgsCodec._encodeGenericExtraArgsV3(extraArgs);\\n  }\\n\\n  function decodeEVMExtraArgsV1(\\n    uint256 gasLimit\\n  ) public pure returns (Client.EVMExtraArgsV1 memory) {\\n    return Client.EVMExtraArgsV1(gasLimit);\\n  }\\n\\n  function decodeGenericExtraArgsV2(\\n    uint256 gasLimit,\\n    bool allowOutOfOrderExecution\\n  ) public pure returns (Client.GenericExtraArgsV2 memory) {\\n    return Client.GenericExtraArgsV2({gasLimit: gasLimit, allowOutOfOrderExecution: allowOutOfOrderExecution});\\n  }\\n\\n  function decodeEVMExtraArgsV2(\\n    uint256 gasLimit,\\n    bool allowOutOfOrderExecution\\n  ) public pure returns (Client.GenericExtraArgsV2 memory) {\\n    return Client.GenericExtraArgsV2({gasLimit: gasLimit, allowOutOfOrderExecution: allowOutOfOrderExecution});\\n  }\\n\\n  function encodeSVMExtraArgsV1(\\n    Client.SVMExtraArgsV1 memory extraArgs\\n  ) public pure returns (bytes memory) {\\n    return Client._svmArgsToBytes(extraArgs);\\n  }\\n\\n  function encodeSUIExtraArgsV1(\\n    Client.SuiExtraArgsV1 memory extraArgs\\n  ) public pure returns (bytes memory) {\\n    return Client._suiArgsToBytes(extraArgs);\\n  }\\n\\n  /// @notice used offchain to decode an encoded SVMExtraArgsV1 struct.\\n  /// @dev The unrolled version fails due to differences in encoding when the accounts[] array\\n  /// is empty or not.\\n  function decodeSVMExtraArgsStruct(\\n    Client.SVMExtraArgsV1 memory extraArgs\\n  )\\n    public\\n    pure\\n    returns (\\n      uint32 computeUnits,\\n      uint64 accountIsWritableBitmap,\\n      bool allowOutOfOrderExecution,\\n      bytes32 tokenReceiver,\\n      bytes32[] memory accounts\\n    )\\n  {\\n    return (\\n      extraArgs.computeUnits,\\n      extraArgs.accountIsWritableBitmap,\\n      extraArgs.allowOutOfOrderExecution,\\n      extraArgs.tokenReceiver,\\n      extraArgs.accounts\\n    );\\n  }\\n\\n  /// @notice Used offchain to decode an encoded SuiExtraArgsV1 struct.\\n  function decodeSuiExtraArgsStruct(\\n    Client.SuiExtraArgsV1 memory extraArgs\\n  )\\n    public\\n    pure\\n    returns (uint256 gasLimit, bool allowOutOfOrderExecution, bytes32 tokenReceiver, bytes32[] memory receiverObjectIds)\\n  {\\n    return\\n      (extraArgs.gasLimit, extraArgs.allowOutOfOrderExecution, extraArgs.tokenReceiver, extraArgs.receiverObjectIds);\\n  }\\n}\\n\"}}}"
