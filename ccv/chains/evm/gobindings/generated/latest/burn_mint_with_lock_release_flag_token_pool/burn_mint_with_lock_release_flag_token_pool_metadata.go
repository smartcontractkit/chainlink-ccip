// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package burn_mint_with_lock_release_flag_token_pool

var SolidityStandardInput = "{\"version\":\"v0.8.26+commit.8a97fa7a\",\"language\":\"Solidity\",\"settings\":{\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"appendCBOR\":true,\"bytecodeHash\":\"none\",\"useLiteralContent\":false},\"optimizer\":{\"enabled\":true,\"runs\":50000},\"outputSelection\":{\"contracts/interfaces/IAdvancedPoolHooks.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/interfaces/IBurnMintERC20.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/interfaces/IPool.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/interfaces/IPoolV1V2.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/interfaces/IPoolV2.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/interfaces/IRMN.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/interfaces/IRouter.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/libraries/Client.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/libraries/FeeTokenHandler.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/libraries/Pool.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/libraries/RateLimiter.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/pools/BurnMintTokenPool.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/pools/BurnMintTokenPoolAbstract.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/pools/TokenPool.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/pools/USDC/BurnMintWithLockReleaseFlagTokenPool.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2Step.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2StepMsgSender.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/IOwnable.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/ITypeAndVersion.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/interfaces/IERC1363.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/interfaces/IERC165.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/interfaces/IERC20.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/token/ERC20/IERC20.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/token/ERC20/extensions/IERC20Metadata.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/token/ERC20/utils/SafeERC20.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/utils/Arrays.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/utils/Comparators.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/utils/Panic.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/utils/SlotDerivation.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/utils/StorageSlot.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/utils/introspection/IERC165.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/utils/math/Math.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/utils/math/SafeCast.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.3.0/utils/structs/EnumerableSet.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]}},\"remappings\":[\"forge-std/=node_modules/@chainlink/contracts/src/v0.8/vendor/forge-std/src/\",\"@chainlink/ace/policy-management/=node_modules/@chainlink/ace/packages/policy-management/src/\",\"@chainlink/contracts/=node_modules/@chainlink/contracts/\",\"@openzeppelin/contracts@4.8.3/=node_modules/@openzeppelin/contracts-4.8.3/\",\"@openzeppelin/contracts@5.3.0/=node_modules/@openzeppelin/contracts-5.3.0/\",\"@arbitrum/=node_modules/@arbitrum/\",\"@eth-optimism/=node_modules/@eth-optimism/\",\"@offchainlabs/=node_modules/@offchainlabs/\",\"@scroll-tech/=node_modules/@scroll-tech/\",\"@zksync/=node_modules/@zksync/\",\"hardhat/=node_modules/@zksync/contracts/l1-contracts/node_modules/hardhat/\",\"solady/=node_modules/solady/\"],\"viaIR\":true},\"sources\":{\"contracts/interfaces/IAdvancedPoolHooks.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\nimport {Pool} from \\\"../libraries/Pool.sol\\\";\\nimport {IPoolV2} from \\\"./IPoolV2.sol\\\";\\n\\n/// @notice Interface for AdvancedPoolHooks contract. Implementations may contain no-op logic.\\ninterface IAdvancedPoolHooks {\\n  /// @notice Preflight check before lock or burn operation.\\n  /// @param lockOrBurnIn The lock or burn input parameters.\\n  /// @param blockConfirmationRequested The block confirmation requested.\\n  /// @param tokenArgs Additional token arguments.\\n  /// @param amountPostFee The amount after token pool bps-based fees have been deducted.\\n  /// @dev This function may revert if the preflight check fails. This means the transaction is rolled back on source.\\n  function preflightCheck(\\n    Pool.LockOrBurnInV1 calldata lockOrBurnIn,\\n    uint16 blockConfirmationRequested,\\n    bytes calldata tokenArgs,\\n    uint256 amountPostFee\\n  ) external;\\n\\n  /// @notice Postflight check before releasing or minting tokens.\\n  /// @param releaseOrMintIn The release or mint output parameters.\\n  /// @param localAmount The local amount to be released or minted.\\n  /// @param blockConfirmationRequested The block confirmation requested.\\n  /// @dev This function may revert if the postflight check fails. This means the transaction is unexecutable until\\n  /// the issue is resolved.\\n  function postflightCheck(\\n    Pool.ReleaseOrMintInV1 calldata releaseOrMintIn,\\n    uint256 localAmount,\\n    uint16 blockConfirmationRequested\\n  ) external;\\n\\n  /// @notice Returns the set of required CCVs for transfers in a specific direction.\\n  /// @param localToken The address of the local token.\\n  /// @param remoteChainSelector The remote chain selector for this transfer.\\n  /// @param amount The amount being transferred.\\n  /// @param blockConfirmationRequested Requested block confirmation.\\n  /// @param extraData Direction-specific payload forwarded by the caller (e.g. token args or source pool data).\\n  /// @param direction The direction of the transfer (Inbound or Outbound).\\n  /// @return requiredCCVs Set of required CCV addresses.\\n  function getRequiredCCVs(\\n    address localToken,\\n    uint64 remoteChainSelector,\\n    uint256 amount,\\n    uint16 blockConfirmationRequested,\\n    bytes calldata extraData,\\n    IPoolV2.MessageDirection direction\\n  ) external view returns (address[] memory requiredCCVs);\\n}\\n\"},\"contracts/interfaces/IBurnMintERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts@5.3.0/token/ERC20/IERC20.sol\\\";\\n\\n/// @notice Minimal ERC20 interface with mint/burn extensions used across CCIP.\\n/// @dev Mirrors the Chainlink `IBurnMintERC20` interface but targets OpenZeppelin Contracts v5.3.0.\\ninterface IBurnMintERC20 is IERC20 {\\n  /// @notice Mints new tokens for a given address.\\n  /// @param account The address to mint the new tokens to.\\n  /// @param amount The number of tokens to be minted.\\n  /// @dev This function increases the total supply.\\n  function mint(\\n    address account,\\n    uint256 amount\\n  ) external;\\n\\n  /// @notice Burns tokens from the sender.\\n  /// @param amount The number of tokens to be burned.\\n  /// @dev This function decreases the total supply.\\n  function burn(\\n    uint256 amount\\n  ) external;\\n\\n  /// @notice Burns tokens from a given address.\\n  /// @param account The address to burn tokens from.\\n  /// @param amount The number of tokens to be burned.\\n  /// @dev This function decreases the total supply.\\n  function burn(\\n    address account,\\n    uint256 amount\\n  ) external;\\n\\n  /// @notice Burns tokens from a given address.\\n  /// @param account The address to burn tokens from.\\n  /// @param amount The number of tokens to be burned.\\n  /// @dev This function decreases the total supply.\\n  function burnFrom(\\n    address account,\\n    uint256 amount\\n  ) external;\\n}\\n\\n\"},\"contracts/interfaces/IPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {Pool} from \\\"../libraries/Pool.sol\\\";\\n\\nimport {IERC165} from \\\"@openzeppelin/contracts@5.3.0/utils/introspection/IERC165.sol\\\";\\n\\n/// @notice Shared public interface for multiple V1 pool types.\\n/// Each pool type handles a different child token model e.g. lock/unlock, mint/burn.\\ninterface IPoolV1 is IERC165 {\\n  /// @notice Lock tokens into the pool or burn the tokens.\\n  /// @param lockOrBurnIn Encoded data fields for the processing of tokens on the source chain.\\n  /// @return lockOrBurnOut Encoded data fields for the processing of tokens on the destination chain.\\n  function lockOrBurn(\\n    Pool.LockOrBurnInV1 calldata lockOrBurnIn\\n  ) external returns (Pool.LockOrBurnOutV1 memory lockOrBurnOut);\\n\\n  /// @notice Releases or mints tokens to the receiver address.\\n  /// @param releaseOrMintIn All data required to release or mint tokens.\\n  /// @return releaseOrMintOut The amount of tokens released or minted on the local chain, denominated\\n  /// in the local token's decimals.\\n  /// @dev The offRamp asserts that the balanceOf of the receiver has been incremented by exactly the number\\n  /// of tokens that is returned in ReleaseOrMintOutV1.destinationAmount. If the amounts do not match, the tx reverts.\\n  function releaseOrMint(\\n    Pool.ReleaseOrMintInV1 calldata releaseOrMintIn\\n  ) external returns (Pool.ReleaseOrMintOutV1 memory);\\n\\n  /// @notice Checks whether a remote chain is supported in the token pool.\\n  /// @param remoteChainSelector The selector of the remote chain.\\n  /// @return true if the given chain is a permissioned remote chain.\\n  function isSupportedChain(\\n    uint64 remoteChainSelector\\n  ) external view returns (bool);\\n\\n  /// @notice Returns if the token pool supports the given token.\\n  /// @param token The address of the token.\\n  /// @return true if the token is supported by the pool.\\n  function isSupportedToken(\\n    address token\\n  ) external view returns (bool);\\n}\\n\"},\"contracts/interfaces/IPoolV1V2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {IPoolV1} from \\\"./IPool.sol\\\";\\nimport {IPoolV2} from \\\"./IPoolV2.sol\\\";\\n\\ninterface IPoolV1V2 is IPoolV1, IPoolV2 {}\\n\"},\"contracts/interfaces/IPoolV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {Pool} from \\\"../libraries/Pool.sol\\\";\\n\\nimport {IERC165} from \\\"@openzeppelin/contracts@5.3.0/utils/introspection/IERC165.sol\\\";\\n\\n/// @notice Shared public interface for multiple V2 pool types.\\n/// Each pool type handles a different child token model e.g. lock/release, mint/burn.\\ninterface IPoolV2 is IERC165 {\\n  struct TokenTransferFeeConfig {\\n    uint32 destGasOverhead; // ───────────────────────╮ Gas charged to execute the token transfer on the destination chain.\\n    uint32 destBytesOverhead; //                      │ Data availability bytes.\\n    uint32 defaultBlockConfirmationFeeUSDCents; //    │ Fee to charge for token transfer with default block confirmation, multiples of 0.01 USD.\\n    uint32 customBlockConfirmationFeeUSDCents; //     │ Fee to charge for token transfer with custom block confirmation, multiples of 0.01 USD.\\n    //                                                │ The following two fee is deducted from the transferred asset, not added on top.\\n    uint16 defaultBlockConfirmationTransferFeeBps; // │ Fee in basis points for default finality transfers [0-10_000].\\n    uint16 customBlockConfirmationTransferFeeBps; //  │ Fee in basis points for custom finality transfers [0-10_000].\\n    bool isEnabled; // ───────────────────────────────╯ Whether this config is enabled.\\n  }\\n\\n  enum MessageDirection {\\n    Outbound,\\n    Inbound\\n  }\\n\\n  /// @notice Lock tokens into the pool or burn the tokens.\\n  /// @param lockOrBurnIn Encoded data fields for the processing of tokens on the source chain.\\n  /// @param blockConfirmationRequested Requested block confirmation.\\n  /// @param tokenArgs Additional token arguments.\\n  /// @return lockOrBurnOut Encoded data fields for the processing of tokens on the destination chain.\\n  /// @return destTokenAmount The amount of tokens that will be set in TokenTransferV1.amount to be released/mint on destination.\\n  function lockOrBurn(\\n    Pool.LockOrBurnInV1 calldata lockOrBurnIn,\\n    uint16 blockConfirmationRequested,\\n    bytes calldata tokenArgs\\n  ) external returns (Pool.LockOrBurnOutV1 memory lockOrBurnOut, uint256 destTokenAmount);\\n\\n  /// @notice Releases or mints tokens on the destination chain.\\n  /// @param releaseOrMintIn Encoded data fields for the processing of tokens on the destination chain.\\n  /// @param blockConfirmationRequested Requested block confirmation.\\n  /// @return releaseOrMintOut Encoded data fields describing the result of the release or mint.\\n  function releaseOrMint(\\n    Pool.ReleaseOrMintInV1 calldata releaseOrMintIn,\\n    uint16 blockConfirmationRequested\\n  ) external returns (Pool.ReleaseOrMintOutV1 memory releaseOrMintOut);\\n\\n  /// @notice Returns the set of required CCVs for transfers in a given direction.\\n  /// @param localToken The address of the local token.\\n  /// @param remoteChainSelector The chain selector of the remote chain.\\n  /// @param amount The amount of tokens to be transferred.\\n  /// @param blockConfirmationRequested Requested block confirmation.\\n  /// @param extraData Direction-specific payload forwarded by the caller (e.g. token args or source pool data).\\n  /// @param direction Whether CCVs are required for outbound (source -\\u003e remote) or inbound (remote -\\u003e destination) transfers.\\n  /// @return requiredCCVs A set of addresses representing the required CCVs.\\n  function getRequiredCCVs(\\n    address localToken,\\n    uint64 remoteChainSelector,\\n    uint256 amount,\\n    uint16 blockConfirmationRequested,\\n    bytes calldata extraData,\\n    MessageDirection direction\\n  ) external view returns (address[] memory requiredCCVs);\\n\\n  /// @notice Returns the fee overrides for transferring the pool's token to a destination chain.\\n  /// @param localToken The address of the local token.\\n  /// @param destChainSelector The chain selector of the destination chain.\\n  /// @param blockConfirmationRequested Requested block confirmation.\\n  /// @param tokenArgs Additional token argument from the CCIP message.\\n  /// @return feeConfig the fee configuration for transferring the token to the destination chain.\\n  function getTokenTransferFeeConfig(\\n    address localToken,\\n    uint64 destChainSelector,\\n    uint16 blockConfirmationRequested,\\n    bytes calldata tokenArgs\\n  ) external view returns (TokenTransferFeeConfig memory feeConfig);\\n\\n  /// @notice Returns the pool fee parameters that will apply to a transfer.\\n  /// @param localToken The local asset being transferred.\\n  /// @param destChainSelector The destination lane selector.\\n  /// @param amount The amount of tokens being bridged on this lane.\\n  /// @param feeToken The token used to pay feeUSDCents.\\n  /// @param blockConfirmationRequested Requested block confirmation.\\n  /// @param tokenArgs Opaque token arguments supplied by the caller.\\n  /// @return feeUSDCents Flat fee charged in USD cents (crumbs) for this transfer.\\n  /// @return destGasOverhead Destination gas charged for accounting in the cost model.\\n  /// @return destBytesOverhead Destination calldata size attributed to the transfer.\\n  /// @return tokenFeeBps Bps charged in token units. Value of zero implies no in-token fee.\\n  /// @return isEnabled Whether the pool's fee config is enabled. If false, OnRamp should use FeeQuoter defaults.\\n  function getFee(\\n    address localToken,\\n    uint64 destChainSelector,\\n    uint256 amount,\\n    address feeToken,\\n    uint16 blockConfirmationRequested,\\n    bytes calldata tokenArgs\\n  )\\n    external\\n    view\\n    returns (uint256 feeUSDCents, uint32 destGasOverhead, uint32 destBytesOverhead, uint16 tokenFeeBps, bool isEnabled);\\n\\n  /// @notice Gets the token address on the remote chain.\\n  /// @param remoteChainSelector Remote chain selector.\\n  /// @dev To support non-evm chains, this value is encoded into bytes.\\n  function getRemoteToken(\\n    uint64 remoteChainSelector\\n  ) external view returns (bytes memory);\\n}\\n\"},\"contracts/interfaces/IRMN.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice This interface contains the only RMN-related functions that might be used on-chain by other CCIP contracts.\\ninterface IRMN {\\n  /// @notice A Merkle root tagged with the address of the commit store contract it is destined for.\\n  struct TaggedRoot {\\n    address commitStore;\\n    bytes32 root;\\n  }\\n\\n  /// @notice Callers MUST NOT cache the return value as a blessed tagged root could become unblessed.\\n  function isBlessed(\\n    TaggedRoot calldata taggedRoot\\n  ) external view returns (bool);\\n\\n  /// @notice Iff there is an active global or legacy curse, this function returns true.\\n  function isCursed() external view returns (bool);\\n\\n  /// @notice Iff there is an active global curse, or an active curse for `subject`, this function returns true.\\n  /// @param subject To check whether a particular chain is cursed, set to bytes16(uint128(chainSelector)).\\n  function isCursed(\\n    bytes16 subject\\n  ) external view returns (bool);\\n}\\n\"},\"contracts/interfaces/IRouter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {Client} from \\\"../libraries/Client.sol\\\";\\n\\ninterface IRouter {\\n  error OnlyOffRamp();\\n\\n  /// @notice Route the message to its intended receiver contract.\\n  /// @param message Client.Any2EVMMessage struct.\\n  /// @param gasForCallExactCheck of params for exec.\\n  /// @param gasLimit set of params for exec.\\n  /// @param receiver set of params for exec.\\n  /// @dev if the receiver is a contracts that signals support for CCIP execution through EIP-165.\\n  /// the contract is called. If not, only tokens are transferred.\\n  /// @return success A boolean value indicating whether the ccip message was received without errors.\\n  /// @return retBytes A bytes array containing return data form CCIP receiver.\\n  /// @return gasUsed the gas used by the external customer call. Does not include any overhead.\\n  function routeMessage(\\n    Client.Any2EVMMessage calldata message,\\n    uint16 gasForCallExactCheck,\\n    uint256 gasLimit,\\n    address receiver\\n  ) external returns (bool success, bytes memory retBytes, uint256 gasUsed);\\n\\n  /// @notice Returns the configured onRamp for a specific destination chain.\\n  /// @param destChainSelector The destination chain Id to get the onRamp for.\\n  /// @return onRampAddress The address of the onRamp.\\n  function getOnRamp(\\n    uint64 destChainSelector\\n  ) external view returns (address onRampAddress);\\n\\n  /// @notice Return true if the given offRamp is a configured offRamp for the given source chain.\\n  /// @param sourceChainSelector The source chain selector to check.\\n  /// @param offRamp The address of the offRamp to check.\\n  function isOffRamp(\\n    uint64 sourceChainSelector,\\n    address offRamp\\n  ) external view returns (bool isOffRamp);\\n}\\n\"},\"contracts/libraries/Client.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// End consumer library.\\nlibrary Client {\\n  struct EVMTokenAmount {\\n    address token; // token address on the local chain.\\n    uint256 amount; // Amount of tokens.\\n  }\\n\\n  struct Any2EVMMessage {\\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\\n    uint64 sourceChainSelector; // Source chain selector.\\n    bytes sender; // abi.encode(address) on EVM source chains; abi.decode(sender, (address)) to recover.\\n    bytes data; // payload sent in original message.\\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\\n  }\\n\\n  // If extraArgs is empty bytes, the default is 200k gas limit.\\n  struct EVM2AnyMessage {\\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains.\\n    bytes data; // Data payload.\\n    EVMTokenAmount[] tokenAmounts; // Token transfers.\\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV3).\\n  }\\n\\n  /// @notice Tag to indicate no execution on the destination chain. Execution will need to be done manually.\\n  /// @dev Preimage for this tag is: keccak256(\\\"NO_EXECUTION_TAG\\\")[:4]\\n  bytes4 public constant NO_EXECUTION_TAG = 0xeba517d2;\\n  address public constant NO_EXECUTION_ADDRESS = address(bytes20(NO_EXECUTION_TAG));\\n\\n  // ================================================================\\n  // │                           Legacy                             │\\n  // ================================================================\\n\\n  // Tag to indicate only a gas limit. Only usable for EVM as destination chain.\\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\\n\\n  struct EVMExtraArgsV1 {\\n    uint256 gasLimit;\\n  }\\n\\n  function _argsToBytes(\\n    EVMExtraArgsV1 memory extraArgs\\n  ) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\\n  }\\n\\n  // Tag to indicate a gas limit (or dest chain equivalent processing units) and Out Of Order Execution. This tag is\\n  // available for multiple chain families. If there is no chain family specific tag, this is the default available\\n  // for a chain.\\n  // Note: not available for Solana or Sui VM based chains.\\n  bytes4 public constant GENERIC_EXTRA_ARGS_V2_TAG = 0x181dcf10;\\n\\n  /// @param gasLimit: gas limit for the callback on the destination chain.\\n  /// @param allowOutOfOrderExecution: if true, it indicates that the message can be executed in any order relative to\\n  /// other messages from the same sender. This value's default varies by chain. On some chains, a particular value is\\n  /// enforced, meaning if the expected value is not set, the message request will revert.\\n  /// @dev Fully compatible with the previously existing EVMExtraArgsV2.\\n  struct GenericExtraArgsV2 {\\n    uint256 gasLimit;\\n    bool allowOutOfOrderExecution;\\n  }\\n\\n  // Extra args tag for chains that use the Sui VM.\\n  bytes4 public constant SUI_EXTRA_ARGS_V1_TAG = 0x21ea4ca9;\\n\\n  // Extra args tag for chains that use the Solana VM.\\n  bytes4 public constant SVM_EXTRA_ARGS_V1_TAG = 0x1f3b3aba;\\n\\n  struct SVMExtraArgsV1 {\\n    uint32 computeUnits;\\n    uint64 accountIsWritableBitmap;\\n    bool allowOutOfOrderExecution;\\n    bytes32 tokenReceiver;\\n    // Additional accounts needed for execution of CCIP receiver. Must be empty if message.receiver is zero.\\n    // Token transfer related accounts are specified in the token pool lookup table on SVM.\\n    bytes32[] accounts;\\n  }\\n\\n  /// @dev The maximum number of accounts that can be passed in SVMExtraArgs.\\n  uint256 public constant SVM_EXTRA_ARGS_MAX_ACCOUNTS = 64;\\n\\n  /// @dev The expected static payload size of a token transfer when Borsh encoded and submitted to SVM.\\n  /// TokenPool extra data and offchain data sizes are dynamic, and should be accounted for separately.\\n  uint256 public constant SVM_TOKEN_TRANSFER_DATA_OVERHEAD = (4 + 32) // source_pool\\n    + 32 // token_address\\n    + 4 // gas_amount\\n    + 4 // extra_data overhead\\n    + 32 // amount\\n    + 32 // size of the token lookup table account\\n    + 32 // token-related accounts in the lookup table, over-estimated to 32, typically between 11 - 13\\n    + 32 // token account belonging to the token receiver, e.g ATA, not included in the token lookup table\\n    + 32 // per-chain token pool config, not included in the token lookup table\\n    + 32 // per-chain token billing config, not always included in the token lookup table\\n    + 32; // OffRamp pool signer PDA, not included in the token lookup table\\n\\n  /// @dev Number of overhead accounts needed for message execution on SVM.\\n  /// @dev These are message.receiver, and the OffRamp Signer PDA specific to the receiver.\\n  uint256 public constant SVM_MESSAGING_ACCOUNTS_OVERHEAD = 2;\\n\\n  /// @dev The size of each SVM account address in bytes.\\n  uint256 public constant SVM_ACCOUNT_BYTE_SIZE = 32;\\n\\n  struct SuiExtraArgsV1 {\\n    uint256 gasLimit;\\n    bool allowOutOfOrderExecution;\\n    bytes32 tokenReceiver;\\n    bytes32[] receiverObjectIds;\\n  }\\n\\n  /// @dev The expected static payload size of a token transfer when BCS encoded and submitted to SUI.\\n  /// TokenPool extra data and offchain data sizes are dynamic, and should be accounted for separately.\\n  uint256 public constant SUI_TOKEN_TRANSFER_DATA_OVERHEAD = (4 + 32) // source_pool, 4 bytes for length, 32 bytes for address\\n    + 32 // dest_token_address\\n    + 4 // dest_gas_amount\\n    + 4 // extra_data length, the contents are calculated separately\\n    + 32; // amount\\n\\n  /// @dev Number of overhead accounts needed for message execution on SUI.\\n  /// @dev This is the message.receiver.\\n  uint256 public constant SUI_MESSAGING_ACCOUNTS_OVERHEAD = 1;\\n\\n  /// @dev The maximum number of receiver object ids that can be passed in SuiExtraArgs.\\n  uint256 public constant SUI_EXTRA_ARGS_MAX_RECEIVER_OBJECT_IDS = 64;\\n\\n  /// @dev The size of each SUI account address in bytes.\\n  uint256 public constant SUI_ACCOUNT_BYTE_SIZE = 32;\\n\\n  function _argsToBytes(\\n    GenericExtraArgsV2 memory extraArgs\\n  ) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(GENERIC_EXTRA_ARGS_V2_TAG, extraArgs);\\n  }\\n\\n  function _svmArgsToBytes(\\n    SVMExtraArgsV1 memory extraArgs\\n  ) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(SVM_EXTRA_ARGS_V1_TAG, extraArgs);\\n  }\\n\\n  function _suiArgsToBytes(\\n    SuiExtraArgsV1 memory extraArgs\\n  ) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(SUI_EXTRA_ARGS_V1_TAG, extraArgs);\\n  }\\n}\\n\"},\"contracts/libraries/FeeTokenHandler.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts@5.3.0/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts@5.3.0/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nlibrary FeeTokenHandler {\\n  using SafeERC20 for IERC20;\\n\\n  error ZeroAddressNotAllowed();\\n\\n  event FeeTokenWithdrawn(address indexed receiver, address indexed feeToken, uint256 amount);\\n\\n  /// @notice Withdraws the outstanding fee token balances to the fee aggregator.\\n  /// @param feeTokens The fee tokens to withdraw.\\n  /// @param feeAggregator The address to withdraw the fee tokens to, cannot be the zero address.\\n  function _withdrawFeeTokens(\\n    address[] calldata feeTokens,\\n    address feeAggregator\\n  ) internal {\\n    if (feeAggregator == address(0)) revert ZeroAddressNotAllowed();\\n\\n    for (uint256 i = 0; i \\u003c feeTokens.length; ++i) {\\n      IERC20 feeToken = IERC20(feeTokens[i]);\\n      uint256 feeTokenBalance = feeToken.balanceOf(address(this));\\n\\n      if (feeTokenBalance \\u003e 0) {\\n        feeToken.safeTransfer(feeAggregator, feeTokenBalance);\\n\\n        emit FeeTokenWithdrawn(feeAggregator, address(feeToken), feeTokenBalance);\\n      }\\n    }\\n  }\\n}\\n\"},\"contracts/libraries/Pool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice This library contains various token pool functions to aid constructing the return data.\\nlibrary Pool {\\n  // The tag used to signal support for the pool v1 standard.\\n  // bytes4(keccak256(\\\"CCIP_POOL_V1\\\"))\\n  bytes4 public constant CCIP_POOL_V1 = 0xaff2afbf;\\n\\n  // The number of bytes in the return data for a pool v1 releaseOrMint call.\\n  // This should match the size of the ReleaseOrMintOutV1 struct.\\n  uint16 public constant CCIP_POOL_V1_RET_BYTES = 32;\\n\\n  // The default max number of bytes in the return data for a pool v1 lockOrBurn call.\\n  // This data can be used to send information to the destination chain token pool. Can be overwritten\\n  // in the TokenTransferFeeConfig.destBytesOverhead if more data is required.\\n  uint32 public constant CCIP_LOCK_OR_BURN_V1_RET_BYTES = 32;\\n\\n  struct LockOrBurnInV1 {\\n    bytes receiver; //  The recipient of the tokens on the destination chain. For EVM source chains, this is abi-encoded (32 bytes).\\n    uint64 remoteChainSelector; // ─╮ The chain ID of the destination chain.\\n    address originalSender; // ─────╯ The original sender of the tx on the source chain.\\n    uint256 amount; //  The amount of tokens to lock or burn, denominated in the source token's decimals.\\n    address localToken; // The address on this chain of the token to lock or burn.\\n  }\\n\\n  struct LockOrBurnOutV1 {\\n    // The address of the destination token, abi encoded in the case of EVM chains.\\n    // This value is UNTRUSTED as any pool owner can return whatever value they want.\\n    bytes destTokenAddress;\\n    // Optional pool data to be transferred to the destination chain. Be default this is capped at\\n    // CCIP_LOCK_OR_BURN_V1_RET_BYTES bytes. If more data is required, the TokenTransferFeeConfig.destBytesOverhead\\n    // has to be set for the specific token.\\n    bytes destPoolData;\\n  }\\n\\n  struct ReleaseOrMintInV1 {\\n    bytes originalSender; //            The original sender of the tx on the source chain.\\n    uint64 remoteChainSelector; // ───╮ The chain ID of the source chain.\\n    address receiver; // ─────────────╯ The recipient of the tokens on the destination chain.\\n    uint256 sourceDenominatedAmount; // The amount of tokens to release or mint, denominated in the source token's decimals.\\n    address localToken; //              The address on this chain of the token to release or mint.\\n    /// @dev WARNING: sourcePoolAddress should be checked prior to any processing of funds. Make sure it matches the\\n    /// expected pool address for the given remoteChainSelector.\\n    bytes sourcePoolAddress; //         The address of the source pool, abi encoded in the case of EVM chains.\\n    bytes sourcePoolData; //            The data received from the source pool to process the release or mint.\\n    /// @dev WARNING: offchainTokenData is untrusted data.\\n    bytes offchainTokenData; //         The offchain data to process the release or mint.\\n  }\\n\\n  struct ReleaseOrMintOutV1 {\\n    // The number of tokens released or minted on the destination chain, denominated in the local token's decimals.\\n    // This value is expected to be equal to the ReleaseOrMintInV1.amount in the case where the source and destination\\n    // chain have the same number of decimals.\\n    uint256 destinationAmount;\\n  }\\n}\\n\"},\"contracts/libraries/RateLimiter.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.4;\\n\\n/// @notice Implements Token Bucket rate limiting.\\n/// @dev uint128 is safe for rate limiter state.\\n/// - For USD value rate limiting, it can adequately store USD value in 18 decimals.\\n/// - For ERC20 token amount rate limiting, all tokens that will be listed will have at most a supply of uint128.max\\n/// tokens, and it will therefore not overflow the bucket. In exceptional scenarios where tokens consumed may be larger\\n/// than uint128, e.g. compromised issuer, an enabled RateLimiter will check and revert.\\nlibrary RateLimiter {\\n  error BucketOverfilled();\\n  error TokenMaxCapacityExceeded(uint256 capacity, uint256 requested, address tokenAddress);\\n  error TokenRateLimitReached(uint256 minWaitInSeconds, uint256 available, address tokenAddress);\\n  error InvalidRateLimitRate(Config rateLimiterConfig);\\n  error DisabledNonZeroRateLimit(Config config);\\n\\n  struct TokenBucket {\\n    uint128 tokens; // ────╮ Current number of tokens that are in the bucket.\\n    uint32 lastUpdated; // │ Timestamp in seconds of the last token refill, good for 100+ years.\\n    bool isEnabled; // ────╯ Indication whether the rate limiting is enabled or not.\\n    uint128 capacity; // ──╮ Maximum number of tokens that can be in the bucket.\\n    uint128 rate; // ──────╯ Number of tokens per second that the bucket is refilled.\\n  }\\n\\n  struct Config {\\n    bool isEnabled; // Indication whether the rate limiting should be enabled.\\n    uint128 capacity; // ──╮ Specifies the capacity of the rate limiter.\\n    uint128 rate; //  ─────╯ Specifies the rate of the rate limiter.\\n  }\\n\\n  /// @notice _consume removes the given tokens from the pool, lowering the rate tokens allowed to be\\n  /// consumed for subsequent calls.\\n  /// @param requestTokens The total tokens to be consumed from the bucket.\\n  /// @param tokenAddress The token to consume capacity for, use 0x0 to indicate aggregate value capacity.\\n  /// @dev Reverts when requestTokens exceeds bucket capacity or available tokens in the bucket.\\n  /// @dev emits removal of requestTokens if requestTokens is \\u003e 0.\\n  function _consume(\\n    TokenBucket storage s_bucket,\\n    uint256 requestTokens,\\n    address tokenAddress\\n  ) internal {\\n    // If there is no value to remove or rate limiting is turned off, skip this step to reduce gas usage.\\n    if (!s_bucket.isEnabled || requestTokens == 0) {\\n      return;\\n    }\\n\\n    uint256 tokens = s_bucket.tokens;\\n    uint256 capacity = s_bucket.capacity;\\n    uint256 timeDiff = block.timestamp - s_bucket.lastUpdated;\\n\\n    if (timeDiff != 0) {\\n      if (tokens \\u003e capacity) revert BucketOverfilled();\\n\\n      // Refill tokens when arriving at a new block time.\\n      tokens = _calculateRefill(capacity, tokens, timeDiff, s_bucket.rate);\\n\\n      s_bucket.lastUpdated = uint32(block.timestamp);\\n    }\\n\\n    if (capacity \\u003c requestTokens) {\\n      revert TokenMaxCapacityExceeded(capacity, requestTokens, tokenAddress);\\n    }\\n    if (tokens \\u003c requestTokens) {\\n      uint256 rate = s_bucket.rate;\\n      if (rate == 0) {\\n        // No tokens will ever be refilled. Check is required to avoid division by zero later.\\n        revert TokenRateLimitReached(type(uint256).max, tokens, tokenAddress);\\n      }\\n      // Wait required until the bucket is refilled enough to accept this value, round up to next higher second.\\n      // Consume is not guaranteed to succeed after wait time passes if there is competing traffic.\\n      // This acts as a lower bound of wait time.\\n      uint256 minWaitInSeconds = ((requestTokens - tokens) + (rate - 1)) / rate;\\n\\n      revert TokenRateLimitReached(minWaitInSeconds, tokens, tokenAddress);\\n    }\\n    tokens -= requestTokens;\\n\\n    // Downcast is safe here, as tokens is not larger than capacity.\\n    s_bucket.tokens = uint128(tokens);\\n  }\\n\\n  /// @notice Gets the token bucket with its values for the block it was requested at.\\n  /// @return The token bucket.\\n  function _currentTokenBucketState(\\n    TokenBucket memory bucket\\n  ) internal view returns (TokenBucket memory) {\\n    // We update the bucket to reflect the status at the exact time of the call. This means we might need to refill a\\n    // part of the bucket based on the time that has passed since the last update.\\n    bucket.tokens =\\n      uint128(_calculateRefill(bucket.capacity, bucket.tokens, block.timestamp - bucket.lastUpdated, bucket.rate));\\n    bucket.lastUpdated = uint32(block.timestamp);\\n    return bucket;\\n  }\\n\\n  /// @notice Sets the rate limited config.\\n  /// @param s_bucket The token bucket.\\n  /// @param config The new config.\\n  function _setTokenBucketConfig(\\n    TokenBucket storage s_bucket,\\n    Config memory config\\n  ) internal {\\n    if (config.isEnabled) {\\n      if (config.rate \\u003e config.capacity) {\\n        revert InvalidRateLimitRate(config);\\n      }\\n    } else {\\n      if (config.rate != 0 || config.capacity != 0) {\\n        revert DisabledNonZeroRateLimit(config);\\n      }\\n    }\\n\\n    s_bucket.isEnabled = config.isEnabled;\\n    s_bucket.tokens = config.capacity;\\n    s_bucket.capacity = config.capacity;\\n    s_bucket.rate = config.rate;\\n    s_bucket.lastUpdated = uint32(block.timestamp);\\n  }\\n\\n  /// @notice Calculate refilled tokens.\\n  /// @param capacity bucket capacity.\\n  /// @param tokens current bucket tokens.\\n  /// @param timeDiff block time difference since last refill.\\n  /// @param rate bucket refill rate.\\n  /// @return the value of tokens after refill.\\n  function _calculateRefill(\\n    uint256 capacity,\\n    uint256 tokens,\\n    uint256 timeDiff,\\n    uint256 rate\\n  ) private pure returns (uint256) {\\n    return _min(capacity, tokens + timeDiff * rate);\\n  }\\n\\n  /// @notice Return the smallest of two integers.\\n  /// @param a first int.\\n  /// @param b second int.\\n  /// @return smallest.\\n  function _min(\\n    uint256 a,\\n    uint256 b\\n  ) internal pure returns (uint256) {\\n    return a \\u003c b ? a : b;\\n  }\\n}\\n\"},\"contracts/pools/BurnMintTokenPool.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\nimport {IBurnMintERC20} from \\\"../interfaces/IBurnMintERC20.sol\\\";\\nimport {ITypeAndVersion} from \\\"@chainlink/contracts/src/v0.8/shared/interfaces/ITypeAndVersion.sol\\\";\\n\\nimport {BurnMintTokenPoolAbstract} from \\\"./BurnMintTokenPoolAbstract.sol\\\";\\nimport {TokenPool} from \\\"./TokenPool.sol\\\";\\n\\n/// @notice This pool mints and burns a 3rd-party token.\\n/// @dev Pool whitelisting mode is set in the constructor and cannot be modified later.\\n/// It either accepts any address as originalSender, or only accepts whitelisted originalSender.\\n/// The only way to change whitelisting mode is to deploy a new pool.\\n/// If that is expected, please make sure the token's burner/minter roles are adjustable.\\n/// @dev This contract is a variant of BurnMintTokenPool that uses `burn(amount)`.\\ncontract BurnMintTokenPool is BurnMintTokenPoolAbstract, ITypeAndVersion {\\n  function typeAndVersion() external pure virtual override returns (string memory) {\\n    return \\\"BurnMintTokenPool 2.0.0-dev\\\";\\n  }\\n\\n  constructor(\\n    IBurnMintERC20 token,\\n    uint8 localTokenDecimals,\\n    address advancedPoolHooks,\\n    address rmnProxy,\\n    address router\\n  ) TokenPool(token, localTokenDecimals, advancedPoolHooks, rmnProxy, router) {}\\n\\n  /// @notice Burns tokens held by the pool.\\n  function _lockOrBurn(\\n    uint64, // remoteChainSelector\\n    uint256 amount\\n  ) internal virtual override {\\n    IBurnMintERC20(address(i_token)).burn(amount);\\n  }\\n}\\n\"},\"contracts/pools/BurnMintTokenPoolAbstract.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\nimport {IBurnMintERC20} from \\\"../interfaces/IBurnMintERC20.sol\\\";\\n\\nimport {TokenPool} from \\\"./TokenPool.sol\\\";\\n\\nabstract contract BurnMintTokenPoolAbstract is TokenPool {\\n  /// @notice Contains the specific release or mint token logic for a pool.\\n  /// @dev overriding this method allows us to create pools with different release/mint signatures\\n  /// without duplicating the underlying logic.\\n  function _releaseOrMint(\\n    address receiver,\\n    uint256 amount,\\n    uint64 // remoteChainSelector\\n  ) internal virtual override {\\n    IBurnMintERC20(address(i_token)).mint(receiver, amount);\\n  }\\n}\\n\"},\"contracts/pools/TokenPool.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\nimport {IAdvancedPoolHooks} from \\\"../interfaces/IAdvancedPoolHooks.sol\\\";\\nimport {IPoolV1} from \\\"../interfaces/IPool.sol\\\";\\nimport {IPoolV1V2} from \\\"../interfaces/IPoolV1V2.sol\\\";\\nimport {IPoolV2} from \\\"../interfaces/IPoolV2.sol\\\";\\nimport {IRMN} from \\\"../interfaces/IRMN.sol\\\";\\nimport {IRouter} from \\\"../interfaces/IRouter.sol\\\";\\n\\nimport {FeeTokenHandler} from \\\"../libraries/FeeTokenHandler.sol\\\";\\nimport {Pool} from \\\"../libraries/Pool.sol\\\";\\nimport {RateLimiter} from \\\"../libraries/RateLimiter.sol\\\";\\nimport {Ownable2StepMsgSender} from \\\"@chainlink/contracts/src/v0.8/shared/access/Ownable2StepMsgSender.sol\\\";\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts@5.3.0/token/ERC20/IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts@5.3.0/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts@5.3.0/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {IERC165} from \\\"@openzeppelin/contracts@5.3.0/utils/introspection/IERC165.sol\\\";\\nimport {EnumerableSet} from \\\"@openzeppelin/contracts@5.3.0/utils/structs/EnumerableSet.sol\\\";\\n\\n/// @notice Base abstract class with common functions for all token pools.\\n/// A token pool serves as isolated place for holding tokens and token specific logic\\n/// that may execute as tokens move across the bridge.\\n/// @dev This pool supports different decimals on different chains but using this feature could impact the total number\\n/// of tokens in circulation. Since all of the tokens are locked/burned on the source, and a rounded amount is\\n/// minted/released on the destination, the number of tokens minted/released could be less than the number of tokens\\n/// burned/locked. This is because the source chain does not know about the destination token decimals. This is not a\\n/// problem if the decimals are the same on both chains.\\n///\\n/// Example:\\n/// Assume there is a token with 6 decimals on chain A and 3 decimals on chain B.\\n/// - 1.234567 tokens are burned on chain A.\\n/// - 1.234    tokens are minted on chain B.\\n/// When sending the 1.234 tokens back to chain A, you will receive 1.234000 tokens on chain A, effectively losing\\n/// 0.000567 tokens.\\n/// In the case of a burnMint pool on chain A, these funds are burned in the pool on chain A.\\n/// In the case of a lockRelease pool on chain A, these funds accumulate in the pool on chain A.\\nabstract contract TokenPool is IPoolV1V2, Ownable2StepMsgSender {\\n  using EnumerableSet for EnumerableSet.Bytes32Set;\\n  using EnumerableSet for EnumerableSet.UintSet;\\n  using RateLimiter for RateLimiter.TokenBucket;\\n  using SafeERC20 for IERC20;\\n\\n  error InvalidMinBlockConfirmation(uint16 requested, uint16 minBlockConfirmation);\\n  error CustomBlockConfirmationsNotEnabled();\\n  error InvalidTransferFeeBps(uint256 bps);\\n  error InvalidTokenTransferFeeConfig(uint64 destChainSelector);\\n  error CallerIsNotARampOnRouter(address caller);\\n  error ZeroAddressInvalid();\\n  error NonExistentChain(uint64 remoteChainSelector);\\n  error ChainNotAllowed(uint64 remoteChainSelector);\\n  error CursedByRMN();\\n  error ChainAlreadyExists(uint64 chainSelector);\\n  error InvalidSourcePoolAddress(bytes sourcePoolAddress);\\n  error InvalidToken(address token);\\n  error Unauthorized(address caller);\\n  error PoolAlreadyAdded(uint64 remoteChainSelector, bytes remotePoolAddress);\\n  error InvalidRemotePoolForChain(uint64 remoteChainSelector, bytes remotePoolAddress);\\n  error InvalidRemoteChainDecimals(bytes sourcePoolData);\\n  error MismatchedArrayLengths();\\n  error OverflowDetected(uint8 remoteDecimals, uint8 localDecimals, uint256 remoteAmount);\\n  error InvalidDecimalArgs(uint8 expected, uint8 actual);\\n  error CallerIsNotOwnerOrFeeAdmin(address caller);\\n\\n  event LockedOrBurned(uint64 indexed remoteChainSelector, address token, address sender, uint256 amount);\\n  event ReleasedOrMinted(\\n    uint64 indexed remoteChainSelector, address token, address sender, address recipient, uint256 amount\\n  );\\n  event ChainAdded(\\n    uint64 remoteChainSelector,\\n    bytes remoteToken,\\n    RateLimiter.Config outboundRateLimiterConfig,\\n    RateLimiter.Config inboundRateLimiterConfig\\n  );\\n  event ChainRemoved(uint64 remoteChainSelector);\\n  event RemotePoolAdded(uint64 indexed remoteChainSelector, bytes remotePoolAddress);\\n  event RemotePoolRemoved(uint64 indexed remoteChainSelector, bytes remotePoolAddress);\\n  event DynamicConfigSet(address router, address rateLimitAdmin, address feeAdmin);\\n  event OutboundRateLimitConsumed(uint64 indexed remoteChainSelector, address token, uint256 amount);\\n  event InboundRateLimitConsumed(uint64 indexed remoteChainSelector, address token, uint256 amount);\\n  event TokenTransferFeeConfigUpdated(uint64 indexed destChainSelector, TokenTransferFeeConfig tokenTransferFeeConfig);\\n  event TokenTransferFeeConfigDeleted(uint64 indexed destChainSelector);\\n  event CustomBlockConfirmationOutboundRateLimitConsumed(\\n    uint64 indexed remoteChainSelector, address token, uint256 amount\\n  );\\n  event CustomBlockConfirmationInboundRateLimitConsumed(\\n    uint64 indexed remoteChainSelector, address token, uint256 amount\\n  );\\n  event RateLimitConfigured(\\n    uint64 indexed remoteChainSelector,\\n    bool customBlockConfirmation,\\n    RateLimiter.Config outboundRateLimiterConfig,\\n    RateLimiter.Config inboundRateLimiterConfig\\n  );\\n  event MinBlockConfirmationSet(uint16 minBlockConfirmation);\\n  event AdvancedPoolHooksUpdated(IAdvancedPoolHooks oldHook, IAdvancedPoolHooks newHook);\\n\\n  struct ChainUpdate {\\n    uint64 remoteChainSelector; // Remote chain selector.\\n    bytes[] remotePoolAddresses; // Address of the remote pool, ABI encoded in the case of a remote EVM chain.\\n    bytes remoteTokenAddress; // Address of the remote token, ABI encoded in the case of a remote EVM chain.\\n    RateLimiter.Config outboundRateLimiterConfig; // Outbound rate limited config, meaning the rate limits for all of the onRamps for the given chain.\\n    RateLimiter.Config inboundRateLimiterConfig; // Inbound rate limited config, meaning the rate limits for all of the offRamps for the given chain.\\n  }\\n\\n  struct RemoteChainConfig {\\n    RateLimiter.TokenBucket outboundRateLimiterConfig; // Outbound rate limited config, meaning the rate limits for all of the onRamps for the given chain.\\n    RateLimiter.TokenBucket inboundRateLimiterConfig; // Inbound rate limited config, meaning the rate limits for all of the offRamps for the given chain.\\n    bytes remoteTokenAddress; // Address of the remote token, ABI encoded in the case of a remote EVM chain.\\n    EnumerableSet.Bytes32Set remotePools; // Set of remote pool hashes, ABI encoded in the case of a remote EVM chain.\\n  }\\n\\n  struct RateLimitConfigArgs {\\n    uint64 remoteChainSelector; // Remote chain selector.\\n    bool customBlockConfirmation; // Whether the rate limit config is for custom block confirmation transfers.\\n    RateLimiter.Config outboundRateLimiterConfig; // Outbound rate limiter configuration.\\n    RateLimiter.Config inboundRateLimiterConfig; // Inbound rate limiter configuration.\\n  }\\n\\n  /// @dev Struct with args for setting the token transfer fee configurations for a destination chain and a set of tokens.\\n  struct TokenTransferFeeConfigArgs {\\n    uint64 destChainSelector; // Destination chain selector.\\n    TokenTransferFeeConfig tokenTransferFeeConfig; // Token transfer fee configuration.\\n  }\\n\\n  /// @notice The division factor for bps. This also represents the maximum bps fee.\\n  uint256 internal constant BPS_DIVIDER = 10_000;\\n  /// @dev Constant representing the default finality.\\n  uint16 internal constant WAIT_FOR_FINALITY = 0;\\n  /// @dev The bridgeable token that is managed by this pool. Pools could support multiple tokens at the same time if\\n  /// required, but this implementation only supports one token.\\n  IERC20 internal immutable i_token;\\n  /// @dev The number of decimals of the token managed by this pool.\\n  uint8 internal immutable i_tokenDecimals;\\n  /// @dev The address of the RMN proxy.\\n  address internal immutable i_rmnProxy;\\n\\n  /// @dev The address of the router.\\n  IRouter internal s_router;\\n  /// @dev Minimum block confirmation on the source chain, 0 means the default finality.\\n  uint16 internal s_minBlockConfirmation;\\n  /// @dev Optional advanced pool hooks contract for additional features like allowlists and CCV management.\\n  IAdvancedPoolHooks internal s_advancedPoolHooks;\\n  // Separate buckets provide isolated rate limits for transfers with custom block confirmation, as their risk profiles differ from default transfers.\\n  mapping(uint64 remoteChainSelector =\\u003e RateLimiter.TokenBucket tokenBucketOutbound) internal\\n    s_outboundRateLimiterConfig;\\n  mapping(uint64 remoteChainSelector =\\u003e RateLimiter.TokenBucket tokenBucketInbound) internal s_inboundRateLimiterConfig;\\n  /// @dev A set of allowed chain selectors. We want the allowlist to be enumerable to\\n  /// be able to quickly determine (without parsing logs) who can access the pool.\\n  /// @dev The chain selectors are in uint256 format because of the EnumerableSet implementation.\\n  EnumerableSet.UintSet internal s_remoteChainSelectors;\\n  mapping(uint64 remoteChainSelector =\\u003e RemoteChainConfig) internal s_remoteChainConfigs;\\n  /// @notice A mapping of hashed pool addresses to their unhashed form. This is used to be able to find the actually\\n  /// configured pools and not just their hashed versions.\\n  mapping(bytes32 poolAddressHash =\\u003e bytes poolAddress) internal s_remotePoolAddresses;\\n  /// @notice The address of the rate limiter admin.\\n  /// @dev Can be address(0) if none is configured.\\n  address internal s_rateLimitAdmin;\\n  /// @dev Optional token-transfer fee overrides keyed by destination chain selector.\\n  mapping(uint64 destChainSelector =\\u003e TokenTransferFeeConfig tokenTransferFeeConfig) internal s_tokenTransferFeeConfig;\\n  /// @notice The address of the fee admin.\\n  /// @dev Constructor does not set this value so it is opt in only.\\n  address internal s_feeAdmin;\\n\\n  constructor(\\n    IERC20 token,\\n    uint8 localTokenDecimals,\\n    address advancedPoolHooks,\\n    address rmnProxy,\\n    address router\\n  ) {\\n    if (address(token) == address(0) || router == address(0) || rmnProxy == address(0)) {\\n      revert ZeroAddressInvalid();\\n    }\\n    i_token = token;\\n    i_rmnProxy = rmnProxy;\\n\\n    try IERC20Metadata(address(token)).decimals() returns (uint8 actualTokenDecimals) {\\n      if (localTokenDecimals != actualTokenDecimals) {\\n        revert InvalidDecimalArgs(localTokenDecimals, actualTokenDecimals);\\n      }\\n    } catch {\\n      // The decimals function doesn't exist, which is possible since it's optional in the ERC20 spec. We skip the check and\\n      // assume the supplied token decimals are correct.\\n    }\\n    i_tokenDecimals = localTokenDecimals;\\n    s_advancedPoolHooks = IAdvancedPoolHooks(advancedPoolHooks);\\n\\n    s_router = IRouter(router);\\n  }\\n\\n  /// @inheritdoc IPoolV1\\n  /// @param token The token address to check.\\n  function isSupportedToken(\\n    address token\\n  ) public view virtual returns (bool) {\\n    return token == address(i_token);\\n  }\\n\\n  /// @notice Gets the IERC20 token that this pool can lock or burn.\\n  /// @return token The IERC20 token representation.\\n  function getToken() public view virtual returns (IERC20 token) {\\n    return i_token;\\n  }\\n\\n  /// @notice Get RMN proxy address.\\n  /// @return rmnProxy Address of RMN proxy.\\n  function getRmnProxy() public view virtual returns (address rmnProxy) {\\n    return i_rmnProxy;\\n  }\\n\\n  /// @notice Gets the pools dynamic configuration.\\n  function getDynamicConfig() public view virtual returns (address router, address rateLimitAdmin, address feeAdmin) {\\n    return (address(s_router), s_rateLimitAdmin, s_feeAdmin);\\n  }\\n\\n  /// @notice Gets the minimum block confirmations required for custom finality transfers.\\n  function getMinBlockConfirmation() public view virtual returns (uint16 minBlockConfirmation) {\\n    return s_minBlockConfirmation;\\n  }\\n\\n  /// @notice Gets the advanced pool hook contract address used by this pool.\\n  function getAdvancedPoolHooks() public view virtual returns (IAdvancedPoolHooks advancedPoolHook) {\\n    return s_advancedPoolHooks;\\n  }\\n\\n  /// @notice Sets the dynamic configuration for the pool.\\n  /// @param router The address of the router contract.\\n  /// @param rateLimitAdmin The address of the rate limiter admin.\\n  /// @param feeAdmin An additional address that can withdraw fees from this contract.\\n  /// @dev FeeTokenHandler will revert if feeAdmin is zero when withdrawing fees.\\n  /// @dev If only the owner can withdraw fees, set feeAdmin to address(0).\\n  function setDynamicConfig(\\n    address router,\\n    address rateLimitAdmin,\\n    address feeAdmin\\n  ) public virtual onlyOwner {\\n    if (router == address(0)) revert ZeroAddressInvalid();\\n    s_router = IRouter(router);\\n    s_rateLimitAdmin = rateLimitAdmin;\\n    s_feeAdmin = feeAdmin;\\n    emit DynamicConfigSet(router, rateLimitAdmin, feeAdmin);\\n  }\\n\\n  /// @notice Sets the minimum block confirmations required for custom finality transfers.\\n  /// @param minBlockConfirmation The minimum block confirmations required for custom finality transfers.\\n  function setMinBlockConfirmation(\\n    uint16 minBlockConfirmation\\n  ) public virtual onlyOwner {\\n    // Since 0 means default finality it is a valid value.\\n    s_minBlockConfirmation = minBlockConfirmation;\\n    emit MinBlockConfirmationSet(minBlockConfirmation);\\n  }\\n\\n  /// @notice Updates the advanced pool hook.\\n  /// @param newHook The new advanced pool hooks contract.\\n  function updateAdvancedPoolHooks(\\n    IAdvancedPoolHooks newHook\\n  ) public virtual onlyOwner {\\n    emit AdvancedPoolHooksUpdated(s_advancedPoolHooks, newHook);\\n    s_advancedPoolHooks = newHook;\\n  }\\n\\n  /// @notice Signals which version of the pool interface is supported.\\n  /// @param interfaceId The interface identifier, as specified in ERC-165.\\n  function supportsInterface(\\n    bytes4 interfaceId\\n  ) public pure virtual override returns (bool) {\\n    return interfaceId == Pool.CCIP_POOL_V1 || interfaceId == type(IPoolV2).interfaceId\\n      || interfaceId == type(IPoolV1).interfaceId || interfaceId == type(IERC165).interfaceId;\\n  }\\n\\n  // ================================================================\\n  // │                        Lock or Burn                          │\\n  // ================================================================\\n\\n  /// @inheritdoc IPoolV2\\n  /// @dev The _validateLockOrBurn check is an essential security check.\\n  /// @dev The _getFee function deducts the fee from the amount and returns the amount after fee deduction.\\n  /// @param lockOrBurnIn Encoded data fields for the processing of tokens on the source chain.\\n  /// @param blockConfirmationRequested Requested block confirmation.\\n  /// @param tokenArgs Additional token arguments.\\n  function lockOrBurn(\\n    Pool.LockOrBurnInV1 calldata lockOrBurnIn,\\n    uint16 blockConfirmationRequested,\\n    bytes calldata tokenArgs\\n  ) public virtual returns (Pool.LockOrBurnOutV1 memory, uint256 destTokenAmount) {\\n    uint256 feeAmount = _getFee(lockOrBurnIn, blockConfirmationRequested);\\n    _validateLockOrBurn(lockOrBurnIn, blockConfirmationRequested, tokenArgs, feeAmount);\\n    destTokenAmount = lockOrBurnIn.amount - feeAmount;\\n    _lockOrBurn(lockOrBurnIn.remoteChainSelector, destTokenAmount);\\n\\n    emit LockedOrBurned({\\n      remoteChainSelector: lockOrBurnIn.remoteChainSelector,\\n      token: lockOrBurnIn.localToken,\\n      sender: msg.sender,\\n      amount: destTokenAmount\\n    });\\n\\n    return (\\n      Pool.LockOrBurnOutV1({\\n        destTokenAddress: getRemoteToken(lockOrBurnIn.remoteChainSelector), destPoolData: _encodeLocalDecimals()\\n      }),\\n      destTokenAmount\\n    );\\n  }\\n\\n  /// @inheritdoc IPoolV1\\n  /// @dev The _validateLockOrBurn check is an essential security check.\\n  /// @dev _getFee is not called in this legacy method, so the full amount is locked or burned.\\n  /// @param lockOrBurnIn Encoded data fields for the processing of tokens on the source chain.\\n  function lockOrBurn(\\n    Pool.LockOrBurnInV1 calldata lockOrBurnIn\\n  ) public virtual returns (Pool.LockOrBurnOutV1 memory lockOrBurnOutV1) {\\n    _validateLockOrBurn(lockOrBurnIn, WAIT_FOR_FINALITY, \\\"\\\", 0); // feeAmount is zero\\n    _lockOrBurn(lockOrBurnIn.remoteChainSelector, lockOrBurnIn.amount);\\n\\n    emit LockedOrBurned({\\n      remoteChainSelector: lockOrBurnIn.remoteChainSelector,\\n      token: lockOrBurnIn.localToken,\\n      sender: msg.sender,\\n      amount: lockOrBurnIn.amount\\n    });\\n\\n    return Pool.LockOrBurnOutV1({\\n      destTokenAddress: getRemoteToken(lockOrBurnIn.remoteChainSelector), destPoolData: _encodeLocalDecimals()\\n    });\\n  }\\n\\n  /// @notice Contains the specific lock or burn token logic for a pool.\\n  /// @dev overriding this method allows us to create pools with different lock/burn signatures\\n  /// without duplicating the underlying logic.\\n  /// @param remoteChainSelector The selector of the remote chain.\\n  /// @param amount The amount of tokens to lock or burn.\\n  function _lockOrBurn(\\n    uint64 remoteChainSelector,\\n    uint256 amount\\n  ) internal virtual {}\\n\\n  // ================================================================\\n  // │                      Release or Mint                         │\\n  // ================================================================\\n\\n  /// @inheritdoc IPoolV2\\n  /// @dev The _validateReleaseOrMint check is an essential security check.\\n  /// @param releaseOrMintIn Encoded data fields for the processing of tokens on the destination chain.\\n  /// @param blockConfirmationRequested Requested block confirmation.\\n  function releaseOrMint(\\n    Pool.ReleaseOrMintInV1 calldata releaseOrMintIn,\\n    uint16 blockConfirmationRequested\\n  ) public virtual override(IPoolV2) returns (Pool.ReleaseOrMintOutV1 memory) {\\n    uint256 localAmount = _calculateLocalAmount(\\n      releaseOrMintIn.sourceDenominatedAmount, _parseRemoteDecimals(releaseOrMintIn.sourcePoolData)\\n    );\\n\\n    _validateReleaseOrMint(releaseOrMintIn, localAmount, blockConfirmationRequested);\\n\\n    _releaseOrMint(releaseOrMintIn.receiver, localAmount, releaseOrMintIn.remoteChainSelector);\\n\\n    emit ReleasedOrMinted({\\n      remoteChainSelector: releaseOrMintIn.remoteChainSelector,\\n      token: releaseOrMintIn.localToken,\\n      sender: msg.sender,\\n      recipient: releaseOrMintIn.receiver,\\n      amount: localAmount\\n    });\\n\\n    return Pool.ReleaseOrMintOutV1({destinationAmount: localAmount});\\n  }\\n\\n  /// @inheritdoc IPoolV1\\n  /// @dev calls IPoolV2.releaseOrMint with default finality.\\n  /// @param releaseOrMintIn Encoded data fields for the processing of tokens on the destination chain.\\n  function releaseOrMint(\\n    Pool.ReleaseOrMintInV1 calldata releaseOrMintIn\\n  ) public virtual override returns (Pool.ReleaseOrMintOutV1 memory) {\\n    return releaseOrMint(releaseOrMintIn, WAIT_FOR_FINALITY);\\n  }\\n\\n  /// @notice Contains the specific release or mint token logic for a pool.\\n  /// @dev overriding this method allows us to create pools with different release/mint signatures\\n  /// without duplicating the underlying logic.\\n  /// @param receiver The address to receive the tokens.\\n  /// @param amount The amount of tokens to release or mint.\\n  /// @param remoteChainSelector The selector of the remote chain.\\n  function _releaseOrMint(\\n    address receiver,\\n    uint256 amount,\\n    uint64 remoteChainSelector\\n  ) internal virtual {}\\n\\n  // ================================================================\\n  // │                         Validation                           │\\n  // ================================================================\\n\\n  /// @notice Validates the lock or burn input for correctness on\\n  /// - token to be locked or burned\\n  /// - RMN curse status\\n  /// - if the sender is a valid onRamp\\n  /// - rate limiting for either default or custom block confirmation transfer messages.\\n  /// - preflight checks hooks (if enabled)\\n  /// @param lockOrBurnIn The input to validate.\\n  /// @param blockConfirmationRequested The minimum block confirmation requested by the message. A value of zero is used for default finality.\\n  /// @param tokenArgs Additional token arguments passed in by the sender of the message.\\n  /// @param feeAmount The fee amount deducted from the transfer amount.\\n  /// @dev This function should always be called before executing a lock or burn. Not doing so would allow\\n  /// for various exploits.\\n  function _validateLockOrBurn(\\n    Pool.LockOrBurnInV1 calldata lockOrBurnIn,\\n    uint16 blockConfirmationRequested,\\n    bytes memory tokenArgs,\\n    uint256 feeAmount\\n  ) internal virtual {\\n    if (!isSupportedToken(lockOrBurnIn.localToken)) {\\n      revert InvalidToken(lockOrBurnIn.localToken);\\n    }\\n    if (IRMN(i_rmnProxy).isCursed(bytes16(uint128(lockOrBurnIn.remoteChainSelector)))) revert CursedByRMN();\\n\\n    _onlyOnRamp(lockOrBurnIn.remoteChainSelector);\\n\\n    uint256 amount = lockOrBurnIn.amount - feeAmount;\\n    // If custom block confirmations are requested, validate against the minimum and apply the custom rate limit.\\n    if (blockConfirmationRequested != WAIT_FOR_FINALITY) {\\n      uint16 minBlockConfirmationConfigured = s_minBlockConfirmation;\\n      if (minBlockConfirmationConfigured == WAIT_FOR_FINALITY) {\\n        revert CustomBlockConfirmationsNotEnabled();\\n      }\\n      if (blockConfirmationRequested \\u003c minBlockConfirmationConfigured) {\\n        revert InvalidMinBlockConfirmation(blockConfirmationRequested, minBlockConfirmationConfigured);\\n      }\\n      _consumeCustomBlockConfirmationOutboundRateLimit(\\n        lockOrBurnIn.localToken, lockOrBurnIn.remoteChainSelector, amount\\n      );\\n    } else {\\n      _consumeOutboundRateLimit(lockOrBurnIn.localToken, lockOrBurnIn.remoteChainSelector, amount);\\n    }\\n\\n    _preflightCheck(lockOrBurnIn, blockConfirmationRequested, tokenArgs, amount);\\n  }\\n\\n  /// @notice Hook for pre-flight checks on lock or burn.\\n  /// @dev These hooks are optional but take up a lot of space in the contracts bytecode. To avoid this overhead when\\n  /// not needed, you can override this function in the derived contract with an empty implementation. This will result\\n  /// in the compiler removing the function and all related code, saving close to 1KB.\\n  /// @param lockOrBurnIn The input to validate.\\n  /// @param blockConfirmationRequested The minimum block confirmation requested by the message.\\n  /// @param tokenArgs Additional token arguments passed in by the sender of the message.\\n  /// @param amountPostFee The amount after token pool bps-based fees have been deducted.\\n  function _preflightCheck(\\n    Pool.LockOrBurnInV1 calldata lockOrBurnIn,\\n    uint16 blockConfirmationRequested,\\n    bytes memory tokenArgs,\\n    uint256 amountPostFee\\n  ) internal virtual {\\n    if (address(s_advancedPoolHooks) != address(0)) {\\n      s_advancedPoolHooks.preflightCheck(lockOrBurnIn, blockConfirmationRequested, tokenArgs, amountPostFee);\\n    }\\n  }\\n\\n  /// @notice Validates the release or mint input for correctness on\\n  /// - token to be released or minted\\n  /// - RMN curse status\\n  /// - if the sender is a valid offRamp\\n  /// - if the source pool is configured for the remote chain\\n  /// - rate limiting for either default or custom block confirmation transfer messages.\\n  /// @param releaseOrMintIn The input to validate.\\n  /// @param localAmount The local amount to be released or minted.\\n  /// @param blockConfirmationRequested The minimum block confirmation requested by the message. A value of zero is used for default finality.\\n  /// @dev This function should always be called before executing a release or mint. Not doing so would allow\\n  /// for various exploits.\\n  function _validateReleaseOrMint(\\n    Pool.ReleaseOrMintInV1 calldata releaseOrMintIn,\\n    uint256 localAmount,\\n    uint16 blockConfirmationRequested\\n  ) internal virtual {\\n    if (!isSupportedToken(releaseOrMintIn.localToken)) {\\n      revert InvalidToken(releaseOrMintIn.localToken);\\n    }\\n    if (IRMN(i_rmnProxy).isCursed(bytes16(uint128(releaseOrMintIn.remoteChainSelector)))) revert CursedByRMN();\\n    _onlyOffRamp(releaseOrMintIn.remoteChainSelector);\\n\\n    // Validates that the source pool address is configured on this pool.\\n    if (!isRemotePool(releaseOrMintIn.remoteChainSelector, releaseOrMintIn.sourcePoolAddress)) {\\n      revert InvalidSourcePoolAddress(releaseOrMintIn.sourcePoolAddress);\\n    }\\n    if (blockConfirmationRequested != WAIT_FOR_FINALITY) {\\n      _consumeCustomBlockConfirmationInboundRateLimit(\\n        releaseOrMintIn.localToken, releaseOrMintIn.remoteChainSelector, localAmount\\n      );\\n    } else {\\n      _consumeInboundRateLimit(releaseOrMintIn.localToken, releaseOrMintIn.remoteChainSelector, localAmount);\\n    }\\n\\n    _postflightCheck(releaseOrMintIn, localAmount, blockConfirmationRequested);\\n  }\\n\\n  /// @notice Hook for post-flight checks on release or mint.\\n  /// @dev These hooks are optional but take up a lot of space in the contracts bytecode. To avoid this overhead when\\n  /// not needed, you can override this function in the derived contract with an empty implementation. This will result\\n  /// in the compiler removing the function and all related code, saving close to 1KB.\\n  /// @param releaseOrMintIn The input to validate.\\n  /// @param localAmount The local amount to be released or minted.\\n  /// @param blockConfirmationRequested The minimum block confirmation requested by the message.\\n  function _postflightCheck(\\n    Pool.ReleaseOrMintInV1 calldata releaseOrMintIn,\\n    uint256 localAmount,\\n    uint16 blockConfirmationRequested\\n  ) internal virtual {\\n    if (address(s_advancedPoolHooks) != address(0)) {\\n      s_advancedPoolHooks.postflightCheck(releaseOrMintIn, localAmount, blockConfirmationRequested);\\n    }\\n  }\\n\\n  // ================================================================\\n  // │                      Token decimals                          │\\n  // ================================================================\\n\\n  /// @notice Gets the IERC20 token decimals on the local chain.\\n  function getTokenDecimals() public view virtual returns (uint8 decimals) {\\n    return i_tokenDecimals;\\n  }\\n\\n  function _encodeLocalDecimals() internal view virtual returns (bytes memory) {\\n    return abi.encode(i_tokenDecimals);\\n  }\\n\\n  function _parseRemoteDecimals(\\n    bytes memory sourcePoolData\\n  ) internal view virtual returns (uint8) {\\n    // Fallback to the local token decimals if the source pool data is empty. This allows for backwards compatibility.\\n    if (sourcePoolData.length == 0) {\\n      return i_tokenDecimals;\\n    }\\n    if (sourcePoolData.length != 32) {\\n      revert InvalidRemoteChainDecimals(sourcePoolData);\\n    }\\n    uint256 remoteDecimals = abi.decode(sourcePoolData, (uint256));\\n    if (remoteDecimals \\u003e type(uint8).max) {\\n      revert InvalidRemoteChainDecimals(sourcePoolData);\\n    }\\n    return uint8(remoteDecimals);\\n  }\\n\\n  /// @notice Calculates the local amount based on the remote amount and decimals.\\n  /// @param remoteAmount The amount on the remote chain.\\n  /// @param remoteDecimals The decimals of the token on the remote chain.\\n  /// @return The local amount.\\n  /// @dev This function protects against overflows. If there is a transaction that hits the overflow check, it is\\n  /// probably incorrect as that means the amount cannot be represented on this chain. If the local decimals have been\\n  /// wrongly configured, the token issuer could redeploy the pool with the correct decimals and manually re-execute the\\n  /// CCIP tx to fix the issue.\\n  function _calculateLocalAmount(\\n    uint256 remoteAmount,\\n    uint8 remoteDecimals\\n  ) internal view virtual returns (uint256) {\\n    if (remoteDecimals == i_tokenDecimals) {\\n      return remoteAmount;\\n    }\\n    if (remoteDecimals \\u003e i_tokenDecimals) {\\n      uint8 decimalsDiff = remoteDecimals - i_tokenDecimals;\\n      if (decimalsDiff \\u003e 77) {\\n        // This is a safety check to prevent overflow in the next calculation.\\n        revert OverflowDetected(remoteDecimals, i_tokenDecimals, remoteAmount);\\n      }\\n      // Solidity rounds down so there is no risk of minting more tokens than the remote chain sent.\\n      return remoteAmount / (10 ** decimalsDiff);\\n    }\\n\\n    // This is a safety check to prevent overflow in the next calculation.\\n    // More than 77 would never fit in a uint256 and would cause an overflow. We also check if the resulting amount\\n    // would overflow.\\n    uint8 diffDecimals = i_tokenDecimals - remoteDecimals;\\n    if (diffDecimals \\u003e 77 || remoteAmount \\u003e type(uint256).max / (10 ** diffDecimals)) {\\n      revert OverflowDetected(remoteDecimals, i_tokenDecimals, remoteAmount);\\n    }\\n\\n    return remoteAmount * (10 ** diffDecimals);\\n  }\\n\\n  // ================================================================\\n  // │                     Chain permissions                        │\\n  // ================================================================\\n\\n  /// @notice Gets the pool address on the remote chain.\\n  /// @param remoteChainSelector Remote chain selector.\\n  /// @dev To support non-evm chains, this value is encoded into bytes\\n  function getRemotePools(\\n    uint64 remoteChainSelector\\n  ) public view virtual returns (bytes[] memory) {\\n    bytes32[] memory remotePoolHashes = s_remoteChainConfigs[remoteChainSelector].remotePools.values();\\n\\n    bytes[] memory remotePools = new bytes[](remotePoolHashes.length);\\n    for (uint256 i = 0; i \\u003c remotePoolHashes.length; ++i) {\\n      remotePools[i] = s_remotePoolAddresses[remotePoolHashes[i]];\\n    }\\n\\n    return remotePools;\\n  }\\n\\n  /// @notice Checks if the pool address is configured on the remote chain.\\n  /// @param remoteChainSelector Remote chain selector.\\n  /// @param remotePoolAddress The address of the remote pool.\\n  function isRemotePool(\\n    uint64 remoteChainSelector,\\n    bytes memory remotePoolAddress\\n  ) public view virtual returns (bool) {\\n    return s_remoteChainConfigs[remoteChainSelector].remotePools.contains(keccak256(remotePoolAddress));\\n  }\\n\\n  /// @inheritdoc IPoolV2\\n  /// @param remoteChainSelector Remote chain selector.\\n  function getRemoteToken(\\n    uint64 remoteChainSelector\\n  ) public view virtual returns (bytes memory) {\\n    return s_remoteChainConfigs[remoteChainSelector].remoteTokenAddress;\\n  }\\n\\n  /// @notice Adds a remote pool for a given chain selector. This could be due to a pool being upgraded on the remote\\n  /// chain. We don't simply want to replace the old pool as there could still be valid inflight messages from the old\\n  /// pool. This function allows for multiple pools to be added for a single chain selector.\\n  /// @param remoteChainSelector The remote chain selector for which the remote pool address is being added.\\n  /// @param remotePoolAddress The address of the new remote pool.\\n  function addRemotePool(\\n    uint64 remoteChainSelector,\\n    bytes calldata remotePoolAddress\\n  ) external virtual onlyOwner {\\n    if (!isSupportedChain(remoteChainSelector)) revert NonExistentChain(remoteChainSelector);\\n\\n    _setRemotePool(remoteChainSelector, remotePoolAddress);\\n  }\\n\\n  /// @notice Removes the remote pool address for a given chain selector.\\n  /// @dev All inflight txs from the remote pool will be rejected after it is removed. To ensure no loss of funds, there\\n  /// should be no inflight txs from the given pool.\\n  /// @param remoteChainSelector The remote chain selector.\\n  /// @param remotePoolAddress The remote pool address to remove.\\n  function removeRemotePool(\\n    uint64 remoteChainSelector,\\n    bytes calldata remotePoolAddress\\n  ) external virtual onlyOwner {\\n    if (!isSupportedChain(remoteChainSelector)) revert NonExistentChain(remoteChainSelector);\\n\\n    if (!s_remoteChainConfigs[remoteChainSelector].remotePools.remove(keccak256(remotePoolAddress))) {\\n      revert InvalidRemotePoolForChain(remoteChainSelector, remotePoolAddress);\\n    }\\n\\n    emit RemotePoolRemoved(remoteChainSelector, remotePoolAddress);\\n  }\\n\\n  /// @inheritdoc IPoolV1\\n  /// @param remoteChainSelector The remote chain selector to check.\\n  function isSupportedChain(\\n    uint64 remoteChainSelector\\n  ) public view virtual returns (bool) {\\n    return s_remoteChainSelectors.contains(remoteChainSelector);\\n  }\\n\\n  /// @notice Get list of allowed chains\\n  /// @return list of chains.\\n  function getSupportedChains() public view virtual returns (uint64[] memory) {\\n    uint256[] memory uint256ChainSelectors = s_remoteChainSelectors.values();\\n    uint64[] memory chainSelectors = new uint64[](uint256ChainSelectors.length);\\n    for (uint256 i = 0; i \\u003c uint256ChainSelectors.length; ++i) {\\n      chainSelectors[i] = uint64(uint256ChainSelectors[i]);\\n    }\\n\\n    return chainSelectors;\\n  }\\n\\n  /// @notice Sets the permissions for a list of chains selectors. Actual senders for these chains\\n  /// need to be allowed on the Router to interact with this pool.\\n  /// @param remoteChainSelectorsToRemove A list of chain selectors to remove.\\n  /// @param chainsToAdd A list of chains and their new permission status \\u0026 rate limits. Rate limits\\n  /// are only used when the chain is being added through `allowed` being true.\\n  /// @dev Only callable by the owner\\n  function applyChainUpdates(\\n    uint64[] calldata remoteChainSelectorsToRemove,\\n    ChainUpdate[] calldata chainsToAdd\\n  ) external virtual onlyOwner {\\n    for (uint256 i = 0; i \\u003c remoteChainSelectorsToRemove.length; ++i) {\\n      uint64 remoteChainSelectorToRemove = remoteChainSelectorsToRemove[i];\\n      // If the chain doesn't exist, revert.\\n      if (!s_remoteChainSelectors.remove(remoteChainSelectorToRemove)) {\\n        revert NonExistentChain(remoteChainSelectorToRemove);\\n      }\\n\\n      // Remove all remote pool hashes for the chain.\\n      bytes32[] memory remotePools = s_remoteChainConfigs[remoteChainSelectorToRemove].remotePools.values();\\n      for (uint256 j = 0; j \\u003c remotePools.length; ++j) {\\n        s_remoteChainConfigs[remoteChainSelectorToRemove].remotePools.remove(remotePools[j]);\\n      }\\n\\n      delete s_remoteChainConfigs[remoteChainSelectorToRemove];\\n\\n      emit ChainRemoved(remoteChainSelectorToRemove);\\n    }\\n\\n    for (uint256 i = 0; i \\u003c chainsToAdd.length; ++i) {\\n      ChainUpdate memory newChain = chainsToAdd[i];\\n      if (newChain.remoteTokenAddress.length == 0) {\\n        revert ZeroAddressInvalid();\\n      }\\n\\n      // If the chain already exists, revert\\n      if (!s_remoteChainSelectors.add(newChain.remoteChainSelector)) {\\n        revert ChainAlreadyExists(newChain.remoteChainSelector);\\n      }\\n\\n      RemoteChainConfig storage remoteChainConfig = s_remoteChainConfigs[newChain.remoteChainSelector];\\n      remoteChainConfig.outboundRateLimiterConfig._setTokenBucketConfig(newChain.outboundRateLimiterConfig);\\n      remoteChainConfig.inboundRateLimiterConfig._setTokenBucketConfig(newChain.inboundRateLimiterConfig);\\n\\n      remoteChainConfig.remoteTokenAddress = newChain.remoteTokenAddress;\\n\\n      for (uint256 j = 0; j \\u003c newChain.remotePoolAddresses.length; ++j) {\\n        _setRemotePool(newChain.remoteChainSelector, newChain.remotePoolAddresses[j]);\\n      }\\n\\n      emit ChainAdded(\\n        newChain.remoteChainSelector,\\n        newChain.remoteTokenAddress,\\n        newChain.outboundRateLimiterConfig,\\n        newChain.inboundRateLimiterConfig\\n      );\\n    }\\n  }\\n\\n  /// @notice Adds a pool address to the allowed remote token pools for a particular chain.\\n  /// @param remoteChainSelector The remote chain selector for which the remote pool address is being added.\\n  /// @param remotePoolAddress The address of the new remote pool.\\n  function _setRemotePool(\\n    uint64 remoteChainSelector,\\n    bytes memory remotePoolAddress\\n  ) internal virtual {\\n    if (remotePoolAddress.length == 0) {\\n      revert ZeroAddressInvalid();\\n    }\\n\\n    bytes32 poolHash = keccak256(remotePoolAddress);\\n\\n    // Check if the pool already exists.\\n    if (!s_remoteChainConfigs[remoteChainSelector].remotePools.add(poolHash)) {\\n      revert PoolAlreadyAdded(remoteChainSelector, remotePoolAddress);\\n    }\\n\\n    // Add the pool to the mapping to be able to un-hash it later.\\n    s_remotePoolAddresses[poolHash] = remotePoolAddress;\\n\\n    emit RemotePoolAdded(remoteChainSelector, remotePoolAddress);\\n  }\\n\\n  // ================================================================\\n  // │                        Rate limiting                         │\\n  // ================================================================\\n\\n  /// @dev The inbound rate limits should be slightly higher than the outbound rate limits. This is because many chains\\n  /// finalize blocks in batches. CCIP also commits messages in batches: the commit plugin bundles multiple messages in\\n  /// a single merkle root.\\n  /// Imagine the following scenario.\\n  /// - Chain A has an inbound and outbound rate limit of 100 tokens capacity and 1 token per second refill rate.\\n  /// - Chain B has an inbound and outbound rate limit of 100 tokens capacity and 1 token per second refill rate.\\n  ///\\n  /// At time 0:\\n  /// - Chain A sends 100 tokens to Chain B.\\n  /// At time 5:\\n  /// - Chain A sends 5 tokens to Chain B.\\n  /// At time 6:\\n  /// The epoch that contains blocks [0-5] is finalized.\\n  /// Both transactions will be included in the same merkle root and become executable at the same time. This means\\n  /// the token pool on chain B requires a capacity of 105 to successfully execute both messages at the same time.\\n  /// The exact additional capacity required depends on the refill rate and the size of the source chain epochs and the\\n  /// CCIP round time. For simplicity, a 5-10% buffer should be sufficient in most cases.\\n\\n  /// @notice Consumes outbound rate limiting capacity in this pool.\\n  /// @param remoteChainSelector The remote chain selector.\\n  /// @param amount The amount of tokens consumed.\\n  function _consumeOutboundRateLimit(\\n    address token,\\n    uint64 remoteChainSelector,\\n    uint256 amount\\n  ) internal virtual {\\n    s_remoteChainConfigs[remoteChainSelector].outboundRateLimiterConfig._consume(amount, token);\\n\\n    emit OutboundRateLimitConsumed({token: token, remoteChainSelector: remoteChainSelector, amount: amount});\\n  }\\n\\n  /// @notice Consumes inbound rate limiting capacity in this pool.\\n  /// @param remoteChainSelector The remote chain selector.\\n  /// @param amount The amount of tokens consumed.\\n  function _consumeInboundRateLimit(\\n    address token,\\n    uint64 remoteChainSelector,\\n    uint256 amount\\n  ) internal virtual {\\n    s_remoteChainConfigs[remoteChainSelector].inboundRateLimiterConfig._consume(amount, token);\\n\\n    emit InboundRateLimitConsumed({token: token, remoteChainSelector: remoteChainSelector, amount: amount});\\n  }\\n\\n  /// @notice Consumes custom block confirmation outbound rate limiting capacity in this pool.\\n  /// @param remoteChainSelector The remote chain selector.\\n  /// @param amount The amount of tokens consumed.\\n  function _consumeCustomBlockConfirmationOutboundRateLimit(\\n    address token,\\n    uint64 remoteChainSelector,\\n    uint256 amount\\n  ) internal virtual {\\n    s_outboundRateLimiterConfig[remoteChainSelector]._consume(amount, token);\\n\\n    emit CustomBlockConfirmationOutboundRateLimitConsumed({\\n      token: token, remoteChainSelector: remoteChainSelector, amount: amount\\n    });\\n  }\\n\\n  /// @notice Consumes custom block confirmation inbound rate limiting capacity in this pool.\\n  /// @param remoteChainSelector The remote chain selector.\\n  /// @param amount The amount of tokens consumed.\\n  function _consumeCustomBlockConfirmationInboundRateLimit(\\n    address token,\\n    uint64 remoteChainSelector,\\n    uint256 amount\\n  ) internal virtual {\\n    s_inboundRateLimiterConfig[remoteChainSelector]._consume(amount, token);\\n\\n    emit CustomBlockConfirmationInboundRateLimitConsumed({\\n      token: token, remoteChainSelector: remoteChainSelector, amount: amount\\n    });\\n  }\\n\\n  /// @notice Returns the outbound and inbound rate limiter state for the given remote chain at the time of the call.\\n  /// @param remoteChainSelector The remote chain selector.\\n  /// @param customBlockConfirmation Whether to get the custom block confirmation rate limiter state.\\n  /// @return outboundRateLimiterState The outbound token bucket.\\n  /// @return inboundRateLimiterState The inbound token bucket.\\n  function getCurrentRateLimiterState(\\n    uint64 remoteChainSelector,\\n    bool customBlockConfirmation\\n  )\\n    external\\n    view\\n    virtual\\n    returns (\\n      RateLimiter.TokenBucket memory outboundRateLimiterState,\\n      RateLimiter.TokenBucket memory inboundRateLimiterState\\n    )\\n  {\\n    if (customBlockConfirmation) {\\n      return (\\n        s_outboundRateLimiterConfig[remoteChainSelector]._currentTokenBucketState(),\\n        s_inboundRateLimiterConfig[remoteChainSelector]._currentTokenBucketState()\\n      );\\n    }\\n    RemoteChainConfig storage config = s_remoteChainConfigs[remoteChainSelector];\\n    return (\\n      config.outboundRateLimiterConfig._currentTokenBucketState(),\\n      config.inboundRateLimiterConfig._currentTokenBucketState()\\n    );\\n  }\\n\\n  /// @notice Sets the rate limit configurations for specified remote chains.\\n  /// @param rateLimitConfigArgs Array of structs containing remote chain selectors and their rate limiter configs.\\n  function setRateLimitConfig(\\n    RateLimitConfigArgs[] calldata rateLimitConfigArgs\\n  ) external virtual {\\n    _onlyOwnerOrRateLimitAdmin();\\n\\n    for (uint256 i = 0; i \\u003c rateLimitConfigArgs.length; ++i) {\\n      RateLimitConfigArgs calldata configArgs = rateLimitConfigArgs[i];\\n\\n      uint64 remoteChainSelector = configArgs.remoteChainSelector;\\n      if (!isSupportedChain(remoteChainSelector)) revert NonExistentChain(remoteChainSelector);\\n\\n      if (configArgs.customBlockConfirmation) {\\n        s_outboundRateLimiterConfig[remoteChainSelector]._setTokenBucketConfig(configArgs.outboundRateLimiterConfig);\\n        s_inboundRateLimiterConfig[remoteChainSelector]._setTokenBucketConfig(configArgs.inboundRateLimiterConfig);\\n      } else {\\n        s_remoteChainConfigs[remoteChainSelector].outboundRateLimiterConfig\\n          ._setTokenBucketConfig(configArgs.outboundRateLimiterConfig);\\n        s_remoteChainConfigs[remoteChainSelector].inboundRateLimiterConfig\\n          ._setTokenBucketConfig(configArgs.inboundRateLimiterConfig);\\n      }\\n\\n      emit RateLimitConfigured(\\n        remoteChainSelector,\\n        configArgs.customBlockConfirmation,\\n        configArgs.outboundRateLimiterConfig,\\n        configArgs.inboundRateLimiterConfig\\n      );\\n    }\\n  }\\n\\n  // ================================================================\\n  // │                           Access                             │\\n  // ================================================================\\n\\n  /// @notice Checks whether remote chain selector is configured on this contract, and if the msg.sender\\n  /// is a permissioned onRamp for the given chain on the Router.\\n  /// @dev This function is marked virtual as other token pools may inherit from this contract, but do\\n  /// not receive calls from the ramps directly, instead receiving them from a proxy contract. In that\\n  /// situation this function must be overridden and the ramp-check removed and replaced with a different\\n  /// access-control scheme.\\n  /// @param remoteChainSelector The remote chain selector.\\n  function _onlyOnRamp(\\n    uint64 remoteChainSelector\\n  ) internal view virtual {\\n    if (!isSupportedChain(remoteChainSelector)) revert ChainNotAllowed(remoteChainSelector);\\n    if (!(msg.sender == s_router.getOnRamp(remoteChainSelector))) revert CallerIsNotARampOnRouter(msg.sender);\\n  }\\n\\n  /// @notice Checks whether remote chain selector is configured on this contract, and if the msg.sender\\n  /// is a permissioned offRamp for the given chain on the Router.\\n  /// @dev This function is marked virtual as other token pools may inherit from this contract, but do\\n  /// not receive calls from the ramps directly, instead receiving them from a proxy contract. In that\\n  /// situation this function must be overridden and the ramp-check removed and replaced with a different\\n  /// access-control scheme.\\n  /// @param remoteChainSelector The remote chain selector.\\n  function _onlyOffRamp(\\n    uint64 remoteChainSelector\\n  ) internal view virtual {\\n    if (!isSupportedChain(remoteChainSelector)) revert ChainNotAllowed(remoteChainSelector);\\n    if (!s_router.isOffRamp(remoteChainSelector, msg.sender)) revert CallerIsNotARampOnRouter(msg.sender);\\n  }\\n\\n  /// @notice Checks whether the msg.sender is either the owner or the rate limit admin.\\n  function _onlyOwnerOrRateLimitAdmin() internal view virtual {\\n    if (msg.sender != s_rateLimitAdmin \\u0026\\u0026 msg.sender != owner()) {\\n      revert Unauthorized(msg.sender);\\n    }\\n  }\\n\\n  /// @notice Returns the set of required CCVs for transfers in a specific direction.\\n  /// @dev This function delegates to AdvancedPoolHooks if configured, otherwise returns an empty array.\\n  /// @param localToken The address of the local token.\\n  /// @param remoteChainSelector The remote chain selector for this transfer.\\n  /// @param amount The amount being transferred.\\n  /// @param blockConfirmationRequested Requested block confirmation.\\n  /// @param extraData Direction-specific payload forwarded by the caller (e.g. token args or source pool data).\\n  /// @param direction The direction of the transfer (Inbound or Outbound).\\n  /// @return requiredCCVs Set of required CCV addresses.\\n  function getRequiredCCVs(\\n    address localToken,\\n    uint64 remoteChainSelector,\\n    uint256 amount,\\n    uint16 blockConfirmationRequested,\\n    bytes calldata extraData,\\n    IPoolV2.MessageDirection direction\\n  ) external view virtual returns (address[] memory requiredCCVs) {\\n    if (address(s_advancedPoolHooks) == address(0)) {\\n      return new address[](0);\\n    }\\n    return s_advancedPoolHooks.getRequiredCCVs(\\n      localToken, remoteChainSelector, amount, blockConfirmationRequested, extraData, direction\\n    );\\n  }\\n\\n  // ================================================================\\n  // │                          Fee                                 │\\n  // ================================================================\\n\\n  /// @notice Updates the token transfer fee configurations for specified destination chains.\\n  /// @param tokenTransferFeeConfigArgs Array of structs containing destination chain selectors and their fee configs.\\n  /// @param disableTokenTransferFeeConfigs Array of destination chain selectors to disable custom fee configs for.\\n  function applyTokenTransferFeeConfigUpdates(\\n    TokenTransferFeeConfigArgs[] calldata tokenTransferFeeConfigArgs,\\n    uint64[] calldata disableTokenTransferFeeConfigs\\n  ) external virtual onlyOwner {\\n    for (uint256 i = 0; i \\u003c tokenTransferFeeConfigArgs.length; ++i) {\\n      uint64 destChainSelector = tokenTransferFeeConfigArgs[i].destChainSelector;\\n      TokenTransferFeeConfig calldata tokenTransferFeeConfig = tokenTransferFeeConfigArgs[i].tokenTransferFeeConfig;\\n\\n      // Reject configs with isEnabled: false - use disableTokenTransferFeeConfigs parameter instead.\\n      if (!tokenTransferFeeConfig.isEnabled) {\\n        revert InvalidTokenTransferFeeConfig(destChainSelector);\\n      }\\n\\n      if (tokenTransferFeeConfig.defaultBlockConfirmationTransferFeeBps \\u003e= BPS_DIVIDER) {\\n        revert InvalidTransferFeeBps(tokenTransferFeeConfig.defaultBlockConfirmationTransferFeeBps);\\n      }\\n      if (tokenTransferFeeConfig.customBlockConfirmationTransferFeeBps \\u003e= BPS_DIVIDER) {\\n        revert InvalidTransferFeeBps(tokenTransferFeeConfig.customBlockConfirmationTransferFeeBps);\\n      }\\n      // Gas overhead must be non-zero for proper fee accounting.\\n      if (tokenTransferFeeConfig.destGasOverhead == 0) {\\n        revert InvalidTokenTransferFeeConfig(destChainSelector);\\n      }\\n\\n      s_tokenTransferFeeConfig[destChainSelector] = tokenTransferFeeConfig;\\n      emit TokenTransferFeeConfigUpdated(destChainSelector, tokenTransferFeeConfig);\\n    }\\n\\n    for (uint256 i = 0; i \\u003c disableTokenTransferFeeConfigs.length; ++i) {\\n      uint64 destChainSelector = disableTokenTransferFeeConfigs[i];\\n      delete s_tokenTransferFeeConfig[destChainSelector];\\n      emit TokenTransferFeeConfigDeleted(destChainSelector);\\n    }\\n  }\\n\\n  /// @notice Returns the token transfer fee override for a destination chain.\\n  /// @param destChainSelector The destination chain selector used for lookup.\\n  /// @return feeConfig The enabled fee configuration for the lane.\\n  function getTokenTransferFeeConfig(\\n    address, // localToken\\n    uint64 destChainSelector,\\n    uint16, // blockConfirmationRequested\\n    bytes calldata // tokenArgs\\n  ) external view virtual returns (TokenTransferFeeConfig memory feeConfig) {\\n    return s_tokenTransferFeeConfig[destChainSelector];\\n  }\\n\\n  /// @inheritdoc IPoolV2\\n  /// @notice Returns the pool fee parameters that will apply to a transfer.\\n  /// @param destChainSelector The destination lane selector.\\n  /// @param blockConfirmationRequested Requested block confirmation.\\n  function getFee(\\n    address, // localToken\\n    uint64 destChainSelector,\\n    uint256, // amount\\n    address, // feeToken\\n    uint16 blockConfirmationRequested,\\n    bytes calldata // tokenArgs\\n  )\\n    external\\n    view\\n    virtual\\n    returns (uint256 feeUSDCents, uint32 destGasOverhead, uint32 destBytesOverhead, uint16 tokenFeeBps, bool isEnabled)\\n  {\\n    uint16 minBlockConfirmationConfigured = s_minBlockConfirmation;\\n    if (blockConfirmationRequested != WAIT_FOR_FINALITY \\u0026\\u0026 minBlockConfirmationConfigured == 0) {\\n      revert CustomBlockConfirmationsNotEnabled();\\n    }\\n    TokenTransferFeeConfig memory feeConfig = s_tokenTransferFeeConfig[destChainSelector];\\n\\n    // If config is disabled, return zeros with isEnabled=false to signal OnRamp to use FeeQuoter defaults.\\n    if (!feeConfig.isEnabled) {\\n      return (0, 0, 0, 0, false);\\n    }\\n\\n    if (blockConfirmationRequested != WAIT_FOR_FINALITY) {\\n      if (blockConfirmationRequested \\u003c minBlockConfirmationConfigured) {\\n        revert InvalidMinBlockConfirmation(blockConfirmationRequested, minBlockConfirmationConfigured);\\n      }\\n      return (\\n        feeConfig.customBlockConfirmationFeeUSDCents,\\n        feeConfig.destGasOverhead,\\n        feeConfig.destBytesOverhead,\\n        feeConfig.customBlockConfirmationTransferFeeBps,\\n        true\\n      );\\n    }\\n    return (\\n      feeConfig.defaultBlockConfirmationFeeUSDCents,\\n      feeConfig.destGasOverhead,\\n      feeConfig.destBytesOverhead,\\n      feeConfig.defaultBlockConfirmationTransferFeeBps,\\n      true\\n    );\\n  }\\n\\n  /// @dev Calculates the fee based on the transferred amount, and the configured basis points.\\n  /// @param lockOrBurnIn The original lock or burn request.\\n  /// @param blockConfirmationRequested The minimum block confirmation requested by the message.\\n  /// A value of zero (WAIT_FOR_FINALITY) applies default finality fees.\\n  /// Returns the fee amount.\\n  function _getFee(\\n    Pool.LockOrBurnInV1 calldata lockOrBurnIn,\\n    uint16 blockConfirmationRequested\\n  ) internal view virtual returns (uint256) {\\n    TokenTransferFeeConfig storage feeConfig = s_tokenTransferFeeConfig[lockOrBurnIn.remoteChainSelector];\\n\\n    // Determine which fee basis points to apply based on finality type.\\n    if (blockConfirmationRequested != WAIT_FOR_FINALITY) {\\n      return (lockOrBurnIn.amount * feeConfig.customBlockConfirmationTransferFeeBps) / BPS_DIVIDER;\\n    } else {\\n      return (lockOrBurnIn.amount * feeConfig.defaultBlockConfirmationTransferFeeBps) / BPS_DIVIDER;\\n    }\\n  }\\n\\n  /// @notice Withdraws accrued fee token balances to the provided `recipient`.\\n  /// @dev Only callable by the owner or the fee admin.\\n  /// @dev FeeTokenHandler will revert if `recipient` is zero address.\\n  /// @dev Pools accrue fees directly on this contract. Lock/release pools send bridge liquidity to their ERC20 lockbox\\n  /// during the lock flow, which means any balance left on this contract represents fees that have accrued to the pool.\\n  /// Because user liquidity never resides on `address(this)` for lock/release pools, transferring the full contract balance is safe\\n  /// and clears only accrued fees.\\n  /// @param feeTokens The token addresses to withdraw, including the pool token when applicable.\\n  /// @param recipient The address to withdraw the fee tokens to.\\n  function withdrawFeeTokens(\\n    address[] calldata feeTokens,\\n    address recipient\\n  ) external virtual {\\n    if (msg.sender != owner() \\u0026\\u0026 msg.sender != s_feeAdmin) {\\n      revert CallerIsNotOwnerOrFeeAdmin(msg.sender);\\n    }\\n    FeeTokenHandler._withdrawFeeTokens(feeTokens, recipient);\\n  }\\n}\\n\"},\"contracts/pools/USDC/BurnMintWithLockReleaseFlagTokenPool.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\nimport {IBurnMintERC20} from \\\"../../interfaces/IBurnMintERC20.sol\\\";\\nimport {IPoolV1} from \\\"../../interfaces/IPool.sol\\\";\\nimport {IPoolV2} from \\\"../../interfaces/IPoolV2.sol\\\";\\n\\nimport {Pool} from \\\"../../libraries/Pool.sol\\\";\\nimport {BurnMintTokenPool} from \\\"../BurnMintTokenPool.sol\\\";\\n\\nbytes4 constant LOCK_RELEASE_FLAG = 0xfa7c07de;\\n\\n/// @notice A standard BurnMintTokenPool with modified destPoolData so that the remote pool knows to release tokens\\n/// instead of minting. This enables interoperability with HybridLockReleaseUSDCTokenPool which uses\\n// the destPoolData to determine whether to mint or release tokens.\\n/// @dev The only difference between this contract and BurnMintTokenPool is the destPoolData returns the\\n/// abi-encoded LOCK_RELEASE_FLAG instead of the local token decimals.\\ncontract BurnMintWithLockReleaseFlagTokenPool is BurnMintTokenPool {\\n  /// @dev Using a function because constant state variables cannot be overridden by child contracts.\\n  function typeAndVersion() external pure override returns (string memory) {\\n    return \\\"BurnMintWithLockReleaseFlagTokenPool 2.0.0-dev\\\";\\n  }\\n\\n  constructor(\\n    IBurnMintERC20 token,\\n    uint8 localTokenDecimals,\\n    address advancedPoolHooks,\\n    address rmnProxy,\\n    address router\\n  ) BurnMintTokenPool(token, localTokenDecimals, advancedPoolHooks, rmnProxy, router) {}\\n\\n  /// @dev Performs the exact same functionality as BurnMintTokenPool, but returns the LOCK_RELEASE_FLAG\\n  /// as the destPoolData to signal to the remote pool to release tokens instead of minting them.\\n  /// @inheritdoc IPoolV1\\n  function lockOrBurn(\\n    Pool.LockOrBurnInV1 calldata lockOrBurnIn\\n  ) public override returns (Pool.LockOrBurnOutV1 memory out) {\\n    out = super.lockOrBurn(lockOrBurnIn);\\n    out.destPoolData = abi.encode(LOCK_RELEASE_FLAG);\\n    return out;\\n  }\\n\\n  /// @dev Performs the exact same functionality as BurnMintTokenPool, but returns the LOCK_RELEASE_FLAG\\n  /// as the destPoolData to signal to the remote pool to release tokens instead of minting them.\\n  /// @inheritdoc IPoolV2\\n  function lockOrBurn(\\n    Pool.LockOrBurnInV1 calldata lockOrBurnIn,\\n    uint16 blockConfirmationRequested,\\n    bytes calldata tokenArgs\\n  ) public override returns (Pool.LockOrBurnOutV1 memory out, uint256 destTokenAmount) {\\n    (out, destTokenAmount) = super.lockOrBurn(lockOrBurnIn, blockConfirmationRequested, tokenArgs);\\n    out.destPoolData = abi.encode(LOCK_RELEASE_FLAG);\\n    return (out, destTokenAmount);\\n  }\\n\\n  /// @inheritdoc IPoolV2\\n  function releaseOrMint(\\n    Pool.ReleaseOrMintInV1 calldata releaseOrMintIn,\\n    uint16 blockConfirmationRequested\\n  ) public virtual override returns (Pool.ReleaseOrMintOutV1 memory) {\\n    // Since USDC is 6 decimals on all chains, we don't need to convert to a different denomination.\\n    _validateReleaseOrMint(releaseOrMintIn, releaseOrMintIn.sourceDenominatedAmount, blockConfirmationRequested);\\n\\n    _releaseOrMint(\\n      releaseOrMintIn.receiver, releaseOrMintIn.sourceDenominatedAmount, releaseOrMintIn.remoteChainSelector\\n    );\\n\\n    emit ReleasedOrMinted({\\n      remoteChainSelector: releaseOrMintIn.remoteChainSelector,\\n      token: address(i_token),\\n      sender: msg.sender,\\n      recipient: releaseOrMintIn.receiver,\\n      amount: releaseOrMintIn.sourceDenominatedAmount\\n    });\\n\\n    return Pool.ReleaseOrMintOutV1({destinationAmount: releaseOrMintIn.sourceDenominatedAmount});\\n  }\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2Step.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {IOwnable} from \\\"../interfaces/IOwnable.sol\\\";\\n\\n/// @notice A minimal contract that implements 2-step ownership transfer and nothing more. It's made to be minimal\\n/// to reduce the impact of the bytecode size on any contract that inherits from it.\\ncontract Ownable2Step is IOwnable {\\n  /// @notice The pending owner is the address to which ownership may be transferred.\\n  address private s_pendingOwner;\\n  /// @notice The owner is the current owner of the contract.\\n  /// @dev The owner is the second storage variable so any implementing contract could pack other state with it\\n  /// instead of the much less used s_pendingOwner.\\n  address private s_owner;\\n\\n  error OwnerCannotBeZero();\\n  error MustBeProposedOwner();\\n  error CannotTransferToSelf();\\n  error OnlyCallableByOwner();\\n\\n  event OwnershipTransferRequested(address indexed from, address indexed to);\\n  event OwnershipTransferred(address indexed from, address indexed to);\\n\\n  constructor(address newOwner, address pendingOwner) {\\n    if (newOwner == address(0)) {\\n      revert OwnerCannotBeZero();\\n    }\\n\\n    s_owner = newOwner;\\n    if (pendingOwner != address(0)) {\\n      _transferOwnership(pendingOwner);\\n    }\\n  }\\n\\n  /// @notice Get the current owner\\n  function owner() public view override returns (address) {\\n    return s_owner;\\n  }\\n\\n  /// @notice Allows an owner to begin transferring ownership to a new address. The new owner needs to call\\n  /// `acceptOwnership` to accept the transfer before any permissions are changed.\\n  /// @param to The address to which ownership will be transferred.\\n  function transferOwnership(\\n    address to\\n  ) public override onlyOwner {\\n    _transferOwnership(to);\\n  }\\n\\n  /// @notice validate, transfer ownership, and emit relevant events\\n  /// @param to The address to which ownership will be transferred.\\n  function _transferOwnership(\\n    address to\\n  ) private {\\n    if (to == msg.sender) {\\n      revert CannotTransferToSelf();\\n    }\\n\\n    s_pendingOwner = to;\\n\\n    emit OwnershipTransferRequested(s_owner, to);\\n  }\\n\\n  /// @notice Allows an ownership transfer to be completed by the recipient.\\n  function acceptOwnership() external override {\\n    if (msg.sender != s_pendingOwner) {\\n      revert MustBeProposedOwner();\\n    }\\n\\n    address oldOwner = s_owner;\\n    s_owner = msg.sender;\\n    s_pendingOwner = address(0);\\n\\n    emit OwnershipTransferred(oldOwner, msg.sender);\\n  }\\n\\n  /// @notice validate access\\n  function _validateOwnership() internal view {\\n    if (msg.sender != s_owner) {\\n      revert OnlyCallableByOwner();\\n    }\\n  }\\n\\n  /// @notice Reverts if called by anyone other than the contract owner.\\n  modifier onlyOwner() {\\n    _validateOwnership();\\n    _;\\n  }\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2StepMsgSender.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {Ownable2Step} from \\\"./Ownable2Step.sol\\\";\\n\\n/// @notice Sets the msg.sender to be the owner of the contract and does not set a pending owner.\\ncontract Ownable2StepMsgSender is Ownable2Step {\\n  constructor() Ownable2Step(msg.sender, address(0)) {}\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/IOwnable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IOwnable {\\n  function owner() external returns (address);\\n\\n  function transferOwnership(\\n    address recipient\\n  ) external;\\n\\n  function acceptOwnership() external;\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/ITypeAndVersion.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ITypeAndVersion {\\n  function typeAndVersion() external pure returns (string memory);\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/interfaces/IERC1363.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1363.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @title IERC1363\\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\\n *\\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\\n */\\ninterface IERC1363 is IERC20, IERC165 {\\n    /*\\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\\n     * 0xb0202a11 ===\\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\\n     */\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferAndCall(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @param data Additional data with no specified format, sent in call to `to`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param from The address which you want to send tokens from.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param from The address which you want to send tokens from.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @param data Additional data with no specified format, sent in call to `to`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function approveAndCall(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     * @param data Additional data with no specified format, sent in call to `spender`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../utils/introspection/IERC165.sol\\\";\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../token/ERC20/IERC20.sol\\\";\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-20 standard as defined in the ERC.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\nimport {IERC1363} from \\\"../../../interfaces/IERC1363.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    /**\\n     * @dev An operation with an ERC-20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Indicates a failed `decreaseAllowance` request.\\n     */\\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\\n     */\\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\\n     */\\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     *\\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \\\"client\\\"\\n     * smart contract uses ERC-7674 to set temporary allowances, then the \\\"client\\\" smart contract should avoid using\\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\\n     * value, non-reverting calls are assumed to be successful.\\n     *\\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \\\"client\\\"\\n     * smart contract uses ERC-7674 to set temporary allowances, then the \\\"client\\\" smart contract should avoid using\\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance \\u003c requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     *\\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\\n     * only sets the \\\"standard\\\" allowance. Any temporary allowance will remain active, in addition to the value being\\n     * set here.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\\n        if (to.code.length == 0) {\\n            safeTransfer(token, to, value);\\n        } else if (!token.transferAndCall(to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function transferFromAndCallRelaxed(\\n        IERC1363 token,\\n        address from,\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal {\\n        if (to.code.length == 0) {\\n            safeTransferFrom(token, from, to, value);\\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\\n     * once without retrying, and relies on the returned value to be true.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\\n        if (to.code.length == 0) {\\n            forceApprove(token, to, value);\\n        } else if (!token.approveAndCall(to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly (\\\"memory-safe\\\") {\\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\\n            // bubble errors\\n            if iszero(success) {\\n                let ptr := mload(0x40)\\n                returndatacopy(ptr, 0, returndatasize())\\n                revert(ptr, returndatasize())\\n            }\\n            returnSize := returndatasize()\\n            returnValue := mload(0)\\n        }\\n\\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly (\\\"memory-safe\\\") {\\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\\n            returnSize := returndatasize()\\n            returnValue := mload(0)\\n        }\\n        return success \\u0026\\u0026 (returnSize == 0 ? address(token).code.length \\u003e 0 : returnValue == 1);\\n    }\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/utils/Arrays.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Arrays.sol)\\n// This file was procedurally generated from scripts/generate/templates/Arrays.js.\\n\\npragma solidity ^0.8.20;\\n\\nimport {Comparators} from \\\"./Comparators.sol\\\";\\nimport {SlotDerivation} from \\\"./SlotDerivation.sol\\\";\\nimport {StorageSlot} from \\\"./StorageSlot.sol\\\";\\nimport {Math} from \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev Collection of functions related to array types.\\n */\\nlibrary Arrays {\\n    using SlotDerivation for bytes32;\\n    using StorageSlot for bytes32;\\n\\n    /**\\n     * @dev Sort an array of uint256 (in memory) following the provided comparator function.\\n     *\\n     * This function does the sorting \\\"in place\\\", meaning that it overrides the input. The object is returned for\\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\\n     *\\n     * NOTE: this function's cost is `O(n · log(n))` in average and `O(n²)` in the worst case, with n the length of the\\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\\n     * consume more gas than is available in a block, leading to potential DoS.\\n     *\\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\\n     */\\n    function sort(\\n        uint256[] memory array,\\n        function(uint256, uint256) pure returns (bool) comp\\n    ) internal pure returns (uint256[] memory) {\\n        _quickSort(_begin(array), _end(array), comp);\\n        return array;\\n    }\\n\\n    /**\\n     * @dev Variant of {sort} that sorts an array of uint256 in increasing order.\\n     */\\n    function sort(uint256[] memory array) internal pure returns (uint256[] memory) {\\n        sort(array, Comparators.lt);\\n        return array;\\n    }\\n\\n    /**\\n     * @dev Sort an array of address (in memory) following the provided comparator function.\\n     *\\n     * This function does the sorting \\\"in place\\\", meaning that it overrides the input. The object is returned for\\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\\n     *\\n     * NOTE: this function's cost is `O(n · log(n))` in average and `O(n²)` in the worst case, with n the length of the\\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\\n     * consume more gas than is available in a block, leading to potential DoS.\\n     *\\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\\n     */\\n    function sort(\\n        address[] memory array,\\n        function(address, address) pure returns (bool) comp\\n    ) internal pure returns (address[] memory) {\\n        sort(_castToUint256Array(array), _castToUint256Comp(comp));\\n        return array;\\n    }\\n\\n    /**\\n     * @dev Variant of {sort} that sorts an array of address in increasing order.\\n     */\\n    function sort(address[] memory array) internal pure returns (address[] memory) {\\n        sort(_castToUint256Array(array), Comparators.lt);\\n        return array;\\n    }\\n\\n    /**\\n     * @dev Sort an array of bytes32 (in memory) following the provided comparator function.\\n     *\\n     * This function does the sorting \\\"in place\\\", meaning that it overrides the input. The object is returned for\\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\\n     *\\n     * NOTE: this function's cost is `O(n · log(n))` in average and `O(n²)` in the worst case, with n the length of the\\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\\n     * consume more gas than is available in a block, leading to potential DoS.\\n     *\\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\\n     */\\n    function sort(\\n        bytes32[] memory array,\\n        function(bytes32, bytes32) pure returns (bool) comp\\n    ) internal pure returns (bytes32[] memory) {\\n        sort(_castToUint256Array(array), _castToUint256Comp(comp));\\n        return array;\\n    }\\n\\n    /**\\n     * @dev Variant of {sort} that sorts an array of bytes32 in increasing order.\\n     */\\n    function sort(bytes32[] memory array) internal pure returns (bytes32[] memory) {\\n        sort(_castToUint256Array(array), Comparators.lt);\\n        return array;\\n    }\\n\\n    /**\\n     * @dev Performs a quick sort of a segment of memory. The segment sorted starts at `begin` (inclusive), and stops\\n     * at end (exclusive). Sorting follows the `comp` comparator.\\n     *\\n     * Invariant: `begin \\u003c= end`. This is the case when initially called by {sort} and is preserved in subcalls.\\n     *\\n     * IMPORTANT: Memory locations between `begin` and `end` are not validated/zeroed. This function should\\n     * be used only if the limits are within a memory array.\\n     */\\n    function _quickSort(uint256 begin, uint256 end, function(uint256, uint256) pure returns (bool) comp) private pure {\\n        unchecked {\\n            if (end - begin \\u003c 0x40) return;\\n\\n            // Use first element as pivot\\n            uint256 pivot = _mload(begin);\\n            // Position where the pivot should be at the end of the loop\\n            uint256 pos = begin;\\n\\n            for (uint256 it = begin + 0x20; it \\u003c end; it += 0x20) {\\n                if (comp(_mload(it), pivot)) {\\n                    // If the value stored at the iterator's position comes before the pivot, we increment the\\n                    // position of the pivot and move the value there.\\n                    pos += 0x20;\\n                    _swap(pos, it);\\n                }\\n            }\\n\\n            _swap(begin, pos); // Swap pivot into place\\n            _quickSort(begin, pos, comp); // Sort the left side of the pivot\\n            _quickSort(pos + 0x20, end, comp); // Sort the right side of the pivot\\n        }\\n    }\\n\\n    /**\\n     * @dev Pointer to the memory location of the first element of `array`.\\n     */\\n    function _begin(uint256[] memory array) private pure returns (uint256 ptr) {\\n        assembly (\\\"memory-safe\\\") {\\n            ptr := add(array, 0x20)\\n        }\\n    }\\n\\n    /**\\n     * @dev Pointer to the memory location of the first memory word (32bytes) after `array`. This is the memory word\\n     * that comes just after the last element of the array.\\n     */\\n    function _end(uint256[] memory array) private pure returns (uint256 ptr) {\\n        unchecked {\\n            return _begin(array) + array.length * 0x20;\\n        }\\n    }\\n\\n    /**\\n     * @dev Load memory word (as a uint256) at location `ptr`.\\n     */\\n    function _mload(uint256 ptr) private pure returns (uint256 value) {\\n        assembly {\\n            value := mload(ptr)\\n        }\\n    }\\n\\n    /**\\n     * @dev Swaps the elements memory location `ptr1` and `ptr2`.\\n     */\\n    function _swap(uint256 ptr1, uint256 ptr2) private pure {\\n        assembly {\\n            let value1 := mload(ptr1)\\n            let value2 := mload(ptr2)\\n            mstore(ptr1, value2)\\n            mstore(ptr2, value1)\\n        }\\n    }\\n\\n    /// @dev Helper: low level cast address memory array to uint256 memory array\\n    function _castToUint256Array(address[] memory input) private pure returns (uint256[] memory output) {\\n        assembly {\\n            output := input\\n        }\\n    }\\n\\n    /// @dev Helper: low level cast bytes32 memory array to uint256 memory array\\n    function _castToUint256Array(bytes32[] memory input) private pure returns (uint256[] memory output) {\\n        assembly {\\n            output := input\\n        }\\n    }\\n\\n    /// @dev Helper: low level cast address comp function to uint256 comp function\\n    function _castToUint256Comp(\\n        function(address, address) pure returns (bool) input\\n    ) private pure returns (function(uint256, uint256) pure returns (bool) output) {\\n        assembly {\\n            output := input\\n        }\\n    }\\n\\n    /// @dev Helper: low level cast bytes32 comp function to uint256 comp function\\n    function _castToUint256Comp(\\n        function(bytes32, bytes32) pure returns (bool) input\\n    ) private pure returns (function(uint256, uint256) pure returns (bool) output) {\\n        assembly {\\n            output := input\\n        }\\n    }\\n\\n    /**\\n     * @dev Searches a sorted `array` and returns the first index that contains\\n     * a value greater or equal to `element`. If no such index exists (i.e. all\\n     * values in the array are strictly less than `element`), the array length is\\n     * returned. Time complexity O(log n).\\n     *\\n     * NOTE: The `array` is expected to be sorted in ascending order, and to\\n     * contain no repeated elements.\\n     *\\n     * IMPORTANT: Deprecated. This implementation behaves as {lowerBound} but lacks\\n     * support for repeated elements in the array. The {lowerBound} function should\\n     * be used instead.\\n     */\\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\\n        uint256 low = 0;\\n        uint256 high = array.length;\\n\\n        if (high == 0) {\\n            return 0;\\n        }\\n\\n        while (low \\u003c high) {\\n            uint256 mid = Math.average(low, high);\\n\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\n            // because Math.average rounds towards zero (it does integer division with truncation).\\n            if (unsafeAccess(array, mid).value \\u003e element) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\\n        if (low \\u003e 0 \\u0026\\u0026 unsafeAccess(array, low - 1).value == element) {\\n            return low - 1;\\n        } else {\\n            return low;\\n        }\\n    }\\n\\n    /**\\n     * @dev Searches an `array` sorted in ascending order and returns the first\\n     * index that contains a value greater or equal than `element`. If no such index\\n     * exists (i.e. all values in the array are strictly less than `element`), the array\\n     * length is returned. Time complexity O(log n).\\n     *\\n     * See C++'s https://en.cppreference.com/w/cpp/algorithm/lower_bound[lower_bound].\\n     */\\n    function lowerBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\\n        uint256 low = 0;\\n        uint256 high = array.length;\\n\\n        if (high == 0) {\\n            return 0;\\n        }\\n\\n        while (low \\u003c high) {\\n            uint256 mid = Math.average(low, high);\\n\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\n            // because Math.average rounds towards zero (it does integer division with truncation).\\n            if (unsafeAccess(array, mid).value \\u003c element) {\\n                // this cannot overflow because mid \\u003c high\\n                unchecked {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                high = mid;\\n            }\\n        }\\n\\n        return low;\\n    }\\n\\n    /**\\n     * @dev Searches an `array` sorted in ascending order and returns the first\\n     * index that contains a value strictly greater than `element`. If no such index\\n     * exists (i.e. all values in the array are strictly less than `element`), the array\\n     * length is returned. Time complexity O(log n).\\n     *\\n     * See C++'s https://en.cppreference.com/w/cpp/algorithm/upper_bound[upper_bound].\\n     */\\n    function upperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\\n        uint256 low = 0;\\n        uint256 high = array.length;\\n\\n        if (high == 0) {\\n            return 0;\\n        }\\n\\n        while (low \\u003c high) {\\n            uint256 mid = Math.average(low, high);\\n\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\n            // because Math.average rounds towards zero (it does integer division with truncation).\\n            if (unsafeAccess(array, mid).value \\u003e element) {\\n                high = mid;\\n            } else {\\n                // this cannot overflow because mid \\u003c high\\n                unchecked {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n\\n        return low;\\n    }\\n\\n    /**\\n     * @dev Same as {lowerBound}, but with an array in memory.\\n     */\\n    function lowerBoundMemory(uint256[] memory array, uint256 element) internal pure returns (uint256) {\\n        uint256 low = 0;\\n        uint256 high = array.length;\\n\\n        if (high == 0) {\\n            return 0;\\n        }\\n\\n        while (low \\u003c high) {\\n            uint256 mid = Math.average(low, high);\\n\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\n            // because Math.average rounds towards zero (it does integer division with truncation).\\n            if (unsafeMemoryAccess(array, mid) \\u003c element) {\\n                // this cannot overflow because mid \\u003c high\\n                unchecked {\\n                    low = mid + 1;\\n                }\\n            } else {\\n                high = mid;\\n            }\\n        }\\n\\n        return low;\\n    }\\n\\n    /**\\n     * @dev Same as {upperBound}, but with an array in memory.\\n     */\\n    function upperBoundMemory(uint256[] memory array, uint256 element) internal pure returns (uint256) {\\n        uint256 low = 0;\\n        uint256 high = array.length;\\n\\n        if (high == 0) {\\n            return 0;\\n        }\\n\\n        while (low \\u003c high) {\\n            uint256 mid = Math.average(low, high);\\n\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\n            // because Math.average rounds towards zero (it does integer division with truncation).\\n            if (unsafeMemoryAccess(array, mid) \\u003e element) {\\n                high = mid;\\n            } else {\\n                // this cannot overflow because mid \\u003c high\\n                unchecked {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n\\n        return low;\\n    }\\n\\n    /**\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\n     *\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\n     */\\n    function unsafeAccess(address[] storage arr, uint256 pos) internal pure returns (StorageSlot.AddressSlot storage) {\\n        bytes32 slot;\\n        assembly (\\\"memory-safe\\\") {\\n            slot := arr.slot\\n        }\\n        return slot.deriveArray().offset(pos).getAddressSlot();\\n    }\\n\\n    /**\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\n     *\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\n     */\\n    function unsafeAccess(bytes32[] storage arr, uint256 pos) internal pure returns (StorageSlot.Bytes32Slot storage) {\\n        bytes32 slot;\\n        assembly (\\\"memory-safe\\\") {\\n            slot := arr.slot\\n        }\\n        return slot.deriveArray().offset(pos).getBytes32Slot();\\n    }\\n\\n    /**\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\n     *\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\n     */\\n    function unsafeAccess(uint256[] storage arr, uint256 pos) internal pure returns (StorageSlot.Uint256Slot storage) {\\n        bytes32 slot;\\n        assembly (\\\"memory-safe\\\") {\\n            slot := arr.slot\\n        }\\n        return slot.deriveArray().offset(pos).getUint256Slot();\\n    }\\n\\n    /**\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\n     *\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\n     */\\n    function unsafeMemoryAccess(address[] memory arr, uint256 pos) internal pure returns (address res) {\\n        assembly {\\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\\n        }\\n    }\\n\\n    /**\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\n     *\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\n     */\\n    function unsafeMemoryAccess(bytes32[] memory arr, uint256 pos) internal pure returns (bytes32 res) {\\n        assembly {\\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\\n        }\\n    }\\n\\n    /**\\n     * @dev Access an array in an \\\"unsafe\\\" way. Skips solidity \\\"index-out-of-range\\\" check.\\n     *\\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\\n     */\\n    function unsafeMemoryAccess(uint256[] memory arr, uint256 pos) internal pure returns (uint256 res) {\\n        assembly {\\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\\n        }\\n    }\\n\\n    /**\\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\\n     *\\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\\n     */\\n    function unsafeSetLength(address[] storage array, uint256 len) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(array.slot, len)\\n        }\\n    }\\n\\n    /**\\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\\n     *\\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\\n     */\\n    function unsafeSetLength(bytes32[] storage array, uint256 len) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(array.slot, len)\\n        }\\n    }\\n\\n    /**\\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\\n     *\\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\\n     */\\n    function unsafeSetLength(uint256[] storage array, uint256 len) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(array.slot, len)\\n        }\\n    }\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/utils/Comparators.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Comparators.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides a set of functions to compare values.\\n *\\n * _Available since v5.1._\\n */\\nlibrary Comparators {\\n    function lt(uint256 a, uint256 b) internal pure returns (bool) {\\n        return a \\u003c b;\\n    }\\n\\n    function gt(uint256 a, uint256 b) internal pure returns (bool) {\\n        return a \\u003e b;\\n    }\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/utils/Panic.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Helper library for emitting standardized panic codes.\\n *\\n * ```solidity\\n * contract Example {\\n *      using Panic for uint256;\\n *\\n *      // Use any of the declared internal constants\\n *      function foo() { Panic.GENERIC.panic(); }\\n *\\n *      // Alternatively\\n *      function foo() { Panic.panic(Panic.GENERIC); }\\n * }\\n * ```\\n *\\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\\n *\\n * _Available since v5.1._\\n */\\n// slither-disable-next-line unused-state\\nlibrary Panic {\\n    /// @dev generic / unspecified error\\n    uint256 internal constant GENERIC = 0x00;\\n    /// @dev used by the assert() builtin\\n    uint256 internal constant ASSERT = 0x01;\\n    /// @dev arithmetic underflow or overflow\\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\\n    /// @dev division or modulo by zero\\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\\n    /// @dev enum conversion error\\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\\n    /// @dev invalid encoding in storage\\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\\n    /// @dev empty array pop\\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\\n    /// @dev array out of bounds access\\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\\n    /// @dev resource error (too large allocation or too large array)\\n    uint256 internal constant RESOURCE_ERROR = 0x41;\\n    /// @dev calling invalid internal function\\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\\n\\n    /// @dev Reverts with a panic code. Recommended to use with\\n    /// the internal constants with predefined codes.\\n    function panic(uint256 code) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, 0x4e487b71)\\n            mstore(0x20, code)\\n            revert(0x1c, 0x24)\\n        }\\n    }\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/utils/SlotDerivation.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/SlotDerivation.sol)\\n// This file was procedurally generated from scripts/generate/templates/SlotDerivation.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for computing storage (and transient storage) locations from namespaces and deriving slots\\n * corresponding to standard patterns. The derivation method for array and mapping matches the storage layout used by\\n * the solidity language / compiler.\\n *\\n * See https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays[Solidity docs for mappings and dynamic arrays.].\\n *\\n * Example usage:\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using StorageSlot for bytes32;\\n *     using SlotDerivation for bytes32;\\n *\\n *     // Declare a namespace\\n *     string private constant _NAMESPACE = \\\"\\u003cnamespace\\u003e\\\"; // eg. OpenZeppelin.Slot\\n *\\n *     function setValueInNamespace(uint256 key, address newValue) internal {\\n *         _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value = newValue;\\n *     }\\n *\\n *     function getValueInNamespace(uint256 key) internal view returns (address) {\\n *         return _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value;\\n *     }\\n * }\\n * ```\\n *\\n * TIP: Consider using this library along with {StorageSlot}.\\n *\\n * NOTE: This library provides a way to manipulate storage locations in a non-standard way. Tooling for checking\\n * upgrade safety will ignore the slots accessed through this library.\\n *\\n * _Available since v5.1._\\n */\\nlibrary SlotDerivation {\\n    /**\\n     * @dev Derive an ERC-7201 slot from a string (namespace).\\n     */\\n    function erc7201Slot(string memory namespace) internal pure returns (bytes32 slot) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, sub(keccak256(add(namespace, 0x20), mload(namespace)), 1))\\n            slot := and(keccak256(0x00, 0x20), not(0xff))\\n        }\\n    }\\n\\n    /**\\n     * @dev Add an offset to a slot to get the n-th element of a structure or an array.\\n     */\\n    function offset(bytes32 slot, uint256 pos) internal pure returns (bytes32 result) {\\n        unchecked {\\n            return bytes32(uint256(slot) + pos);\\n        }\\n    }\\n\\n    /**\\n     * @dev Derive the location of the first element in an array from the slot where the length is stored.\\n     */\\n    function deriveArray(bytes32 slot) internal pure returns (bytes32 result) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, slot)\\n            result := keccak256(0x00, 0x20)\\n        }\\n    }\\n\\n    /**\\n     * @dev Derive the location of a mapping element from the key.\\n     */\\n    function deriveMapping(bytes32 slot, address key) internal pure returns (bytes32 result) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, and(key, shr(96, not(0))))\\n            mstore(0x20, slot)\\n            result := keccak256(0x00, 0x40)\\n        }\\n    }\\n\\n    /**\\n     * @dev Derive the location of a mapping element from the key.\\n     */\\n    function deriveMapping(bytes32 slot, bool key) internal pure returns (bytes32 result) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, iszero(iszero(key)))\\n            mstore(0x20, slot)\\n            result := keccak256(0x00, 0x40)\\n        }\\n    }\\n\\n    /**\\n     * @dev Derive the location of a mapping element from the key.\\n     */\\n    function deriveMapping(bytes32 slot, bytes32 key) internal pure returns (bytes32 result) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, key)\\n            mstore(0x20, slot)\\n            result := keccak256(0x00, 0x40)\\n        }\\n    }\\n\\n    /**\\n     * @dev Derive the location of a mapping element from the key.\\n     */\\n    function deriveMapping(bytes32 slot, uint256 key) internal pure returns (bytes32 result) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, key)\\n            mstore(0x20, slot)\\n            result := keccak256(0x00, 0x40)\\n        }\\n    }\\n\\n    /**\\n     * @dev Derive the location of a mapping element from the key.\\n     */\\n    function deriveMapping(bytes32 slot, int256 key) internal pure returns (bytes32 result) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, key)\\n            mstore(0x20, slot)\\n            result := keccak256(0x00, 0x40)\\n        }\\n    }\\n\\n    /**\\n     * @dev Derive the location of a mapping element from the key.\\n     */\\n    function deriveMapping(bytes32 slot, string memory key) internal pure returns (bytes32 result) {\\n        assembly (\\\"memory-safe\\\") {\\n            let length := mload(key)\\n            let begin := add(key, 0x20)\\n            let end := add(begin, length)\\n            let cache := mload(end)\\n            mstore(end, slot)\\n            result := keccak256(begin, add(length, 0x20))\\n            mstore(end, cache)\\n        }\\n    }\\n\\n    /**\\n     * @dev Derive the location of a mapping element from the key.\\n     */\\n    function deriveMapping(bytes32 slot, bytes memory key) internal pure returns (bytes32 result) {\\n        assembly (\\\"memory-safe\\\") {\\n            let length := mload(key)\\n            let begin := add(key, 0x20)\\n            let end := add(begin, length)\\n            let cache := mload(end)\\n            mstore(end, slot)\\n            result := keccak256(begin, add(length, 0x20))\\n            mstore(end, cache)\\n        }\\n    }\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/utils/StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC-1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(newImplementation.code.length \\u003e 0);\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * TIP: Consider using this library along with {SlotDerivation}.\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct Int256Slot {\\n        int256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `Int256Slot` with member `value` located at `slot`.\\n     */\\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Panic} from \\\"../Panic.sol\\\";\\nimport {SafeCast} from \\\"./SafeCast.sol\\\";\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Return the 512-bit addition of two uint256.\\n     *\\n     * The result is stored in two 256 variables such that sum = high * 2²⁵⁶ + low.\\n     */\\n    function add512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\\n        assembly (\\\"memory-safe\\\") {\\n            low := add(a, b)\\n            high := lt(low, a)\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the 512-bit multiplication of two uint256.\\n     *\\n     * The result is stored in two 256 variables such that product = high * 2²⁵⁶ + low.\\n     */\\n    function mul512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\\n        // 512-bit multiply [high low] = x * y. Compute the product mod 2²⁵⁶ and mod 2²⁵⁶ - 1, then use\\n        // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n        // variables such that product = high * 2²⁵⁶ + low.\\n        assembly (\\\"memory-safe\\\") {\\n            let mm := mulmod(a, b, not(0))\\n            low := mul(a, b)\\n            high := sub(sub(mm, low), lt(mm, low))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with a success flag (no overflow).\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n        unchecked {\\n            uint256 c = a + b;\\n            success = c \\u003e= a;\\n            result = c * SafeCast.toUint(success);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with a success flag (no overflow).\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n        unchecked {\\n            uint256 c = a - b;\\n            success = c \\u003c= a;\\n            result = c * SafeCast.toUint(success);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with a success flag (no overflow).\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n        unchecked {\\n            uint256 c = a * b;\\n            assembly (\\\"memory-safe\\\") {\\n                // Only true when the multiplication doesn't overflow\\n                // (c / a == b) || (a == 0)\\n                success := or(eq(div(c, a), b), iszero(a))\\n            }\\n            // equivalent to: success ? c : 0\\n            result = c * SafeCast.toUint(success);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n        unchecked {\\n            success = b \\u003e 0;\\n            assembly (\\\"memory-safe\\\") {\\n                // The `DIV` opcode returns zero when the denominator is 0.\\n                result := div(a, b)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\\n        unchecked {\\n            success = b \\u003e 0;\\n            assembly (\\\"memory-safe\\\") {\\n                // The `MOD` opcode returns zero when the denominator is 0.\\n                result := mod(a, b)\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Unsigned saturating addition, bounds to `2²⁵⁶ - 1` instead of overflowing.\\n     */\\n    function saturatingAdd(uint256 a, uint256 b) internal pure returns (uint256) {\\n        (bool success, uint256 result) = tryAdd(a, b);\\n        return ternary(success, result, type(uint256).max);\\n    }\\n\\n    /**\\n     * @dev Unsigned saturating subtraction, bounds to zero instead of overflowing.\\n     */\\n    function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        (, uint256 result) = trySub(a, b);\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Unsigned saturating multiplication, bounds to `2²⁵⁶ - 1` instead of overflowing.\\n     */\\n    function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        (bool success, uint256 result) = tryMul(a, b);\\n        return ternary(success, result, type(uint256).max);\\n    }\\n\\n    /**\\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\\n     *\\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\\n     * one branch when needed, making this function more expensive.\\n     */\\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\\n        unchecked {\\n            // branchless ternary works because:\\n            // b ^ (a ^ b) == a\\n            // b ^ 0 == b\\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return ternary(a \\u003e b, a, b);\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return ternary(a \\u003c b, a, b);\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a \\u0026 b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            Panic.panic(Panic.DIVISION_BY_ZERO);\\n        }\\n\\n        // The following calculation ensures accurate ceiling division without overflow.\\n        // Since a is non-zero, (a - 1) / b will not overflow.\\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\\n        // when a = type(uint256).max and b = 1.\\n        unchecked {\\n            return SafeCast.toUint(a \\u003e 0) * ((a - 1) / b + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     *\\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            (uint256 high, uint256 low) = mul512(x, y);\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (high == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return low / denominator;\\n            }\\n\\n            // Make sure the result is less than 2²⁵⁶. Also prevents denominator == 0.\\n            if (denominator \\u003c= high) {\\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [high low].\\n            uint256 remainder;\\n            assembly (\\\"memory-safe\\\") {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                high := sub(high, gt(remainder, low))\\n                low := sub(low, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always \\u003e= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator \\u0026 (0 - denominator);\\n            assembly (\\\"memory-safe\\\") {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [high low] by twos.\\n                low := div(low, twos)\\n\\n                // Flip twos such that it is 2²⁵⁶ / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from high into low.\\n            low |= high * twos;\\n\\n            // Invert denominator mod 2²⁵⁶. Now that denominator is an odd number, it has an inverse modulo 2²⁵⁶ such\\n            // that denominator * inv ≡ 1 mod 2²⁵⁶. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv ≡ 1 mod 2⁴.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁸\\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹⁶\\n            inverse *= 2 - denominator * inverse; // inverse mod 2³²\\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁶⁴\\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹²⁸\\n            inverse *= 2 - denominator * inverse; // inverse mod 2²⁵⁶\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2²⁵⁶. Since the preconditions guarantee that the outcome is\\n            // less than 2²⁵⁶, this is the final result. We don't need to compute the high bits of the result and high\\n            // is no longer required.\\n            result = low * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) \\u0026\\u0026 mulmod(x, y, denominator) \\u003e 0);\\n    }\\n\\n    /**\\n     * @dev Calculates floor(x * y \\u003e\\u003e n) with full precision. Throws if result overflows a uint256.\\n     */\\n    function mulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {\\n        unchecked {\\n            (uint256 high, uint256 low) = mul512(x, y);\\n            if (high \\u003e= 1 \\u003c\\u003c n) {\\n                Panic.panic(Panic.UNDER_OVERFLOW);\\n            }\\n            return (high \\u003c\\u003c (256 - n)) | (low \\u003e\\u003e n);\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates x * y \\u003e\\u003e n with full precision, following the selected rounding direction.\\n     */\\n    function mulShr(uint256 x, uint256 y, uint8 n, Rounding rounding) internal pure returns (uint256) {\\n        return mulShr(x, y, n) + SafeCast.toUint(unsignedRoundsUp(rounding) \\u0026\\u0026 mulmod(x, y, 1 \\u003c\\u003c n) \\u003e 0);\\n    }\\n\\n    /**\\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\\n     *\\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\\n     *\\n     * If the input value is not inversible, 0 is returned.\\n     *\\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\\n     */\\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\\n        unchecked {\\n            if (n == 0) return 0;\\n\\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\\n            // ax + ny = 1\\n            // ax = 1 + (-y)n\\n            // ax ≡ 1 (mod n) # x is the inverse of a modulo n\\n\\n            // If the remainder is 0 the gcd is n right away.\\n            uint256 remainder = a % n;\\n            uint256 gcd = n;\\n\\n            // Therefore the initial coefficients are:\\n            // ax + ny = gcd(a, n) = n\\n            // 0a + 1n = n\\n            int256 x = 0;\\n            int256 y = 1;\\n\\n            while (remainder != 0) {\\n                uint256 quotient = gcd / remainder;\\n\\n                (gcd, remainder) = (\\n                    // The old remainder is the next gcd to try.\\n                    remainder,\\n                    // Compute the next remainder.\\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) \\u003c= gcd\\n                    // where gcd is at most n (capped to type(uint256).max)\\n                    gcd - remainder * quotient\\n                );\\n\\n                (x, y) = (\\n                    // Increment the coefficient of a.\\n                    y,\\n                    // Decrement the coefficient of n.\\n                    // Can overflow, but the result is casted to uint256 so that the\\n                    // next value of y is \\\"wrapped around\\\" to a value between 0 and n - 1.\\n                    x - y * int256(quotient)\\n                );\\n            }\\n\\n            if (gcd != 1) return 0; // No inverse exists.\\n            return ternary(x \\u003c 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\\n        }\\n    }\\n\\n    /**\\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\\n     *\\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\\n     * prime, then `a**(p-1) ≡ 1 mod p`. As a consequence, we have `a * a**(p-2) ≡ 1 mod p`, which means that\\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\\n     *\\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\\n     */\\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\\n        unchecked {\\n            return Math.modExp(a, p - 2, p);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\\n     *\\n     * Requirements:\\n     * - modulus can't be zero\\n     * - underlying staticcall to precompile must succeed\\n     *\\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\\n     * interpreted as 0.\\n     */\\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\\n        (bool success, uint256 result) = tryModExp(b, e, m);\\n        if (!success) {\\n            Panic.panic(Panic.DIVISION_BY_ZERO);\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\\n     * to operate modulo 0 or if the underlying precompile reverted.\\n     *\\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\\n     * of a revert, but the result may be incorrectly interpreted as 0.\\n     */\\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\\n        if (m == 0) return (false, 0);\\n        assembly (\\\"memory-safe\\\") {\\n            let ptr := mload(0x40)\\n            // | Offset    | Content    | Content (Hex)                                                      |\\n            // |-----------|------------|--------------------------------------------------------------------|\\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\\n            // | 0x60:0x7f | value of b | 0x\\u003c.............................................................b\\u003e |\\n            // | 0x80:0x9f | value of e | 0x\\u003c.............................................................e\\u003e |\\n            // | 0xa0:0xbf | value of m | 0x\\u003c.............................................................m\\u003e |\\n            mstore(ptr, 0x20)\\n            mstore(add(ptr, 0x20), 0x20)\\n            mstore(add(ptr, 0x40), 0x20)\\n            mstore(add(ptr, 0x60), b)\\n            mstore(add(ptr, 0x80), e)\\n            mstore(add(ptr, 0xa0), m)\\n\\n            // Given the result \\u003c m, it's guaranteed to fit in 32 bytes,\\n            // so we can use the memory scratch space located at offset 0.\\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /**\\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\\n     */\\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\\n        (bool success, bytes memory result) = tryModExp(b, e, m);\\n        if (!success) {\\n            Panic.panic(Panic.DIVISION_BY_ZERO);\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\\n     */\\n    function tryModExp(\\n        bytes memory b,\\n        bytes memory e,\\n        bytes memory m\\n    ) internal view returns (bool success, bytes memory result) {\\n        if (_zeroBytes(m)) return (false, new bytes(0));\\n\\n        uint256 mLen = m.length;\\n\\n        // Encode call args in result and move the free memory pointer\\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\\n\\n        assembly (\\\"memory-safe\\\") {\\n            let dataPtr := add(result, 0x20)\\n            // Write result on top of args to avoid allocating extra memory.\\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\\n            // Overwrite the length.\\n            // result.length \\u003e returndatasize() is guaranteed because returndatasize() == m.length\\n            mstore(result, mLen)\\n            // Set the memory pointer after the returned data.\\n            mstore(0x40, add(dataPtr, mLen))\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether the provided byte array is zero.\\n     */\\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\\n        for (uint256 i = 0; i \\u003c byteArray.length; ++i) {\\n            if (byteArray[i] != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\\n     * using integer operations.\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        unchecked {\\n            // Take care of easy edge cases when a == 0 or a == 1\\n            if (a \\u003c= 1) {\\n                return a;\\n            }\\n\\n            // In this function, we use Newton's method to get a root of `f(x) := x² - a`. It involves building a\\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\\n            // the current value as `ε_n = | x_n - sqrt(a) |`.\\n            //\\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\\n            // of the target. (i.e. `2**(e-1) ≤ sqrt(a) \\u003c 2**e`). We know that `e ≤ 128` because `(2¹²⁸)² = 2²⁵⁶` is\\n            // bigger than any uint256.\\n            //\\n            // By noticing that\\n            // `2**(e-1) ≤ sqrt(a) \\u003c 2**e → (2**(e-1))² ≤ a \\u003c (2**e)² → 2**(2*e-2) ≤ a \\u003c 2**(2*e)`\\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\\n            // to the msb function.\\n            uint256 aa = a;\\n            uint256 xn = 1;\\n\\n            if (aa \\u003e= (1 \\u003c\\u003c 128)) {\\n                aa \\u003e\\u003e= 128;\\n                xn \\u003c\\u003c= 64;\\n            }\\n            if (aa \\u003e= (1 \\u003c\\u003c 64)) {\\n                aa \\u003e\\u003e= 64;\\n                xn \\u003c\\u003c= 32;\\n            }\\n            if (aa \\u003e= (1 \\u003c\\u003c 32)) {\\n                aa \\u003e\\u003e= 32;\\n                xn \\u003c\\u003c= 16;\\n            }\\n            if (aa \\u003e= (1 \\u003c\\u003c 16)) {\\n                aa \\u003e\\u003e= 16;\\n                xn \\u003c\\u003c= 8;\\n            }\\n            if (aa \\u003e= (1 \\u003c\\u003c 8)) {\\n                aa \\u003e\\u003e= 8;\\n                xn \\u003c\\u003c= 4;\\n            }\\n            if (aa \\u003e= (1 \\u003c\\u003c 4)) {\\n                aa \\u003e\\u003e= 4;\\n                xn \\u003c\\u003c= 2;\\n            }\\n            if (aa \\u003e= (1 \\u003c\\u003c 2)) {\\n                xn \\u003c\\u003c= 1;\\n            }\\n\\n            // We now have x_n such that `x_n = 2**(e-1) ≤ sqrt(a) \\u003c 2**e = 2 * x_n`. This implies ε_n ≤ 2**(e-1).\\n            //\\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to ε_n ≤ 2**(e-2).\\n            // This is going to be our x_0 (and ε_0)\\n            xn = (3 * xn) \\u003e\\u003e 1; // ε_0 := | x_0 - sqrt(a) | ≤ 2**(e-2)\\n\\n            // From here, Newton's method give us:\\n            // x_{n+1} = (x_n + a / x_n) / 2\\n            //\\n            // One should note that:\\n            // x_{n+1}² - a = ((x_n + a / x_n) / 2)² - a\\n            //              = ((x_n² + a) / (2 * x_n))² - a\\n            //              = (x_n⁴ + 2 * a * x_n² + a²) / (4 * x_n²) - a\\n            //              = (x_n⁴ + 2 * a * x_n² + a² - 4 * a * x_n²) / (4 * x_n²)\\n            //              = (x_n⁴ - 2 * a * x_n² + a²) / (4 * x_n²)\\n            //              = (x_n² - a)² / (2 * x_n)²\\n            //              = ((x_n² - a) / (2 * x_n))²\\n            //              ≥ 0\\n            // Which proves that for all n ≥ 1, sqrt(a) ≤ x_n\\n            //\\n            // This gives us the proof of quadratic convergence of the sequence:\\n            // ε_{n+1} = | x_{n+1} - sqrt(a) |\\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\\n            //         = | (x_n² + a - 2*x_n*sqrt(a)) / (2 * x_n) |\\n            //         = | (x_n - sqrt(a))² / (2 * x_n) |\\n            //         = | ε_n² / (2 * x_n) |\\n            //         = ε_n² / | (2 * x_n) |\\n            //\\n            // For the first iteration, we have a special case where x_0 is known:\\n            // ε_1 = ε_0² / | (2 * x_0) |\\n            //     ≤ (2**(e-2))² / (2 * (2**(e-1) + 2**(e-2)))\\n            //     ≤ 2**(2*e-4) / (3 * 2**(e-1))\\n            //     ≤ 2**(e-3) / 3\\n            //     ≤ 2**(e-3-log2(3))\\n            //     ≤ 2**(e-4.5)\\n            //\\n            // For the following iterations, we use the fact that, 2**(e-1) ≤ sqrt(a) ≤ x_n:\\n            // ε_{n+1} = ε_n² / | (2 * x_n) |\\n            //         ≤ (2**(e-k))² / (2 * 2**(e-1))\\n            //         ≤ 2**(2*e-2*k) / 2**e\\n            //         ≤ 2**(e-2*k)\\n            xn = (xn + a / xn) \\u003e\\u003e 1; // ε_1 := | x_1 - sqrt(a) | ≤ 2**(e-4.5)  -- special case, see above\\n            xn = (xn + a / xn) \\u003e\\u003e 1; // ε_2 := | x_2 - sqrt(a) | ≤ 2**(e-9)    -- general case with k = 4.5\\n            xn = (xn + a / xn) \\u003e\\u003e 1; // ε_3 := | x_3 - sqrt(a) | ≤ 2**(e-18)   -- general case with k = 9\\n            xn = (xn + a / xn) \\u003e\\u003e 1; // ε_4 := | x_4 - sqrt(a) | ≤ 2**(e-36)   -- general case with k = 18\\n            xn = (xn + a / xn) \\u003e\\u003e 1; // ε_5 := | x_5 - sqrt(a) | ≤ 2**(e-72)   -- general case with k = 36\\n            xn = (xn + a / xn) \\u003e\\u003e 1; // ε_6 := | x_6 - sqrt(a) | ≤ 2**(e-144)  -- general case with k = 72\\n\\n            // Because e ≤ 128 (as discussed during the first estimation phase), we know have reached a precision\\n            // ε_6 ≤ 2**(e-144) \\u003c 1. Given we're operating on integers, then we can ensure that xn is now either\\n            // sqrt(a) or sqrt(a) + 1.\\n            return xn - SafeCast.toUint(xn \\u003e a / xn);\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) \\u0026\\u0026 result * result \\u003c a);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 x) internal pure returns (uint256 r) {\\n        // If value has upper 128 bits set, log2 result is at least 128\\n        r = SafeCast.toUint(x \\u003e 0xffffffffffffffffffffffffffffffff) \\u003c\\u003c 7;\\n        // If upper 64 bits of 128-bit half set, add 64 to result\\n        r |= SafeCast.toUint((x \\u003e\\u003e r) \\u003e 0xffffffffffffffff) \\u003c\\u003c 6;\\n        // If upper 32 bits of 64-bit half set, add 32 to result\\n        r |= SafeCast.toUint((x \\u003e\\u003e r) \\u003e 0xffffffff) \\u003c\\u003c 5;\\n        // If upper 16 bits of 32-bit half set, add 16 to result\\n        r |= SafeCast.toUint((x \\u003e\\u003e r) \\u003e 0xffff) \\u003c\\u003c 4;\\n        // If upper 8 bits of 16-bit half set, add 8 to result\\n        r |= SafeCast.toUint((x \\u003e\\u003e r) \\u003e 0xff) \\u003c\\u003c 3;\\n        // If upper 4 bits of 8-bit half set, add 4 to result\\n        r |= SafeCast.toUint((x \\u003e\\u003e r) \\u003e 0xf) \\u003c\\u003c 2;\\n\\n        // Shifts value right by the current result and use it as an index into this lookup table:\\n        //\\n        // | x (4 bits) |  index  | table[index] = MSB position |\\n        // |------------|---------|-----------------------------|\\n        // |    0000    |    0    |        table[0] = 0         |\\n        // |    0001    |    1    |        table[1] = 0         |\\n        // |    0010    |    2    |        table[2] = 1         |\\n        // |    0011    |    3    |        table[3] = 1         |\\n        // |    0100    |    4    |        table[4] = 2         |\\n        // |    0101    |    5    |        table[5] = 2         |\\n        // |    0110    |    6    |        table[6] = 2         |\\n        // |    0111    |    7    |        table[7] = 2         |\\n        // |    1000    |    8    |        table[8] = 3         |\\n        // |    1001    |    9    |        table[9] = 3         |\\n        // |    1010    |   10    |        table[10] = 3        |\\n        // |    1011    |   11    |        table[11] = 3        |\\n        // |    1100    |   12    |        table[12] = 3        |\\n        // |    1101    |   13    |        table[13] = 3        |\\n        // |    1110    |   14    |        table[14] = 3        |\\n        // |    1111    |   15    |        table[15] = 3        |\\n        //\\n        // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.\\n        assembly (\\\"memory-safe\\\") {\\n            r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) \\u0026\\u0026 1 \\u003c\\u003c result \\u003c value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value \\u003e= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value \\u003e= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value \\u003e= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value \\u003e= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value \\u003e= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value \\u003e= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value \\u003e= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) \\u0026\\u0026 10 ** result \\u003c value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 x) internal pure returns (uint256 r) {\\n        // If value has upper 128 bits set, log2 result is at least 128\\n        r = SafeCast.toUint(x \\u003e 0xffffffffffffffffffffffffffffffff) \\u003c\\u003c 7;\\n        // If upper 64 bits of 128-bit half set, add 64 to result\\n        r |= SafeCast.toUint((x \\u003e\\u003e r) \\u003e 0xffffffffffffffff) \\u003c\\u003c 6;\\n        // If upper 32 bits of 64-bit half set, add 32 to result\\n        r |= SafeCast.toUint((x \\u003e\\u003e r) \\u003e 0xffffffff) \\u003c\\u003c 5;\\n        // If upper 16 bits of 32-bit half set, add 16 to result\\n        r |= SafeCast.toUint((x \\u003e\\u003e r) \\u003e 0xffff) \\u003c\\u003c 4;\\n        // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8\\n        return (r \\u003e\\u003e 3) | SafeCast.toUint((x \\u003e\\u003e r) \\u003e 0xff);\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) \\u0026\\u0026 1 \\u003c\\u003c (result \\u003c\\u003c 3) \\u003c value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/utils/math/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\\n\\n    /**\\n     * @dev An int value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedIntToUint(int256 value);\\n\\n    /**\\n     * @dev Value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\\n\\n    /**\\n     * @dev An uint value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedUintToInt(uint256 value);\\n\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        if (value \\u003e type(uint248).max) {\\n            revert SafeCastOverflowedUintDowncast(248, value);\\n        }\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        if (value \\u003e type(uint240).max) {\\n            revert SafeCastOverflowedUintDowncast(240, value);\\n        }\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        if (value \\u003e type(uint232).max) {\\n            revert SafeCastOverflowedUintDowncast(232, value);\\n        }\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        if (value \\u003e type(uint224).max) {\\n            revert SafeCastOverflowedUintDowncast(224, value);\\n        }\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        if (value \\u003e type(uint216).max) {\\n            revert SafeCastOverflowedUintDowncast(216, value);\\n        }\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        if (value \\u003e type(uint208).max) {\\n            revert SafeCastOverflowedUintDowncast(208, value);\\n        }\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        if (value \\u003e type(uint200).max) {\\n            revert SafeCastOverflowedUintDowncast(200, value);\\n        }\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        if (value \\u003e type(uint192).max) {\\n            revert SafeCastOverflowedUintDowncast(192, value);\\n        }\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        if (value \\u003e type(uint184).max) {\\n            revert SafeCastOverflowedUintDowncast(184, value);\\n        }\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        if (value \\u003e type(uint176).max) {\\n            revert SafeCastOverflowedUintDowncast(176, value);\\n        }\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        if (value \\u003e type(uint168).max) {\\n            revert SafeCastOverflowedUintDowncast(168, value);\\n        }\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        if (value \\u003e type(uint160).max) {\\n            revert SafeCastOverflowedUintDowncast(160, value);\\n        }\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        if (value \\u003e type(uint152).max) {\\n            revert SafeCastOverflowedUintDowncast(152, value);\\n        }\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        if (value \\u003e type(uint144).max) {\\n            revert SafeCastOverflowedUintDowncast(144, value);\\n        }\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        if (value \\u003e type(uint136).max) {\\n            revert SafeCastOverflowedUintDowncast(136, value);\\n        }\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        if (value \\u003e type(uint128).max) {\\n            revert SafeCastOverflowedUintDowncast(128, value);\\n        }\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        if (value \\u003e type(uint120).max) {\\n            revert SafeCastOverflowedUintDowncast(120, value);\\n        }\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        if (value \\u003e type(uint112).max) {\\n            revert SafeCastOverflowedUintDowncast(112, value);\\n        }\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        if (value \\u003e type(uint104).max) {\\n            revert SafeCastOverflowedUintDowncast(104, value);\\n        }\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        if (value \\u003e type(uint96).max) {\\n            revert SafeCastOverflowedUintDowncast(96, value);\\n        }\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        if (value \\u003e type(uint88).max) {\\n            revert SafeCastOverflowedUintDowncast(88, value);\\n        }\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        if (value \\u003e type(uint80).max) {\\n            revert SafeCastOverflowedUintDowncast(80, value);\\n        }\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        if (value \\u003e type(uint72).max) {\\n            revert SafeCastOverflowedUintDowncast(72, value);\\n        }\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        if (value \\u003e type(uint64).max) {\\n            revert SafeCastOverflowedUintDowncast(64, value);\\n        }\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        if (value \\u003e type(uint56).max) {\\n            revert SafeCastOverflowedUintDowncast(56, value);\\n        }\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        if (value \\u003e type(uint48).max) {\\n            revert SafeCastOverflowedUintDowncast(48, value);\\n        }\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        if (value \\u003e type(uint40).max) {\\n            revert SafeCastOverflowedUintDowncast(40, value);\\n        }\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        if (value \\u003e type(uint32).max) {\\n            revert SafeCastOverflowedUintDowncast(32, value);\\n        }\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        if (value \\u003e type(uint24).max) {\\n            revert SafeCastOverflowedUintDowncast(24, value);\\n        }\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        if (value \\u003e type(uint16).max) {\\n            revert SafeCastOverflowedUintDowncast(16, value);\\n        }\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        if (value \\u003e type(uint8).max) {\\n            revert SafeCastOverflowedUintDowncast(8, value);\\n        }\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        if (value \\u003c 0) {\\n            revert SafeCastOverflowedIntToUint(value);\\n        }\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(248, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(240, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(232, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(224, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(216, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(208, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(200, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(192, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(184, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(176, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(168, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(160, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(152, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(144, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(136, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(128, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(120, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(112, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(104, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(96, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(88, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(80, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(72, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(64, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(56, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(48, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(40, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(32, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(24, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(16, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(8, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        if (value \\u003e uint256(type(int256).max)) {\\n            revert SafeCastOverflowedUintToInt(value);\\n        }\\n        return int256(value);\\n    }\\n\\n    /**\\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\\n     */\\n    function toUint(bool b) internal pure returns (uint256 u) {\\n        assembly (\\\"memory-safe\\\") {\\n            u := iszero(iszero(b))\\n        }\\n    }\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.3.0/utils/structs/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.20;\\n\\nimport {Arrays} from \\\"../Arrays.sol\\\";\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n * - Set can be cleared (all elements removed) in O(n).\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position is the index of the value in the `values` array plus 1.\\n        // Position 0 is used to mean a value is not in the set.\\n        mapping(bytes32 value =\\u003e uint256) _positions;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._positions[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We cache the value's position to prevent multiple reads from the same storage slot\\n        uint256 position = set._positions[value];\\n\\n        if (position != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 valueIndex = position - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (valueIndex != lastIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the lastValue to the index where the value to delete is\\n                set._values[valueIndex] = lastValue;\\n                // Update the tracked position of the lastValue (that was just moved)\\n                set._positions[lastValue] = position;\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the tracked position for the deleted slot\\n            delete set._positions[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes all the values from a set. O(n).\\n     *\\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\\n     */\\n    function _clear(Set storage set) private {\\n        uint256 len = _length(set);\\n        for (uint256 i = 0; i \\u003c len; ++i) {\\n            delete set._positions[set._values[i]];\\n        }\\n        Arrays.unsafeSetLength(set._values, 0);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._positions[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes all the values from a set. O(n).\\n     *\\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\\n     */\\n    function clear(Bytes32Set storage set) internal {\\n        _clear(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        assembly (\\\"memory-safe\\\") {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes all the values from a set. O(n).\\n     *\\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\\n     */\\n    function clear(AddressSet storage set) internal {\\n        _clear(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        assembly (\\\"memory-safe\\\") {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes all the values from a set. O(n).\\n     *\\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\\n     */\\n    function clear(UintSet storage set) internal {\\n        _clear(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        assembly (\\\"memory-safe\\\") {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"}}}"
