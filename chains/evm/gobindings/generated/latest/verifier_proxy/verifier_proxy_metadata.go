// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.


package verifier_proxy

var SolidityStandardInput = "{\"version\":\"v0.8.26+commit.8a97fa7a\",\"language\":\"Solidity\",\"settings\":{\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"appendCBOR\":true,\"bytecodeHash\":\"none\",\"useLiteralContent\":false},\"optimizer\":{\"enabled\":true,\"runs\":80000},\"outputSelection\":{\"contracts/ccvs/VerifierProxy.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2Step.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2StepMsgSender.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/IOwnable.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]}},\"remappings\":[\"forge-std/=node_modules/@chainlink/contracts/src/v0.8/vendor/forge-std/src/\",\"@chainlink/contracts/=node_modules/@chainlink/contracts/\",\"@openzeppelin/contracts@4.8.3/=node_modules/@openzeppelin/contracts-4.8.3/\",\"@openzeppelin/contracts@5.0.2/=node_modules/@openzeppelin/contracts-5.0.2/\"],\"viaIR\":true},\"sources\":{\"contracts/ccvs/VerifierProxy.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\nimport {Ownable2StepMsgSender} from \\\"@chainlink/contracts/src/v0.8/shared/access/Ownable2StepMsgSender.sol\\\";\\n\\n/// @notice VerifierProxy enables upgrades to Cross-Chain Verifiers (CCVs) without breaking existing references in token pools, receivers, and apps.\\n/// The address of this contract will be referenced in the following places:\\n///   - Senders of messages will specify required and optional CCVs as part of ccipSend extraArgs.\\n///   - Token pools will specify required CCVs on both source and destination.\\n///   - Receiver contracts will specify required and optional CCVs on destination.\\n///   - OnRamp will specify default and mandated CCVs for each destination.\\n///   - OffRamp will specify default and mandated CCVs for each source.\\n/// Each of these references should be to a VerifierProxy contract, not a Verifier contract directly.\\n/// @dev On source, the OnRamp will forward requests (i.e. getFee, forwardToVerifier) through this contract to the required Verifier.\\n/// The same applies on destination. The OffRamp will forward requests (i.e. verifyMessage) through this contract to the required Verifier.\\n/// To support this proxy, all future Verifier interfaces must have originalCaller defined as the first arg to each method.\\ncontract VerifierProxy is Ownable2StepMsgSender {\\n  error ZeroAddressNotAllowed();\\n\\n  event VerifierUpdated(address indexed oldVerifier, address indexed newVerifier);\\n\\n  /// @notice The address of the verifier contract.\\n  address internal s_verifier;\\n\\n  constructor(\\n    address verifierAddress\\n  ) {\\n    _setVerifier(verifierAddress);\\n  }\\n\\n  /// @dev Allows for child contracts to modify the access control logic.\\n  function _onlyAllowedCaller() internal virtual {\\n    if (msg.sender != owner()) {\\n      revert OnlyCallableByOwner();\\n    }\\n  }\\n\\n  /// @notice Returns the address of the verifier contract.\\n  function getVerifier() external view virtual returns (address) {\\n    return s_verifier;\\n  }\\n\\n  /// @notice Sets the address of the verifier contract.\\n  /// @param verifierAddress The address of the new verifier contract.\\n  function setVerifier(\\n    address verifierAddress\\n  ) external virtual {\\n    _onlyAllowedCaller();\\n    _setVerifier(verifierAddress);\\n  }\\n\\n  /// @dev Internal method that allows for reuse in constructor.\\n  function _setVerifier(\\n    address verifierAddress\\n  ) internal virtual {\\n    if (verifierAddress == address(0)) {\\n      revert ZeroAddressNotAllowed();\\n    }\\n    address oldVerifier = s_verifier;\\n    s_verifier = verifierAddress;\\n    emit VerifierUpdated(oldVerifier, verifierAddress);\\n  }\\n\\n  /// @notice The fallback function forwards all calls to the verifier contract via a call.\\n  /// @dev The first argument of the calldata is always overwritten with the caller of the proxy. This ensures that the\\n  /// verifier contract always sees the original caller of the proxy. It also means originalCaller should be the first\\n  /// argument of any method called via this proxy.\\n  /// solhint-disable-next-line payable-fallback, no-complex-fallback\\n  fallback() external virtual {\\n    address verifierAddress = s_verifier;\\n    assembly {\\n      // We never cede control back to Solidity, so we can overwrite memory starting from index 0.\\n      calldatacopy(0, 0, calldatasize())\\n      // Overwrite calldata with the actual caller.\\n      // This prevents an attacker from spoofing a different caller.\\n      // The caller must be at calldata index 4 (skip function selector)\\n      mstore(4, caller())\\n\\n      // Forward the call to the verifier contract.\\n      let success := call(gas(), verifierAddress, 0, 0, calldatasize(), 0, 0)\\n      returndatacopy(0, 0, returndatasize())\\n      if success { return(0, returndatasize()) }\\n      revert(0, returndatasize())\\n    }\\n  }\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2Step.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {IOwnable} from \\\"../interfaces/IOwnable.sol\\\";\\n\\n/// @notice A minimal contract that implements 2-step ownership transfer and nothing more. It's made to be minimal\\n/// to reduce the impact of the bytecode size on any contract that inherits from it.\\ncontract Ownable2Step is IOwnable {\\n  /// @notice The pending owner is the address to which ownership may be transferred.\\n  address private s_pendingOwner;\\n  /// @notice The owner is the current owner of the contract.\\n  /// @dev The owner is the second storage variable so any implementing contract could pack other state with it\\n  /// instead of the much less used s_pendingOwner.\\n  address private s_owner;\\n\\n  error OwnerCannotBeZero();\\n  error MustBeProposedOwner();\\n  error CannotTransferToSelf();\\n  error OnlyCallableByOwner();\\n\\n  event OwnershipTransferRequested(address indexed from, address indexed to);\\n  event OwnershipTransferred(address indexed from, address indexed to);\\n\\n  constructor(address newOwner, address pendingOwner) {\\n    if (newOwner == address(0)) {\\n      revert OwnerCannotBeZero();\\n    }\\n\\n    s_owner = newOwner;\\n    if (pendingOwner != address(0)) {\\n      _transferOwnership(pendingOwner);\\n    }\\n  }\\n\\n  /// @notice Get the current owner\\n  function owner() public view override returns (address) {\\n    return s_owner;\\n  }\\n\\n  /// @notice Allows an owner to begin transferring ownership to a new address. The new owner needs to call\\n  /// `acceptOwnership` to accept the transfer before any permissions are changed.\\n  /// @param to The address to which ownership will be transferred.\\n  function transferOwnership(\\n    address to\\n  ) public override onlyOwner {\\n    _transferOwnership(to);\\n  }\\n\\n  /// @notice validate, transfer ownership, and emit relevant events\\n  /// @param to The address to which ownership will be transferred.\\n  function _transferOwnership(\\n    address to\\n  ) private {\\n    if (to == msg.sender) {\\n      revert CannotTransferToSelf();\\n    }\\n\\n    s_pendingOwner = to;\\n\\n    emit OwnershipTransferRequested(s_owner, to);\\n  }\\n\\n  /// @notice Allows an ownership transfer to be completed by the recipient.\\n  function acceptOwnership() external override {\\n    if (msg.sender != s_pendingOwner) {\\n      revert MustBeProposedOwner();\\n    }\\n\\n    address oldOwner = s_owner;\\n    s_owner = msg.sender;\\n    s_pendingOwner = address(0);\\n\\n    emit OwnershipTransferred(oldOwner, msg.sender);\\n  }\\n\\n  /// @notice validate access\\n  function _validateOwnership() internal view {\\n    if (msg.sender != s_owner) {\\n      revert OnlyCallableByOwner();\\n    }\\n  }\\n\\n  /// @notice Reverts if called by anyone other than the contract owner.\\n  modifier onlyOwner() {\\n    _validateOwnership();\\n    _;\\n  }\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2StepMsgSender.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {Ownable2Step} from \\\"./Ownable2Step.sol\\\";\\n\\n/// @notice Sets the msg.sender to be the owner of the contract and does not set a pending owner.\\ncontract Ownable2StepMsgSender is Ownable2Step {\\n  constructor() Ownable2Step(msg.sender, address(0)) {}\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/IOwnable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IOwnable {\\n  function owner() external returns (address);\\n\\n  function transferOwnership(\\n    address recipient\\n  ) external;\\n\\n  function acceptOwnership() external;\\n}\\n\"}}}"
