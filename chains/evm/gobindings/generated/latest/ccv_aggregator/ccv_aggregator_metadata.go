// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.


package ccv_aggregator

var SolidityStandardInput = "{\"version\":\"v0.8.26+commit.8a97fa7a\",\"language\":\"Solidity\",\"settings\":{\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"appendCBOR\":true,\"bytecodeHash\":\"none\",\"useLiteralContent\":false},\"optimizer\":{\"enabled\":true,\"runs\":80000},\"outputSelection\":{\"contracts/interfaces/IAny2EVMMessageReceiver.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/interfaces/IAny2EVMMessageReceiverV2.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/interfaces/ICrossChainVerifierV1.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/interfaces/IPool.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/interfaces/IPoolV2.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/interfaces/IRMNRemote.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/interfaces/IRouter.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/interfaces/ITokenAdminRegistry.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/libraries/CCVConfigValidation.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/libraries/Client.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/libraries/ERC165CheckerReverting.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/libraries/Internal.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/libraries/MerkleMultiProof.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/libraries/MessageV1Codec.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/libraries/Pool.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/offRamp/CCVAggregator.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2Step.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2StepMsgSender.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/IOwnable.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/ITypeAndVersion.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-4.8.3/utils/introspection/IERC165.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.0.2/token/ERC20/IERC20.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.0.2/utils/introspection/IERC165.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.0.2/utils/structs/EnumerableSet.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]}},\"remappings\":[\"forge-std/=node_modules/@chainlink/contracts/src/v0.8/vendor/forge-std/src/\",\"@chainlink/contracts/=node_modules/@chainlink/contracts/\",\"@openzeppelin/contracts@4.8.3/=node_modules/@openzeppelin/contracts-4.8.3/\",\"@openzeppelin/contracts@5.0.2/=node_modules/@openzeppelin/contracts-5.0.2/\"],\"viaIR\":true},\"sources\":{\"contracts/interfaces/IAny2EVMMessageReceiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {Client} from \\\"../libraries/Client.sol\\\";\\n\\n/// @notice Application contracts that intend to receive messages from  the router should implement this interface.\\ninterface IAny2EVMMessageReceiver {\\n  /// @notice Called by the Router to deliver a message. If this reverts, any token transfers also revert.\\n  /// The message will move to a FAILED state and become available for manual execution.\\n  /// @param message CCIP Message.\\n  /// @dev Note ensure you check the msg.sender is the OffRampRouter.\\n  function ccipReceive(\\n    Client.Any2EVMMessage calldata message\\n  ) external;\\n}\\n\"},\"contracts/interfaces/IAny2EVMMessageReceiverV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IAny2EVMMessageReceiver} from \\\"./IAny2EVMMessageReceiver.sol\\\";\\n\\ninterface IAny2EVMMessageReceiverV2 is IAny2EVMMessageReceiver {\\n  function getCCVs(\\n    uint64 sourceChainSelector\\n  ) external view returns (address[] memory requiredCCVs, address[] memory optionalCCVs, uint8 optionalThreshold);\\n}\\n\"},\"contracts/interfaces/ICrossChainVerifierV1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {Client} from \\\"../libraries/Client.sol\\\";\\nimport {MessageV1Codec} from \\\"../libraries/MessageV1Codec.sol\\\";\\n\\nimport {IERC165} from \\\"@openzeppelin/contracts@5.0.2/utils/introspection/IERC165.sol\\\";\\n\\ninterface ICrossChainVerifierV1 is IERC165 {\\n  /// @notice Verification of the message, in any way the OffRamp wants. This could be using a signature, a quorum\\n  /// of signatures, using native interop, or some ZK light client. Any proof required for the verification is supplied\\n  /// through the ccvData parameter.\\n  /// @param originalCaller The original caller of verifyMessage, which is passed as input to enable proxy patterns.\\n  /// @param message The message to be verified. For efficiency, the messageID is also supplied, which acts as a small\\n  /// payload that once verified means the entire message is verified. Every component of the message is part of the\\n  /// message ID through hashing the struct. The entire message is provided to be able to act differently for different\\n  /// message properties.\\n  /// @param messageId A convenient 32 byte hash of the entire message. It can be recomputed from the passed in message\\n  /// at the cost of a not-insignificant amount of gas. Any CCV MUST include the messageID or the entire message struct\\n  /// as part of its proof.\\n  /// @param ccvData All the data that is specific to the CCV. This often means it contains some sort of proof, but it\\n  /// can also contain certain metadata like a nonce that's specific to the CCV. If any metadata like that exists and is\\n  /// important to the security of the CCV, it MUST be verified as well using the proof. A recommended way to do this is\\n  /// to encode a proof and the metadata separately in the ccvData and then concatenate the messageId with this metadata\\n  /// to get the payload that will be verified. In the case of a simple signature verification this means that the CCV\\n  /// offchain system must sign the concatenated (messageId, ccvMetaData) and not just the messageId. If no metadata\\n  /// is required, simply signing the messageId is enough.\\n  function verifyMessage(\\n    address originalCaller,\\n    MessageV1Codec.MessageV1 memory message,\\n    bytes32 messageId,\\n    bytes memory ccvData\\n  ) external;\\n\\n  /// @notice Quotes the fee for a CCIP message to a destination chain.\\n  /// @dev This takes EVM2AnyMessage (instead of MessageV1) because\\n  /// the router client API that user contracts interact with (IRouterClient.getFee)\\n  /// exposes EVM2AnyMessage. The on-ramp can translate to MessageV1 internally\\n  /// where required (e.g., verifier hooks), but using EVM2AnyMessage here keeps the\\n  /// interface aligned with what clients construct and pass to the router.\\n  /// @param originalCaller The original caller of getFee.\\n  /// @param destChainSelector The destination chain selector of the message.\\n  /// @param message The message to be sent.\\n  /// @param extraArgs Opaque extra args that can be used by the fee quoter\\n  function getFee(\\n    address originalCaller,\\n    uint64 destChainSelector,\\n    Client.EVM2AnyMessage memory message,\\n    bytes memory extraArgs\\n  ) external view returns (uint256);\\n\\n  /// @notice Message sending, verifier hook.\\n  /// @param originalCaller The original caller of forwardToVerifier.\\n  /// @param message Decoded MessageV1 structure for the message being sent.\\n  /// @param messageId The message ID of the message being sent.\\n  /// @param feeToken Fee token used for this message.\\n  /// @param feeTokenAmount Amount of fee token provided.\\n  /// @param verifierArgs Opaque verifier-specific arguments from the sender.\\n  /// @return verifierData Verifier-specific return data blob.\\n  function forwardToVerifier(\\n    address originalCaller,\\n    MessageV1Codec.MessageV1 calldata message,\\n    bytes32 messageId,\\n    address feeToken,\\n    uint256 feeTokenAmount,\\n    bytes calldata verifierArgs\\n  ) external returns (bytes memory verifierData);\\n\\n  /// @notice Returns the storage location identifier for this CCV. This is a string that uniquely identifies the\\n  /// storage location. This can be an address, a URL, or any other identifier that makes sense for the CCV. The format\\n  /// of the string is up to the CCV implementer, but it should be something that can be easily parsed and used by the\\n  /// integrator. This is used by the executor(s) to know where to look for the proof data that the CCV has produced.\\n  function getStorageLocation() external view returns (string memory);\\n}\\n\"},\"contracts/interfaces/IPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {Pool} from \\\"../libraries/Pool.sol\\\";\\n\\nimport {IERC165} from \\\"@openzeppelin/contracts@5.0.2/utils/introspection/IERC165.sol\\\";\\n\\n/// @notice Shared public interface for multiple V1 pool types.\\n/// Each pool type handles a different child token model e.g. lock/unlock, mint/burn.\\ninterface IPoolV1 is IERC165 {\\n  /// @notice Lock tokens into the pool or burn the tokens.\\n  /// @param lockOrBurnIn Encoded data fields for the processing of tokens on the source chain.\\n  /// @return lockOrBurnOut Encoded data fields for the processing of tokens on the destination chain.\\n  function lockOrBurn(\\n    Pool.LockOrBurnInV1 calldata lockOrBurnIn\\n  ) external returns (Pool.LockOrBurnOutV1 memory lockOrBurnOut);\\n\\n  /// @notice Releases or mints tokens to the receiver address.\\n  /// @param releaseOrMintIn All data required to release or mint tokens.\\n  /// @return releaseOrMintOut The amount of tokens released or minted on the local chain, denominated\\n  /// in the local token's decimals.\\n  /// @dev The offRamp asserts that the balanceOf of the receiver has been incremented by exactly the number\\n  /// of tokens that is returned in ReleaseOrMintOutV1.destinationAmount. If the amounts do not match, the tx reverts.\\n  function releaseOrMint(\\n    Pool.ReleaseOrMintInV1 calldata releaseOrMintIn\\n  ) external returns (Pool.ReleaseOrMintOutV1 memory);\\n\\n  /// @notice Checks whether a remote chain is supported in the token pool.\\n  /// @param remoteChainSelector The selector of the remote chain.\\n  /// @return true if the given chain is a permissioned remote chain.\\n  function isSupportedChain(\\n    uint64 remoteChainSelector\\n  ) external view returns (bool);\\n\\n  /// @notice Returns if the token pool supports the given token.\\n  /// @param token The address of the token.\\n  /// @return true if the token is supported by the pool.\\n  function isSupportedToken(\\n    address token\\n  ) external view returns (bool);\\n}\\n\"},\"contracts/interfaces/IPoolV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IPoolV1} from \\\"./IPool.sol\\\";\\n\\nimport {Client} from \\\"../libraries/Client.sol\\\";\\nimport {Pool} from \\\"../libraries/Pool.sol\\\";\\n\\n// TODO Milestone 2: implement.\\n/// @notice Shared public interface for multiple V2 pool types.\\n/// Each pool type handles a different child token model e.g. lock/unlock, mint/burn.\\ninterface IPoolV2 is IPoolV1 {\\n  /// @notice Lock tokens into the pool or burn the tokens.\\n  /// @param lockOrBurnIn Encoded data fields for the processing of tokens on the source chain.\\n  /// @param tokenArgs Additional token arguments.\\n  /// @return lockOrBurnOut Encoded data fields for the processing of tokens on the destination chain.\\n  function lockOrBurn(\\n    Pool.LockOrBurnInV1 calldata lockOrBurnIn,\\n    bytes calldata tokenArgs\\n  ) external returns (Pool.LockOrBurnOutV1 memory lockOrBurnOut);\\n\\n  /// @notice Returns the set of required CCVs for outgoing messages to a destination chain.\\n  /// @param localToken The address of the local token.\\n  /// @param destChainSelector The chain selector of the destination chain.\\n  /// @param amount The amount of tokens to be transferred.\\n  /// @param finality The finality configuration from the CCIP message.\\n  /// @param tokenArgs Additional token arguments.\\n  /// @return requiredCCVs A set of addresses representing the required outbound CCVs.\\n  function getRequiredOutboundCCVs(\\n    address localToken,\\n    uint64 destChainSelector,\\n    uint256 amount,\\n    uint16 finality,\\n    bytes calldata tokenArgs\\n  ) external view returns (address[] memory requiredCCVs);\\n\\n  /// @notice Returns the set of required CCVs for incoming messages from a source chain.\\n  /// @param localToken The address of the local token.\\n  /// @param sourceChainSelector The chain selector of the source chain.\\n  /// @param amount The amount of tokens to be transferred.\\n  /// @param finality The finality configuration from the CCIP message.\\n  /// @param sourcePoolData The data received from the source pool to process the release or mint.\\n  /// @return requiredCCVs A set of addresses representing the required inbound CCVs.\\n  function getRequiredInboundCCVs(\\n    address localToken,\\n    uint64 sourceChainSelector,\\n    uint256 amount,\\n    uint16 finality,\\n    bytes calldata sourcePoolData\\n  ) external view returns (address[] memory requiredCCVs);\\n\\n  /// @notice Returns a fee quote for transferring tokens to a destination chain.\\n  /// @param destChainSelector The chain selector of the destination chain.\\n  /// @param message The message to be sent to the destination chain.\\n  /// @param finality The finality configuration from the CCIP message.\\n  /// @param tokenArgs Additional token argument from the CCIP message.\\n  /// @return feeTokenAmount The amount of fee token needed for the fee.\\n  function getFee(\\n    uint64 destChainSelector,\\n    Client.EVM2AnyMessage calldata message,\\n    uint16 finality,\\n    bytes calldata tokenArgs\\n  ) external view returns (uint256 feeTokenAmount);\\n}\\n\"},\"contracts/interfaces/IRMNRemote.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {Internal} from \\\"../libraries/Internal.sol\\\";\\n\\n/// @notice This interface contains the only RMN-related functions that might be used on-chain by other CCIP contracts.\\ninterface IRMNRemote {\\n  /// @notice signature components from RMN nodes.\\n  struct Signature {\\n    bytes32 r;\\n    bytes32 s;\\n  }\\n\\n  /// @notice Verifies signatures of RMN nodes, on dest lane updates as provided in the CommitReport.\\n  /// @param offRampAddress is not inferred by msg.sender, in case the call is made through RMNProxy.\\n  /// @param merkleRoots must be well formed, and is a representation of the CommitReport received from the oracles.\\n  /// @param signatures rmnNodes ECDSA sigs, only r \\u0026 s, must be sorted in ascending order by signer address.\\n  /// @dev Will revert if verification fails.\\n  function verify(\\n    address offRampAddress,\\n    Internal.MerkleRoot[] memory merkleRoots,\\n    Signature[] memory signatures\\n  ) external view;\\n\\n  /// @notice gets the current set of cursed subjects.\\n  /// @return subjects the list of cursed subjects.\\n  function getCursedSubjects() external view returns (bytes16[] memory subjects);\\n\\n  /// @notice If there is an active global or legacy curse, this function returns true.\\n  /// @return bool true if there is an active global curse.\\n  function isCursed() external view returns (bool);\\n\\n  /// @notice If there is an active global curse, or an active curse for `subject`, this function returns true.\\n  /// @param subject To check whether a particular chain is cursed, set to bytes16(uint128(chainSelector)).\\n  /// @return bool true if the provided subject is cured *or* if there is an active global curse.\\n  function isCursed(\\n    bytes16 subject\\n  ) external view returns (bool);\\n}\\n\"},\"contracts/interfaces/IRouter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {Client} from \\\"../libraries/Client.sol\\\";\\n\\ninterface IRouter {\\n  error OnlyOffRamp();\\n\\n  /// @notice Route the message to its intended receiver contract.\\n  /// @param message Client.Any2EVMMessage struct.\\n  /// @param gasForCallExactCheck of params for exec.\\n  /// @param gasLimit set of params for exec.\\n  /// @param receiver set of params for exec.\\n  /// @dev if the receiver is a contracts that signals support for CCIP execution through EIP-165.\\n  /// the contract is called. If not, only tokens are transferred.\\n  /// @return success A boolean value indicating whether the ccip message was received without errors.\\n  /// @return retBytes A bytes array containing return data form CCIP receiver.\\n  /// @return gasUsed the gas used by the external customer call. Does not include any overhead.\\n  function routeMessage(\\n    Client.Any2EVMMessage calldata message,\\n    uint16 gasForCallExactCheck,\\n    uint256 gasLimit,\\n    address receiver\\n  ) external returns (bool success, bytes memory retBytes, uint256 gasUsed);\\n\\n  /// @notice Returns the configured onRamp for a specific destination chain.\\n  /// @param destChainSelector The destination chain Id to get the onRamp for.\\n  /// @return onRampAddress The address of the onRamp.\\n  function getOnRamp(\\n    uint64 destChainSelector\\n  ) external view returns (address onRampAddress);\\n\\n  /// @notice Return true if the given offRamp is a configured offRamp for the given source chain.\\n  /// @param sourceChainSelector The source chain selector to check.\\n  /// @param offRamp The address of the offRamp to check.\\n  function isOffRamp(uint64 sourceChainSelector, address offRamp) external view returns (bool isOffRamp);\\n}\\n\"},\"contracts/interfaces/ITokenAdminRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ITokenAdminRegistry {\\n  /// @notice Returns the pool for the given token.\\n  function getPool(\\n    address token\\n  ) external view returns (address);\\n\\n  /// @notice Proposes an administrator for the given token as pending administrator.\\n  /// @param localToken The token to register the administrator for.\\n  /// @param administrator The administrator to register.\\n  function proposeAdministrator(address localToken, address administrator) external;\\n\\n  /// @notice Accepts the administrator role for a token.\\n  /// @param localToken The token to accept the administrator role for.\\n  /// @dev This function can only be called by the pending administrator.\\n  function acceptAdminRole(\\n    address localToken\\n  ) external;\\n\\n  /// @notice Sets the pool for a token. Setting the pool to address(0) effectively delists the token\\n  /// from CCIP. Setting the pool to any other address enables the token on CCIP.\\n  /// @param localToken The token to set the pool for.\\n  /// @param pool The pool to set for the token.\\n  function setPool(address localToken, address pool) external;\\n\\n  /// @notice Transfers the administrator role for a token to a new address with a 2-step process.\\n  /// @param localToken The token to transfer the administrator role for.\\n  /// @param newAdmin The address to transfer the administrator role to. Can be address(0) to cancel\\n  /// a pending transfer.\\n  /// @dev The new admin must call `acceptAdminRole` to accept the role.\\n  function transferAdminRole(address localToken, address newAdmin) external;\\n}\\n\"},\"contracts/libraries/CCVConfigValidation.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice CCV config validation helpers.\\nlibrary CCVConfigValidation {\\n  error MustSpecifyDefaultOrRequiredCCVs();\\n  error DuplicateCCVNotAllowed(address ccvAddress);\\n  error ZeroAddressNotAllowed();\\n\\n  /// @notice Ensures at least one CCV combined, no zero addresses, no duplicates within or across both sets.\\n  /// @param defaultCCV The default CCVs.\\n  /// @param laneMandatedCCVs The mandated CCVs.\\n  function _validateDefaultAndMandatedCCVs(\\n    address[] memory defaultCCV,\\n    address[] memory laneMandatedCCVs\\n  ) internal pure {\\n    uint256 defaultLength = defaultCCV.length;\\n    uint256 mandatedLength = laneMandatedCCVs.length;\\n    uint256 totalLength = defaultLength + mandatedLength;\\n\\n    // There must always be at least one default or mandated CCV. This ensures that any receiver who does not specify\\n    // CCVs will always have at least one CCV to validate the message.\\n    if (totalLength == 0) revert MustSpecifyDefaultOrRequiredCCVs();\\n\\n    // We check for duplicates and zero addresses in the default and mandated CCVs. We need to check for duplicates\\n    // between the two sets of CCVs as well as within each set. Doing these checks here means we can assume there are\\n    // no duplicates or zero addresses in the rest of the code.\\n    for (uint256 combinedIndex = 0; combinedIndex \\u003c totalLength; ++combinedIndex) {\\n      address currentCCVAddress =\\n        combinedIndex \\u003c defaultLength ? defaultCCV[combinedIndex] : laneMandatedCCVs[combinedIndex - defaultLength];\\n      if (currentCCVAddress == address(0)) revert ZeroAddressNotAllowed();\\n\\n      for (uint256 nextIndex = combinedIndex + 1; nextIndex \\u003c totalLength; ++nextIndex) {\\n        address compareCCVAddress =\\n          nextIndex \\u003c defaultLength ? defaultCCV[nextIndex] : laneMandatedCCVs[nextIndex - defaultLength];\\n        if (currentCCVAddress == compareCCVAddress) revert DuplicateCCVNotAllowed(currentCCVAddress);\\n      }\\n    }\\n  }\\n\\n  function _assertNoDuplicates(\\n    address[] memory addresses\\n  ) internal pure {\\n    uint256 length = addresses.length;\\n    for (uint256 i = 0; i \\u003c length; ++i) {\\n      for (uint256 j = i + 1; j \\u003c length; ++j) {\\n        if (addresses[i] == addresses[j]) revert DuplicateCCVNotAllowed(addresses[i]);\\n      }\\n    }\\n  }\\n}\\n\"},\"contracts/libraries/Client.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// End consumer library.\\nlibrary Client {\\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\\n  struct EVMTokenAmount {\\n    address token; // token address on the local chain.\\n    uint256 amount; // Amount of tokens.\\n  }\\n\\n  struct Any2EVMMessage {\\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\\n    uint64 sourceChainSelector; // Source chain selector.\\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\\n    bytes data; // payload sent in original message.\\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\\n  }\\n\\n  // If extraArgs is empty bytes, the default is 200k gas limit.\\n  struct EVM2AnyMessage {\\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains.\\n    bytes data; // Data payload.\\n    EVMTokenAmount[] tokenAmounts; // Token transfers.\\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV2).\\n  }\\n\\n  // Tag to indicate only a gas limit. Only usable for EVM as destination chain.\\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\\n\\n  struct EVMExtraArgsV1 {\\n    uint256 gasLimit;\\n  }\\n\\n  function _argsToBytes(\\n    EVMExtraArgsV1 memory extraArgs\\n  ) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\\n  }\\n\\n  // Tag to indicate a gas limit (or dest chain equivalent processing units) and Out Of Order Execution. This tag is\\n  // available for multiple chain families. If there is no chain family specific tag, this is the default available\\n  // for a chain.\\n  // Note: not available for Solana VM based chains.\\n  bytes4 public constant GENERIC_EXTRA_ARGS_V2_TAG = 0x181dcf10;\\n\\n  /// @param gasLimit: gas limit for the callback on the destination chain.\\n  /// @param allowOutOfOrderExecution: if true, it indicates that the message can be executed in any order relative to\\n  /// other messages from the same sender. This value's default varies by chain. On some chains, a particular value is\\n  /// enforced, meaning if the expected value is not set, the message request will revert.\\n  /// @dev Fully compatible with the previously existing EVMExtraArgsV2.\\n  struct GenericExtraArgsV2 {\\n    uint256 gasLimit;\\n    bool allowOutOfOrderExecution;\\n  }\\n\\n  // Extra args tag for chains that use the Sui VM.\\n  bytes4 public constant SUI_EXTRA_ARGS_V1_TAG = 0x21ea4ca9;\\n\\n  // Extra args tag for chains that use the Solana VM.\\n  bytes4 public constant SVM_EXTRA_ARGS_V1_TAG = 0x1f3b3aba;\\n\\n  struct SVMExtraArgsV1 {\\n    uint32 computeUnits;\\n    uint64 accountIsWritableBitmap;\\n    bool allowOutOfOrderExecution;\\n    bytes32 tokenReceiver;\\n    // Additional accounts needed for execution of CCIP receiver. Must be empty if message.receiver is zero.\\n    // Token transfer related accounts are specified in the token pool lookup table on SVM.\\n    bytes32[] accounts;\\n  }\\n\\n  /// @dev The maximum number of accounts that can be passed in SVMExtraArgs.\\n  uint256 public constant SVM_EXTRA_ARGS_MAX_ACCOUNTS = 64;\\n\\n  /// @dev The expected static payload size of a token transfer when Borsh encoded and submitted to SVM.\\n  /// TokenPool extra data and offchain data sizes are dynamic, and should be accounted for separately.\\n  uint256 public constant SVM_TOKEN_TRANSFER_DATA_OVERHEAD = (4 + 32) // source_pool\\n    + 32 // token_address\\n    + 4 // gas_amount\\n    + 4 // extra_data overhead\\n    + 32 // amount\\n    + 32 // size of the token lookup table account\\n    + 32 // token-related accounts in the lookup table, over-estimated to 32, typically between 11 - 13\\n    + 32 // token account belonging to the token receiver, e.g ATA, not included in the token lookup table\\n    + 32 // per-chain token pool config, not included in the token lookup table\\n    + 32 // per-chain token billing config, not always included in the token lookup table\\n    + 32; // OffRamp pool signer PDA, not included in the token lookup table\\n\\n  /// @dev Number of overhead accounts needed for message execution on SVM.\\n  /// @dev These are message.receiver, and the OffRamp Signer PDA specific to the receiver.\\n  uint256 public constant SVM_MESSAGING_ACCOUNTS_OVERHEAD = 2;\\n\\n  /// @dev The size of each SVM account address in bytes.\\n  uint256 public constant SVM_ACCOUNT_BYTE_SIZE = 32;\\n\\n  struct SuiExtraArgsV1 {\\n    uint256 gasLimit;\\n    bool allowOutOfOrderExecution;\\n    bytes32 tokenReceiver;\\n    bytes32[] receiverObjectIds;\\n  }\\n\\n  /// @dev The expected static payload size of a token transfer when Borsh encoded and submitted to SUI.\\n  /// TokenPool extra data and offchain data sizes are dynamic, and should be accounted for separately.\\n  uint256 public constant SUI_TOKEN_TRANSFER_DATA_OVERHEAD = (4 + 32) // source_pool\\n    + 32 // token_address\\n    + 4 // gas_amount\\n    + 4 // extra_data overhead\\n    + 32 // amount\\n    + 32 // size of the token lookup table account\\n    + 32 // token-related accounts in the lookup table, over-estimated to 32, typically between 11 - 13\\n    + 32 // token account belonging to the token receiver, e.g ATA, not included in the token lookup table\\n    + 32 // per-chain token pool config, not included in the token lookup table\\n    + 32; // per-chain token billing config, not always included in the token lookup table\\n\\n  /// @dev Number of overhead accounts needed for message execution on SUI.\\n  /// @dev This is the message.receiver.\\n  uint256 public constant SUI_MESSAGING_ACCOUNTS_OVERHEAD = 1;\\n\\n  /// @dev The maximum number of receiver object ids that can be passed in SuiExtraArgs.\\n  uint256 public constant SUI_EXTRA_ARGS_MAX_RECEIVER_OBJECT_IDS = 64;\\n\\n  /// @dev The size of each SUI account address in bytes.\\n  uint256 public constant SUI_ACCOUNT_BYTE_SIZE = 32;\\n\\n  function _argsToBytes(\\n    GenericExtraArgsV2 memory extraArgs\\n  ) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(GENERIC_EXTRA_ARGS_V2_TAG, extraArgs);\\n  }\\n\\n  function _svmArgsToBytes(\\n    SVMExtraArgsV1 memory extraArgs\\n  ) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(SVM_EXTRA_ARGS_V1_TAG, extraArgs);\\n  }\\n\\n  function _suiArgsToBytes(\\n    SuiExtraArgsV1 memory extraArgs\\n  ) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(SUI_EXTRA_ARGS_V1_TAG, extraArgs);\\n  }\\n\\n  /// @notice The CCV struct is used to represent a cross-chain verifier.\\n  struct CCV {\\n    /// @param The ccvAddress is the address of the verifier contract on the source chain\\n    address ccvAddress;\\n    /// @param args The args are the arguments that the verifier contract expects. They are opaque to CCIP and are only\\n    /// used in the CCV.\\n    bytes args;\\n  }\\n\\n  bytes4 public constant GENERIC_EXTRA_ARGS_V3_TAG = 0x302326cb;\\n\\n  struct EVMExtraArgsV3 {\\n    CCV[] requiredCCV;\\n    CCV[] optionalCCV;\\n    uint8 optionalThreshold;\\n    /// @notice The finality config, 0 means the default finality that the CCV considers final. Any non-zero value means\\n    /// a block depth.\\n    uint16 finalityConfig;\\n    address executor;\\n    bytes executorArgs;\\n    bytes tokenArgs;\\n  }\\n\\n  function _argsToBytes(\\n    EVMExtraArgsV3 memory extraArgs\\n  ) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(GENERIC_EXTRA_ARGS_V3_TAG, extraArgs);\\n  }\\n}\\n\"},\"contracts/libraries/ERC165CheckerReverting.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IERC165} from \\\"@openzeppelin/contracts@4.8.3/utils/introspection/IERC165.sol\\\";\\n\\n/// @notice Library used to query support of an interface declared via {IERC165}.\\n/// @dev These functions return the actual result of the query: they do not `revert` if an interface is not supported.\\nlibrary ERC165CheckerReverting {\\n  error InsufficientGasForStaticCall();\\n\\n  // As per the EIP-165 spec, no interface should ever match 0xffffffff.\\n  bytes4 private constant INTERFACE_ID_INVALID = 0xffffffff;\\n\\n  /// @dev 30k gas is required to make the staticcall. Under the 63/64 rule this means that 30,477 gas must be available\\n  /// to ensure that at least 30k is forwarded. Checking for at least 31,000 ensures that after additional\\n  /// operations are performed there is still \\u003e= 30,477 gas remaining.\\n  /// 30,000 = ((30,477 * 63) / 64)\\n  uint256 private constant MINIMUM_GAS_REQUIREMENT = 31_000;\\n\\n  /// @notice Returns true if `account` supports a defined interface.\\n  /// @dev The function must support both the interfaceId and interfaces specified by ERC165 generally as per the standard.\\n  /// @param account the contract to be queried for support.\\n  /// @param interfaceId the interface being checked for support.\\n  /// @return true if the contract at account indicates support of the interface with, false otherwise.\\n  function _supportsInterfaceReverting(address account, bytes4 interfaceId) internal view returns (bool) {\\n    // As a gas optimization, short circuit return false if interfaceId is not supported, as it is most likely interfaceId\\n    // to be unsupported by the target.\\n    return _supportsERC165InterfaceUncheckedReverting(account, interfaceId)\\n      \\u0026\\u0026 !_supportsERC165InterfaceUncheckedReverting(account, INTERFACE_ID_INVALID)\\n      \\u0026\\u0026 _supportsERC165InterfaceUncheckedReverting(account, type(IERC165).interfaceId);\\n  }\\n\\n  /// @notice Query if a contract implements an interface, does not check ERC165 support\\n  /// @param account The address of the contract to query for support of an interface\\n  /// @param interfaceId The interface identifier, as specified in ERC-165\\n  /// @return true if the contract at account indicates support of the interface with\\n  /// identifier interfaceId, false otherwise\\n  /// @dev Assumes that account contains a contract that supports ERC165, otherwise\\n  /// the behavior of this method is undefined. This precondition can be checked.\\n  /// @dev Function will only revert if the minimum gas requirement is not met before the staticcall is performed.\\n  function _supportsERC165InterfaceUncheckedReverting(address account, bytes4 interfaceId) internal view returns (bool) {\\n    bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\\n\\n    bool success;\\n    uint256 returnSize;\\n    uint256 returnValue;\\n\\n    bytes4 notEnoughGasSelector = InsufficientGasForStaticCall.selector;\\n\\n    assembly {\\n      // The EVM does not return a specific error code if a revert is due to OOG. This check ensures that\\n      // the message will not throw an OOG error by requiring that the amount of gas for the following\\n      // staticcall exists before invoking it.\\n      if lt(gas(), MINIMUM_GAS_REQUIREMENT) {\\n        mstore(0x0, notEnoughGasSelector)\\n        revert(0x0, 0x4)\\n      }\\n\\n      success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\\n      returnSize := returndatasize()\\n      returnValue := mload(0x00)\\n    }\\n    return success \\u0026\\u0026 returnSize \\u003e= 0x20 \\u0026\\u0026 returnValue \\u003e 0;\\n  }\\n}\\n\"},\"contracts/libraries/Internal.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {MerkleMultiProof} from \\\"../libraries/MerkleMultiProof.sol\\\";\\n\\n/// @notice Library for CCIP internal definitions common to multiple contracts.\\n/// @dev The following is a non-exhaustive list of \\\"known issues\\\" for CCIP:\\n/// - We could implement yield claiming for Blast. This is not worth the custom code path on non-blast chains.\\n/// - uint32 is used for timestamps, which will overflow in 2106. This is not a concern for the current use case, as we\\n/// expect to have migrated to a new version by then.\\nlibrary Internal {\\n  error InvalidEVMAddress(bytes encodedAddress);\\n  error Invalid32ByteAddress(bytes encodedAddress);\\n  error InvalidTVMAddress(bytes encodedAddress);\\n\\n  /// @dev We limit return data to a selector plus 4 words. This is to avoid malicious contracts from returning\\n  /// large amounts of data and causing repeated out-of-gas scenarios.\\n  uint16 internal constant MAX_RET_BYTES = 4 + 4 * 32;\\n  /// @dev The expected number of bytes returned by the balanceOf function.\\n  uint256 internal constant MAX_BALANCE_OF_RET_BYTES = 32;\\n\\n  /// @dev The address used to send calls for gas estimation.\\n  /// You only need to use this address if the minimum gas limit specified by the user is not actually enough to execute the\\n  /// given message and you're attempting to estimate the actual necessary gas limit\\n  address public constant GAS_ESTIMATION_SENDER = address(0xC11C11C11C11C11C11C11C11C11C11C11C11C1);\\n\\n  /// @notice A collection of token price and gas price updates.\\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\\n  struct PriceUpdates {\\n    TokenPriceUpdate[] tokenPriceUpdates;\\n    GasPriceUpdate[] gasPriceUpdates;\\n  }\\n\\n  /// @notice Token price in USD.\\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\\n  struct TokenPriceUpdate {\\n    address sourceToken; // Source token.\\n    uint224 usdPerToken; // 1e18 USD per 1e18 of the smallest token denomination.\\n  }\\n\\n  /// @notice Gas price for a given chain in USD, its value may contain tightly packed fields.\\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\\n  struct GasPriceUpdate {\\n    uint64 destChainSelector; // Destination chain selector.\\n    uint224 usdPerUnitGas; // 1e18 USD per smallest unit (e.g. wei) of destination chain gas.\\n  }\\n\\n  /// @notice A timestamped uint224 value that can contain several tightly packed fields.\\n  struct TimestampedPackedUint224 {\\n    uint224 value; // ────╮ Value in uint224, packed.\\n    uint32 timestamp; // ─╯ Timestamp of the most recent price update.\\n  }\\n\\n  /// @dev Gas price is stored in 112-bit unsigned int. uint224 can pack 2 prices.\\n  /// When packing L1 and L2 gas prices, L1 gas price is left-shifted to the higher-order bits.\\n  /// Using uint8 type, which cannot be higher than other bit shift operands, to avoid shift operand type warning.\\n  uint8 public constant GAS_PRICE_BITS = 112;\\n\\n  struct SourceTokenData {\\n    // The source pool address, abi encoded. This value is trusted as it was obtained through the onRamp. It can be\\n    // relied upon by the destination pool to validate the source pool.\\n    bytes sourcePoolAddress;\\n    // The address of the destination token, abi encoded in the case of EVM chains.\\n    // This value is UNTRUSTED as any pool owner can return whatever value they want.\\n    bytes destTokenAddress;\\n    // Optional pool data to be transferred to the destination chain. Be default this is capped at\\n    // CCIP_LOCK_OR_BURN_V1_RET_BYTES bytes. If more data is required, the TokenTransferFeeConfig.destBytesOverhead\\n    // has to be set for the specific token.\\n    bytes extraData;\\n    uint32 destGasAmount; // The amount of gas available for the releaseOrMint and balanceOf calls on the offRamp\\n  }\\n\\n  /// @notice Report that is submitted by the execution DON at the execution phase, including chain selector data.\\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\\n  struct ExecutionReport {\\n    uint64 sourceChainSelector; // Source chain selector for which the report is submitted.\\n    Any2EVMRampMessage[] messages;\\n    // Contains a bytes array for each message, each inner bytes array contains bytes per transferred token.\\n    bytes[][] offchainTokenData;\\n    bytes32[] proofs;\\n    uint256 proofFlagBits;\\n  }\\n\\n  /// @dev Any2EVMRampMessage struct has 10 fields, including 3 variable unnested arrays, sender, data and tokenAmounts.\\n  /// Each variable array takes 1 more slot to store its length.\\n  /// When abi encoded, excluding array contents, Any2EVMMessage takes up a fixed number of 13 slots, 32 bytes each.\\n  /// Assume 1 slot for sender\\n  /// For structs that contain arrays, 1 more slot is added to the front, reaching a total of 14.\\n  /// The fixed bytes does not cover struct data (this is represented by MESSAGE_FIXED_BYTES_PER_TOKEN)\\n  uint256 public constant MESSAGE_FIXED_BYTES = 32 * 15;\\n\\n  /// @dev Any2EVMTokensTransfer struct bytes length\\n  /// 0x20\\n  /// sourcePoolAddress_offset\\n  /// destTokenAddress\\n  /// destGasAmount\\n  /// extraData_offset\\n  /// amount\\n  /// sourcePoolAddress_length\\n  /// sourcePoolAddress_content // assume 1 slot\\n  /// extraData_length // contents billed separately\\n  uint256 public constant MESSAGE_FIXED_BYTES_PER_TOKEN = 32 * (4 + (3 + 2));\\n\\n  bytes32 internal constant ANY_2_EVM_MESSAGE_HASH = keccak256(\\\"Any2EVMMessageHashV1\\\");\\n  bytes32 internal constant EVM_2_ANY_MESSAGE_HASH = keccak256(\\\"EVM2AnyMessageHashV1\\\");\\n\\n  /// @dev Used to hash messages for multi-lane family-agnostic OffRamps.\\n  /// OnRamp hash(EVM2AnyMessage) != Any2EVMRampMessage.messageId.\\n  /// OnRamp hash(EVM2AnyMessage) != OffRamp hash(Any2EVMRampMessage).\\n  /// @param original OffRamp message to hash.\\n  /// @param metadataHash Hash preimage to ensure global uniqueness.\\n  /// @return hashedMessage hashed message as a keccak256.\\n  function _hash(Any2EVMRampMessage memory original, bytes32 metadataHash) internal pure returns (bytes32) {\\n    // Fixed-size message fields are included in nested hash to reduce stack pressure.\\n    // This hashing scheme is also used by RMN. If changing it, please notify the RMN maintainers.\\n    return keccak256(\\n      abi.encode(\\n        MerkleMultiProof.LEAF_DOMAIN_SEPARATOR,\\n        metadataHash,\\n        keccak256(\\n          abi.encode(\\n            original.header.messageId,\\n            original.receiver,\\n            original.header.sequenceNumber,\\n            original.gasLimit,\\n            original.header.nonce\\n          )\\n        ),\\n        keccak256(original.sender),\\n        keccak256(original.data),\\n        keccak256(abi.encode(original.tokenAmounts))\\n      )\\n    );\\n  }\\n\\n  function _hash(EVM2AnyRampMessage memory original, bytes32 metadataHash) internal pure returns (bytes32) {\\n    // Fixed-size message fields are included in nested hash to reduce stack pressure.\\n    // This hashing scheme is also used by RMN. If changing it, please notify the RMN maintainers.\\n    return keccak256(\\n      abi.encode(\\n        MerkleMultiProof.LEAF_DOMAIN_SEPARATOR,\\n        metadataHash,\\n        keccak256(\\n          abi.encode(\\n            original.sender,\\n            original.header.sequenceNumber,\\n            original.header.nonce,\\n            original.feeToken,\\n            original.feeTokenAmount\\n          )\\n        ),\\n        keccak256(original.receiver),\\n        keccak256(original.data),\\n        keccak256(abi.encode(original.tokenAmounts)),\\n        keccak256(original.extraArgs)\\n      )\\n    );\\n  }\\n\\n  /// @dev We disallow the first 1024 addresses to avoid calling into a range known for hosting precompiles. Calling\\n  /// into precompiles probably won't cause any issues, but to be safe we can disallow this range. It is extremely\\n  /// unlikely that anyone would ever be able to generate an address in this range. There is no official range of\\n  /// precompiles, but EIP-7587 proposes to reserve the range 0x100 to 0x1ff. Our range is more conservative, even\\n  /// though it might not be exhaustive for all chains, which is OK. We also disallow the zero address, which is a\\n  /// common practice.\\n  uint256 public constant EVM_PRECOMPILE_SPACE = 1024;\\n\\n  // According to the Aptos docs, the first 0xa addresses are reserved for precompiles.\\n  // https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-framework/doc/account.md#function-create_framework_reserved_account-1\\n  uint256 public constant APTOS_PRECOMPILE_SPACE = 0x0b;\\n\\n  /// @notice This methods provides validation for parsing abi encoded addresses by ensuring the address is within the\\n  /// EVM address space. If it isn't it will revert with an InvalidEVMAddress error, which we can catch and handle\\n  /// more gracefully than a revert from abi.decode.\\n  function _validateEVMAddress(\\n    bytes memory encodedAddress\\n  ) internal pure {\\n    if (encodedAddress.length != 32) revert InvalidEVMAddress(encodedAddress);\\n    uint256 encodedAddressUint = abi.decode(encodedAddress, (uint256));\\n    if (encodedAddressUint \\u003e type(uint160).max || encodedAddressUint \\u003c EVM_PRECOMPILE_SPACE) {\\n      revert InvalidEVMAddress(encodedAddress);\\n    }\\n  }\\n\\n  /// @notice This methods provides validation for parsing abi encoded addresses by ensuring the address is within the\\n  /// bounds of [minValue, uint256.max]. If it isn't it will revert with an Invalid32ByteAddress error.\\n  function _validate32ByteAddress(bytes memory encodedAddress, uint256 minValue) internal pure {\\n    if (encodedAddress.length != 32) revert Invalid32ByteAddress(encodedAddress);\\n    if (minValue \\u003e 0) {\\n      if (abi.decode(encodedAddress, (uint256)) \\u003c minValue) {\\n        revert Invalid32ByteAddress(encodedAddress);\\n      }\\n    }\\n  }\\n\\n  /// @notice This methods provides validation for TON User-friendly addresses by ensuring the address is 36 bytes long.\\n  /// @dev The encodedAddress is expected to be the 36-byte raw representation:\\n  /// - 1 byte: flags (isBounceable, isTestnetOnly, etc.)\\n  /// - 1 byte: workchain_id (0x00 for BaseChain, 0xff for MasterChain)\\n  /// - 32 bytes: account_id\\n  /// - 2 bytes: CRC16 checksum(computationally heavy, validation omitted for simplicity)\\n  /// @param encodedAddress The 36-byte TON address.\\n  function _validateTVMAddress(\\n    bytes memory encodedAddress\\n  ) internal pure {\\n    if (encodedAddress.length != 36) revert InvalidTVMAddress(encodedAddress);\\n    bytes32 accountId;\\n    assembly {\\n      accountId := mload(add(encodedAddress, 0x22)) // 0x22 = 0x20 (data start) + 2 (offset for account_id)\\n    }\\n    if (accountId == bytes32(0)) revert InvalidTVMAddress(encodedAddress);\\n  }\\n\\n  /// @notice Enum listing the possible message execution states within the offRamp contract.\\n  /// UNTOUCHED never executed.\\n  /// IN_PROGRESS currently being executed, used a replay protection.\\n  /// SUCCESS successfully executed. End state.\\n  /// FAILURE unsuccessfully executed, manual execution is now enabled.\\n  /// @dev RMN depends on this enum, if changing, please notify the RMN maintainers.\\n  enum MessageExecutionState {\\n    UNTOUCHED,\\n    IN_PROGRESS,\\n    SUCCESS,\\n    FAILURE\\n  }\\n\\n  /// @notice CCIP OCR plugin type, used to separate execution \\u0026 commit transmissions and configs.\\n  enum OCRPluginType {\\n    Commit,\\n    Execution\\n  }\\n\\n  /// @notice Family-agnostic header for OnRamp \\u0026 OffRamp messages.\\n  /// The messageId is not expected to match hash(message), since it may originate from another ramp family.\\n  struct RampMessageHeader {\\n    bytes32 messageId; // Unique identifier for the message, generated with the source chain's encoding scheme (i.e. not necessarily abi.encoded).\\n    uint64 sourceChainSelector; // ─╮ the chain selector of the source chain, note: not chainId.\\n    uint64 destChainSelector; //    │ the chain selector of the destination chain, note: not chainId.\\n    uint64 sequenceNumber; //       │ sequence number, not unique across lanes.\\n    uint64 nonce; // ───────────────╯ nonce for this lane for this sender, not unique across senders/lanes.\\n  }\\n\\n  struct EVM2AnyTokenTransfer {\\n    // The source pool EVM address. This value is trusted as it was obtained through the onRamp. It can be relied\\n    // upon by the destination pool to validate the source pool.\\n    address sourcePoolAddress;\\n    // The EVM address of the destination token.\\n    // This value is UNTRUSTED as any pool owner can return whatever value they want.\\n    bytes destTokenAddress;\\n    // Optional pool data to be transferred to the destination chain. Be default this is capped at\\n    // CCIP_LOCK_OR_BURN_V1_RET_BYTES bytes. If more data is required, the TokenTransferFeeConfig.destBytesOverhead\\n    // has to be set for the specific token.\\n    bytes extraData;\\n    uint256 amount; // Amount of tokens.\\n    // Destination chain data used to execute the token transfer on the destination chain. For an EVM destination, it\\n    // consists of the amount of gas available for the releaseOrMint and transfer calls made by the offRamp.\\n    bytes destExecData;\\n  }\\n\\n  struct Any2EVMTokenTransfer {\\n    // The source pool EVM address encoded to bytes. This value is trusted as it is obtained through the onRamp. It can\\n    // be relied upon by the destination pool to validate the source pool.\\n    bytes sourcePoolAddress;\\n    address destTokenAddress; // ─╮ Address of destination token\\n    uint32 destGasAmount; // ─────╯ The amount of gas available for the releaseOrMint and transfer calls on the offRamp.\\n    // Optional pool data to be transferred to the destination chain. Be default this is capped at\\n    // CCIP_LOCK_OR_BURN_V1_RET_BYTES bytes. If more data is required, the TokenTransferFeeConfig.destBytesOverhead\\n    // has to be set for the specific token.\\n    bytes extraData;\\n    uint256 amount; // Amount of tokens.\\n  }\\n\\n  /// @notice Family-agnostic message routed to an OffRamp.\\n  /// Note: hash(Any2EVMRampMessage) != hash(EVM2AnyRampMessage), hash(Any2EVMRampMessage) != messageId due to encoding\\n  /// and parameter differences.\\n  struct Any2EVMRampMessage {\\n    RampMessageHeader header; // Message header.\\n    bytes sender; // sender address on the source chain.\\n    bytes data; // arbitrary data payload supplied by the message sender.\\n    address receiver; // receiver address on the destination chain.\\n    uint256 gasLimit; // user supplied maximum gas amount available for dest chain execution.\\n    Any2EVMTokenTransfer[] tokenAmounts; // array of tokens and amounts to transfer.\\n  }\\n\\n  /// @notice Family-agnostic message emitted from the OnRamp.\\n  /// Note: hash(Any2EVMRampMessage) != hash(EVM2AnyRampMessage) due to encoding \\u0026 parameter differences.\\n  /// messageId = hash(EVM2AnyRampMessage) using the source EVM chain's encoding format.\\n  struct EVM2AnyRampMessage {\\n    RampMessageHeader header; // Message header.\\n    address sender; // sender address on the source chain.\\n    bytes data; // arbitrary data payload supplied by the message sender.\\n    bytes receiver; // receiver address on the destination chain.\\n    bytes extraArgs; // destination-chain specific extra args, such as the gasLimit for EVM chains.\\n    address feeToken; // fee token.\\n    uint256 feeTokenAmount; // fee token amount.\\n    uint256 feeValueJuels; // fee amount in Juels.\\n    EVM2AnyTokenTransfer[] tokenAmounts; // array of tokens and amounts to transfer.\\n  }\\n\\n  // bytes4(keccak256(\\\"CCIP ChainFamilySelector EVM\\\"));\\n  bytes4 public constant CHAIN_FAMILY_SELECTOR_EVM = 0x2812d52c;\\n\\n  // bytes4(keccak256(\\\"CCIP ChainFamilySelector SVM\\\"));\\n  bytes4 public constant CHAIN_FAMILY_SELECTOR_SVM = 0x1e10bdc4;\\n\\n  // bytes4(keccak256(\\\"CCIP ChainFamilySelector APTOS\\\"));\\n  bytes4 public constant CHAIN_FAMILY_SELECTOR_APTOS = 0xac77ffec;\\n\\n  // bytes4(keccak256(\\\"CCIP ChainFamilySelector SUI\\\"));\\n  bytes4 public constant CHAIN_FAMILY_SELECTOR_SUI = 0xc4e05953;\\n\\n  // byte4(keccak256(\\\"CCIP ChainFamilySelector TVM\\\"));\\n  bytes4 public constant CHAIN_FAMILY_SELECTOR_TVM = 0x647e2ba9;\\n\\n  /// @dev Holds a merkle root and interval for a source chain so that an array of these can be passed in the CommitReport.\\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\\n  /// @dev inefficient struct packing intentionally chosen to maintain order of specificity. Not a storage struct so impact is minimal.\\n  // solhint-disable-next-line gas-struct-packing\\n  struct MerkleRoot {\\n    uint64 sourceChainSelector; // Remote source chain selector that the Merkle Root is scoped to\\n    bytes onRampAddress; //        Generic onRamp address, to support arbitrary sources; for EVM, use abi.encode\\n    uint64 minSeqNr; // ─────────╮ Minimum sequence number, inclusive\\n    uint64 maxSeqNr; // ─────────╯ Maximum sequence number, inclusive\\n    bytes32 merkleRoot; //         Merkle root covering the interval \\u0026 source chain messages\\n  }\\n}\\n\"},\"contracts/libraries/MerkleMultiProof.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.4;\\n\\nlibrary MerkleMultiProof {\\n  /// @notice Leaf domain separator, should be used as the first 32 bytes of a leaf's preimage.\\n  bytes32 internal constant LEAF_DOMAIN_SEPARATOR = 0x0000000000000000000000000000000000000000000000000000000000000000;\\n  /// @notice Internal domain separator, should be used as the first 32 bytes of an internal node's preimage.\\n  bytes32 internal constant INTERNAL_DOMAIN_SEPARATOR =\\n    0x0000000000000000000000000000000000000000000000000000000000000001;\\n\\n  uint256 internal constant MAX_NUM_HASHES = 256;\\n\\n  error InvalidProof();\\n  error LeavesCannotBeEmpty();\\n\\n  /// @notice Computes the root based on provided pre-hashed leaf nodes in leaves, internal nodes  in proofs, and using\\n  /// proofFlagBits' i-th bit to determine if an element of proofs or one of the previously computed leafs or internal\\n  /// nodes will be used for the i-th hash.\\n  /// @param leaves Should be pre-hashed and the first 32 bytes of a leaf's preimage should match LEAF_DOMAIN_SEPARATOR.\\n  /// @param proofs Hashes to be used instead of a leaf hash when the proofFlagBits indicates a proof should be used.\\n  /// @param proofFlagBits A single uint256 of which each bit indicates whether a leaf or a proof needs to be used in\\n  /// a hash operation.\\n  /// @dev the maximum number of hash operations it set to 256. Any input that would require more than 256 hashes to get\\n  /// to a root will revert.\\n  /// @dev For given input `leaves` = [a,b,c] `proofs` = [D] and `proofFlagBits` = 5\\n  ///     totalHashes = 3 + 1 - 1 = 3\\n  ///  ** round 1 **\\n  ///    proofFlagBits = (5 \\u003e\\u003e 0) \\u0026 1 = true\\n  ///    hashes[0] = hashPair(a, b)\\n  ///    (leafPos, hashPos, proofPos) = (2, 0, 0);\\n  ///\\n  ///  ** round 2 **\\n  ///    proofFlagBits = (5 \\u003e\\u003e 1) \\u0026 1 = false\\n  ///    hashes[1] = hashPair(D, c)\\n  ///    (leafPos, hashPos, proofPos) = (3, 0, 1);\\n  ///\\n  ///  ** round 3 **\\n  ///    proofFlagBits = (5 \\u003e\\u003e 2) \\u0026 1 = true\\n  ///    hashes[2] = hashPair(hashes[0], hashes[1])\\n  ///    (leafPos, hashPos, proofPos) = (3, 2, 1);\\n  ///\\n  ///    i = 3 and no longer \\u003c totalHashes. The algorithm is done\\n  ///    return hashes[totalHashes - 1] = hashes[2]; the last hash we computed.\\n  // We mark this function as internal to force it to be inlined in contracts that use it, but semantically it is public.\\n  function _merkleRoot(\\n    bytes32[] memory leaves,\\n    bytes32[] memory proofs,\\n    uint256 proofFlagBits\\n  ) internal pure returns (bytes32) {\\n    unchecked {\\n      uint256 leavesLen = leaves.length;\\n      uint256 proofsLen = proofs.length;\\n      if (leavesLen == 0) revert LeavesCannotBeEmpty();\\n      if (!(leavesLen \\u003c= MAX_NUM_HASHES + 1 \\u0026\\u0026 proofsLen \\u003c= MAX_NUM_HASHES + 1)) revert InvalidProof();\\n      uint256 totalHashes = leavesLen + proofsLen - 1;\\n      if (!(totalHashes \\u003c= MAX_NUM_HASHES)) revert InvalidProof();\\n      if (totalHashes == 0) {\\n        return leaves[0];\\n      }\\n      bytes32[] memory hashes = new bytes32[](totalHashes);\\n      (uint256 leafPos, uint256 hashPos, uint256 proofPos) = (0, 0, 0);\\n\\n      for (uint256 i = 0; i \\u003c totalHashes; ++i) {\\n        // Checks if the bit flag signals the use of a supplied proof or a leaf/previous hash.\\n        bytes32 a;\\n        if (proofFlagBits \\u0026 (1 \\u003c\\u003c i) == (1 \\u003c\\u003c i)) {\\n          // Use a leaf or a previously computed hash.\\n          if (leafPos \\u003c leavesLen) {\\n            a = leaves[leafPos++];\\n          } else {\\n            a = hashes[hashPos++];\\n          }\\n        } else {\\n          // Use a supplied proof.\\n          a = proofs[proofPos++];\\n        }\\n\\n        // The second part of the hashed pair is never a proof as hashing two proofs would result in a\\n        // hash that can already be computed offchain.\\n        bytes32 b;\\n        if (leafPos \\u003c leavesLen) {\\n          b = leaves[leafPos++];\\n        } else {\\n          b = hashes[hashPos++];\\n        }\\n\\n        if (!(hashPos \\u003c= i)) revert InvalidProof();\\n\\n        hashes[i] = _hashPair(a, b);\\n      }\\n      if (!(hashPos == totalHashes - 1 \\u0026\\u0026 leafPos == leavesLen \\u0026\\u0026 proofPos == proofsLen)) revert InvalidProof();\\n      // Return the last hash.\\n      return hashes[totalHashes - 1];\\n    }\\n  }\\n\\n  /// @notice Hashes two bytes32 objects in their given order, prepended by the INTERNAL_DOMAIN_SEPARATOR.\\n  function _hashInternalNode(bytes32 left, bytes32 right) private pure returns (bytes32 hash) {\\n    return keccak256(abi.encode(INTERNAL_DOMAIN_SEPARATOR, left, right));\\n  }\\n\\n  /// @notice Hashes two bytes32 objects. The order is taken into account, using the lower value first.\\n  function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n    return a \\u003c b ? _hashInternalNode(a, b) : _hashInternalNode(b, a);\\n  }\\n}\\n\"},\"contracts/libraries/MessageV1Codec.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for CCIP MessageV1 encoding/decoding operations.\\n/// @dev This library handles the complete V1 message format protocol including:\\n/// - MessageV1 and TokenTransferV1 struct definitions\\n/// - Encoding/decoding functions with comprehensive error handling\\n/// - Detailed error location tracking for debugging\\nlibrary MessageV1Codec {\\n  error InvalidDataLength(EncodingErrorLocation location);\\n  error InvalidEncodingVersion(uint8 version);\\n\\n  uint256 public constant MAX_NUMBER_OF_TOKENS = 1;\\n\\n  enum EncodingErrorLocation {\\n    // Message-level components.\\n    MESSAGE_MIN_SIZE,\\n    MESSAGE_ONRAMP_ADDRESS_CONTENT,\\n    MESSAGE_OFFRAMP_ADDRESS_LENGTH,\\n    MESSAGE_OFFRAMP_ADDRESS_CONTENT,\\n    MESSAGE_FINALITY,\\n    MESSAGE_SENDER_LENGTH,\\n    MESSAGE_SENDER_CONTENT,\\n    MESSAGE_RECEIVER_LENGTH,\\n    MESSAGE_RECEIVER_CONTENT,\\n    MESSAGE_DEST_BLOB_LENGTH,\\n    MESSAGE_DEST_BLOB_CONTENT,\\n    MESSAGE_TOKEN_TRANSFER_LENGTH,\\n    MESSAGE_TOKEN_TRANSFER_CONTENT,\\n    MESSAGE_DATA_LENGTH,\\n    MESSAGE_DATA_CONTENT,\\n    MESSAGE_FINAL_OFFSET,\\n    // Token transfer components.\\n    TOKEN_TRANSFER_VERSION,\\n    TOKEN_TRANSFER_AMOUNT,\\n    TOKEN_TRANSFER_SOURCE_POOL_LENGTH,\\n    TOKEN_TRANSFER_SOURCE_POOL_CONTENT,\\n    TOKEN_TRANSFER_SOURCE_TOKEN_LENGTH,\\n    TOKEN_TRANSFER_SOURCE_TOKEN_CONTENT,\\n    TOKEN_TRANSFER_DEST_TOKEN_LENGTH,\\n    TOKEN_TRANSFER_DEST_TOKEN_CONTENT,\\n    TOKEN_TRANSFER_EXTRA_DATA_LENGTH,\\n    TOKEN_TRANSFER_EXTRA_DATA_CONTENT,\\n    // Encoding validation components.\\n    ENCODE_ONRAMP_ADDRESS_LENGTH,\\n    ENCODE_OFFRAMP_ADDRESS_LENGTH,\\n    ENCODE_SENDER_LENGTH,\\n    ENCODE_RECEIVER_LENGTH,\\n    ENCODE_DEST_BLOB_LENGTH,\\n    ENCODE_TOKEN_TRANSFER_ARRAY_LENGTH,\\n    ENCODE_DATA_LENGTH,\\n    ENCODE_TOKEN_SOURCE_POOL_LENGTH,\\n    ENCODE_TOKEN_SOURCE_TOKEN_LENGTH,\\n    ENCODE_TOKEN_DEST_TOKEN_LENGTH,\\n    ENCODE_TOKEN_EXTRA_DATA_LENGTH\\n  }\\n\\n  /// @notice Message format used in the v1 protocol.\\n  /// Protocol Header.\\n  ///   uint8 version;              Version, for future use and backwards compatibility.\\n  ///   uint64 sourceChainSelector; Source Chain Selector.\\n  ///   uint64 destChainSelector;   Destination Chain Selector.\\n  ///   uint64 sequenceNumber;      Auto-incrementing sequence number for the message.\\n  ///   uint8 onRampAddressLength;  Length of the onRamp Address in bytes.\\n  ///   bytes onRampAddress;        Source Chain OnRamp as unpadded bytes.\\n  ///   uint8 offRampAddressLength; Length of the offRamp Address in bytes.\\n  ///   bytes offRampAddress;       Destination Chain OffRamp as unpadded bytes.\\n  ///\\n  /// User controlled data.\\n  ///   uint16 finality;            Configurable per-message finality value.\\n  ///   uint8 senderLength;         Length of the Sender Address in bytes.\\n  ///   bytes sender;               Sender address as unpadded bytes.\\n  ///   uint8 receiverLength;       Length of the Receiver Address in bytes.\\n  ///   bytes receiver;             Receiver address on the destination chain as unpadded bytes.\\n  ///   uint16 destBlobLength;      Length of the Destination Blob in bytes.\\n  ///   bytes destBlob;             Destination chain-specific blob that contains data required for execution e.g.\\n  ///                               Solana accounts.\\n  ///   uint16 tokenTransferLength; Length of the Token Transfer structure in bytes.\\n  ///   bytes tokenTransfer;        Byte representation of the token transfer structure.\\n  ///   uint16 dataLength;          Length of the user specified data payload.\\n  ///   bytes data;                 Arbitrary data payload supplied by the message sender that is passed to the receiver.\\n  ///\\n  /// @dev None of the fields are abi encoded as this storage layout is used for non-EVMs as well. That means if the\\n  /// receiver is an EVM address, it is stored as 20 bytes without any padding.\\n  /// @dev Inefficient struct packing does not matter as this is not a storage struct, and it it would ever be written\\n  /// to storage it would be in its encoded form.\\n  // solhint-disable-next-line gas-struct-packing\\n  struct MessageV1 {\\n    // Protocol Header.\\n    uint64 sourceChainSelector; // ─╮ Source Chain Selector.\\n    uint64 destChainSelector; //    │ Destination Chain Selector.\\n    //                              │ Per-lane-unique sequence number for the message. When faster-than-finality is used\\n    //                              │ the guarantee that this value is unique no longer holds. After a re-org, a message\\n    //                              │ could end up with a different sequence number. Messages that are older than the\\n    uint64 sequenceNumber; //  ─────╯ chain finality delay should all have unique per-lane sequence numbers.\\n    // Source chain onRamp, NOT abi encoded but raw bytes. This means for EVM chains it is 20 bytes.\\n    bytes onRampAddress;\\n    // Destination chain offRamp, NOT abi encoded but raw bytes. This means for EVM chains it is 20 bytes.\\n    bytes offRampAddress;\\n    // Configurable per-message finality value.\\n    uint16 finality;\\n    // Source chain sender address, NOT abi encoded but raw bytes. This means for EVM chains it is 20 bytes.\\n    bytes sender;\\n    // Destination chain receiver address, NOT abi encoded but raw bytes. This means for EVM chains it is 20 bytes.\\n    bytes receiver;\\n    // Destination specific blob that contains chain-family specific data.\\n    bytes destBlob;\\n    // Contains either 0 or 1 token transfer structs. It is encoded as an array for gas efficiency.\\n    TokenTransferV1[] tokenTransfer;\\n    // Arbitrary data payload supplied by the message sender.\\n    bytes data;\\n  }\\n\\n  struct TokenTransferV1 {\\n    uint256 amount; // Number of tokens.\\n    // This can be relied upon by the destination pool to validate the source pool. NOT abi encoded but raw bytes. This\\n    // means for EVM chains it is 20 bytes.\\n    bytes sourcePoolAddress;\\n    bytes sourceTokenAddress; // Address of source token, NOT abi encoded but raw bytes.\\n    bytes destTokenAddress; // Address of destination token, NOT abi encoded but raw bytes.\\n    // Optional pool data to be transferred to the destination chain. Be default this is capped at\\n    // CCIP_LOCK_OR_BURN_V1_RET_BYTES bytes. If more data is required, the TokenTransferFeeConfig.destBytesOverhead\\n    // has to be set for the specific token.\\n    bytes extraData;\\n  }\\n\\n  /// @notice Encodes a TokenTransferV1 struct into bytes.\\n  /// @param tokenTransfer The TokenTransferV1 struct to encode.\\n  /// @return encoded The encoded token transfer as bytes.\\n  function _encodeTokenTransferV1(\\n    TokenTransferV1 memory tokenTransfer\\n  ) internal pure returns (bytes memory) {\\n    // Validate field lengths fit in their respective size limits.\\n    if (tokenTransfer.sourcePoolAddress.length \\u003e type(uint8).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_TOKEN_SOURCE_POOL_LENGTH);\\n    }\\n    if (tokenTransfer.sourceTokenAddress.length \\u003e type(uint8).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_TOKEN_SOURCE_TOKEN_LENGTH);\\n    }\\n    if (tokenTransfer.destTokenAddress.length \\u003e type(uint8).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_TOKEN_DEST_TOKEN_LENGTH);\\n    }\\n    if (tokenTransfer.extraData.length \\u003e type(uint16).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_TOKEN_EXTRA_DATA_LENGTH);\\n    }\\n\\n    return abi.encodePacked(\\n      uint8(1), // version.\\n      tokenTransfer.amount,\\n      uint8(tokenTransfer.sourcePoolAddress.length),\\n      tokenTransfer.sourcePoolAddress,\\n      uint8(tokenTransfer.sourceTokenAddress.length),\\n      tokenTransfer.sourceTokenAddress,\\n      uint8(tokenTransfer.destTokenAddress.length),\\n      tokenTransfer.destTokenAddress,\\n      uint16(tokenTransfer.extraData.length),\\n      tokenTransfer.extraData\\n    );\\n  }\\n\\n  /// @notice Decodes bytes into a TokenTransferV1 struct.\\n  /// @param encoded The encoded token transfer bytes to decode.\\n  /// @param offset The starting offset in the encoded bytes.\\n  /// @return tokenTransfer The decoded TokenTransferV1 struct.\\n  /// @return newOffset The new offset after decoding.\\n  function _decodeTokenTransferV1(\\n    bytes calldata encoded,\\n    uint256 offset\\n  ) internal pure returns (TokenTransferV1 memory tokenTransfer, uint256 newOffset) {\\n    // version (1 byte).\\n    if (offset \\u003e= encoded.length) revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_VERSION);\\n    uint8 version = uint8(encoded[offset++]);\\n    if (version != 1) revert InvalidEncodingVersion(version);\\n\\n    // amount (32 bytes).\\n    if (offset + 32 \\u003e encoded.length) revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_AMOUNT);\\n    tokenTransfer.amount = uint256(bytes32(encoded[offset:offset + 32]));\\n    offset += 32;\\n\\n    // sourcePoolAddressLength and sourcePoolAddress.\\n    if (offset \\u003e= encoded.length) revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_SOURCE_POOL_LENGTH);\\n    uint8 sourcePoolAddressLength = uint8(encoded[offset++]);\\n    if (offset + sourcePoolAddressLength \\u003e encoded.length) {\\n      revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_SOURCE_POOL_CONTENT);\\n    }\\n\\n    tokenTransfer.sourcePoolAddress = encoded[offset:offset + sourcePoolAddressLength];\\n    offset += sourcePoolAddressLength;\\n\\n    // sourceTokenAddressLength and sourceTokenAddress.\\n    if (offset \\u003e= encoded.length) revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_SOURCE_TOKEN_LENGTH);\\n    uint8 sourceTokenAddressLength = uint8(encoded[offset++]);\\n    if (offset + sourceTokenAddressLength \\u003e encoded.length) {\\n      revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_SOURCE_TOKEN_CONTENT);\\n    }\\n\\n    tokenTransfer.sourceTokenAddress = encoded[offset:offset + sourceTokenAddressLength];\\n    offset += sourceTokenAddressLength;\\n\\n    // destTokenAddressLength and destTokenAddress.\\n    if (offset \\u003e= encoded.length) revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_DEST_TOKEN_LENGTH);\\n    uint8 destTokenAddressLength = uint8(encoded[offset++]);\\n    if (offset + destTokenAddressLength \\u003e encoded.length) {\\n      revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_DEST_TOKEN_CONTENT);\\n    }\\n\\n    tokenTransfer.destTokenAddress = encoded[offset:offset + destTokenAddressLength];\\n    offset += destTokenAddressLength;\\n\\n    // extraDataLength and extraData.\\n    if (offset + 2 \\u003e encoded.length) revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_EXTRA_DATA_LENGTH);\\n    uint16 extraDataLength = uint16(bytes2(encoded[offset:offset + 2]));\\n    offset += 2;\\n    if (offset + extraDataLength \\u003e encoded.length) {\\n      revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_EXTRA_DATA_CONTENT);\\n    }\\n\\n    tokenTransfer.extraData = encoded[offset:offset + extraDataLength];\\n    offset += extraDataLength;\\n\\n    return (tokenTransfer, offset);\\n  }\\n\\n  /// @notice Encodes a MessageV1 struct into bytes following the v1 protocol format.\\n  /// @param message The MessageV1 struct to encode.\\n  /// @return encoded The encoded message as bytes.\\n  function _encodeMessageV1(\\n    MessageV1 memory message\\n  ) internal pure returns (bytes memory) {\\n    // Validate field lengths fit in their respective size limits.\\n    if (message.onRampAddress.length \\u003e type(uint8).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_ONRAMP_ADDRESS_LENGTH);\\n    }\\n    if (message.offRampAddress.length \\u003e type(uint8).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_OFFRAMP_ADDRESS_LENGTH);\\n    }\\n    if (message.sender.length \\u003e type(uint8).max) revert InvalidDataLength(EncodingErrorLocation.ENCODE_SENDER_LENGTH);\\n    if (message.receiver.length \\u003e type(uint8).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_RECEIVER_LENGTH);\\n    }\\n    if (message.destBlob.length \\u003e type(uint16).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_DEST_BLOB_LENGTH);\\n    }\\n    if (message.tokenTransfer.length \\u003e MAX_NUMBER_OF_TOKENS) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_TOKEN_TRANSFER_ARRAY_LENGTH);\\n    }\\n    if (message.data.length \\u003e type(uint16).max) revert InvalidDataLength(EncodingErrorLocation.ENCODE_DATA_LENGTH);\\n\\n    // Encode token the transfer if present. We checked above that there is at most 1 token transfer.\\n    bytes memory encodedTokenTransfers;\\n    if (message.tokenTransfer.length \\u003e 0) {\\n      encodedTokenTransfers = _encodeTokenTransferV1(message.tokenTransfer[0]);\\n    }\\n\\n    // Encoding has to be split into groups to avoid \\\"Stack too deep\\\" errors.\\n    return bytes.concat(\\n      abi.encodePacked(\\n        uint8(1), // version.\\n        message.sourceChainSelector,\\n        message.destChainSelector,\\n        message.sequenceNumber,\\n        uint8(message.onRampAddress.length),\\n        message.onRampAddress,\\n        uint8(message.offRampAddress.length),\\n        message.offRampAddress,\\n        message.finality\\n      ),\\n      abi.encodePacked(\\n        uint8(message.sender.length),\\n        message.sender,\\n        uint8(message.receiver.length),\\n        message.receiver,\\n        uint16(message.destBlob.length),\\n        message.destBlob,\\n        uint16(encodedTokenTransfers.length),\\n        encodedTokenTransfers,\\n        uint16(message.data.length),\\n        message.data\\n      )\\n    );\\n  }\\n\\n  /// @notice Decodes bytes into a MessageV1 struct following the v1 protocol format.\\n  /// @param encoded The encoded message bytes to decode.\\n  /// @return message The decoded MessageV1 struct.\\n  function _decodeMessageV1(\\n    bytes calldata encoded\\n  ) internal pure returns (MessageV1 memory) {\\n    if (encoded.length \\u003c 37) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_MIN_SIZE); // Minimum size check.\\n\\n    MessageV1 memory message;\\n    uint256 offset = 0;\\n\\n    uint8 version = uint8(encoded[offset++]);\\n    if (version != 1) revert InvalidEncodingVersion(version);\\n\\n    // Protocol Header.\\n    // sourceChainSelector (8 bytes, big endian).\\n    message.sourceChainSelector = uint64(bytes8(encoded[offset:offset + 8]));\\n    offset += 8;\\n\\n    // destChainSelector (8 bytes, big endian).\\n    message.destChainSelector = uint64(bytes8(encoded[offset:offset + 8]));\\n    offset += 8;\\n\\n    // sequenceNumber (8 bytes, big endian).\\n    message.sequenceNumber = uint64(bytes8(encoded[offset:offset + 8]));\\n    offset += 8;\\n\\n    // onRampAddressLength and onRampAddress.\\n    uint8 onRampAddressLength = uint8(encoded[offset++]);\\n    if (offset + onRampAddressLength \\u003e encoded.length) {\\n      revert InvalidDataLength(EncodingErrorLocation.MESSAGE_ONRAMP_ADDRESS_CONTENT);\\n    }\\n\\n    message.onRampAddress = encoded[offset:offset + onRampAddressLength];\\n    offset += onRampAddressLength;\\n\\n    // offRampAddressLength and offRampAddress.\\n    if (offset \\u003e= encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_OFFRAMP_ADDRESS_LENGTH);\\n    uint8 offRampAddressLength = uint8(encoded[offset++]);\\n    if (offset + offRampAddressLength \\u003e encoded.length) {\\n      revert InvalidDataLength(EncodingErrorLocation.MESSAGE_OFFRAMP_ADDRESS_CONTENT);\\n    }\\n\\n    message.offRampAddress = encoded[offset:offset + offRampAddressLength];\\n    offset += offRampAddressLength;\\n\\n    // User controlled data.\\n    if (offset + 2 \\u003e encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_FINALITY);\\n\\n    // finality (2 bytes, big endian).\\n    message.finality = uint16(bytes2(encoded[offset:offset + 2]));\\n    offset += 2;\\n\\n    // senderLength and sender.\\n    if (offset \\u003e= encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_SENDER_LENGTH);\\n    uint8 senderLength = uint8(encoded[offset++]);\\n    if (offset + senderLength \\u003e encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_SENDER_CONTENT);\\n\\n    message.sender = encoded[offset:offset + senderLength];\\n    offset += senderLength;\\n\\n    // receiverLength and receiver.\\n    if (offset \\u003e= encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_RECEIVER_LENGTH);\\n    uint8 receiverLength = uint8(encoded[offset++]);\\n    if (offset + receiverLength \\u003e encoded.length) {\\n      revert InvalidDataLength(EncodingErrorLocation.MESSAGE_RECEIVER_CONTENT);\\n    }\\n\\n    message.receiver = encoded[offset:offset + receiverLength];\\n    offset += receiverLength;\\n\\n    // destBlobLength and destBlob.\\n    if (offset + 2 \\u003e encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_DEST_BLOB_LENGTH);\\n    uint16 destBlobLength = uint16(bytes2(encoded[offset:offset + 2]));\\n    offset += 2;\\n    if (offset + destBlobLength \\u003e encoded.length) {\\n      revert InvalidDataLength(EncodingErrorLocation.MESSAGE_DEST_BLOB_CONTENT);\\n    }\\n\\n    message.destBlob = encoded[offset:offset + destBlobLength];\\n    offset += destBlobLength;\\n\\n    // tokenTransferLength and tokenTransfer.\\n    if (offset + 2 \\u003e encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_TOKEN_TRANSFER_LENGTH);\\n    uint16 tokenTransferLength = uint16(bytes2(encoded[offset:offset + 2]));\\n    offset += 2;\\n\\n    // Decode token transfer, which is either 0 or 1.\\n    if (tokenTransferLength == 0) {\\n      message.tokenTransfer = new TokenTransferV1[](0);\\n    } else {\\n      message.tokenTransfer = new TokenTransferV1[](1);\\n      uint256 expectedEnd = offset + tokenTransferLength;\\n      (message.tokenTransfer[0], offset) = _decodeTokenTransferV1(encoded, offset);\\n      if (offset != expectedEnd) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_TOKEN_TRANSFER_CONTENT);\\n    }\\n\\n    // dataLength and data.\\n    if (offset + 2 \\u003e encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_DATA_LENGTH);\\n    uint16 dataLength = uint16(bytes2(encoded[offset:offset + 2]));\\n    offset += 2;\\n    if (offset + dataLength \\u003e encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_DATA_CONTENT);\\n\\n    message.data = encoded[offset:offset + dataLength];\\n    offset += dataLength;\\n\\n    // Ensure we've consumed all bytes.\\n    if (offset != encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_FINAL_OFFSET);\\n\\n    return message;\\n  }\\n}\\n\"},\"contracts/libraries/Pool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice This library contains various token pool functions to aid constructing the return data.\\nlibrary Pool {\\n  // The tag used to signal support for the pool v1 standard.\\n  // bytes4(keccak256(\\\"CCIP_POOL_V1\\\"))\\n  bytes4 public constant CCIP_POOL_V1 = 0xaff2afbf;\\n\\n  // The tag used to signal support for the pool v1 standard.\\n  // bytes4(keccak256(\\\"CCIP_POOL_V2\\\"))\\n  bytes4 public constant CCIP_POOL_V2 = 0xf208a58f;\\n\\n  // The number of bytes in the return data for a pool v1 releaseOrMint call.\\n  // This should match the size of the ReleaseOrMintOutV1 struct.\\n  uint16 public constant CCIP_POOL_V1_RET_BYTES = 32;\\n\\n  // The default max number of bytes in the return data for a pool v1 lockOrBurn call.\\n  // This data can be used to send information to the destination chain token pool. Can be overwritten\\n  // in the TokenTransferFeeConfig.destBytesOverhead if more data is required.\\n  uint32 public constant CCIP_LOCK_OR_BURN_V1_RET_BYTES = 32;\\n\\n  struct LockOrBurnInV1 {\\n    bytes receiver; //  The recipient of the tokens on the destination chain, abi encoded.\\n    uint64 remoteChainSelector; // ─╮ The chain ID of the destination chain.\\n    address originalSender; // ─────╯ The original sender of the tx on the source chain.\\n    uint256 amount; //  The amount of tokens to lock or burn, denominated in the source token's decimals.\\n    address localToken; //  The address on this chain of the token to lock or burn.\\n  }\\n\\n  struct LockOrBurnOutV1 {\\n    // The address of the destination token, abi encoded in the case of EVM chains.\\n    // This value is UNTRUSTED as any pool owner can return whatever value they want.\\n    bytes destTokenAddress;\\n    // Optional pool data to be transferred to the destination chain. Be default this is capped at\\n    // CCIP_LOCK_OR_BURN_V1_RET_BYTES bytes. If more data is required, the TokenTransferFeeConfig.destBytesOverhead\\n    // has to be set for the specific token.\\n    bytes destPoolData;\\n  }\\n\\n  struct ReleaseOrMintInV1 {\\n    bytes originalSender; //            The original sender of the tx on the source chain.\\n    uint64 remoteChainSelector; // ───╮ The chain ID of the source chain.\\n    address receiver; // ─────────────╯ The recipient of the tokens on the destination chain.\\n    uint256 sourceDenominatedAmount; // The amount of tokens to release or mint, denominated in the source token's decimals.\\n    address localToken; //              The address on this chain of the token to release or mint.\\n    /// @dev WARNING: sourcePoolAddress should be checked prior to any processing of funds. Make sure it matches the\\n    /// expected pool address for the given remoteChainSelector.\\n    bytes sourcePoolAddress; //         The address of the source pool, abi encoded in the case of EVM chains.\\n    bytes sourcePoolData; //            The data received from the source pool to process the release or mint.\\n    /// @dev WARNING: offchainTokenData is untrusted data.\\n    bytes offchainTokenData; //         The offchain data to process the release or mint.\\n  }\\n\\n  struct ReleaseOrMintOutV1 {\\n    // The number of tokens released or minted on the destination chain, denominated in the local token's decimals.\\n    // This value is expected to be equal to the ReleaseOrMintInV1.amount in the case where the source and destination\\n    // chain have the same number of decimals.\\n    uint256 destinationAmount;\\n  }\\n}\\n\"},\"contracts/offRamp/CCVAggregator.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\nimport {IAny2EVMMessageReceiver} from \\\"../interfaces/IAny2EVMMessageReceiver.sol\\\";\\nimport {IAny2EVMMessageReceiverV2} from \\\"../interfaces/IAny2EVMMessageReceiverV2.sol\\\";\\nimport {ICrossChainVerifierV1} from \\\"../interfaces/ICrossChainVerifierV1.sol\\\";\\nimport {IPoolV1} from \\\"../interfaces/IPool.sol\\\";\\nimport {IPoolV2} from \\\"../interfaces/IPoolV2.sol\\\";\\nimport {IRMNRemote} from \\\"../interfaces/IRMNRemote.sol\\\";\\nimport {IRouter} from \\\"../interfaces/IRouter.sol\\\";\\nimport {ITokenAdminRegistry} from \\\"../interfaces/ITokenAdminRegistry.sol\\\";\\nimport {ITypeAndVersion} from \\\"@chainlink/contracts/src/v0.8/shared/interfaces/ITypeAndVersion.sol\\\";\\n\\nimport {CCVConfigValidation} from \\\"../libraries/CCVConfigValidation.sol\\\";\\nimport {Client} from \\\"../libraries/Client.sol\\\";\\nimport {ERC165CheckerReverting} from \\\"../libraries/ERC165CheckerReverting.sol\\\";\\nimport {Internal} from \\\"../libraries/Internal.sol\\\";\\nimport {MessageV1Codec} from \\\"../libraries/MessageV1Codec.sol\\\";\\nimport {Pool} from \\\"../libraries/Pool.sol\\\";\\nimport {Ownable2StepMsgSender} from \\\"@chainlink/contracts/src/v0.8/shared/access/Ownable2StepMsgSender.sol\\\";\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts@5.0.2/token/ERC20/IERC20.sol\\\";\\nimport {EnumerableSet} from \\\"@openzeppelin/contracts@5.0.2/utils/structs/EnumerableSet.sol\\\";\\n\\ncontract CCVAggregator is ITypeAndVersion, Ownable2StepMsgSender {\\n  using ERC165CheckerReverting for address;\\n  using EnumerableSet for EnumerableSet.UintSet;\\n\\n  error ZeroChainSelectorNotAllowed();\\n  error ExecutionError(bytes32 messageId, bytes err);\\n  error OptionalCCVQuorumNotReached(uint256 wanted, uint256 got);\\n  error SourceChainNotEnabled(uint64 sourceChainSelector);\\n  error CanOnlySelfCall();\\n  error ReceiverError(bytes err);\\n  error TokenHandlingError(address target, bytes err);\\n  error ReleaseOrMintBalanceMismatch(uint256 amountReleased, uint256 balancePre, uint256 balancePost);\\n  error CursedByRMN(uint64 sourceChainSelector);\\n  error NotACompatiblePool(address notPool);\\n  error InvalidCCVDataLength(uint256 expected, uint256 got);\\n  error InvalidNewState(uint64 sourceChainSelector, uint64 sequenceNumber, Internal.MessageExecutionState newState);\\n  error ZeroAddressNotAllowed();\\n  error InvalidMessageDestChainSelector(uint64 messageDestChainSelector);\\n  error InsufficientGasToCompleteTx(bytes4 err);\\n  error SkippedAlreadyExecutedMessage(bytes32 messageId, uint64 sourceChainSelector, uint64 sequenceNumber);\\n  error InvalidVerifierSelector(bytes4 selector);\\n  error ReentrancyGuardReentrantCall();\\n  error RequiredCCVMissing(address requiredCCV);\\n  error InvalidNumberOfTokens(uint256 numTokens);\\n\\n  /// @dev Atlas depends on various events, if changing, please notify Atlas.\\n  event StaticConfigSet(StaticConfig staticConfig);\\n  event ExecutionStateChanged(\\n    uint64 indexed sourceChainSelector,\\n    uint64 indexed sequenceNumber,\\n    bytes32 indexed messageId,\\n    Internal.MessageExecutionState state,\\n    bytes returnData\\n  );\\n  event SourceChainConfigSet(uint64 indexed sourceChainSelector, SourceChainConfig sourceConfig);\\n\\n  // 5k for updating the state + 5k for the event and misc costs.\\n  uint256 internal constant MAX_GAS_BUFFER_TO_UPDATE_STATE = 5000 + 5000 + 2000;\\n\\n  /// @dev Struct that contains the static configuration. The individual components are stored as immutable variables.\\n  // solhint-disable-next-line gas-struct-packing\\n  struct StaticConfig {\\n    uint64 localChainSelector; // ──╮ Local chainSelector\\n    uint16 gasForCallExactCheck; // │ Gas for call exact check\\n    IRMNRemote rmnRemote; // ───────╯ RMN Verification Contract\\n    address tokenAdminRegistry; // Token admin registry address\\n  }\\n\\n  /// @dev Per-chain source config (defining a lane from a Source Chain -\\u003e Dest OffRamp).\\n  struct SourceChainConfig {\\n    IRouter router; // ─╮ Local router to use for messages coming from this source chain.\\n    bool isEnabled; // ─╯ Flag whether the source chain is enabled or not.\\n    bytes onRamp; // OnRamp address on the source chain.\\n    address[] defaultCCVs; // Default CCVs to use for messages from this source chain.\\n    address[] laneMandatedCCVs; // Required CCVs to use for all messages from this source chain.\\n  }\\n\\n  /// @dev Same as SourceChainConfig but with source chain selector so that an array of these\\n  /// can be passed in the constructor and the applySourceChainConfigUpdates function.\\n  // solhint-disable-next-line gas-struct-packing\\n  struct SourceChainConfigArgs {\\n    IRouter router; // ────────────╮  Local router to use for messages coming from this source chain.\\n    uint64 sourceChainSelector; // │  Source chain selector of the config to update.\\n    bool isEnabled; // ────────────╯  Flag whether the source chain is enabled or not.\\n    bytes onRamp; // OnRamp address on the source chain.\\n    address[] defaultCCV; // Default CCV to use for messages from this source chain.\\n    address[] laneMandatedCCVs; // Required CCV to use for all messages from this source chain.\\n  }\\n\\n  // STATIC CONFIG\\n  string public constant override typeAndVersion = \\\"CCVAggregator 1.7.0-dev\\\";\\n  /// @dev Hash of encoded address(0) used for empty address checks.\\n  bytes32 internal constant EMPTY_ENCODED_ADDRESS_HASH = keccak256(abi.encode(address(0)));\\n  /// @dev ChainSelector of this chain.\\n  uint64 internal immutable i_chainSelector;\\n  /// @dev The RMN verification contract.\\n  IRMNRemote internal immutable i_rmnRemote;\\n  /// @dev The address of the token admin registry.\\n  address internal immutable i_tokenAdminRegistry;\\n  /// @dev The minimum amount of gas to perform the call with exact gas.\\n  /// We include this in the offRamp so that we can redeploy to adjust it should a hardfork change the gas costs of\\n  /// relevant opcodes in callWithExactGas.\\n  uint16 internal immutable i_gasForCallExactCheck;\\n\\n  // DYNAMIC CONFIG\\n  bool private s_reentrancyGuardEntered;\\n\\n  /// @notice Set of source chain selectors.\\n  EnumerableSet.UintSet internal s_sourceChainSelectors;\\n\\n  /// @notice SourceChainConfig per source chain selector.\\n  mapping(uint64 sourceChainSelector =\\u003e SourceChainConfig sourceChainConfig) private s_sourceChainConfigs;\\n\\n  // STATE\\n\\n  /// Message state is tracked to ensure message can only be executed successfully once.\\n  mapping(bytes32 execStateKey =\\u003e Internal.MessageExecutionState state) internal s_executionStates;\\n\\n  constructor(\\n    StaticConfig memory staticConfig\\n  ) {\\n    if (address(staticConfig.rmnRemote) == address(0) || staticConfig.tokenAdminRegistry == address(0)) {\\n      revert ZeroAddressNotAllowed();\\n    }\\n\\n    if (staticConfig.localChainSelector == 0) {\\n      revert ZeroChainSelectorNotAllowed();\\n    }\\n\\n    i_chainSelector = staticConfig.localChainSelector;\\n    i_rmnRemote = staticConfig.rmnRemote;\\n    i_tokenAdminRegistry = staticConfig.tokenAdminRegistry;\\n    i_gasForCallExactCheck = staticConfig.gasForCallExactCheck;\\n    emit StaticConfigSet(staticConfig);\\n  }\\n\\n  // ================================================================\\n  // │                           Execution                          │\\n  // ================================================================\\n\\n  /// @notice Returns the current execution state of a message.\\n  /// @return executionState The current execution state of the message.\\n  function getExecutionState(\\n    uint64 sourceChainSelector,\\n    uint64 sequenceNumber,\\n    bytes memory sender,\\n    address receiver\\n  ) public view returns (Internal.MessageExecutionState) {\\n    return s_executionStates[_calculateExecutionStateKey(sourceChainSelector, sequenceNumber, sender, receiver)];\\n  }\\n\\n  function _calculateExecutionStateKey(\\n    uint64 sourceChainSelector,\\n    uint64 sequenceNumber,\\n    bytes memory sender,\\n    address receiver\\n  ) internal pure returns (bytes32) {\\n    return keccak256(abi.encode(sourceChainSelector, sequenceNumber, sender, receiver));\\n  }\\n\\n  /// @notice Executes a message from a source chain.\\n  /// @param encodedMessage The message that is being executed, encoded as bytes.\\n  /// @param ccvs CCVs that attested to the message. Must match the CCVs specified by the receiver and token pool.\\n  /// @param ccvData CCV-specific data used to verify the message. Must be same length as ccvs array.\\n  function execute(bytes calldata encodedMessage, address[] calldata ccvs, bytes[] calldata ccvData) external {\\n    if (s_reentrancyGuardEntered) revert ReentrancyGuardReentrantCall();\\n    s_reentrancyGuardEntered = true;\\n\\n    MessageV1Codec.MessageV1 memory message =\\n      _beforeExecuteSingleMessage(MessageV1Codec._decodeMessageV1(encodedMessage));\\n    bytes32 messageId = keccak256(encodedMessage);\\n\\n    if (i_rmnRemote.isCursed(bytes16(uint128(message.sourceChainSelector)))) {\\n      revert CursedByRMN(message.sourceChainSelector);\\n    }\\n    if (!s_sourceChainConfigs[message.sourceChainSelector].isEnabled) {\\n      revert SourceChainNotEnabled(message.sourceChainSelector);\\n    }\\n    if (message.destChainSelector != i_chainSelector) {\\n      revert InvalidMessageDestChainSelector(message.destChainSelector);\\n    }\\n    if (ccvs.length != ccvData.length) {\\n      revert InvalidCCVDataLength(ccvs.length, ccvData.length);\\n    }\\n    if (message.receiver.length != 20) {\\n      revert Internal.InvalidEVMAddress(message.receiver);\\n    }\\n\\n    /////// Original state checks ///////\\n\\n    bytes32 executionStateKey = _calculateExecutionStateKey(\\n      message.sourceChainSelector, message.sequenceNumber, message.sender, address(bytes20(message.receiver))\\n    );\\n\\n    Internal.MessageExecutionState originalState = s_executionStates[executionStateKey];\\n\\n    // Two valid cases here, we either have never touched this message before, or we tried to execute and failed. This\\n    // check protects against reentry and re-execution because the other state is IN_PROGRESS which should not be\\n    // allowed to execute.\\n    if (\\n      !(\\n        originalState == Internal.MessageExecutionState.UNTOUCHED\\n          || originalState == Internal.MessageExecutionState.FAILURE\\n      )\\n    ) {\\n      revert SkippedAlreadyExecutedMessage(messageId, message.sourceChainSelector, message.sequenceNumber);\\n    }\\n\\n    /////// Execution ///////\\n\\n    s_executionStates[executionStateKey] = Internal.MessageExecutionState.IN_PROGRESS;\\n\\n    (bool success, bytes memory err) =\\n      _callWithGasBuffer(abi.encodeCall(this.executeSingleMessage, (message, messageId, ccvs, ccvData)));\\n    Internal.MessageExecutionState newState =\\n      success ? Internal.MessageExecutionState.SUCCESS : Internal.MessageExecutionState.FAILURE;\\n\\n    s_executionStates[executionStateKey] = newState;\\n\\n    emit ExecutionStateChanged(message.sourceChainSelector, message.sequenceNumber, messageId, newState, err);\\n    s_reentrancyGuardEntered = false;\\n  }\\n\\n  function _callWithGasBuffer(\\n    bytes memory payload\\n  ) internal returns (bool success, bytes memory retData) {\\n    // allocate retData memory ahead of time\\n    retData = new bytes(Internal.MAX_RET_BYTES);\\n    uint16 maxReturnBytes = Internal.MAX_RET_BYTES;\\n\\n    uint256 gasLeft = gasleft();\\n    if (gasLeft \\u003c= MAX_GAS_BUFFER_TO_UPDATE_STATE) {\\n      revert InsufficientGasToCompleteTx(bytes4(uint32(gasleft())));\\n    }\\n\\n    uint256 gasLimit = gasLeft - MAX_GAS_BUFFER_TO_UPDATE_STATE;\\n\\n    assembly {\\n      // call and return whether we succeeded. ignore return data\\n      // call(gas, addr, value, argsOffset, argsLength, retOffset, retLength)\\n      success := call(gasLimit, address(), 0, add(payload, 0x20), mload(payload), 0x0, 0x0)\\n\\n      // limit our copy to maxReturnBytes bytes\\n      let toCopy := returndatasize()\\n      if gt(toCopy, maxReturnBytes) { toCopy := maxReturnBytes }\\n      // Store the length of the copied bytes\\n      mstore(retData, toCopy)\\n      // copy the bytes from retData[0:_toCopy]\\n      returndatacopy(add(retData, 0x20), 0x0, toCopy)\\n    }\\n    return (success, retData);\\n  }\\n\\n  /// @notice Executes a single message.\\n  /// @param message The message that will be executed.\\n  /// @dev We make this external and callable by the contract itself, in order to try/catch\\n  /// its execution and enforce atomicity among successful message processing and token transfer.\\n  /// @dev We use ERC-165 to check for the ccipReceive interface to permit sending tokens to contracts, for example\\n  /// smart contract wallets, without an associated message.\\n  function executeSingleMessage(\\n    MessageV1Codec.MessageV1 calldata message,\\n    bytes32 messageId,\\n    address[] calldata ccvs,\\n    bytes[] calldata ccvData\\n  ) external {\\n    if (msg.sender != address(this)) revert CanOnlySelfCall();\\n\\n    /////// SECURITY CRITICAL CHECKS ///////\\n    address receiver = address(bytes20(message.receiver));\\n\\n    {\\n      (address[] memory ccvsToQuery, uint256[] memory ccvDataIndex) =\\n        _ensureCCVQuorumIsReached(message.sourceChainSelector, receiver, message.tokenTransfer, message.finality, ccvs);\\n\\n      for (uint256 i = 0; i \\u003c ccvsToQuery.length; ++i) {\\n        ICrossChainVerifierV1(ccvsToQuery[i]).verifyMessage({\\n          originalCaller: address(this),\\n          message: message,\\n          messageId: messageId,\\n          ccvData: ccvData[ccvDataIndex[i]]\\n        });\\n      }\\n    }\\n\\n    Client.EVMTokenAmount[] memory destTokenAmounts = new Client.EVMTokenAmount[](message.tokenTransfer.length);\\n    for (uint256 i = 0; i \\u003c message.tokenTransfer.length; ++i) {\\n      destTokenAmounts[i] =\\n        _releaseOrMintSingleToken(message.tokenTransfer[i], message.sender, receiver, message.sourceChainSelector);\\n    }\\n\\n    // TODO gaslimit\\n    uint256 gasLimit = 200000;\\n\\n    // There are three cases in which we skip calling the receiver:\\n    // 1. If the message data is empty AND the gas limit is 0.\\n    //          This indicates a message that only transfers tokens. It is valid to only send tokens to a contract\\n    //          that supports the IAny2EVMMessageReceiver interface, but without this first check we would call the\\n    //          receiver without any gas, which would revert the transaction.\\n    // 2. If the receiver is not a contract.\\n    // 3. If the receiver is a contract but it does not support the IAny2EVMMessageReceiver interface.\\n    //\\n    // The ordering of these checks is important, as the first check is the cheapest to execute.\\n    //\\n    // To prevent message delivery bypass issues, a modified version of the ERC165Checker is used\\n    // which checks for sufficient gas before making the external call.\\n    if (\\n      (message.data.length == 0 \\u0026\\u0026 gasLimit == 0) || receiver.code.length == 0\\n        || !receiver._supportsInterfaceReverting(type(IAny2EVMMessageReceiver).interfaceId)\\n    ) return;\\n\\n    (bool success, bytes memory returnData,) = s_sourceChainConfigs[message.sourceChainSelector].router.routeMessage(\\n      Client.Any2EVMMessage({\\n        messageId: messageId,\\n        sourceChainSelector: message.sourceChainSelector,\\n        sender: message.sender,\\n        data: message.data,\\n        destTokenAmounts: destTokenAmounts\\n      }),\\n      i_gasForCallExactCheck,\\n      gasleft() - i_gasForCallExactCheck - 10000,\\n      receiver\\n    );\\n\\n    // If CCIP receiver execution is not successful, revert the call including token transfers.\\n    if (!success) revert ReceiverError(returnData);\\n  }\\n\\n  // ================================================================\\n  // │                            CCVs                              │\\n  // ================================================================\\n\\n  /// @notice Returns the CCVs required to execute a message. There can be duplicates between the required and optional\\n  // CCVs, but all duplicated within the required CCVs are removed.\\n  /// @dev This function exists for offchain purposes, calling it onchain might not be gas efficient.\\n  function getCCVsForMessage(\\n    bytes calldata encodedMessage\\n  ) external view returns (address[] memory requiredCCVs, address[] memory optionalCCVs, uint8 threshold) {\\n    MessageV1Codec.MessageV1 memory message = MessageV1Codec._decodeMessageV1(encodedMessage);\\n\\n    return _getCCVsForMessage(\\n      message.sourceChainSelector, address(bytes20(message.receiver)), message.tokenTransfer, message.finality\\n    );\\n  }\\n\\n  /// @notice Returns the CCVs required by the receiver, pool and lane for a message. Duplicates are removed and\\n  /// defaults are added if necessary. This function handles all the logic of combining the various sources of CCVs.\\n  /// @param sourceChainSelector The source chain selector of the message.\\n  /// @param receiver The receiver of the message.\\n  /// @param tokenTransfer The tokens transferred in the message.\\n  /// @return requiredCCVs The deduplicated list of required CCVs for the message.\\n  /// @return optionalCCVs The list of optional CCVs for the message, with duplicates removed against required CCVs.\\n  /// @return optionalThreshold The threshold of optional CCVs, adjusted for any duplicates with required CCVs.\\n  /// @dev This function is quite complex as it needs to handle multiple sources of CCVs, deduplication and adding of\\n  /// defaults. The function looks quite gas intensive, but the expected lengths of the various CCV arrays are small, so\\n  /// the gas usage should be acceptable.\\n  /// @dev The offchain system relies on this functions logic as well, meaning both onchain and offchain have the same\\n  /// source of truth for which CCVs are needed for a message.\\n  function _getCCVsForMessage(\\n    uint64 sourceChainSelector,\\n    address receiver,\\n    MessageV1Codec.TokenTransferV1[] memory tokenTransfer,\\n    uint16 finality\\n  ) internal view returns (address[] memory requiredCCVs, address[] memory optionalCCVs, uint8 optionalThreshold) {\\n    address[] memory requiredPoolCCVs = new address[](0);\\n    if (tokenTransfer.length \\u003e 0) {\\n      if (tokenTransfer.length != 1) {\\n        revert InvalidNumberOfTokens(tokenTransfer.length);\\n      }\\n\\n      if (tokenTransfer[0].destTokenAddress.length != 20) {\\n        revert Internal.InvalidEVMAddress(tokenTransfer[0].destTokenAddress);\\n      }\\n      address localTokenAddress = address(bytes20(tokenTransfer[0].destTokenAddress));\\n\\n      // If the pool returns does not specify any CCVs, we fall back to the default CCVs. These will be deduplicated\\n      // in the ensureCCVQuorumIsReached function. This is to maintain the same pre-1.7.0 security level for pools\\n      // that do not support the V2 interface.\\n      requiredPoolCCVs = _getCCVsFromPool(\\n        localTokenAddress, sourceChainSelector, tokenTransfer[0].amount, finality, tokenTransfer[0].extraData\\n      );\\n    }\\n    address[] memory requiredReceiverCCV;\\n    (requiredReceiverCCV, optionalCCVs, optionalThreshold) = _getCCVsFromReceiver(sourceChainSelector, receiver);\\n    address[] memory laneMandatedCCVs = s_sourceChainConfigs[sourceChainSelector].laneMandatedCCVs;\\n    address[] memory defaultCCVs = s_sourceChainConfigs[sourceChainSelector].defaultCCVs;\\n\\n    // We allocate the memory for all possible CCVs upfront to avoid multiple allocations.\\n    address[] memory allRequiredCCVs =\\n      new address[](requiredReceiverCCV.length + requiredPoolCCVs.length + laneMandatedCCVs.length + defaultCCVs.length);\\n\\n    uint256 index = 0;\\n    for (uint256 i = 0; i \\u003c requiredReceiverCCV.length; ++i) {\\n      allRequiredCCVs[index++] = requiredReceiverCCV[i];\\n    }\\n\\n    for (uint256 i = 0; i \\u003c requiredPoolCCVs.length; ++i) {\\n      allRequiredCCVs[index++] = requiredPoolCCVs[i];\\n    }\\n\\n    for (uint256 i = 0; i \\u003c laneMandatedCCVs.length; ++i) {\\n      allRequiredCCVs[index++] = laneMandatedCCVs[i];\\n    }\\n\\n    // Add defaults if any address(0) was found.\\n    for (uint256 i = 0; i \\u003c index; ++i) {\\n      if (allRequiredCCVs[i] == address(0)) {\\n        for (uint256 j = 0; j \\u003c defaultCCVs.length; ++j) {\\n          allRequiredCCVs[index++] = defaultCCVs[j];\\n        }\\n        break;\\n      }\\n    }\\n\\n    // Remove duplicates and address(0) entries.\\n    uint256 writeIndex = 0;\\n    for (uint256 readIndex = 0; readIndex \\u003c index; ++readIndex) {\\n      address currentCCV = allRequiredCCVs[readIndex];\\n\\n      // Skip address(0) entries, effectively removing them.\\n      if (currentCCV == address(0)) {\\n        continue;\\n      }\\n\\n      // Check if this address already exists in the deduplicated portion.\\n      bool isDuplicate = false;\\n      for (uint256 j = 0; j \\u003c writeIndex; ++j) {\\n        if (allRequiredCCVs[j] == currentCCV) {\\n          isDuplicate = true;\\n          break;\\n        }\\n      }\\n\\n      // If not a duplicate, add it to the deduplicated portion.\\n      if (!isDuplicate) {\\n        allRequiredCCVs[writeIndex++] = currentCCV;\\n      }\\n    }\\n\\n    assembly {\\n      // set the length of the array to the new index which we used to track the number of unique CCVs.\\n      mstore(allRequiredCCVs, writeIndex)\\n    }\\n\\n    // Remove duplicates between required and optional CCVs.\\n    uint256 newOptionalLength = optionalCCVs.length;\\n    for (uint256 i = 0; i \\u003c newOptionalLength; ++i) {\\n      for (uint256 j = 0; j \\u003c allRequiredCCVs.length;) {\\n        if (optionalCCVs[i] == allRequiredCCVs[j]) {\\n          // Remove the duplicate by replacing it with the last element and reducing the length of the array.\\n          optionalCCVs[i] = optionalCCVs[--newOptionalLength];\\n\\n          // Since we moved one CCV from optional to required, we can reduce the threshold by one, but not below zero.\\n          if (optionalThreshold \\u003e 0) {\\n            --optionalThreshold;\\n          }\\n        } else {\\n          ++j;\\n        }\\n      }\\n    }\\n\\n    assembly {\\n      // set the length of the array to the new index which we used to track the number of unique CCVs.\\n      mstore(optionalCCVs, newOptionalLength)\\n    }\\n\\n    // Return the deduplicated required CCVs, the unchanged optional CCVs and the optional threshold.\\n    return (allRequiredCCVs, optionalCCVs, optionalThreshold);\\n  }\\n\\n  /// @notice Ensures that the provided CCVs meet the quorum required by the receiver, pool and lane.\\n  /// @param sourceChainSelector The source chain selector of the message.\\n  /// @param receiver The receiver of the message.\\n  /// @param tokenTransfer The tokens transferred in the message.\\n  /// @param ccvs The CCVs that provided data for the message.\\n  /// @param finality The finality requirement of the message.\\n  /// @return ccvsToQuery The CCVs that need to be queried to verify the message.\\n  /// @return dataIndexes The indexes of the CCVs in the provided ccvs array that correspond to ccvsToQuery.\\n  function _ensureCCVQuorumIsReached(\\n    uint64 sourceChainSelector,\\n    address receiver,\\n    MessageV1Codec.TokenTransferV1[] memory tokenTransfer,\\n    uint16 finality,\\n    address[] calldata ccvs\\n  ) internal view returns (address[] memory ccvsToQuery, uint256[] memory dataIndexes) {\\n    (address[] memory requiredCCV, address[] memory optionalCCVs, uint8 optionalThreshold) =\\n      _getCCVsForMessage(sourceChainSelector, receiver, tokenTransfer, finality);\\n\\n    ccvsToQuery = new address[](ccvs.length);\\n    dataIndexes = new uint256[](ccvs.length);\\n    uint256 numCCVsToQuery = 0;\\n\\n    for (uint256 i = 0; i \\u003c requiredCCV.length; ++i) {\\n      bool found = false;\\n      for (uint256 j = 0; j \\u003c ccvs.length; ++j) {\\n        if (ccvs[j] == requiredCCV[i]) {\\n          found = true;\\n          ccvsToQuery[numCCVsToQuery] = ccvs[j];\\n          dataIndexes[numCCVsToQuery++] = j;\\n          break;\\n        }\\n      }\\n      if (!found) {\\n        revert RequiredCCVMissing(requiredCCV[i]);\\n      }\\n    }\\n\\n    uint256 optionalCCVsToFind = optionalThreshold;\\n    for (uint256 i = 0; i \\u003c optionalCCVs.length; ++i) {\\n      for (uint256 j = 0; j \\u003c ccvs.length \\u0026\\u0026 optionalCCVsToFind \\u003e 0; ++j) {\\n        if (ccvs[j] == optionalCCVs[i]) {\\n          optionalCCVsToFind--;\\n\\n          ccvsToQuery[numCCVsToQuery] = ccvs[j];\\n          dataIndexes[numCCVsToQuery++] = j;\\n          break;\\n        }\\n      }\\n    }\\n\\n    if (optionalCCVsToFind \\u003e 0) {\\n      revert OptionalCCVQuorumNotReached(optionalThreshold, optionalThreshold - optionalCCVsToFind);\\n    }\\n\\n    if (numCCVsToQuery != ccvsToQuery.length) {\\n      // Resize the array to the actual number of CCVs found.\\n      assembly {\\n        mstore(ccvsToQuery, numCCVsToQuery)\\n        mstore(dataIndexes, numCCVsToQuery)\\n      }\\n    }\\n    return (ccvsToQuery, dataIndexes);\\n  }\\n\\n  /// @notice Retrieves the required and optional CCVs from a receiver contract. If the receiver does not specify any\\n  /// CCVs, we fall back to the default CCVs.\\n  /// @dev This function reverts if the receiver returns duplicates in either the required or optional CCVs.\\n  /// @param sourceChainSelector The source chain selector.\\n  /// @param receiver The receiver address.\\n  /// @return requiredCCV The required CCVs.\\n  /// @return optionalCCVs The optional CCVs.\\n  /// @return optionalThreshold The threshold of optional CCVs.\\n  function _getCCVsFromReceiver(\\n    uint64 sourceChainSelector,\\n    address receiver\\n  ) internal view returns (address[] memory requiredCCV, address[] memory optionalCCVs, uint8 optionalThreshold) {\\n    SourceChainConfig memory sourceConfig = s_sourceChainConfigs[sourceChainSelector];\\n\\n    // If the receiver is a contract\\n    if (receiver.code.length != 0) {\\n      // And the contract implements the IAny2EVMMessageReceiverV2 interface.\\n      if (receiver._supportsInterfaceReverting(type(IAny2EVMMessageReceiverV2).interfaceId)) {\\n        (requiredCCV, optionalCCVs, optionalThreshold) =\\n          IAny2EVMMessageReceiverV2(receiver).getCCVs(sourceChainSelector);\\n\\n        CCVConfigValidation._assertNoDuplicates(requiredCCV);\\n        CCVConfigValidation._assertNoDuplicates(optionalCCVs);\\n\\n        // If the user specified empty required and optional CCVs, we fall back to the default CCVs.\\n        // If they did specify something, we use what they specified.\\n        if (requiredCCV.length != 0 || optionalThreshold != 0) {\\n          return (requiredCCV, optionalCCVs, optionalThreshold);\\n        }\\n      }\\n    }\\n    return (sourceConfig.defaultCCVs, new address[](0), 0);\\n  }\\n\\n  /// @notice Retrieves the required CCVs from a pool. If the pool does not specify any CCVs, we fall back to the\\n  /// default CCVs.\\n  /// @dev The params passed into getRequiredCCVs could influence the CCVs returned.\\n  /// @param localToken The local token address.\\n  /// @param sourceChainSelector The source chain selector.\\n  /// @param amount The amount of the token to be released/minted.\\n  /// @param extraData The extra data for the pool.\\n  /// @return requiredCCV The required CCVs.\\n  function _getCCVsFromPool(\\n    address localToken,\\n    uint64 sourceChainSelector,\\n    uint256 amount,\\n    uint16 finality,\\n    bytes memory extraData\\n  ) internal view returns (address[] memory requiredCCV) {\\n    address pool = ITokenAdminRegistry(i_tokenAdminRegistry).getPool(localToken);\\n\\n    if (pool._supportsInterfaceReverting(type(IPoolV2).interfaceId)) {\\n      requiredCCV = IPoolV2(pool).getRequiredInboundCCVs(localToken, sourceChainSelector, amount, finality, extraData);\\n      CCVConfigValidation._assertNoDuplicates(requiredCCV);\\n    }\\n\\n    // If the pool does not specify any CCVs, or the pool does not support the V2 interface, we fall back to the\\n    // default CCVs. If this wasn't done, any pool not specifying CCVs would allow any arbitrary CCV to mint infinite\\n    // tokens by fabricating messages. Since CCVs are permissionless, this would mean anyone would be able to mint.\\n    if (requiredCCV.length == 0) {\\n      requiredCCV = s_sourceChainConfigs[sourceChainSelector].defaultCCVs;\\n    }\\n    return requiredCCV;\\n  }\\n\\n  // ================================================================\\n  // │                      Tokens and pools                        │\\n  // ================================================================\\n\\n  /// @notice Uses a pool to release or mint a token to a receiver address, with balance checks before and after the\\n  /// transfer. This is done to ensure the exact number of tokens the pool claims to release are actually transferred.\\n  /// @dev The local token address is validated through the TokenAdminRegistry. If, due to some misconfiguration, the\\n  /// token is unknown to the registry, the offRamp will revert. The tx, and the tokens, can be retrieved by registering\\n  /// the token on this chain, and re-trying the msg.\\n  /// @param sourceTokenAmount Amount and source data of the token to be released/minted.\\n  /// @param originalSender The message sender on the source chain.\\n  /// @param receiver The address that will receive the tokens.\\n  /// @param sourceChainSelector The remote source chain selector\\n  /// @return destTokenAmount local token address with amount.\\n  function _releaseOrMintSingleToken(\\n    MessageV1Codec.TokenTransferV1 memory sourceTokenAmount,\\n    bytes memory originalSender,\\n    address receiver,\\n    uint64 sourceChainSelector\\n  ) internal returns (Client.EVMTokenAmount memory destTokenAmount) {\\n    Internal._validateEVMAddress(sourceTokenAmount.destTokenAddress);\\n\\n    address localToken = abi.decode(sourceTokenAmount.destTokenAddress, (address));\\n    // We check with the token admin registry if the token has a pool on this chain.\\n    address localPoolAddress = ITokenAdminRegistry(i_tokenAdminRegistry).getPool(localToken);\\n    // This will call the supportsInterface through the ERC165Checker, and not directly on the pool address.\\n    // This is done to prevent a pool from reverting the entire transaction if it doesn't support the interface.\\n    // The call gets a max or 30k gas per instance, of which there are three. This means offchain gas estimations should\\n    // account for 90k gas overhead due to the interface check.\\n    if (localPoolAddress == address(0)) {\\n      revert NotACompatiblePool(localPoolAddress);\\n    }\\n\\n    // Check V2 first, as it is the most recent version of the pool interface.\\n    if (localPoolAddress._supportsInterfaceReverting(Pool.CCIP_POOL_V2)) {\\n      // Revert for now\\n      // TODO write IPoolV2\\n      revert NotACompatiblePool(localPoolAddress);\\n    }\\n\\n    if (!localPoolAddress._supportsInterfaceReverting(Pool.CCIP_POOL_V1)) {\\n      // If the pool does not support the v1 interface, we revert.\\n      revert NotACompatiblePool(localPoolAddress);\\n    }\\n    // We retrieve the local token balance of the receiver before the pool call.\\n    uint256 balancePre = _getBalanceOfReceiver(receiver, localToken);\\n\\n    Pool.ReleaseOrMintOutV1 memory returnData;\\n    try IPoolV1(localPoolAddress).releaseOrMint(\\n      Pool.ReleaseOrMintInV1({\\n        originalSender: originalSender,\\n        receiver: receiver,\\n        sourceDenominatedAmount: sourceTokenAmount.amount,\\n        localToken: localToken,\\n        remoteChainSelector: sourceChainSelector,\\n        sourcePoolAddress: sourceTokenAmount.sourcePoolAddress,\\n        sourcePoolData: sourceTokenAmount.extraData,\\n        // All use cases that use offchain token data in IPoolV1 have to upgrade to the modular security interface.\\n        offchainTokenData: \\\"\\\"\\n      })\\n    ) returns (Pool.ReleaseOrMintOutV1 memory result) {\\n      returnData = result;\\n    } catch (bytes memory err) {\\n      revert TokenHandlingError(localToken, err);\\n    }\\n\\n    // We don't need to do balance checks if the pool is the receiver, as they would always fail in the case\\n    // of a lockRelease pool.\\n    if (receiver != localPoolAddress) {\\n      uint256 balancePost = _getBalanceOfReceiver(receiver, localToken);\\n\\n      // First we check if the subtraction would result in an underflow to ensure we revert with a clear error.\\n      if (balancePost \\u003c balancePre || balancePost - balancePre != returnData.destinationAmount) {\\n        revert ReleaseOrMintBalanceMismatch(returnData.destinationAmount, balancePre, balancePost);\\n      }\\n    }\\n\\n    return Client.EVMTokenAmount({token: localToken, amount: returnData.destinationAmount});\\n  }\\n\\n  /// @notice Retrieves the balance of a receiver address for a given token.\\n  /// @param receiver The address to check the balance of.\\n  /// @param token The token address.\\n  /// @return balance The balance of the receiver.\\n  function _getBalanceOfReceiver(address receiver, address token) internal view returns (uint256) {\\n    try IERC20(token).balanceOf(receiver) returns (uint256 balance_) {\\n      // If the call succeeds, we return the balance and the gas left.\\n      return (balance_);\\n    } catch (bytes memory err) {\\n      // If the call fails, we revert with a known error.\\n      revert TokenHandlingError(token, err);\\n    }\\n  }\\n\\n  // ================================================================\\n  // │                           Config                             │\\n  // ================================================================\\n\\n  /// @notice Returns the static config.\\n  /// @dev This function will always return the same struct as the contents is static and can never change.\\n  /// @return staticConfig The static config.\\n  function getStaticConfig() external view returns (StaticConfig memory) {\\n    return StaticConfig({\\n      localChainSelector: i_chainSelector,\\n      gasForCallExactCheck: i_gasForCallExactCheck,\\n      rmnRemote: i_rmnRemote,\\n      tokenAdminRegistry: i_tokenAdminRegistry\\n    });\\n  }\\n\\n  /// @notice Returns the source chain config for the provided source chain selector.\\n  /// @param sourceChainSelector chain to retrieve configuration for.\\n  /// @return sourceChainConfig The config for the source chain.\\n  function getSourceChainConfig(\\n    uint64 sourceChainSelector\\n  ) external view returns (SourceChainConfig memory) {\\n    return s_sourceChainConfigs[sourceChainSelector];\\n  }\\n\\n  /// @notice Returns all source chain configs.\\n  /// @return sourceChainConfigs The source chain configs corresponding to all the supported chain selectors.\\n  function getAllSourceChainConfigs() external view returns (uint64[] memory, SourceChainConfig[] memory) {\\n    SourceChainConfig[] memory sourceChainConfigs = new SourceChainConfig[](s_sourceChainSelectors.length());\\n    uint64[] memory sourceChainSelectors = new uint64[](s_sourceChainSelectors.length());\\n    for (uint256 i = 0; i \\u003c s_sourceChainSelectors.length(); ++i) {\\n      sourceChainSelectors[i] = uint64(s_sourceChainSelectors.at(i));\\n      sourceChainConfigs[i] = s_sourceChainConfigs[sourceChainSelectors[i]];\\n    }\\n    return (sourceChainSelectors, sourceChainConfigs);\\n  }\\n\\n  /// @notice Updates source configs.\\n  /// @param sourceChainConfigUpdates Source chain configs.\\n  function applySourceChainConfigUpdates(\\n    SourceChainConfigArgs[] calldata sourceChainConfigUpdates\\n  ) external onlyOwner {\\n    for (uint256 i = 0; i \\u003c sourceChainConfigUpdates.length; ++i) {\\n      SourceChainConfigArgs memory configUpdate = sourceChainConfigUpdates[i];\\n\\n      if (configUpdate.sourceChainSelector == 0) {\\n        revert ZeroChainSelectorNotAllowed();\\n      }\\n      if (address(configUpdate.router) == address(0) || configUpdate.defaultCCV.length == 0) {\\n        revert ZeroAddressNotAllowed();\\n      }\\n\\n      for (uint256 j = 0; j \\u003c configUpdate.defaultCCV.length; ++j) {\\n        if (configUpdate.defaultCCV[j] == address(0)) {\\n          revert ZeroAddressNotAllowed();\\n        }\\n      }\\n      for (uint256 j = 0; j \\u003c configUpdate.laneMandatedCCVs.length; ++j) {\\n        if (configUpdate.laneMandatedCCVs[j] == address(0)) {\\n          revert ZeroAddressNotAllowed();\\n        }\\n      }\\n\\n      // OnRamp can never be zero.\\n      if (configUpdate.onRamp.length == 0 || keccak256(configUpdate.onRamp) == EMPTY_ENCODED_ADDRESS_HASH) {\\n        revert ZeroAddressNotAllowed();\\n      }\\n\\n      CCVConfigValidation._validateDefaultAndMandatedCCVs(configUpdate.defaultCCV, configUpdate.laneMandatedCCVs);\\n\\n      // TODO check replay protection if onRamp changes\\n      SourceChainConfig storage currentConfig = s_sourceChainConfigs[configUpdate.sourceChainSelector];\\n\\n      currentConfig.isEnabled = configUpdate.isEnabled;\\n      currentConfig.router = configUpdate.router;\\n      currentConfig.onRamp = configUpdate.onRamp;\\n      currentConfig.defaultCCVs = configUpdate.defaultCCV;\\n      currentConfig.laneMandatedCCVs = configUpdate.laneMandatedCCVs;\\n\\n      // We don't need to check the return value, as inserting the item twice has no effect.\\n      s_sourceChainSelectors.add(configUpdate.sourceChainSelector);\\n\\n      emit SourceChainConfigSet(configUpdate.sourceChainSelector, currentConfig);\\n    }\\n  }\\n\\n  /// @notice hook for applying custom logic to the input message before executeSingleMessage()\\n  /// @param message initial message\\n  /// @return transformedMessage modified message\\n  function _beforeExecuteSingleMessage(\\n    MessageV1Codec.MessageV1 memory message\\n  ) internal virtual returns (MessageV1Codec.MessageV1 memory transformedMessage) {\\n    return message;\\n  }\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2Step.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {IOwnable} from \\\"../interfaces/IOwnable.sol\\\";\\n\\n/// @notice A minimal contract that implements 2-step ownership transfer and nothing more. It's made to be minimal\\n/// to reduce the impact of the bytecode size on any contract that inherits from it.\\ncontract Ownable2Step is IOwnable {\\n  /// @notice The pending owner is the address to which ownership may be transferred.\\n  address private s_pendingOwner;\\n  /// @notice The owner is the current owner of the contract.\\n  /// @dev The owner is the second storage variable so any implementing contract could pack other state with it\\n  /// instead of the much less used s_pendingOwner.\\n  address private s_owner;\\n\\n  error OwnerCannotBeZero();\\n  error MustBeProposedOwner();\\n  error CannotTransferToSelf();\\n  error OnlyCallableByOwner();\\n\\n  event OwnershipTransferRequested(address indexed from, address indexed to);\\n  event OwnershipTransferred(address indexed from, address indexed to);\\n\\n  constructor(address newOwner, address pendingOwner) {\\n    if (newOwner == address(0)) {\\n      revert OwnerCannotBeZero();\\n    }\\n\\n    s_owner = newOwner;\\n    if (pendingOwner != address(0)) {\\n      _transferOwnership(pendingOwner);\\n    }\\n  }\\n\\n  /// @notice Get the current owner\\n  function owner() public view override returns (address) {\\n    return s_owner;\\n  }\\n\\n  /// @notice Allows an owner to begin transferring ownership to a new address. The new owner needs to call\\n  /// `acceptOwnership` to accept the transfer before any permissions are changed.\\n  /// @param to The address to which ownership will be transferred.\\n  function transferOwnership(\\n    address to\\n  ) public override onlyOwner {\\n    _transferOwnership(to);\\n  }\\n\\n  /// @notice validate, transfer ownership, and emit relevant events\\n  /// @param to The address to which ownership will be transferred.\\n  function _transferOwnership(\\n    address to\\n  ) private {\\n    if (to == msg.sender) {\\n      revert CannotTransferToSelf();\\n    }\\n\\n    s_pendingOwner = to;\\n\\n    emit OwnershipTransferRequested(s_owner, to);\\n  }\\n\\n  /// @notice Allows an ownership transfer to be completed by the recipient.\\n  function acceptOwnership() external override {\\n    if (msg.sender != s_pendingOwner) {\\n      revert MustBeProposedOwner();\\n    }\\n\\n    address oldOwner = s_owner;\\n    s_owner = msg.sender;\\n    s_pendingOwner = address(0);\\n\\n    emit OwnershipTransferred(oldOwner, msg.sender);\\n  }\\n\\n  /// @notice validate access\\n  function _validateOwnership() internal view {\\n    if (msg.sender != s_owner) {\\n      revert OnlyCallableByOwner();\\n    }\\n  }\\n\\n  /// @notice Reverts if called by anyone other than the contract owner.\\n  modifier onlyOwner() {\\n    _validateOwnership();\\n    _;\\n  }\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2StepMsgSender.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {Ownable2Step} from \\\"./Ownable2Step.sol\\\";\\n\\n/// @notice Sets the msg.sender to be the owner of the contract and does not set a pending owner.\\ncontract Ownable2StepMsgSender is Ownable2Step {\\n  constructor() Ownable2Step(msg.sender, address(0)) {}\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/IOwnable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IOwnable {\\n  function owner() external returns (address);\\n\\n  function transferOwnership(\\n    address recipient\\n  ) external;\\n\\n  function acceptOwnership() external;\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/ITypeAndVersion.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ITypeAndVersion {\\n  function typeAndVersion() external pure returns (string memory);\\n}\\n\"},\"node_modules/@openzeppelin/contracts-4.8.3/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.0.2/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.0.2/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.0.2/utils/structs/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position is the index of the value in the `values` array plus 1.\\n        // Position 0 is used to mean a value is not in the set.\\n        mapping(bytes32 value =\\u003e uint256) _positions;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._positions[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We cache the value's position to prevent multiple reads from the same storage slot\\n        uint256 position = set._positions[value];\\n\\n        if (position != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 valueIndex = position - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (valueIndex != lastIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the lastValue to the index where the value to delete is\\n                set._values[valueIndex] = lastValue;\\n                // Update the tracked position of the lastValue (that was just moved)\\n                set._positions[lastValue] = position;\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the tracked position for the deleted slot\\n            delete set._positions[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._positions[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"}}}"
