// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.


package multi_ocr3_helper

var SolidityStandardInput = "{\"version\":\"0.8.26\",\"language\":\"Solidity\",\"settings\":{\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"appendCBOR\":true,\"bytecodeHash\":\"none\",\"useLiteralContent\":false},\"optimizer\":{\"enabled\":true,\"runs\":80000},\"outputSelection\":{\"contracts/libraries/Internal.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/libraries/MerkleMultiProof.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/ocr/MultiOCR3Base.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/test/helpers/MultiOCR3Helper.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2Step.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2StepMsgSender.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/IOwnable.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/ITypeAndVersion.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]}},\"remappings\":[\"forge-std/=node_modules/@chainlink/contracts/src/v0.8/vendor/forge-std/src/\",\"@chainlink/contracts/=node_modules/@chainlink/contracts/\"],\"viaIR\":true},\"sources\":{\"contracts/libraries/Internal.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {MerkleMultiProof} from \\\"../libraries/MerkleMultiProof.sol\\\";\\n\\n/// @notice Library for CCIP internal definitions common to multiple contracts.\\n/// @dev The following is a non-exhaustive list of \\\"known issues\\\" for CCIP:\\n/// - We could implement yield claiming for Blast. This is not worth the custom code path on non-blast chains.\\n/// - uint32 is used for timestamps, which will overflow in 2106. This is not a concern for the current use case, as we\\n/// expect to have migrated to a new version by then.\\nlibrary Internal {\\n  error InvalidEVMAddress(bytes encodedAddress);\\n  error Invalid32ByteAddress(bytes encodedAddress);\\n\\n  /// @dev We limit return data to a selector plus 4 words. This is to avoid malicious contracts from returning\\n  /// large amounts of data and causing repeated out-of-gas scenarios.\\n  uint16 internal constant MAX_RET_BYTES = 4 + 4 * 32;\\n  /// @dev The expected number of bytes returned by the balanceOf function.\\n  uint256 internal constant MAX_BALANCE_OF_RET_BYTES = 32;\\n\\n  /// @dev The address used to send calls for gas estimation.\\n  /// You only need to use this address if the minimum gas limit specified by the user is not actually enough to execute the\\n  /// given message and you're attempting to estimate the actual necessary gas limit\\n  address public constant GAS_ESTIMATION_SENDER = address(0xC11C11C11C11C11C11C11C11C11C11C11C11C1);\\n\\n  /// @notice A collection of token price and gas price updates.\\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\\n  struct PriceUpdates {\\n    TokenPriceUpdate[] tokenPriceUpdates;\\n    GasPriceUpdate[] gasPriceUpdates;\\n  }\\n\\n  /// @notice Token price in USD.\\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\\n  struct TokenPriceUpdate {\\n    address sourceToken; // Source token.\\n    uint224 usdPerToken; // 1e18 USD per 1e18 of the smallest token denomination.\\n  }\\n\\n  /// @notice Gas price for a given chain in USD, its value may contain tightly packed fields.\\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\\n  struct GasPriceUpdate {\\n    uint64 destChainSelector; // Destination chain selector.\\n    uint224 usdPerUnitGas; // 1e18 USD per smallest unit (e.g. wei) of destination chain gas.\\n  }\\n\\n  /// @notice A timestamped uint224 value that can contain several tightly packed fields.\\n  struct TimestampedPackedUint224 {\\n    uint224 value; // ────╮ Value in uint224, packed.\\n    uint32 timestamp; // ─╯ Timestamp of the most recent price update.\\n  }\\n\\n  /// @dev Gas price is stored in 112-bit unsigned int. uint224 can pack 2 prices.\\n  /// When packing L1 and L2 gas prices, L1 gas price is left-shifted to the higher-order bits.\\n  /// Using uint8 type, which cannot be higher than other bit shift operands, to avoid shift operand type warning.\\n  uint8 public constant GAS_PRICE_BITS = 112;\\n\\n  struct SourceTokenData {\\n    // The source pool address, abi encoded. This value is trusted as it was obtained through the onRamp. It can be\\n    // relied upon by the destination pool to validate the source pool.\\n    bytes sourcePoolAddress;\\n    // The address of the destination token, abi encoded in the case of EVM chains.\\n    // This value is UNTRUSTED as any pool owner can return whatever value they want.\\n    bytes destTokenAddress;\\n    // Optional pool data to be transferred to the destination chain. Be default this is capped at\\n    // CCIP_LOCK_OR_BURN_V1_RET_BYTES bytes. If more data is required, the TokenTransferFeeConfig.destBytesOverhead\\n    // has to be set for the specific token.\\n    bytes extraData;\\n    uint32 destGasAmount; // The amount of gas available for the releaseOrMint and balanceOf calls on the offRamp\\n  }\\n\\n  /// @notice Report that is submitted by the execution DON at the execution phase, including chain selector data.\\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\\n  struct ExecutionReport {\\n    uint64 sourceChainSelector; // Source chain selector for which the report is submitted.\\n    Any2EVMRampMessage[] messages;\\n    // Contains a bytes array for each message, each inner bytes array contains bytes per transferred token.\\n    bytes[][] offchainTokenData;\\n    bytes32[] proofs;\\n    uint256 proofFlagBits;\\n  }\\n\\n  /// @dev Any2EVMRampMessage struct has 10 fields, including 3 variable unnested arrays, sender, data and tokenAmounts.\\n  /// Each variable array takes 1 more slot to store its length.\\n  /// When abi encoded, excluding array contents, Any2EVMMessage takes up a fixed number of 13 slots, 32 bytes each.\\n  /// Assume 1 slot for sender\\n  /// For structs that contain arrays, 1 more slot is added to the front, reaching a total of 14.\\n  /// The fixed bytes does not cover struct data (this is represented by MESSAGE_FIXED_BYTES_PER_TOKEN)\\n  uint256 public constant MESSAGE_FIXED_BYTES = 32 * 15;\\n\\n  /// @dev Any2EVMTokensTransfer struct bytes length\\n  /// 0x20\\n  /// sourcePoolAddress_offset\\n  /// destTokenAddress\\n  /// destGasAmount\\n  /// extraData_offset\\n  /// amount\\n  /// sourcePoolAddress_length\\n  /// sourcePoolAddress_content // assume 1 slot\\n  /// extraData_length // contents billed separately\\n  uint256 public constant MESSAGE_FIXED_BYTES_PER_TOKEN = 32 * (4 + (3 + 2));\\n\\n  bytes32 internal constant ANY_2_EVM_MESSAGE_HASH = keccak256(\\\"Any2EVMMessageHashV1\\\");\\n  bytes32 internal constant EVM_2_ANY_MESSAGE_HASH = keccak256(\\\"EVM2AnyMessageHashV1\\\");\\n\\n  /// @dev Used to hash messages for multi-lane family-agnostic OffRamps.\\n  /// OnRamp hash(EVM2AnyMessage) != Any2EVMRampMessage.messageId.\\n  /// OnRamp hash(EVM2AnyMessage) != OffRamp hash(Any2EVMRampMessage).\\n  /// @param original OffRamp message to hash.\\n  /// @param metadataHash Hash preimage to ensure global uniqueness.\\n  /// @return hashedMessage hashed message as a keccak256.\\n  function _hash(Any2EVMRampMessage memory original, bytes32 metadataHash) internal pure returns (bytes32) {\\n    // Fixed-size message fields are included in nested hash to reduce stack pressure.\\n    // This hashing scheme is also used by RMN. If changing it, please notify the RMN maintainers.\\n    return keccak256(\\n      abi.encode(\\n        MerkleMultiProof.LEAF_DOMAIN_SEPARATOR,\\n        metadataHash,\\n        keccak256(\\n          abi.encode(\\n            original.header.messageId,\\n            original.receiver,\\n            original.header.sequenceNumber,\\n            original.gasLimit,\\n            original.header.nonce\\n          )\\n        ),\\n        keccak256(original.sender),\\n        keccak256(original.data),\\n        keccak256(abi.encode(original.tokenAmounts))\\n      )\\n    );\\n  }\\n\\n  function _hash(EVM2AnyRampMessage memory original, bytes32 metadataHash) internal pure returns (bytes32) {\\n    // Fixed-size message fields are included in nested hash to reduce stack pressure.\\n    // This hashing scheme is also used by RMN. If changing it, please notify the RMN maintainers.\\n    return keccak256(\\n      abi.encode(\\n        MerkleMultiProof.LEAF_DOMAIN_SEPARATOR,\\n        metadataHash,\\n        keccak256(\\n          abi.encode(\\n            original.sender,\\n            original.header.sequenceNumber,\\n            original.header.nonce,\\n            original.feeToken,\\n            original.feeTokenAmount\\n          )\\n        ),\\n        keccak256(original.receiver),\\n        keccak256(original.data),\\n        keccak256(abi.encode(original.tokenAmounts)),\\n        keccak256(original.extraArgs)\\n      )\\n    );\\n  }\\n\\n  /// @dev We disallow the first 1024 addresses to avoid calling into a range known for hosting precompiles. Calling\\n  /// into precompiles probably won't cause any issues, but to be safe we can disallow this range. It is extremely\\n  /// unlikely that anyone would ever be able to generate an address in this range. There is no official range of\\n  /// precompiles, but EIP-7587 proposes to reserve the range 0x100 to 0x1ff. Our range is more conservative, even\\n  /// though it might not be exhaustive for all chains, which is OK. We also disallow the zero address, which is a\\n  /// common practice.\\n  uint256 public constant EVM_PRECOMPILE_SPACE = 1024;\\n\\n  // According to the Aptos docs, the first 0xa addresses are reserved for precompiles.\\n  // https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-framework/doc/account.md#function-create_framework_reserved_account-1\\n  uint256 public constant APTOS_PRECOMPILE_SPACE = 0x0b;\\n\\n  /// @notice This methods provides validation for parsing abi encoded addresses by ensuring the address is within the\\n  /// EVM address space. If it isn't it will revert with an InvalidEVMAddress error, which we can catch and handle\\n  /// more gracefully than a revert from abi.decode.\\n  function _validateEVMAddress(\\n    bytes memory encodedAddress\\n  ) internal pure {\\n    if (encodedAddress.length != 32) revert InvalidEVMAddress(encodedAddress);\\n    uint256 encodedAddressUint = abi.decode(encodedAddress, (uint256));\\n    if (encodedAddressUint \\u003e type(uint160).max || encodedAddressUint \\u003c EVM_PRECOMPILE_SPACE) {\\n      revert InvalidEVMAddress(encodedAddress);\\n    }\\n  }\\n\\n  /// @notice This methods provides validation for parsing abi encoded addresses by ensuring the address is within the\\n  /// bounds of [minValue, uint256.max]. If it isn't it will revert with an Invalid32ByteAddress error.\\n  function _validate32ByteAddress(bytes memory encodedAddress, uint256 minValue) internal pure {\\n    if (encodedAddress.length != 32) revert Invalid32ByteAddress(encodedAddress);\\n    if (minValue \\u003e 0) {\\n      if (abi.decode(encodedAddress, (uint256)) \\u003c minValue) {\\n        revert Invalid32ByteAddress(encodedAddress);\\n      }\\n    }\\n  }\\n\\n  /// @notice Enum listing the possible message execution states within the offRamp contract.\\n  /// UNTOUCHED never executed.\\n  /// IN_PROGRESS currently being executed, used a replay protection.\\n  /// SUCCESS successfully executed. End state.\\n  /// FAILURE unsuccessfully executed, manual execution is now enabled.\\n  /// @dev RMN depends on this enum, if changing, please notify the RMN maintainers.\\n  enum MessageExecutionState {\\n    UNTOUCHED,\\n    IN_PROGRESS,\\n    SUCCESS,\\n    FAILURE\\n  }\\n\\n  /// @notice CCIP OCR plugin type, used to separate execution \\u0026 commit transmissions and configs.\\n  enum OCRPluginType {\\n    Commit,\\n    Execution\\n  }\\n\\n  /// @notice Family-agnostic header for OnRamp \\u0026 OffRamp messages.\\n  /// The messageId is not expected to match hash(message), since it may originate from another ramp family.\\n  struct RampMessageHeader {\\n    bytes32 messageId; // Unique identifier for the message, generated with the source chain's encoding scheme (i.e. not necessarily abi.encoded).\\n    uint64 sourceChainSelector; // ─╮ the chain selector of the source chain, note: not chainId.\\n    uint64 destChainSelector; //    │ the chain selector of the destination chain, note: not chainId.\\n    uint64 sequenceNumber; //       │ sequence number, not unique across lanes.\\n    uint64 nonce; // ───────────────╯ nonce for this lane for this sender, not unique across senders/lanes.\\n  }\\n\\n  struct EVM2AnyTokenTransfer {\\n    // The source pool EVM address. This value is trusted as it was obtained through the onRamp. It can be relied\\n    // upon by the destination pool to validate the source pool.\\n    address sourcePoolAddress;\\n    // The EVM address of the destination token.\\n    // This value is UNTRUSTED as any pool owner can return whatever value they want.\\n    bytes destTokenAddress;\\n    // Optional pool data to be transferred to the destination chain. Be default this is capped at\\n    // CCIP_LOCK_OR_BURN_V1_RET_BYTES bytes. If more data is required, the TokenTransferFeeConfig.destBytesOverhead\\n    // has to be set for the specific token.\\n    bytes extraData;\\n    uint256 amount; // Amount of tokens.\\n    // Destination chain data used to execute the token transfer on the destination chain. For an EVM destination, it\\n    // consists of the amount of gas available for the releaseOrMint and transfer calls made by the offRamp.\\n    bytes destExecData;\\n  }\\n\\n  struct Any2EVMTokenTransfer {\\n    // The source pool EVM address encoded to bytes. This value is trusted as it is obtained through the onRamp. It can\\n    // be relied upon by the destination pool to validate the source pool.\\n    bytes sourcePoolAddress;\\n    address destTokenAddress; // ─╮ Address of destination token\\n    uint32 destGasAmount; // ─────╯ The amount of gas available for the releaseOrMint and transfer calls on the offRamp.\\n    // Optional pool data to be transferred to the destination chain. Be default this is capped at\\n    // CCIP_LOCK_OR_BURN_V1_RET_BYTES bytes. If more data is required, the TokenTransferFeeConfig.destBytesOverhead\\n    // has to be set for the specific token.\\n    bytes extraData;\\n    uint256 amount; // Amount of tokens.\\n  }\\n\\n  /// @notice Family-agnostic message routed to an OffRamp.\\n  /// Note: hash(Any2EVMRampMessage) != hash(EVM2AnyRampMessage), hash(Any2EVMRampMessage) != messageId due to encoding\\n  /// and parameter differences.\\n  struct Any2EVMRampMessage {\\n    RampMessageHeader header; // Message header.\\n    bytes sender; // sender address on the source chain.\\n    bytes data; // arbitrary data payload supplied by the message sender.\\n    address receiver; // receiver address on the destination chain.\\n    uint256 gasLimit; // user supplied maximum gas amount available for dest chain execution.\\n    Any2EVMTokenTransfer[] tokenAmounts; // array of tokens and amounts to transfer.\\n  }\\n\\n  /// @notice Family-agnostic message emitted from the OnRamp.\\n  /// Note: hash(Any2EVMRampMessage) != hash(EVM2AnyRampMessage) due to encoding \\u0026 parameter differences.\\n  /// messageId = hash(EVM2AnyRampMessage) using the source EVM chain's encoding format.\\n  struct EVM2AnyRampMessage {\\n    RampMessageHeader header; // Message header.\\n    address sender; // sender address on the source chain.\\n    bytes data; // arbitrary data payload supplied by the message sender.\\n    bytes receiver; // receiver address on the destination chain.\\n    bytes extraArgs; // destination-chain specific extra args, such as the gasLimit for EVM chains.\\n    address feeToken; // fee token.\\n    uint256 feeTokenAmount; // fee token amount.\\n    uint256 feeValueJuels; // fee amount in Juels.\\n    EVM2AnyTokenTransfer[] tokenAmounts; // array of tokens and amounts to transfer.\\n  }\\n\\n  // bytes4(keccak256(\\\"CCIP ChainFamilySelector EVM\\\"));\\n  bytes4 public constant CHAIN_FAMILY_SELECTOR_EVM = 0x2812d52c;\\n\\n  // bytes4(keccak256(\\\"CCIP ChainFamilySelector SVM\\\"));\\n  bytes4 public constant CHAIN_FAMILY_SELECTOR_SVM = 0x1e10bdc4;\\n\\n  // bytes4(keccak256(\\\"CCIP ChainFamilySelector APTOS\\\"));\\n  bytes4 public constant CHAIN_FAMILY_SELECTOR_APTOS = 0xac77ffec;\\n\\n  // bytes4(keccak256(\\\"CCIP ChainFamilySelector SUI\\\"));\\n  bytes4 public constant CHAIN_FAMILY_SELECTOR_SUI = 0xc4e05953;\\n\\n  /// @dev Holds a merkle root and interval for a source chain so that an array of these can be passed in the CommitReport.\\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\\n  /// @dev inefficient struct packing intentionally chosen to maintain order of specificity. Not a storage struct so impact is minimal.\\n  // solhint-disable-next-line gas-struct-packing\\n  struct MerkleRoot {\\n    uint64 sourceChainSelector; // Remote source chain selector that the Merkle Root is scoped to\\n    bytes onRampAddress; //        Generic onRamp address, to support arbitrary sources; for EVM, use abi.encode\\n    uint64 minSeqNr; // ─────────╮ Minimum sequence number, inclusive\\n    uint64 maxSeqNr; // ─────────╯ Maximum sequence number, inclusive\\n    bytes32 merkleRoot; //         Merkle root covering the interval \\u0026 source chain messages\\n  }\\n}\\n\"},\"contracts/libraries/MerkleMultiProof.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.4;\\n\\nlibrary MerkleMultiProof {\\n  /// @notice Leaf domain separator, should be used as the first 32 bytes of a leaf's preimage.\\n  bytes32 internal constant LEAF_DOMAIN_SEPARATOR = 0x0000000000000000000000000000000000000000000000000000000000000000;\\n  /// @notice Internal domain separator, should be used as the first 32 bytes of an internal node's preimage.\\n  bytes32 internal constant INTERNAL_DOMAIN_SEPARATOR =\\n    0x0000000000000000000000000000000000000000000000000000000000000001;\\n\\n  uint256 internal constant MAX_NUM_HASHES = 256;\\n\\n  error InvalidProof();\\n  error LeavesCannotBeEmpty();\\n\\n  /// @notice Computes the root based on provided pre-hashed leaf nodes in leaves, internal nodes  in proofs, and using\\n  /// proofFlagBits' i-th bit to determine if an element of proofs or one of the previously computed leafs or internal\\n  /// nodes will be used for the i-th hash.\\n  /// @param leaves Should be pre-hashed and the first 32 bytes of a leaf's preimage should match LEAF_DOMAIN_SEPARATOR.\\n  /// @param proofs Hashes to be used instead of a leaf hash when the proofFlagBits indicates a proof should be used.\\n  /// @param proofFlagBits A single uint256 of which each bit indicates whether a leaf or a proof needs to be used in\\n  /// a hash operation.\\n  /// @dev the maximum number of hash operations it set to 256. Any input that would require more than 256 hashes to get\\n  /// to a root will revert.\\n  /// @dev For given input `leaves` = [a,b,c] `proofs` = [D] and `proofFlagBits` = 5\\n  ///     totalHashes = 3 + 1 - 1 = 3\\n  ///  ** round 1 **\\n  ///    proofFlagBits = (5 \\u003e\\u003e 0) \\u0026 1 = true\\n  ///    hashes[0] = hashPair(a, b)\\n  ///    (leafPos, hashPos, proofPos) = (2, 0, 0);\\n  ///\\n  ///  ** round 2 **\\n  ///    proofFlagBits = (5 \\u003e\\u003e 1) \\u0026 1 = false\\n  ///    hashes[1] = hashPair(D, c)\\n  ///    (leafPos, hashPos, proofPos) = (3, 0, 1);\\n  ///\\n  ///  ** round 3 **\\n  ///    proofFlagBits = (5 \\u003e\\u003e 2) \\u0026 1 = true\\n  ///    hashes[2] = hashPair(hashes[0], hashes[1])\\n  ///    (leafPos, hashPos, proofPos) = (3, 2, 1);\\n  ///\\n  ///    i = 3 and no longer \\u003c totalHashes. The algorithm is done\\n  ///    return hashes[totalHashes - 1] = hashes[2]; the last hash we computed.\\n  // We mark this function as internal to force it to be inlined in contracts that use it, but semantically it is public.\\n  function _merkleRoot(\\n    bytes32[] memory leaves,\\n    bytes32[] memory proofs,\\n    uint256 proofFlagBits\\n  ) internal pure returns (bytes32) {\\n    unchecked {\\n      uint256 leavesLen = leaves.length;\\n      uint256 proofsLen = proofs.length;\\n      if (leavesLen == 0) revert LeavesCannotBeEmpty();\\n      if (!(leavesLen \\u003c= MAX_NUM_HASHES + 1 \\u0026\\u0026 proofsLen \\u003c= MAX_NUM_HASHES + 1)) revert InvalidProof();\\n      uint256 totalHashes = leavesLen + proofsLen - 1;\\n      if (!(totalHashes \\u003c= MAX_NUM_HASHES)) revert InvalidProof();\\n      if (totalHashes == 0) {\\n        return leaves[0];\\n      }\\n      bytes32[] memory hashes = new bytes32[](totalHashes);\\n      (uint256 leafPos, uint256 hashPos, uint256 proofPos) = (0, 0, 0);\\n\\n      for (uint256 i = 0; i \\u003c totalHashes; ++i) {\\n        // Checks if the bit flag signals the use of a supplied proof or a leaf/previous hash.\\n        bytes32 a;\\n        if (proofFlagBits \\u0026 (1 \\u003c\\u003c i) == (1 \\u003c\\u003c i)) {\\n          // Use a leaf or a previously computed hash.\\n          if (leafPos \\u003c leavesLen) {\\n            a = leaves[leafPos++];\\n          } else {\\n            a = hashes[hashPos++];\\n          }\\n        } else {\\n          // Use a supplied proof.\\n          a = proofs[proofPos++];\\n        }\\n\\n        // The second part of the hashed pair is never a proof as hashing two proofs would result in a\\n        // hash that can already be computed offchain.\\n        bytes32 b;\\n        if (leafPos \\u003c leavesLen) {\\n          b = leaves[leafPos++];\\n        } else {\\n          b = hashes[hashPos++];\\n        }\\n\\n        if (!(hashPos \\u003c= i)) revert InvalidProof();\\n\\n        hashes[i] = _hashPair(a, b);\\n      }\\n      if (!(hashPos == totalHashes - 1 \\u0026\\u0026 leafPos == leavesLen \\u0026\\u0026 proofPos == proofsLen)) revert InvalidProof();\\n      // Return the last hash.\\n      return hashes[totalHashes - 1];\\n    }\\n  }\\n\\n  /// @notice Hashes two bytes32 objects in their given order, prepended by the INTERNAL_DOMAIN_SEPARATOR.\\n  function _hashInternalNode(bytes32 left, bytes32 right) private pure returns (bytes32 hash) {\\n    return keccak256(abi.encode(INTERNAL_DOMAIN_SEPARATOR, left, right));\\n  }\\n\\n  /// @notice Hashes two bytes32 objects. The order is taken into account, using the lower value first.\\n  function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n    return a \\u003c b ? _hashInternalNode(a, b) : _hashInternalNode(b, a);\\n  }\\n}\\n\"},\"contracts/ocr/MultiOCR3Base.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.4;\\n\\nimport {Internal} from \\\"../libraries/Internal.sol\\\";\\nimport {Ownable2StepMsgSender} from \\\"@chainlink/contracts/src/v0.8/shared/access/Ownable2StepMsgSender.sol\\\";\\nimport {ITypeAndVersion} from \\\"@chainlink/contracts/src/v0.8/shared/interfaces/ITypeAndVersion.sol\\\";\\n\\n/// @notice Onchain verification of reports from the offchain reporting protocol with multiple OCR plugin support.\\nabstract contract MultiOCR3Base is ITypeAndVersion, Ownable2StepMsgSender {\\n  // Maximum number of oracles the offchain reporting protocol is designed for\\n  uint256 internal constant MAX_NUM_ORACLES = 256;\\n\\n  /// @notice Triggers a new run of the offchain reporting protocol.\\n  /// @param ocrPluginType OCR plugin type for which the config was set.\\n  /// @param configDigest configDigest of this configuration.\\n  /// @param signers ith element is address ith oracle uses to sign a report.\\n  /// @param transmitters ith element is address ith oracle uses to transmit a report via the transmit method.\\n  /// @param F maximum number of faulty/dishonest oracles the protocol can tolerate while still working correctly.\\n  event ConfigSet(uint8 ocrPluginType, bytes32 configDigest, address[] signers, address[] transmitters, uint8 F);\\n\\n  /// @notice Optionally emitted to indicate the latest configDigest and sequence number\\n  /// for which a report was successfully transmitted. Alternatively, the contract may\\n  /// use latestConfigDigestAndEpoch with scanLogs set to false.\\n  event Transmitted(uint8 indexed ocrPluginType, bytes32 configDigest, uint64 sequenceNumber);\\n\\n  enum InvalidConfigErrorType {\\n    F_MUST_BE_POSITIVE,\\n    TOO_MANY_TRANSMITTERS,\\n    TOO_MANY_SIGNERS,\\n    F_TOO_HIGH,\\n    REPEATED_ORACLE_ADDRESS,\\n    NO_TRANSMITTERS\\n  }\\n\\n  error InvalidConfig(InvalidConfigErrorType errorType);\\n  error WrongMessageLength(uint256 expected, uint256 actual);\\n  error ConfigDigestMismatch(bytes32 expected, bytes32 actual);\\n  error ForkedChain(uint256 expected, uint256 actual);\\n  error WrongNumberOfSignatures();\\n  error SignaturesOutOfRegistration();\\n  error UnauthorizedTransmitter();\\n  error UnauthorizedSigner();\\n  error NonUniqueSignatures();\\n  error OracleCannotBeZeroAddress();\\n  error StaticConfigCannotBeChanged(uint8 ocrPluginType);\\n  error InsufficientGasToCompleteTx(bytes4 err);\\n\\n  /// @dev Packing these fields used on the hot path in a ConfigInfo variable reduces the retrieval of all\\n  /// of them to a minimum number of SLOADs.\\n  struct ConfigInfo {\\n    bytes32 configDigest;\\n    uint8 F; // ─────────────────────────────╮ maximum number of faulty/dishonest oracles the system can tolerate.\\n    uint8 n; //                              │ number of configured signers.\\n    bool isSignatureVerificationEnabled; // ─╯ if true, requires signers and verifies signatures on transmission.\\n  }\\n\\n  /// @notice Used for s_oracles[a].role, where a is an address, to track the purpose of the address, or to indicate\\n  /// that the address is unset.\\n  enum Role {\\n    // No oracle role has been set for the address `a`\\n    Unset,\\n    // Signing address for the s_oracles[a].index'th oracle. I.e., report signatures from this oracle should ecrecover\\n    // back to address `a`.\\n    Signer,\\n    // Transmission address for the s_oracles[a].index'th oracle. I.e., if `a` report is received by\\n    // OCR2Aggregator.transmit in which msg.sender is  a, it is attributed to the s_oracles[a].index'th oracle.\\n    Transmitter\\n  }\\n\\n  struct Oracle {\\n    uint8 index; // ─╮ Index of oracle in s_signers/s_transmitters.\\n    Role role; // ───╯ Role of the address which mapped to this struct.\\n  }\\n\\n  /// @notice OCR configuration for a single OCR plugin within a DON.\\n  struct OCRConfig {\\n    ConfigInfo configInfo; //  latest OCR config.\\n    // NOTE: len(signers) can be different from len(transmitters). There is no index relationship between the two arrays.\\n    address[] signers; //      addresses oracles use to sign the reports.\\n    address[] transmitters; // addresses oracles use to transmit the reports.\\n  }\\n\\n  /// @notice Args to update an OCR Config.\\n  struct OCRConfigArgs {\\n    bytes32 configDigest; // The new config digest.\\n    uint8 ocrPluginType; // ─────────────────╮ OCR plugin type to update config for.\\n    uint8 F; //                              │ Maximum number of faulty/dishonest oracles.\\n    bool isSignatureVerificationEnabled; // ─╯ If true, requires signers and verifies signatures on transmission.\\n    address[] signers; // signing address of each oracle.\\n    address[] transmitters; // the address the oracle sends transactions from.\\n  }\\n\\n  /// @notice mapping of OCR plugin type -\\u003e DON config.\\n  mapping(uint8 ocrPluginType =\\u003e OCRConfig config) internal s_ocrConfigs;\\n\\n  /// @notice OCR plugin type =\\u003e signer OR transmitter address mapping.\\n  mapping(uint8 ocrPluginType =\\u003e mapping(address signerOrTransmiter =\\u003e Oracle oracle)) internal s_oracles;\\n\\n  // Constant-length components of the msg.data sent to transmit.\\n  // See the \\\"If we wanted to call sam\\\" example on for example reasoning.\\n  // https://solidity.readthedocs.io/en/v0.7.2/abi-spec.html\\n\\n  /// @notice Constant length component for transmit functions with no signatures.\\n  /// The signatures are expected to match transmitPlugin(reportContext, report).\\n  uint16 private constant TRANSMIT_MSGDATA_CONSTANT_LENGTH_COMPONENT_NO_SIGNATURES = 4 // function selector.\\n    + 2 * 32 // 2 words containing reportContext.\\n    + 32 // word containing start location of abiencoded report value.\\n    + 32; // word containing length of report.\\n\\n  /// @notice Extra constant length component for transmit functions with signatures (relative to no signatures).\\n  /// The signatures are expected to match transmitPlugin(reportContext, report, rs, ss, rawVs).\\n  uint16 private constant TRANSMIT_MSGDATA_EXTRA_CONSTANT_LENGTH_COMPONENT_FOR_SIGNATURES = 32 // word containing location start of abiencoded rs value.\\n    + 32 // word containing start location of abiencoded ss value.\\n    + 32 // rawVs value.\\n    + 32 // word containing length rs.\\n    + 32; // word containing length of ss.\\n\\n  uint256 internal immutable i_chainID;\\n\\n  constructor() {\\n    i_chainID = block.chainid;\\n  }\\n\\n  /// @notice Sets offchain reporting protocol configuration incl. participating oracles.\\n  /// NOTE: The OCR3 config must be sanity-checked against the home-chain registry configuration, to ensure home-chain\\n  /// and remote-chain parity!\\n  /// @param ocrConfigArgs OCR config update args.\\n  /// @dev precondition number of transmitters should match the expected F/fChain relationship.\\n  /// For transmitters, the function only validates that len(transmitters) \\u003e 0 \\u0026\\u0026 len(transmitters) \\u003c= MAX_NUM_ORACLES\\n  /// \\u0026\\u0026 len(transmitters) \\u003c= len(signers) [if sig verification is enabled].\\n  function setOCR3Configs(\\n    OCRConfigArgs[] memory ocrConfigArgs\\n  ) external onlyOwner {\\n    for (uint256 i; i \\u003c ocrConfigArgs.length; ++i) {\\n      _setOCR3Config(ocrConfigArgs[i]);\\n    }\\n  }\\n\\n  /// @notice Sets offchain reporting protocol configuration incl. participating oracles for a single OCR plugin type.\\n  /// @param ocrConfigArgs OCR config update args.\\n  function _setOCR3Config(\\n    OCRConfigArgs memory ocrConfigArgs\\n  ) internal {\\n    if (ocrConfigArgs.F == 0) revert InvalidConfig(InvalidConfigErrorType.F_MUST_BE_POSITIVE);\\n\\n    uint8 ocrPluginType = ocrConfigArgs.ocrPluginType;\\n    OCRConfig storage ocrConfig = s_ocrConfigs[ocrPluginType];\\n    ConfigInfo storage configInfo = ocrConfig.configInfo;\\n\\n    // If F is 0, then the config is not yet set.\\n    if (configInfo.F == 0) {\\n      configInfo.isSignatureVerificationEnabled = ocrConfigArgs.isSignatureVerificationEnabled;\\n    } else {\\n      if (configInfo.isSignatureVerificationEnabled != ocrConfigArgs.isSignatureVerificationEnabled) {\\n        revert StaticConfigCannotBeChanged(ocrPluginType);\\n      }\\n    }\\n\\n    address[] memory transmitters = ocrConfigArgs.transmitters;\\n    if (transmitters.length \\u003e MAX_NUM_ORACLES) revert InvalidConfig(InvalidConfigErrorType.TOO_MANY_TRANSMITTERS);\\n    if (transmitters.length == 0) revert InvalidConfig(InvalidConfigErrorType.NO_TRANSMITTERS);\\n\\n    _clearOracleRoles(ocrPluginType, ocrConfig.transmitters);\\n\\n    if (ocrConfigArgs.isSignatureVerificationEnabled) {\\n      _clearOracleRoles(ocrPluginType, ocrConfig.signers);\\n\\n      address[] memory signers = ocrConfigArgs.signers;\\n\\n      if (signers.length \\u003e MAX_NUM_ORACLES) revert InvalidConfig(InvalidConfigErrorType.TOO_MANY_SIGNERS);\\n      if (signers.length \\u003c= 3 * ocrConfigArgs.F) revert InvalidConfig(InvalidConfigErrorType.F_TOO_HIGH);\\n      // NOTE: Transmitters cannot exceed signers. Transmitters do not have to be \\u003e= 3F + 1 because they can\\n      // match \\u003e= 3fChain + 1, where fChain \\u003c= F. fChain is not represented in MultiOCR3Base - so we skip this check.\\n      if (signers.length \\u003c transmitters.length) revert InvalidConfig(InvalidConfigErrorType.TOO_MANY_TRANSMITTERS);\\n\\n      configInfo.n = uint8(signers.length);\\n      ocrConfig.signers = signers;\\n\\n      _assignOracleRoles(ocrPluginType, signers, Role.Signer);\\n    }\\n\\n    _assignOracleRoles(ocrPluginType, transmitters, Role.Transmitter);\\n\\n    ocrConfig.transmitters = transmitters;\\n    configInfo.F = ocrConfigArgs.F;\\n    configInfo.configDigest = ocrConfigArgs.configDigest;\\n\\n    emit ConfigSet(\\n      ocrPluginType, ocrConfigArgs.configDigest, ocrConfig.signers, ocrConfigArgs.transmitters, ocrConfigArgs.F\\n    );\\n    _afterOCR3ConfigSet(ocrPluginType);\\n  }\\n\\n  /// @notice Hook that is called after a plugin's OCR3 config changes.\\n  /// @param ocrPluginType Plugin type for which the config changed.\\n  function _afterOCR3ConfigSet(\\n    uint8 ocrPluginType\\n  ) internal virtual;\\n\\n  /// @notice Clears oracle roles for the provided oracle addresses.\\n  /// @param ocrPluginType OCR plugin type to clear roles for.\\n  /// @param oracleAddresses Oracle addresses to clear roles for.\\n  function _clearOracleRoles(uint8 ocrPluginType, address[] memory oracleAddresses) internal {\\n    for (uint256 i = 0; i \\u003c oracleAddresses.length; ++i) {\\n      delete s_oracles[ocrPluginType][oracleAddresses[i]];\\n    }\\n  }\\n\\n  /// @notice Assigns oracles roles for the provided oracle addresses with uniqueness verification.\\n  /// @param ocrPluginType OCR plugin type to assign roles for.\\n  /// @param oracleAddresses Oracle addresses to assign roles to.\\n  /// @param role Role to assign.\\n  function _assignOracleRoles(uint8 ocrPluginType, address[] memory oracleAddresses, Role role) internal {\\n    for (uint256 i = 0; i \\u003c oracleAddresses.length; ++i) {\\n      address oracle = oracleAddresses[i];\\n      if (s_oracles[ocrPluginType][oracle].role != Role.Unset) {\\n        revert InvalidConfig(InvalidConfigErrorType.REPEATED_ORACLE_ADDRESS);\\n      }\\n      if (oracle == address(0)) revert OracleCannotBeZeroAddress();\\n      s_oracles[ocrPluginType][oracle] = Oracle(uint8(i), role);\\n    }\\n  }\\n\\n  /// @notice _transmit is called to post a new report to the contract. The function should be called after the per-DON\\n  /// reporting logic is completed.\\n  /// @param ocrPluginType OCR plugin type to transmit report for\\n  /// @param report serialized report, which the signatures are signing.\\n  /// @param rs ith element is the R components of the ith signature on report. Must have at most MAX_NUM_ORACLES entries.\\n  /// @param ss ith element is the S components of the ith signature on report. Must have at most MAX_NUM_ORACLES entries.\\n  /// @param rawVs ith element is the the V component of the ith signature.\\n  function _transmit(\\n    uint8 ocrPluginType,\\n    // NOTE: If these parameters are changed, expectedMsgDataLength and/or TRANSMIT_MSGDATA_CONSTANT_LENGTH_COMPONENT\\n    // need to be changed accordingly.\\n    bytes32[2] calldata reportContext,\\n    bytes calldata report,\\n    bytes32[] memory rs,\\n    bytes32[] memory ss,\\n    bytes32 rawVs\\n  ) internal {\\n    // reportContext consists of:\\n    // reportContext[0]: ConfigDigest.\\n    // reportContext[1]: 24 byte padding, 8 byte sequence number.\\n    ConfigInfo memory configInfo = s_ocrConfigs[ocrPluginType].configInfo;\\n    bytes32 configDigest = reportContext[0];\\n\\n    // Scoping this reduces stack pressure and gas usage.\\n    {\\n      // one byte per entry in _report\\n      uint256 expectedDataLength = uint256(TRANSMIT_MSGDATA_CONSTANT_LENGTH_COMPONENT_NO_SIGNATURES) + report.length;\\n\\n      if (configInfo.isSignatureVerificationEnabled) {\\n        // 32 bytes per entry in _rs, _ss\\n        expectedDataLength +=\\n          TRANSMIT_MSGDATA_EXTRA_CONSTANT_LENGTH_COMPONENT_FOR_SIGNATURES + rs.length * 32 + ss.length * 32;\\n      }\\n\\n      if (msg.data.length != expectedDataLength) revert WrongMessageLength(expectedDataLength, msg.data.length);\\n    }\\n\\n    if (configInfo.configDigest != configDigest) {\\n      revert ConfigDigestMismatch(configInfo.configDigest, configDigest);\\n    }\\n    // If the cached chainID at time of deployment doesn't match the current chainID, we reject all signed reports.\\n    // This avoids a (rare) scenario where chain A forks into chain A and A', A' still has configDigest calculated\\n    // from chain A and so OCR reports will be valid on both forks.\\n    _whenChainNotForked();\\n\\n    // Scoping this reduces stack pressure and gas usage.\\n    {\\n      Oracle memory transmitter = s_oracles[ocrPluginType][msg.sender];\\n      // Check that sender is authorized to report.\\n      if (\\n        !(\\n          transmitter.role == Role.Transmitter\\n            \\u0026\\u0026 msg.sender == s_ocrConfigs[ocrPluginType].transmitters[transmitter.index]\\n        )\\n      ) {\\n        if (msg.sender != Internal.GAS_ESTIMATION_SENDER) {\\n          revert UnauthorizedTransmitter();\\n        }\\n      }\\n    }\\n\\n    if (configInfo.isSignatureVerificationEnabled) {\\n      // Scoping to reduce stack pressure.\\n      {\\n        if (rs.length != configInfo.F + 1) revert WrongNumberOfSignatures();\\n        if (rs.length != ss.length) revert SignaturesOutOfRegistration();\\n      }\\n\\n      bytes32 h = keccak256(abi.encodePacked(keccak256(report), reportContext));\\n      _verifySignatures(ocrPluginType, h, rs, ss, rawVs);\\n    }\\n\\n    emit Transmitted(ocrPluginType, configDigest, uint64(uint256(reportContext[1])));\\n  }\\n\\n  /// @notice Verifies the signatures of a hashed report value for one OCR plugin type.\\n  /// @param ocrPluginType OCR plugin type to transmit report for.\\n  /// @param hashedReport hashed encoded packing of report + reportContext.\\n  /// @param rs ith element is the R components of the ith signature on report. Must have at most MAX_NUM_ORACLES entries.\\n  /// @param ss ith element is the S components of the ith signature on report. Must have at most MAX_NUM_ORACLES entries.\\n  /// @param rawVs ith element is the the V component of the ith signature.\\n  function _verifySignatures(\\n    uint8 ocrPluginType,\\n    bytes32 hashedReport,\\n    bytes32[] memory rs,\\n    bytes32[] memory ss,\\n    bytes32 rawVs\\n  ) internal view {\\n    // Verify signatures attached to report. Using a uint256 means we can only verify up to 256 oracles.\\n    uint256 signed = 0;\\n\\n    uint256 numberOfSignatures = rs.length;\\n    for (uint256 i; i \\u003c numberOfSignatures; ++i) {\\n      // Safe from ECDSA malleability here since we check for duplicate signers.\\n      address signer = ecrecover(hashedReport, uint8(rawVs[i]) + 27, rs[i], ss[i]);\\n      // Since we disallow address(0) as a valid signer address, it can never have a signer role.\\n      Oracle memory oracle = s_oracles[ocrPluginType][signer];\\n      if (oracle.role != Role.Signer) revert UnauthorizedSigner();\\n      if (signed \\u0026 (0x1 \\u003c\\u003c oracle.index) != 0) revert NonUniqueSignatures();\\n      signed |= 0x1 \\u003c\\u003c oracle.index;\\n    }\\n  }\\n\\n  /// @notice Validates that the chain ID has not diverged after deployment. Reverts if the chain IDs do not match.\\n  function _whenChainNotForked() internal view {\\n    if (i_chainID != block.chainid) revert ForkedChain(i_chainID, block.chainid);\\n  }\\n\\n  /// @notice Information about current offchain reporting protocol configuration.\\n  /// @param ocrPluginType OCR plugin type to return config details for.\\n  /// @return ocrConfig OCR config for the plugin type.\\n  function latestConfigDetails(\\n    uint8 ocrPluginType\\n  ) external view returns (OCRConfig memory ocrConfig) {\\n    return s_ocrConfigs[ocrPluginType];\\n  }\\n}\\n\"},\"contracts/test/helpers/MultiOCR3Helper.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\nimport {MultiOCR3Base} from \\\"../../ocr/MultiOCR3Base.sol\\\";\\n\\ncontract MultiOCR3Helper is MultiOCR3Base {\\n  event AfterConfigSet(uint8 ocrPluginType);\\n\\n  /// @dev OCR plugin type used for transmit.\\n  /// Defined in storage since it cannot be passed as calldata due to strict transmit checks\\n  uint8 internal s_transmitOcrPluginType;\\n\\n  function setTransmitOcrPluginType(\\n    uint8 ocrPluginType\\n  ) external {\\n    s_transmitOcrPluginType = ocrPluginType;\\n  }\\n\\n  /// @dev transmit function with signatures\\n  function transmitWithSignatures(\\n    bytes32[2] calldata reportContext,\\n    bytes calldata report,\\n    bytes32[] calldata rs,\\n    bytes32[] calldata ss,\\n    bytes32 rawVs\\n  ) external {\\n    _transmit(s_transmitOcrPluginType, reportContext, report, rs, ss, rawVs);\\n  }\\n\\n  /// @dev transmit function with no signatures\\n  function transmitWithoutSignatures(bytes32[2] calldata reportContext, bytes calldata report) external {\\n    bytes32[] memory emptySigs = new bytes32[](0);\\n    _transmit(s_transmitOcrPluginType, reportContext, report, emptySigs, emptySigs, bytes32(\\\"\\\"));\\n  }\\n\\n  function getOracle(uint8 ocrPluginType, address oracleAddress) external view returns (Oracle memory) {\\n    return s_oracles[ocrPluginType][oracleAddress];\\n  }\\n\\n  function typeAndVersion() public pure override returns (string memory) {\\n    return \\\"MultiOCR3BaseHelper 1.0.0\\\";\\n  }\\n\\n  function _afterOCR3ConfigSet(\\n    uint8 ocrPluginType\\n  ) internal virtual override {\\n    emit AfterConfigSet(ocrPluginType);\\n  }\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2Step.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {IOwnable} from \\\"../interfaces/IOwnable.sol\\\";\\n\\n/// @notice A minimal contract that implements 2-step ownership transfer and nothing more. It's made to be minimal\\n/// to reduce the impact of the bytecode size on any contract that inherits from it.\\ncontract Ownable2Step is IOwnable {\\n  /// @notice The pending owner is the address to which ownership may be transferred.\\n  address private s_pendingOwner;\\n  /// @notice The owner is the current owner of the contract.\\n  /// @dev The owner is the second storage variable so any implementing contract could pack other state with it\\n  /// instead of the much less used s_pendingOwner.\\n  address private s_owner;\\n\\n  error OwnerCannotBeZero();\\n  error MustBeProposedOwner();\\n  error CannotTransferToSelf();\\n  error OnlyCallableByOwner();\\n\\n  event OwnershipTransferRequested(address indexed from, address indexed to);\\n  event OwnershipTransferred(address indexed from, address indexed to);\\n\\n  constructor(address newOwner, address pendingOwner) {\\n    if (newOwner == address(0)) {\\n      revert OwnerCannotBeZero();\\n    }\\n\\n    s_owner = newOwner;\\n    if (pendingOwner != address(0)) {\\n      _transferOwnership(pendingOwner);\\n    }\\n  }\\n\\n  /// @notice Get the current owner\\n  function owner() public view override returns (address) {\\n    return s_owner;\\n  }\\n\\n  /// @notice Allows an owner to begin transferring ownership to a new address. The new owner needs to call\\n  /// `acceptOwnership` to accept the transfer before any permissions are changed.\\n  /// @param to The address to which ownership will be transferred.\\n  function transferOwnership(address to) public override onlyOwner {\\n    _transferOwnership(to);\\n  }\\n\\n  /// @notice validate, transfer ownership, and emit relevant events\\n  /// @param to The address to which ownership will be transferred.\\n  function _transferOwnership(address to) private {\\n    if (to == msg.sender) {\\n      revert CannotTransferToSelf();\\n    }\\n\\n    s_pendingOwner = to;\\n\\n    emit OwnershipTransferRequested(s_owner, to);\\n  }\\n\\n  /// @notice Allows an ownership transfer to be completed by the recipient.\\n  function acceptOwnership() external override {\\n    if (msg.sender != s_pendingOwner) {\\n      revert MustBeProposedOwner();\\n    }\\n\\n    address oldOwner = s_owner;\\n    s_owner = msg.sender;\\n    s_pendingOwner = address(0);\\n\\n    emit OwnershipTransferred(oldOwner, msg.sender);\\n  }\\n\\n  /// @notice validate access\\n  function _validateOwnership() internal view {\\n    if (msg.sender != s_owner) {\\n      revert OnlyCallableByOwner();\\n    }\\n  }\\n\\n  /// @notice Reverts if called by anyone other than the contract owner.\\n  modifier onlyOwner() {\\n    _validateOwnership();\\n    _;\\n  }\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2StepMsgSender.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {Ownable2Step} from \\\"./Ownable2Step.sol\\\";\\n\\n/// @notice Sets the msg.sender to be the owner of the contract and does not set a pending owner.\\ncontract Ownable2StepMsgSender is Ownable2Step {\\n  constructor() Ownable2Step(msg.sender, address(0)) {}\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/IOwnable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IOwnable {\\n  function owner() external returns (address);\\n\\n  function transferOwnership(address recipient) external;\\n\\n  function acceptOwnership() external;\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/ITypeAndVersion.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ITypeAndVersion {\\n  function typeAndVersion() external pure returns (string memory);\\n}\\n\"}}}"
