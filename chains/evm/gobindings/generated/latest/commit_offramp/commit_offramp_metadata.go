// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.


package commit_offramp

var SolidityStandardInput = "{\"version\":\"v0.8.26+commit.8a97fa7a\",\"language\":\"Solidity\",\"settings\":{\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"appendCBOR\":true,\"bytecodeHash\":\"none\",\"useLiteralContent\":false},\"optimizer\":{\"enabled\":true,\"runs\":80000},\"outputSelection\":{\"contracts/interfaces/ICCVOffRampV1.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/libraries/MessageV1Codec.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/offRamp/CommitOffRamp.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/offRamp/components/SignatureQuorumVerifier.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2Step.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2StepMsgSender.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/IOwnable.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/ITypeAndVersion.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v5.0.2/contracts/utils/introspection/IERC165.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v5.0.2/contracts/utils/structs/EnumerableSet.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]}},\"remappings\":[\"forge-std/=node_modules/@chainlink/contracts/src/v0.8/vendor/forge-std/src/\",\"@chainlink/contracts/=node_modules/@chainlink/contracts/\"],\"viaIR\":true},\"sources\":{\"contracts/interfaces/ICCVOffRampV1.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {MessageV1Codec} from \\\"../libraries/MessageV1Codec.sol\\\";\\n\\nimport {IERC165} from\\n  \\\"@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v5.0.2/contracts/utils/introspection/IERC165.sol\\\";\\n\\ninterface ICCVOffRampV1 is IERC165 {\\n  /// @notice Verification of the message, in any way the OffRamp wants. This could be using a signature, a quorum\\n  /// of signatures, using native interop, or some ZK light client. Any proof required for the verification is supplied\\n  /// through the ccvData parameter.\\n  /// @param message The message to be verified. For efficiency, the messageID is also supplied, which acts as a small\\n  /// payload that once verified means the entire message is verified. Every component of the message is part of the\\n  /// message ID through hashing the struct. The entire message is provided to be able to act differently for different\\n  /// message properties.\\n  /// @param messageId A convenient 32 byte hash of the entire message. It can be recomputed from the passed in message\\n  /// at the cost of a not-insignificant amount of gas. Any CCV MUST verify this as part of this call.\\n  /// @param ccvData All the data that is specific to the CCV. This often means it contains some sort of proof, but it\\n  /// can also contain certain metadata like a nonce that's specific to the CCV. If any metadata like that exists and is\\n  /// important to the security of the CCV, it MUST be verified as well using the proof. A recommended way to do this is\\n  /// to encode a proof and the metadata separately in the ccvData and then concatenate the messageId with this metadata\\n  /// to get the payload that will be verified. In the case of a simple signature verification this means that the CCV\\n  /// offchain system must sign the concatenated (messageId, ccvMetaData) and not just the messageId. If no metadata\\n  /// is required, simply signing the messageId is enough.\\n  function verifyMessage(MessageV1Codec.MessageV1 memory message, bytes32 messageId, bytes memory ccvData) external;\\n}\\n\"},\"contracts/libraries/MessageV1Codec.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for CCIP MessageV1 encoding/decoding operations.\\n/// @dev This library handles the complete V1 message format protocol including:\\n/// - MessageV1 and TokenTransferV1 struct definitions\\n/// - Encoding/decoding functions with comprehensive error handling\\n/// - Detailed error location tracking for debugging\\nlibrary MessageV1Codec {\\n  error InvalidDataLength(EncodingErrorLocation location);\\n  error InvalidEncodingVersion(uint8 version);\\n\\n  uint256 public constant MAX_NUMBER_OF_TOKENS = 1;\\n\\n  enum EncodingErrorLocation {\\n    // Message-level components.\\n    MESSAGE_MIN_SIZE,\\n    MESSAGE_ONRAMP_ADDRESS_CONTENT,\\n    MESSAGE_OFFRAMP_ADDRESS_LENGTH,\\n    MESSAGE_OFFRAMP_ADDRESS_CONTENT,\\n    MESSAGE_FINALITY,\\n    MESSAGE_SENDER_LENGTH,\\n    MESSAGE_SENDER_CONTENT,\\n    MESSAGE_RECEIVER_LENGTH,\\n    MESSAGE_RECEIVER_CONTENT,\\n    MESSAGE_DEST_BLOB_LENGTH,\\n    MESSAGE_DEST_BLOB_CONTENT,\\n    MESSAGE_TOKEN_TRANSFER_LENGTH,\\n    MESSAGE_TOKEN_TRANSFER_CONTENT,\\n    MESSAGE_DATA_LENGTH,\\n    MESSAGE_DATA_CONTENT,\\n    MESSAGE_FINAL_OFFSET,\\n    // Token transfer components.\\n    TOKEN_TRANSFER_VERSION,\\n    TOKEN_TRANSFER_AMOUNT,\\n    TOKEN_TRANSFER_SOURCE_POOL_LENGTH,\\n    TOKEN_TRANSFER_SOURCE_POOL_CONTENT,\\n    TOKEN_TRANSFER_SOURCE_TOKEN_LENGTH,\\n    TOKEN_TRANSFER_SOURCE_TOKEN_CONTENT,\\n    TOKEN_TRANSFER_DEST_TOKEN_LENGTH,\\n    TOKEN_TRANSFER_DEST_TOKEN_CONTENT,\\n    TOKEN_TRANSFER_EXTRA_DATA_LENGTH,\\n    TOKEN_TRANSFER_EXTRA_DATA_CONTENT,\\n    // Encoding validation components.\\n    ENCODE_ONRAMP_ADDRESS_LENGTH,\\n    ENCODE_OFFRAMP_ADDRESS_LENGTH,\\n    ENCODE_SENDER_LENGTH,\\n    ENCODE_RECEIVER_LENGTH,\\n    ENCODE_DEST_BLOB_LENGTH,\\n    ENCODE_TOKEN_TRANSFER_ARRAY_LENGTH,\\n    ENCODE_DATA_LENGTH,\\n    ENCODE_TOKEN_SOURCE_POOL_LENGTH,\\n    ENCODE_TOKEN_SOURCE_TOKEN_LENGTH,\\n    ENCODE_TOKEN_DEST_TOKEN_LENGTH,\\n    ENCODE_TOKEN_EXTRA_DATA_LENGTH\\n  }\\n\\n  /// @notice Message format used in the v1 protocol.\\n  /// Protocol Header.\\n  ///   uint8 version;              Version, for future use and backwards compatibility.\\n  ///   uint64 sourceChainSelector; Source Chain Selector.\\n  ///   uint64 destChainSelector;   Destination Chain Selector.\\n  ///   uint64 sequenceNumber;      Auto-incrementing sequence number for the message.\\n  ///   uint8 onRampAddressLength;  Length of the onRamp Address in bytes.\\n  ///   bytes onRampAddress;        Source Chain OnRamp as unpadded bytes.\\n  ///   uint8 offRampAddressLength; Length of the offRamp Address in bytes.\\n  ///   bytes offRampAddress;       Destination Chain OffRamp as unpadded bytes.\\n  ///\\n  /// User controlled data.\\n  ///   uint16 finality;            Configurable per-message finality value.\\n  ///   uint8 senderLength;         Length of the Sender Address in bytes.\\n  ///   bytes sender;               Sender address as unpadded bytes.\\n  ///   uint8 receiverLength;       Length of the Receiver Address in bytes.\\n  ///   bytes receiver;             Receiver address on the destination chain as unpadded bytes.\\n  ///   uint16 destBlobLength;      Length of the Destination Blob in bytes.\\n  ///   bytes destBlob;             Destination chain-specific blob that contains data required for execution e.g.\\n  ///                               Solana accounts.\\n  ///   uint16 tokenTransferLength; Length of the Token Transfer structure in bytes.\\n  ///   bytes tokenTransfer;        Byte representation of the token transfer structure.\\n  ///   uint16 dataLength;          Length of the user specified data payload.\\n  ///   bytes data;                 Arbitrary data payload supplied by the message sender that is passed to the receiver.\\n  ///\\n  /// @dev None of the fields are abi encoded as this storage layout is used for non-EVMs as well. That means if the\\n  /// receiver is an EVM address, it is stored as 20 bytes without any padding.\\n  /// @dev Inefficient struct packing does not matter as this is not a storage struct, and it it would ever be written\\n  /// to storage it would be in its encoded form.\\n  // solhint-disable-next-line gas-struct-packing\\n  struct MessageV1 {\\n    // Protocol Header.\\n    uint64 sourceChainSelector; // ─╮ Source Chain Selector.\\n    uint64 destChainSelector; //    │ Destination Chain Selector.\\n    //                              │ Per-lane-unique sequence number for the message. When faster-than-finality is used\\n    //                              │ the guarantee that this value is unique no longer holds. After a re-org, a message\\n    //                              │ could end up with a different sequence number. Messages that are older than the\\n    uint64 sequenceNumber; //  ─────╯ chain finality delay should all have unique per-lane sequence numbers.\\n    // Source chain onRamp, NOT abi encoded but raw bytes. This means for EVM chains it is 20 bytes.\\n    bytes onRampAddress;\\n    // Destination chain offRamp, NOT abi encoded but raw bytes. This means for EVM chains it is 20 bytes.\\n    bytes offRampAddress;\\n    // Configurable per-message finality value.\\n    uint16 finality;\\n    // Source chain sender address, NOT abi encoded but raw bytes. This means for EVM chains it is 20 bytes.\\n    bytes sender;\\n    // Destination chain receiver address, NOT abi encoded but raw bytes. This means for EVM chains it is 20 bytes.\\n    bytes receiver;\\n    // Destination specific blob that contains chain-family specific data.\\n    bytes destBlob;\\n    // Contains either 0 or 1 token transfer structs. It is encoded as an array for gas efficiency.\\n    TokenTransferV1[] tokenTransfer;\\n    // Arbitrary data payload supplied by the message sender.\\n    bytes data;\\n  }\\n\\n  struct TokenTransferV1 {\\n    uint256 amount; // Number of tokens.\\n    // This can be relied upon by the destination pool to validate the source pool. NOT abi encoded but raw bytes. This\\n    // means for EVM chains it is 20 bytes.\\n    bytes sourcePoolAddress;\\n    bytes sourceTokenAddress; // Address of source token, NOT abi encoded but raw bytes.\\n    bytes destTokenAddress; // Address of destination token, NOT abi encoded but raw bytes.\\n    // Optional pool data to be transferred to the destination chain. Be default this is capped at\\n    // CCIP_LOCK_OR_BURN_V1_RET_BYTES bytes. If more data is required, the TokenTransferFeeConfig.destBytesOverhead\\n    // has to be set for the specific token.\\n    bytes extraData;\\n  }\\n\\n  /// @notice Encodes a TokenTransferV1 struct into bytes.\\n  /// @param tokenTransfer The TokenTransferV1 struct to encode.\\n  /// @return encoded The encoded token transfer as bytes.\\n  function _encodeTokenTransferV1(\\n    TokenTransferV1 memory tokenTransfer\\n  ) internal pure returns (bytes memory) {\\n    // Validate field lengths fit in their respective size limits.\\n    if (tokenTransfer.sourcePoolAddress.length \\u003e type(uint8).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_TOKEN_SOURCE_POOL_LENGTH);\\n    }\\n    if (tokenTransfer.sourceTokenAddress.length \\u003e type(uint8).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_TOKEN_SOURCE_TOKEN_LENGTH);\\n    }\\n    if (tokenTransfer.destTokenAddress.length \\u003e type(uint8).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_TOKEN_DEST_TOKEN_LENGTH);\\n    }\\n    if (tokenTransfer.extraData.length \\u003e type(uint16).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_TOKEN_EXTRA_DATA_LENGTH);\\n    }\\n\\n    return abi.encodePacked(\\n      uint8(1), // version.\\n      tokenTransfer.amount,\\n      uint8(tokenTransfer.sourcePoolAddress.length),\\n      tokenTransfer.sourcePoolAddress,\\n      uint8(tokenTransfer.sourceTokenAddress.length),\\n      tokenTransfer.sourceTokenAddress,\\n      uint8(tokenTransfer.destTokenAddress.length),\\n      tokenTransfer.destTokenAddress,\\n      uint16(tokenTransfer.extraData.length),\\n      tokenTransfer.extraData\\n    );\\n  }\\n\\n  /// @notice Decodes bytes into a TokenTransferV1 struct.\\n  /// @param encoded The encoded token transfer bytes to decode.\\n  /// @param offset The starting offset in the encoded bytes.\\n  /// @return tokenTransfer The decoded TokenTransferV1 struct.\\n  /// @return newOffset The new offset after decoding.\\n  function _decodeTokenTransferV1(\\n    bytes calldata encoded,\\n    uint256 offset\\n  ) internal pure returns (TokenTransferV1 memory tokenTransfer, uint256 newOffset) {\\n    // version (1 byte).\\n    if (offset \\u003e= encoded.length) revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_VERSION);\\n    uint8 version = uint8(encoded[offset++]);\\n    if (version != 1) revert InvalidEncodingVersion(version);\\n\\n    // amount (32 bytes).\\n    if (offset + 32 \\u003e encoded.length) revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_AMOUNT);\\n    tokenTransfer.amount = uint256(bytes32(encoded[offset:offset + 32]));\\n    offset += 32;\\n\\n    // sourcePoolAddressLength and sourcePoolAddress.\\n    if (offset \\u003e= encoded.length) revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_SOURCE_POOL_LENGTH);\\n    uint8 sourcePoolAddressLength = uint8(encoded[offset++]);\\n    if (offset + sourcePoolAddressLength \\u003e encoded.length) {\\n      revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_SOURCE_POOL_CONTENT);\\n    }\\n\\n    tokenTransfer.sourcePoolAddress = encoded[offset:offset + sourcePoolAddressLength];\\n    offset += sourcePoolAddressLength;\\n\\n    // sourceTokenAddressLength and sourceTokenAddress.\\n    if (offset \\u003e= encoded.length) revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_SOURCE_TOKEN_LENGTH);\\n    uint8 sourceTokenAddressLength = uint8(encoded[offset++]);\\n    if (offset + sourceTokenAddressLength \\u003e encoded.length) {\\n      revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_SOURCE_TOKEN_CONTENT);\\n    }\\n\\n    tokenTransfer.sourceTokenAddress = encoded[offset:offset + sourceTokenAddressLength];\\n    offset += sourceTokenAddressLength;\\n\\n    // destTokenAddressLength and destTokenAddress.\\n    if (offset \\u003e= encoded.length) revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_DEST_TOKEN_LENGTH);\\n    uint8 destTokenAddressLength = uint8(encoded[offset++]);\\n    if (offset + destTokenAddressLength \\u003e encoded.length) {\\n      revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_DEST_TOKEN_CONTENT);\\n    }\\n\\n    tokenTransfer.destTokenAddress = encoded[offset:offset + destTokenAddressLength];\\n    offset += destTokenAddressLength;\\n\\n    // extraDataLength and extraData.\\n    if (offset + 2 \\u003e encoded.length) revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_EXTRA_DATA_LENGTH);\\n    uint16 extraDataLength = uint16(bytes2(encoded[offset:offset + 2]));\\n    offset += 2;\\n    if (offset + extraDataLength \\u003e encoded.length) {\\n      revert InvalidDataLength(EncodingErrorLocation.TOKEN_TRANSFER_EXTRA_DATA_CONTENT);\\n    }\\n\\n    tokenTransfer.extraData = encoded[offset:offset + extraDataLength];\\n    offset += extraDataLength;\\n\\n    return (tokenTransfer, offset);\\n  }\\n\\n  /// @notice Encodes a MessageV1 struct into bytes following the v1 protocol format.\\n  /// @param message The MessageV1 struct to encode.\\n  /// @return encoded The encoded message as bytes.\\n  function _encodeMessageV1(\\n    MessageV1 memory message\\n  ) internal pure returns (bytes memory) {\\n    // Validate field lengths fit in their respective size limits.\\n    if (message.onRampAddress.length \\u003e type(uint8).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_ONRAMP_ADDRESS_LENGTH);\\n    }\\n    if (message.offRampAddress.length \\u003e type(uint8).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_OFFRAMP_ADDRESS_LENGTH);\\n    }\\n    if (message.sender.length \\u003e type(uint8).max) revert InvalidDataLength(EncodingErrorLocation.ENCODE_SENDER_LENGTH);\\n    if (message.receiver.length \\u003e type(uint8).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_RECEIVER_LENGTH);\\n    }\\n    if (message.destBlob.length \\u003e type(uint16).max) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_DEST_BLOB_LENGTH);\\n    }\\n    if (message.tokenTransfer.length \\u003e MAX_NUMBER_OF_TOKENS) {\\n      revert InvalidDataLength(EncodingErrorLocation.ENCODE_TOKEN_TRANSFER_ARRAY_LENGTH);\\n    }\\n    if (message.data.length \\u003e type(uint16).max) revert InvalidDataLength(EncodingErrorLocation.ENCODE_DATA_LENGTH);\\n\\n    // Encode token the transfer if present. We checked above that there is at most 1 token transfer.\\n    bytes memory encodedTokenTransfers;\\n    if (message.tokenTransfer.length \\u003e 0) {\\n      encodedTokenTransfers = _encodeTokenTransferV1(message.tokenTransfer[0]);\\n    }\\n\\n    // Encoding has to be split into groups to avoid \\\"Stack too deep\\\" errors.\\n    return bytes.concat(\\n      abi.encodePacked(\\n        uint8(1), // version.\\n        message.sourceChainSelector,\\n        message.destChainSelector,\\n        message.sequenceNumber,\\n        uint8(message.onRampAddress.length),\\n        message.onRampAddress,\\n        uint8(message.offRampAddress.length),\\n        message.offRampAddress,\\n        message.finality\\n      ),\\n      abi.encodePacked(\\n        uint8(message.sender.length),\\n        message.sender,\\n        uint8(message.receiver.length),\\n        message.receiver,\\n        uint16(message.destBlob.length),\\n        message.destBlob,\\n        uint16(encodedTokenTransfers.length),\\n        encodedTokenTransfers,\\n        uint16(message.data.length),\\n        message.data\\n      )\\n    );\\n  }\\n\\n  /// @notice Decodes bytes into a MessageV1 struct following the v1 protocol format.\\n  /// @param encoded The encoded message bytes to decode.\\n  /// @return message The decoded MessageV1 struct.\\n  function _decodeMessageV1(\\n    bytes calldata encoded\\n  ) internal pure returns (MessageV1 memory) {\\n    if (encoded.length \\u003c 37) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_MIN_SIZE); // Minimum size check.\\n\\n    MessageV1 memory message;\\n    uint256 offset = 0;\\n\\n    uint8 version = uint8(encoded[offset++]);\\n    if (version != 1) revert InvalidEncodingVersion(version);\\n\\n    // Protocol Header.\\n    // sourceChainSelector (8 bytes, big endian).\\n    message.sourceChainSelector = uint64(bytes8(encoded[offset:offset + 8]));\\n    offset += 8;\\n\\n    // destChainSelector (8 bytes, big endian).\\n    message.destChainSelector = uint64(bytes8(encoded[offset:offset + 8]));\\n    offset += 8;\\n\\n    // sequenceNumber (8 bytes, big endian).\\n    message.sequenceNumber = uint64(bytes8(encoded[offset:offset + 8]));\\n    offset += 8;\\n\\n    // onRampAddressLength and onRampAddress.\\n    uint8 onRampAddressLength = uint8(encoded[offset++]);\\n    if (offset + onRampAddressLength \\u003e encoded.length) {\\n      revert InvalidDataLength(EncodingErrorLocation.MESSAGE_ONRAMP_ADDRESS_CONTENT);\\n    }\\n\\n    message.onRampAddress = encoded[offset:offset + onRampAddressLength];\\n    offset += onRampAddressLength;\\n\\n    // offRampAddressLength and offRampAddress.\\n    if (offset \\u003e= encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_OFFRAMP_ADDRESS_LENGTH);\\n    uint8 offRampAddressLength = uint8(encoded[offset++]);\\n    if (offset + offRampAddressLength \\u003e encoded.length) {\\n      revert InvalidDataLength(EncodingErrorLocation.MESSAGE_OFFRAMP_ADDRESS_CONTENT);\\n    }\\n\\n    message.offRampAddress = encoded[offset:offset + offRampAddressLength];\\n    offset += offRampAddressLength;\\n\\n    // User controlled data.\\n    if (offset + 2 \\u003e encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_FINALITY);\\n\\n    // finality (2 bytes, big endian).\\n    message.finality = uint16(bytes2(encoded[offset:offset + 2]));\\n    offset += 2;\\n\\n    // senderLength and sender.\\n    if (offset \\u003e= encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_SENDER_LENGTH);\\n    uint8 senderLength = uint8(encoded[offset++]);\\n    if (offset + senderLength \\u003e encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_SENDER_CONTENT);\\n\\n    message.sender = encoded[offset:offset + senderLength];\\n    offset += senderLength;\\n\\n    // receiverLength and receiver.\\n    if (offset \\u003e= encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_RECEIVER_LENGTH);\\n    uint8 receiverLength = uint8(encoded[offset++]);\\n    if (offset + receiverLength \\u003e encoded.length) {\\n      revert InvalidDataLength(EncodingErrorLocation.MESSAGE_RECEIVER_CONTENT);\\n    }\\n\\n    message.receiver = encoded[offset:offset + receiverLength];\\n    offset += receiverLength;\\n\\n    // destBlobLength and destBlob.\\n    if (offset + 2 \\u003e encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_DEST_BLOB_LENGTH);\\n    uint16 destBlobLength = uint16(bytes2(encoded[offset:offset + 2]));\\n    offset += 2;\\n    if (offset + destBlobLength \\u003e encoded.length) {\\n      revert InvalidDataLength(EncodingErrorLocation.MESSAGE_DEST_BLOB_CONTENT);\\n    }\\n\\n    message.destBlob = encoded[offset:offset + destBlobLength];\\n    offset += destBlobLength;\\n\\n    // tokenTransferLength and tokenTransfer.\\n    if (offset + 2 \\u003e encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_TOKEN_TRANSFER_LENGTH);\\n    uint16 tokenTransferLength = uint16(bytes2(encoded[offset:offset + 2]));\\n    offset += 2;\\n\\n    // Decode token transfer, which is either 0 or 1.\\n    if (tokenTransferLength == 0) {\\n      message.tokenTransfer = new TokenTransferV1[](0);\\n    } else {\\n      message.tokenTransfer = new TokenTransferV1[](1);\\n      uint256 expectedEnd = offset + tokenTransferLength;\\n      (message.tokenTransfer[0], offset) = _decodeTokenTransferV1(encoded, offset);\\n      if (offset != expectedEnd) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_TOKEN_TRANSFER_CONTENT);\\n    }\\n\\n    // dataLength and data.\\n    if (offset + 2 \\u003e encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_DATA_LENGTH);\\n    uint16 dataLength = uint16(bytes2(encoded[offset:offset + 2]));\\n    offset += 2;\\n    if (offset + dataLength \\u003e encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_DATA_CONTENT);\\n\\n    message.data = encoded[offset:offset + dataLength];\\n    offset += dataLength;\\n\\n    // Ensure we've consumed all bytes.\\n    if (offset != encoded.length) revert InvalidDataLength(EncodingErrorLocation.MESSAGE_FINAL_OFFSET);\\n\\n    return message;\\n  }\\n}\\n\"},\"contracts/offRamp/CommitOffRamp.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\nimport {ICCVOffRampV1} from \\\"../interfaces/ICCVOffRampV1.sol\\\";\\nimport {ITypeAndVersion} from \\\"@chainlink/contracts/src/v0.8/shared/interfaces/ITypeAndVersion.sol\\\";\\n\\nimport {MessageV1Codec} from \\\"../libraries/MessageV1Codec.sol\\\";\\nimport {SignatureQuorumVerifier} from \\\"./components/SignatureQuorumVerifier.sol\\\";\\n\\nimport {IERC165} from\\n  \\\"@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v5.0.2/contracts/utils/introspection/IERC165.sol\\\";\\n\\ncontract CommitOffRamp is ICCVOffRampV1, SignatureQuorumVerifier, ITypeAndVersion {\\n  error InvalidCCVData();\\n\\n  string public constant override typeAndVersion = \\\"CommitOffRamp 1.7.0-dev\\\";\\n\\n  uint256 internal constant SIGNATURE_LENGTH_BYTES = 2;\\n\\n  function verifyMessage(MessageV1Codec.MessageV1 calldata, bytes32 messageHash, bytes calldata ccvData) external view {\\n    if (ccvData.length \\u003c SIGNATURE_LENGTH_BYTES) {\\n      revert InvalidCCVData();\\n    }\\n\\n    uint256 signatureLength = uint16(bytes2(ccvData[:SIGNATURE_LENGTH_BYTES]));\\n    if (ccvData.length \\u003c SIGNATURE_LENGTH_BYTES + signatureLength) {\\n      revert InvalidCCVData();\\n    }\\n\\n    // Even though the current version of this contract only expects signatures to be included in the ccvData, bounding\\n    // it to the given length allows potential forward compatibility with future formats that supply more data.\\n    _validateSignatures(messageHash, ccvData[SIGNATURE_LENGTH_BYTES:SIGNATURE_LENGTH_BYTES + signatureLength]);\\n  }\\n\\n  function supportsInterface(\\n    bytes4 interfaceId\\n  ) external pure returns (bool) {\\n    return interfaceId == type(ICCVOffRampV1).interfaceId || interfaceId == type(IERC165).interfaceId;\\n  }\\n}\\n\"},\"contracts/offRamp/components/SignatureQuorumVerifier.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.4;\\n\\nimport {Ownable2StepMsgSender} from \\\"@chainlink/contracts/src/v0.8/shared/access/Ownable2StepMsgSender.sol\\\";\\n\\nimport {EnumerableSet} from\\n  \\\"@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v5.0.2/contracts/utils/structs/EnumerableSet.sol\\\";\\n\\ncontract SignatureQuorumVerifier is Ownable2StepMsgSender {\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n  using EnumerableSet for EnumerableSet.Bytes32Set;\\n\\n  /// @param signers List of valid signers of which only `threshold` are required to sign each report.\\n  /// @param threshold The number of signatures required for a report to be valid.\\n  event ConfigSet(address[] signers, uint8 threshold);\\n\\n  error InvalidConfig();\\n  error ForkedChain(uint256 expected, uint256 actual);\\n  error WrongNumberOfSignatures();\\n  error UnauthorizedSigner();\\n  error NonOrderedOrNonUniqueSignatures();\\n  error OracleCannotBeZeroAddress();\\n\\n  uint256 internal constant SIGNATURE_LENGTH = 64;\\n  uint256 internal constant SIGNATURE_COMPONENT_LENGTH = 32;\\n\\n  uint256 internal immutable i_chainID;\\n\\n  /// @notice List of valid signers of which only `threshold` are required to sign each report.\\n  EnumerableSet.AddressSet internal s_signers;\\n\\n  /// @notice The number of signatures required for a report to be valid.\\n  uint8 internal s_threshold;\\n\\n  constructor() {\\n    i_chainID = block.chainid;\\n  }\\n\\n  /// @notice Validates the signatures of a given report hash. IMPORTANT: the signatures must be provided in order of\\n  /// their signer addresses. This is required to efficiently check for duplicated signatures. If any signature is out\\n  /// of order, this function will revert with `NonOrderedOrNonUniqueSignatures`.\\n  /// @param signedHash The hash that is signed.\\n  /// @param signatures The concatenated signatures to validate. Each signature is 64 bytes long, consisting of r\\n  /// (32 bytes) and s (32 bytes). The signatures must be provided in order of their signer addresses. For example, if\\n  /// the signers are [A, B, C] with addresses [0x1, 0x2, 0x3], the signatures must be provided ordered as [A, B, C].\\n  /// @dev The v values are assumed to be 27 for all signatures, this can be achieved by using ECDSA malleability.\\n  function _validateSignatures(bytes32 signedHash, bytes calldata signatures) internal view {\\n    if (s_signers.length() == 0) {\\n      revert InvalidConfig();\\n    }\\n\\n    // If the cached chainID at time of deployment doesn't match the current chainID, we reject all signed reports.\\n    // This avoids a (rare) scenario where chain A forks into chain A and A', and a report signed on A is replayed on A'.\\n    if (i_chainID != block.chainid) revert ForkedChain(i_chainID, block.chainid);\\n\\n    uint256 numberOfSignatures = signatures.length / SIGNATURE_LENGTH;\\n\\n    uint256 threshold = s_threshold;\\n\\n    // We allow more signatures than the threshold, but we will only validate up to the threshold to save gas.\\n    // This still preserves the security properties while adding flexibility.\\n    if (numberOfSignatures \\u003c threshold) revert WrongNumberOfSignatures();\\n\\n    uint160 lastSigner = 0;\\n\\n    for (uint256 i; i \\u003c threshold; ++i) {\\n      uint256 offset = i * SIGNATURE_LENGTH;\\n      // We use ECDSA malleability to only have signatures with a `v` value of 27.\\n      address signer = ecrecover(\\n        signedHash,\\n        27,\\n        bytes32(signatures[offset:offset + SIGNATURE_COMPONENT_LENGTH]),\\n        bytes32(signatures[offset + SIGNATURE_COMPONENT_LENGTH:offset + SIGNATURE_LENGTH])\\n      );\\n      // Check that the signer is registered.\\n      if (!s_signers.contains(signer)) revert UnauthorizedSigner();\\n      // This requires ordered signatures to check for duplicates. This also disallows the zero address.\\n      if (uint160(signer) \\u003c= lastSigner) revert NonOrderedOrNonUniqueSignatures();\\n      lastSigner = uint160(signer);\\n    }\\n  }\\n\\n  /// @notice Returns the signer sets, and F value.\\n  function getSignatureConfig() external view returns (address[] memory, uint8) {\\n    return (s_signers.values(), s_threshold);\\n  }\\n\\n  /// @notice Sets a new signature configuration.\\n  function setSignatureConfig(address[] memory signers, uint8 threshold) external onlyOwner {\\n    if (threshold == 0 || threshold \\u003e signers.length) {\\n      revert InvalidConfig();\\n    }\\n\\n    // We must remove all current signers first.\\n    while (s_signers.length() \\u003e 0) {\\n      s_signers.remove(s_signers.at(0));\\n    }\\n\\n    // Add new signers.\\n    for (uint256 signerIndex = 0; signerIndex \\u003c signers.length; ++signerIndex) {\\n      if (signers[signerIndex] == address(0)) revert OracleCannotBeZeroAddress();\\n\\n      // This checks for duplicates.\\n      if (!s_signers.add(signers[signerIndex])) {\\n        revert InvalidConfig();\\n      }\\n    }\\n\\n    s_threshold = threshold;\\n\\n    emit ConfigSet(signers, threshold);\\n  }\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2Step.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {IOwnable} from \\\"../interfaces/IOwnable.sol\\\";\\n\\n/// @notice A minimal contract that implements 2-step ownership transfer and nothing more. It's made to be minimal\\n/// to reduce the impact of the bytecode size on any contract that inherits from it.\\ncontract Ownable2Step is IOwnable {\\n  /// @notice The pending owner is the address to which ownership may be transferred.\\n  address private s_pendingOwner;\\n  /// @notice The owner is the current owner of the contract.\\n  /// @dev The owner is the second storage variable so any implementing contract could pack other state with it\\n  /// instead of the much less used s_pendingOwner.\\n  address private s_owner;\\n\\n  error OwnerCannotBeZero();\\n  error MustBeProposedOwner();\\n  error CannotTransferToSelf();\\n  error OnlyCallableByOwner();\\n\\n  event OwnershipTransferRequested(address indexed from, address indexed to);\\n  event OwnershipTransferred(address indexed from, address indexed to);\\n\\n  constructor(address newOwner, address pendingOwner) {\\n    if (newOwner == address(0)) {\\n      revert OwnerCannotBeZero();\\n    }\\n\\n    s_owner = newOwner;\\n    if (pendingOwner != address(0)) {\\n      _transferOwnership(pendingOwner);\\n    }\\n  }\\n\\n  /// @notice Get the current owner\\n  function owner() public view override returns (address) {\\n    return s_owner;\\n  }\\n\\n  /// @notice Allows an owner to begin transferring ownership to a new address. The new owner needs to call\\n  /// `acceptOwnership` to accept the transfer before any permissions are changed.\\n  /// @param to The address to which ownership will be transferred.\\n  function transferOwnership(address to) public override onlyOwner {\\n    _transferOwnership(to);\\n  }\\n\\n  /// @notice validate, transfer ownership, and emit relevant events\\n  /// @param to The address to which ownership will be transferred.\\n  function _transferOwnership(address to) private {\\n    if (to == msg.sender) {\\n      revert CannotTransferToSelf();\\n    }\\n\\n    s_pendingOwner = to;\\n\\n    emit OwnershipTransferRequested(s_owner, to);\\n  }\\n\\n  /// @notice Allows an ownership transfer to be completed by the recipient.\\n  function acceptOwnership() external override {\\n    if (msg.sender != s_pendingOwner) {\\n      revert MustBeProposedOwner();\\n    }\\n\\n    address oldOwner = s_owner;\\n    s_owner = msg.sender;\\n    s_pendingOwner = address(0);\\n\\n    emit OwnershipTransferred(oldOwner, msg.sender);\\n  }\\n\\n  /// @notice validate access\\n  function _validateOwnership() internal view {\\n    if (msg.sender != s_owner) {\\n      revert OnlyCallableByOwner();\\n    }\\n  }\\n\\n  /// @notice Reverts if called by anyone other than the contract owner.\\n  modifier onlyOwner() {\\n    _validateOwnership();\\n    _;\\n  }\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2StepMsgSender.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {Ownable2Step} from \\\"./Ownable2Step.sol\\\";\\n\\n/// @notice Sets the msg.sender to be the owner of the contract and does not set a pending owner.\\ncontract Ownable2StepMsgSender is Ownable2Step {\\n  constructor() Ownable2Step(msg.sender, address(0)) {}\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/IOwnable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IOwnable {\\n  function owner() external returns (address);\\n\\n  function transferOwnership(address recipient) external;\\n\\n  function acceptOwnership() external;\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/ITypeAndVersion.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ITypeAndVersion {\\n  function typeAndVersion() external pure returns (string memory);\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v5.0.2/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v5.0.2/contracts/utils/structs/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position is the index of the value in the `values` array plus 1.\\n        // Position 0 is used to mean a value is not in the set.\\n        mapping(bytes32 value =\\u003e uint256) _positions;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._positions[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We cache the value's position to prevent multiple reads from the same storage slot\\n        uint256 position = set._positions[value];\\n\\n        if (position != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 valueIndex = position - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (valueIndex != lastIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the lastValue to the index where the value to delete is\\n                set._values[valueIndex] = lastValue;\\n                // Update the tracked position of the lastValue (that was just moved)\\n                set._positions[lastValue] = position;\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the tracked position for the deleted slot\\n            delete set._positions[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._positions[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"}}}"
