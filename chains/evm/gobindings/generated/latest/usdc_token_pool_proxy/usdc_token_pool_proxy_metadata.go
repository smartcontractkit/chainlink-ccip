// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.


package usdc_token_pool_proxy

var SolidityStandardInput = "{\"version\":\"v0.8.26+commit.8a97fa7a\",\"language\":\"Solidity\",\"settings\":{\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"appendCBOR\":true,\"bytecodeHash\":\"none\",\"useLiteralContent\":false},\"optimizer\":{\"enabled\":true,\"runs\":80000},\"outputSelection\":{\"contracts/interfaces/IPool.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/interfaces/IRMN.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/interfaces/IRouter.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/libraries/Client.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/libraries/ERC165CheckerReverting.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/libraries/Pool.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/libraries/RateLimiter.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/libraries/USDCSourcePoolDataCodec.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/pools/TokenPool.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/pools/USDC/CCTPMessageTransmitterProxy.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/pools/USDC/USDCTokenPool.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/pools/USDC/USDCTokenPoolProxy.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/pools/USDC/interfaces/IMessageTransmitter.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"contracts/pools/USDC/interfaces/ITokenMessenger.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/AuthorizedCallers.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2Step.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2StepMsgSender.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/IOwnable.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/ITypeAndVersion.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-4.8.3/token/ERC20/IERC20.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-4.8.3/token/ERC20/extensions/IERC20Metadata.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-4.8.3/token/ERC20/extensions/draft-IERC20Permit.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-4.8.3/token/ERC20/utils/SafeERC20.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-4.8.3/utils/Address.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-4.8.3/utils/introspection/IERC165.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-4.8.3/utils/structs/EnumerableSet.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.0.2/utils/introspection/IERC165.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]},\"node_modules/@openzeppelin/contracts-5.0.2/utils/structs/EnumerableSet.sol\":{\"\":[\"ast\"],\"*\":[\"abi\",\"evm.bytecode.object\",\"evm.bytecode.sourceMap\",\"evm.bytecode.linkReferences\",\"evm.deployedBytecode.object\",\"evm.deployedBytecode.sourceMap\",\"evm.deployedBytecode.linkReferences\",\"evm.deployedBytecode.immutableReferences\",\"evm.methodIdentifiers\",\"metadata\"]}},\"remappings\":[\"forge-std/=node_modules/@chainlink/contracts/src/v0.8/vendor/forge-std/src/\",\"@chainlink/contracts/=node_modules/@chainlink/contracts/\",\"@openzeppelin/contracts@4.8.3/=node_modules/@openzeppelin/contracts-4.8.3/\",\"@openzeppelin/contracts@5.0.2/=node_modules/@openzeppelin/contracts-5.0.2/\"],\"viaIR\":true},\"sources\":{\"contracts/interfaces/IPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {Pool} from \\\"../libraries/Pool.sol\\\";\\n\\nimport {IERC165} from \\\"@openzeppelin/contracts@5.0.2/utils/introspection/IERC165.sol\\\";\\n\\n/// @notice Shared public interface for multiple V1 pool types.\\n/// Each pool type handles a different child token model e.g. lock/unlock, mint/burn.\\ninterface IPoolV1 is IERC165 {\\n  /// @notice Lock tokens into the pool or burn the tokens.\\n  /// @param lockOrBurnIn Encoded data fields for the processing of tokens on the source chain.\\n  /// @return lockOrBurnOut Encoded data fields for the processing of tokens on the destination chain.\\n  function lockOrBurn(\\n    Pool.LockOrBurnInV1 calldata lockOrBurnIn\\n  ) external returns (Pool.LockOrBurnOutV1 memory lockOrBurnOut);\\n\\n  /// @notice Releases or mints tokens to the receiver address.\\n  /// @param releaseOrMintIn All data required to release or mint tokens.\\n  /// @return releaseOrMintOut The amount of tokens released or minted on the local chain, denominated\\n  /// in the local token's decimals.\\n  /// @dev The offRamp asserts that the balanceOf of the receiver has been incremented by exactly the number\\n  /// of tokens that is returned in ReleaseOrMintOutV1.destinationAmount. If the amounts do not match, the tx reverts.\\n  function releaseOrMint(\\n    Pool.ReleaseOrMintInV1 calldata releaseOrMintIn\\n  ) external returns (Pool.ReleaseOrMintOutV1 memory);\\n\\n  /// @notice Checks whether a remote chain is supported in the token pool.\\n  /// @param remoteChainSelector The selector of the remote chain.\\n  /// @return true if the given chain is a permissioned remote chain.\\n  function isSupportedChain(\\n    uint64 remoteChainSelector\\n  ) external view returns (bool);\\n\\n  /// @notice Returns if the token pool supports the given token.\\n  /// @param token The address of the token.\\n  /// @return true if the token is supported by the pool.\\n  function isSupportedToken(\\n    address token\\n  ) external view returns (bool);\\n}\\n\"},\"contracts/interfaces/IRMN.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice This interface contains the only RMN-related functions that might be used on-chain by other CCIP contracts.\\ninterface IRMN {\\n  /// @notice A Merkle root tagged with the address of the commit store contract it is destined for.\\n  struct TaggedRoot {\\n    address commitStore;\\n    bytes32 root;\\n  }\\n\\n  /// @notice Callers MUST NOT cache the return value as a blessed tagged root could become unblessed.\\n  function isBlessed(\\n    TaggedRoot calldata taggedRoot\\n  ) external view returns (bool);\\n\\n  /// @notice Iff there is an active global or legacy curse, this function returns true.\\n  function isCursed() external view returns (bool);\\n\\n  /// @notice Iff there is an active global curse, or an active curse for `subject`, this function returns true.\\n  /// @param subject To check whether a particular chain is cursed, set to bytes16(uint128(chainSelector)).\\n  function isCursed(\\n    bytes16 subject\\n  ) external view returns (bool);\\n}\\n\"},\"contracts/interfaces/IRouter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {Client} from \\\"../libraries/Client.sol\\\";\\n\\ninterface IRouter {\\n  error OnlyOffRamp();\\n\\n  /// @notice Route the message to its intended receiver contract.\\n  /// @param message Client.Any2EVMMessage struct.\\n  /// @param gasForCallExactCheck of params for exec.\\n  /// @param gasLimit set of params for exec.\\n  /// @param receiver set of params for exec.\\n  /// @dev if the receiver is a contracts that signals support for CCIP execution through EIP-165.\\n  /// the contract is called. If not, only tokens are transferred.\\n  /// @return success A boolean value indicating whether the ccip message was received without errors.\\n  /// @return retBytes A bytes array containing return data form CCIP receiver.\\n  /// @return gasUsed the gas used by the external customer call. Does not include any overhead.\\n  function routeMessage(\\n    Client.Any2EVMMessage calldata message,\\n    uint16 gasForCallExactCheck,\\n    uint256 gasLimit,\\n    address receiver\\n  ) external returns (bool success, bytes memory retBytes, uint256 gasUsed);\\n\\n  /// @notice Returns the configured onRamp for a specific destination chain.\\n  /// @param destChainSelector The destination chain Id to get the onRamp for.\\n  /// @return onRampAddress The address of the onRamp.\\n  function getOnRamp(\\n    uint64 destChainSelector\\n  ) external view returns (address onRampAddress);\\n\\n  /// @notice Return true if the given offRamp is a configured offRamp for the given source chain.\\n  /// @param sourceChainSelector The source chain selector to check.\\n  /// @param offRamp The address of the offRamp to check.\\n  function isOffRamp(uint64 sourceChainSelector, address offRamp) external view returns (bool isOffRamp);\\n}\\n\"},\"contracts/libraries/Client.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// End consumer library.\\nlibrary Client {\\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\\n  struct EVMTokenAmount {\\n    address token; // token address on the local chain.\\n    uint256 amount; // Amount of tokens.\\n  }\\n\\n  struct Any2EVMMessage {\\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\\n    uint64 sourceChainSelector; // Source chain selector.\\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\\n    bytes data; // payload sent in original message.\\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\\n  }\\n\\n  // If extraArgs is empty bytes, the default is 200k gas limit.\\n  struct EVM2AnyMessage {\\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains.\\n    bytes data; // Data payload.\\n    EVMTokenAmount[] tokenAmounts; // Token transfers.\\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV2).\\n  }\\n\\n  // Tag to indicate only a gas limit. Only usable for EVM as destination chain.\\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\\n\\n  struct EVMExtraArgsV1 {\\n    uint256 gasLimit;\\n  }\\n\\n  function _argsToBytes(\\n    EVMExtraArgsV1 memory extraArgs\\n  ) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\\n  }\\n\\n  // Tag to indicate a gas limit (or dest chain equivalent processing units) and Out Of Order Execution. This tag is\\n  // available for multiple chain families. If there is no chain family specific tag, this is the default available\\n  // for a chain.\\n  // Note: not available for Solana VM based chains.\\n  bytes4 public constant GENERIC_EXTRA_ARGS_V2_TAG = 0x181dcf10;\\n\\n  /// @param gasLimit: gas limit for the callback on the destination chain.\\n  /// @param allowOutOfOrderExecution: if true, it indicates that the message can be executed in any order relative to\\n  /// other messages from the same sender. This value's default varies by chain. On some chains, a particular value is\\n  /// enforced, meaning if the expected value is not set, the message request will revert.\\n  /// @dev Fully compatible with the previously existing EVMExtraArgsV2.\\n  struct GenericExtraArgsV2 {\\n    uint256 gasLimit;\\n    bool allowOutOfOrderExecution;\\n  }\\n\\n  // Extra args tag for chains that use the Sui VM.\\n  bytes4 public constant SUI_EXTRA_ARGS_V1_TAG = 0x21ea4ca9;\\n\\n  // Extra args tag for chains that use the Solana VM.\\n  bytes4 public constant SVM_EXTRA_ARGS_V1_TAG = 0x1f3b3aba;\\n\\n  struct SVMExtraArgsV1 {\\n    uint32 computeUnits;\\n    uint64 accountIsWritableBitmap;\\n    bool allowOutOfOrderExecution;\\n    bytes32 tokenReceiver;\\n    // Additional accounts needed for execution of CCIP receiver. Must be empty if message.receiver is zero.\\n    // Token transfer related accounts are specified in the token pool lookup table on SVM.\\n    bytes32[] accounts;\\n  }\\n\\n  /// @dev The maximum number of accounts that can be passed in SVMExtraArgs.\\n  uint256 public constant SVM_EXTRA_ARGS_MAX_ACCOUNTS = 64;\\n\\n  /// @dev The expected static payload size of a token transfer when Borsh encoded and submitted to SVM.\\n  /// TokenPool extra data and offchain data sizes are dynamic, and should be accounted for separately.\\n  uint256 public constant SVM_TOKEN_TRANSFER_DATA_OVERHEAD = (4 + 32) // source_pool\\n    + 32 // token_address\\n    + 4 // gas_amount\\n    + 4 // extra_data overhead\\n    + 32 // amount\\n    + 32 // size of the token lookup table account\\n    + 32 // token-related accounts in the lookup table, over-estimated to 32, typically between 11 - 13\\n    + 32 // token account belonging to the token receiver, e.g ATA, not included in the token lookup table\\n    + 32 // per-chain token pool config, not included in the token lookup table\\n    + 32 // per-chain token billing config, not always included in the token lookup table\\n    + 32; // OffRamp pool signer PDA, not included in the token lookup table\\n\\n  /// @dev Number of overhead accounts needed for message execution on SVM.\\n  /// @dev These are message.receiver, and the OffRamp Signer PDA specific to the receiver.\\n  uint256 public constant SVM_MESSAGING_ACCOUNTS_OVERHEAD = 2;\\n\\n  /// @dev The size of each SVM account address in bytes.\\n  uint256 public constant SVM_ACCOUNT_BYTE_SIZE = 32;\\n\\n  struct SuiExtraArgsV1 {\\n    uint256 gasLimit;\\n    bool allowOutOfOrderExecution;\\n    bytes32 tokenReceiver;\\n    bytes32[] receiverObjectIds;\\n  }\\n\\n  /// @dev The expected static payload size of a token transfer when BCS encoded and submitted to SUI.\\n  /// TokenPool extra data and offchain data sizes are dynamic, and should be accounted for separately.\\n  uint256 public constant SUI_TOKEN_TRANSFER_DATA_OVERHEAD = (4 + 32) // source_pool, 4 bytes for length, 32 bytes for address\\n    + 32 // dest_token_address\\n    + 4 // dest_gas_amount\\n    + 4 // extra_data length, the contents are calculated separately\\n    + 32; // amount\\n\\n  /// @dev Number of overhead accounts needed for message execution on SUI.\\n  /// @dev This is the message.receiver.\\n  uint256 public constant SUI_MESSAGING_ACCOUNTS_OVERHEAD = 1;\\n\\n  /// @dev The maximum number of receiver object ids that can be passed in SuiExtraArgs.\\n  uint256 public constant SUI_EXTRA_ARGS_MAX_RECEIVER_OBJECT_IDS = 64;\\n\\n  /// @dev The size of each SUI account address in bytes.\\n  uint256 public constant SUI_ACCOUNT_BYTE_SIZE = 32;\\n\\n  function _argsToBytes(\\n    GenericExtraArgsV2 memory extraArgs\\n  ) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(GENERIC_EXTRA_ARGS_V2_TAG, extraArgs);\\n  }\\n\\n  function _svmArgsToBytes(\\n    SVMExtraArgsV1 memory extraArgs\\n  ) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(SVM_EXTRA_ARGS_V1_TAG, extraArgs);\\n  }\\n\\n  function _suiArgsToBytes(\\n    SuiExtraArgsV1 memory extraArgs\\n  ) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(SUI_EXTRA_ARGS_V1_TAG, extraArgs);\\n  }\\n}\\n\"},\"contracts/libraries/ERC165CheckerReverting.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IERC165} from \\\"@openzeppelin/contracts@4.8.3/utils/introspection/IERC165.sol\\\";\\n\\n/// @notice Library used to query support of an interface declared via {IERC165}.\\n/// @dev These functions return the actual result of the query: they do not `revert` if an interface is not supported.\\nlibrary ERC165CheckerReverting {\\n  error InsufficientGasForStaticCall();\\n\\n  // As per the EIP-165 spec, no interface should ever match 0xffffffff.\\n  bytes4 private constant INTERFACE_ID_INVALID = 0xffffffff;\\n\\n  /// @dev 30k gas is required to make the staticcall. Under the 63/64 rule this means that 30,477 gas must be available\\n  /// to ensure that at least 30k is forwarded. Checking for at least 31,000 ensures that after additional\\n  /// operations are performed there is still \\u003e= 30,477 gas remaining.\\n  /// 30,000 = ((30,477 * 63) / 64)\\n  uint256 private constant MINIMUM_GAS_REQUIREMENT = 31_000;\\n\\n  /// @notice Returns true if `account` supports a defined interface.\\n  /// @dev The function must support both the interfaceId and interfaces specified by ERC165 generally as per the standard.\\n  /// @param account the contract to be queried for support.\\n  /// @param interfaceId the interface being checked for support.\\n  /// @return true if the contract at account indicates support of the interface with, false otherwise.\\n  function _supportsInterfaceReverting(address account, bytes4 interfaceId) internal view returns (bool) {\\n    // As a gas optimization, short circuit return false if interfaceId is not supported, as it is most likely interfaceId\\n    // to be unsupported by the target.\\n    return _supportsERC165InterfaceUncheckedReverting(account, interfaceId)\\n      \\u0026\\u0026 !_supportsERC165InterfaceUncheckedReverting(account, INTERFACE_ID_INVALID)\\n      \\u0026\\u0026 _supportsERC165InterfaceUncheckedReverting(account, type(IERC165).interfaceId);\\n  }\\n\\n  /// @notice Query if a contract implements an interface, does not check ERC165 support\\n  /// @param account The address of the contract to query for support of an interface\\n  /// @param interfaceId The interface identifier, as specified in ERC-165\\n  /// @return true if the contract at account indicates support of the interface with\\n  /// identifier interfaceId, false otherwise\\n  /// @dev Assumes that account contains a contract that supports ERC165, otherwise\\n  /// the behavior of this method is undefined. This precondition can be checked.\\n  /// @dev Function will only revert if the minimum gas requirement is not met before the staticcall is performed.\\n  function _supportsERC165InterfaceUncheckedReverting(address account, bytes4 interfaceId) internal view returns (bool) {\\n    bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\\n\\n    bool success;\\n    uint256 returnSize;\\n    uint256 returnValue;\\n\\n    bytes4 notEnoughGasSelector = InsufficientGasForStaticCall.selector;\\n\\n    assembly {\\n      // The EVM does not return a specific error code if a revert is due to OOG. This check ensures that\\n      // the message will not throw an OOG error by requiring that the amount of gas for the following\\n      // staticcall exists before invoking it.\\n      if lt(gas(), MINIMUM_GAS_REQUIREMENT) {\\n        mstore(0x0, notEnoughGasSelector)\\n        revert(0x0, 0x4)\\n      }\\n\\n      success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\\n      returnSize := returndatasize()\\n      returnValue := mload(0x00)\\n    }\\n    return success \\u0026\\u0026 returnSize \\u003e= 0x20 \\u0026\\u0026 returnValue \\u003e 0;\\n  }\\n}\\n\"},\"contracts/libraries/Pool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice This library contains various token pool functions to aid constructing the return data.\\nlibrary Pool {\\n  // The tag used to signal support for the pool v1 standard.\\n  // bytes4(keccak256(\\\"CCIP_POOL_V1\\\"))\\n  bytes4 public constant CCIP_POOL_V1 = 0xaff2afbf;\\n\\n  // The tag used to signal support for the pool v1 standard.\\n  // bytes4(keccak256(\\\"CCIP_POOL_V2\\\"))\\n  bytes4 public constant CCIP_POOL_V2 = 0xf208a58f;\\n\\n  // The number of bytes in the return data for a pool v1 releaseOrMint call.\\n  // This should match the size of the ReleaseOrMintOutV1 struct.\\n  uint16 public constant CCIP_POOL_V1_RET_BYTES = 32;\\n\\n  // The default max number of bytes in the return data for a pool v1 lockOrBurn call.\\n  // This data can be used to send information to the destination chain token pool. Can be overwritten\\n  // in the TokenTransferFeeConfig.destBytesOverhead if more data is required.\\n  uint32 public constant CCIP_LOCK_OR_BURN_V1_RET_BYTES = 32;\\n\\n  struct LockOrBurnInV1 {\\n    bytes receiver; //  The recipient of the tokens on the destination chain, abi encoded.\\n    uint64 remoteChainSelector; // ─╮ The chain ID of the destination chain.\\n    address originalSender; // ─────╯ The original sender of the tx on the source chain.\\n    uint256 amount; //  The amount of tokens to lock or burn, denominated in the source token's decimals.\\n    address localToken; //  The address on this chain of the token to lock or burn.\\n  }\\n\\n  struct LockOrBurnOutV1 {\\n    // The address of the destination token, abi encoded in the case of EVM chains.\\n    // This value is UNTRUSTED as any pool owner can return whatever value they want.\\n    bytes destTokenAddress;\\n    // Optional pool data to be transferred to the destination chain. Be default this is capped at\\n    // CCIP_LOCK_OR_BURN_V1_RET_BYTES bytes. If more data is required, the TokenTransferFeeConfig.destBytesOverhead\\n    // has to be set for the specific token.\\n    bytes destPoolData;\\n  }\\n\\n  struct ReleaseOrMintInV1 {\\n    bytes originalSender; //            The original sender of the tx on the source chain.\\n    uint64 remoteChainSelector; // ───╮ The chain ID of the source chain.\\n    address receiver; // ─────────────╯ The recipient of the tokens on the destination chain.\\n    uint256 sourceDenominatedAmount; // The amount of tokens to release or mint, denominated in the source token's decimals.\\n    address localToken; //              The address on this chain of the token to release or mint.\\n    /// @dev WARNING: sourcePoolAddress should be checked prior to any processing of funds. Make sure it matches the\\n    /// expected pool address for the given remoteChainSelector.\\n    bytes sourcePoolAddress; //         The address of the source pool, abi encoded in the case of EVM chains.\\n    bytes sourcePoolData; //            The data received from the source pool to process the release or mint.\\n    /// @dev WARNING: offchainTokenData is untrusted data.\\n    bytes offchainTokenData; //         The offchain data to process the release or mint.\\n  }\\n\\n  struct ReleaseOrMintOutV1 {\\n    // The number of tokens released or minted on the destination chain, denominated in the local token's decimals.\\n    // This value is expected to be equal to the ReleaseOrMintInV1.amount in the case where the source and destination\\n    // chain have the same number of decimals.\\n    uint256 destinationAmount;\\n  }\\n}\\n\"},\"contracts/libraries/RateLimiter.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.4;\\n\\n/// @notice Implements Token Bucket rate limiting.\\n/// @dev uint128 is safe for rate limiter state.\\n/// - For USD value rate limiting, it can adequately store USD value in 18 decimals.\\n/// - For ERC20 token amount rate limiting, all tokens that will be listed will have at most a supply of uint128.max\\n/// tokens, and it will therefore not overflow the bucket. In exceptional scenarios where tokens consumed may be larger\\n/// than uint128, e.g. compromised issuer, an enabled RateLimiter will check and revert.\\nlibrary RateLimiter {\\n  error BucketOverfilled();\\n  error TokenMaxCapacityExceeded(uint256 capacity, uint256 requested, address tokenAddress);\\n  error TokenRateLimitReached(uint256 minWaitInSeconds, uint256 available, address tokenAddress);\\n  error InvalidRateLimitRate(Config rateLimiterConfig);\\n  error DisabledNonZeroRateLimit(Config config);\\n\\n  event ConfigChanged(Config config);\\n\\n  struct TokenBucket {\\n    uint128 tokens; // ────╮ Current number of tokens that are in the bucket.\\n    uint32 lastUpdated; // │ Timestamp in seconds of the last token refill, good for 100+ years.\\n    bool isEnabled; // ────╯ Indication whether the rate limiting is enabled or not.\\n    uint128 capacity; // ──╮ Maximum number of tokens that can be in the bucket.\\n    uint128 rate; // ──────╯ Number of tokens per second that the bucket is refilled.\\n  }\\n\\n  struct Config {\\n    bool isEnabled; // Indication whether the rate limiting should be enabled.\\n    uint128 capacity; // ──╮ Specifies the capacity of the rate limiter.\\n    uint128 rate; //  ─────╯ Specifies the rate of the rate limiter.\\n  }\\n\\n  /// @notice _consume removes the given tokens from the pool, lowering the rate tokens allowed to be\\n  /// consumed for subsequent calls.\\n  /// @param requestTokens The total tokens to be consumed from the bucket.\\n  /// @param tokenAddress The token to consume capacity for, use 0x0 to indicate aggregate value capacity.\\n  /// @dev Reverts when requestTokens exceeds bucket capacity or available tokens in the bucket.\\n  /// @dev emits removal of requestTokens if requestTokens is \\u003e 0.\\n  function _consume(TokenBucket storage s_bucket, uint256 requestTokens, address tokenAddress) internal {\\n    // If there is no value to remove or rate limiting is turned off, skip this step to reduce gas usage.\\n    if (!s_bucket.isEnabled || requestTokens == 0) {\\n      return;\\n    }\\n\\n    uint256 tokens = s_bucket.tokens;\\n    uint256 capacity = s_bucket.capacity;\\n    uint256 timeDiff = block.timestamp - s_bucket.lastUpdated;\\n\\n    if (timeDiff != 0) {\\n      if (tokens \\u003e capacity) revert BucketOverfilled();\\n\\n      // Refill tokens when arriving at a new block time.\\n      tokens = _calculateRefill(capacity, tokens, timeDiff, s_bucket.rate);\\n\\n      s_bucket.lastUpdated = uint32(block.timestamp);\\n    }\\n\\n    if (capacity \\u003c requestTokens) {\\n      revert TokenMaxCapacityExceeded(capacity, requestTokens, tokenAddress);\\n    }\\n    if (tokens \\u003c requestTokens) {\\n      uint256 rate = s_bucket.rate;\\n      // Wait required until the bucket is refilled enough to accept this value, round up to next higher second.\\n      // Consume is not guaranteed to succeed after wait time passes if there is competing traffic.\\n      // This acts as a lower bound of wait time.\\n      uint256 minWaitInSeconds = ((requestTokens - tokens) + (rate - 1)) / rate;\\n\\n      revert TokenRateLimitReached(minWaitInSeconds, tokens, tokenAddress);\\n    }\\n    tokens -= requestTokens;\\n\\n    // Downcast is safe here, as tokens is not larger than capacity.\\n    s_bucket.tokens = uint128(tokens);\\n  }\\n\\n  /// @notice Gets the token bucket with its values for the block it was requested at.\\n  /// @return The token bucket.\\n  function _currentTokenBucketState(\\n    TokenBucket memory bucket\\n  ) internal view returns (TokenBucket memory) {\\n    // We update the bucket to reflect the status at the exact time of the call. This means we might need to refill a\\n    // part of the bucket based on the time that has passed since the last update.\\n    bucket.tokens =\\n      uint128(_calculateRefill(bucket.capacity, bucket.tokens, block.timestamp - bucket.lastUpdated, bucket.rate));\\n    bucket.lastUpdated = uint32(block.timestamp);\\n    return bucket;\\n  }\\n\\n  /// @notice Sets the rate limited config.\\n  /// @param s_bucket The token bucket.\\n  /// @param config The new config.\\n  function _setTokenBucketConfig(TokenBucket storage s_bucket, Config memory config) internal {\\n    // First update the bucket to make sure the proper rate is used for all the time up until the config change.\\n    uint256 timeDiff = block.timestamp - s_bucket.lastUpdated;\\n    if (timeDiff != 0) {\\n      s_bucket.tokens = uint128(_calculateRefill(s_bucket.capacity, s_bucket.tokens, timeDiff, s_bucket.rate));\\n\\n      s_bucket.lastUpdated = uint32(block.timestamp);\\n    }\\n\\n    s_bucket.tokens = uint128(_min(config.capacity, s_bucket.tokens));\\n    s_bucket.isEnabled = config.isEnabled;\\n    s_bucket.capacity = config.capacity;\\n    s_bucket.rate = config.rate;\\n\\n    emit ConfigChanged(config);\\n  }\\n\\n  /// @notice Validates the token bucket config.\\n  function _validateTokenBucketConfig(\\n    Config memory config\\n  ) internal pure {\\n    if (config.isEnabled) {\\n      if (config.rate \\u003e config.capacity) {\\n        revert InvalidRateLimitRate(config);\\n      }\\n    } else {\\n      if (config.rate != 0 || config.capacity != 0) {\\n        revert DisabledNonZeroRateLimit(config);\\n      }\\n    }\\n  }\\n\\n  /// @notice Calculate refilled tokens.\\n  /// @param capacity bucket capacity.\\n  /// @param tokens current bucket tokens.\\n  /// @param timeDiff block time difference since last refill.\\n  /// @param rate bucket refill rate.\\n  /// @return the value of tokens after refill.\\n  function _calculateRefill(\\n    uint256 capacity,\\n    uint256 tokens,\\n    uint256 timeDiff,\\n    uint256 rate\\n  ) private pure returns (uint256) {\\n    return _min(capacity, tokens + timeDiff * rate);\\n  }\\n\\n  /// @notice Return the smallest of two integers.\\n  /// @param a first int.\\n  /// @param b second int.\\n  /// @return smallest.\\n  function _min(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a \\u003c b ? a : b;\\n  }\\n}\\n\"},\"contracts/libraries/USDCSourcePoolDataCodec.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\n/// @notice Library for encoding and decoding the source pool data for the USDC token pool based on the CCTP version.\\n/// @dev While every version of a CCTP-enabled pool has a different source pool data format, the encoding and decoding\\n/// schemes are similar in a few ways. Each source pool data format is prefixed with a version number, in bytes4 format.\\n/// It is then encodePacked() with each of the sourceTokenDataPayload fields. Decoding means parsing the bytes array\\n/// into the corresponding sourceTokenDataPayload struct by parsing each field individually and then assembling them\\n/// into the corresponding struct. This adds some additional gas overhead during decoding, but the benefits of saving\\n/// space on the source pool data outweigh the overhead.\\n/// @dev Any future versions of CCTP should include in this library a new function for encoding and decoding the source\\n/// pool data accordingly.\\nlibrary USDCSourcePoolDataCodec {\\n  error InvalidVersion(bytes4 version);\\n\\n  /// @dev The flag used to indicate that the source pool data is coming from a chain that does not have CCTP Support,\\n  /// and so the lock release pool should be used. The BurnMintWithLockReleaseTokenPool uses this flag as its source pool\\n  /// data to indicate that the tokens should be released from the lock release pool rather than attempting to be minted\\n  /// through CCTP.\\n  /// @dev The preimage is bytes4(keccak256(\\\"NO_CCTP_USE_LOCK_RELEASE\\\")).\\n  bytes4 public constant LOCK_RELEASE_FLAG = 0xfa7c07de;\\n\\n  /// @dev The preimage is bytes4(keccak256(\\\"CCTP_V1\\\"))\\n  bytes4 public constant CCTP_VERSION_1_TAG = 0xf3567d18;\\n\\n  /// @dev There are two different tags for CCTP V2 to allow for CCIP V1.7 Compatibility which will enable fast transfers.\\n  /// Both tags will route to the same CCTP V2 pool, but will allow for pools to identify the type of transfer (slow or fast).\\n\\n  /// @dev The preimage is bytes4(keccak256(\\\"CCTP_V2\\\"))\\n  bytes4 public constant CCTP_VERSION_2_TAG = 0xb148ea5f;\\n\\n  /// @dev The preimage is bytes4(keccak256(\\\"CCTP_V2_CCV\\\"))\\n  bytes4 public constant CCTP_VERSION_2_CCV_TAG = 0x3047587c;\\n\\n  /// Note: Since this struct never exists in storage, only in memory after an ABI-decoding, proper struct-packing\\n  /// is not necessary and field ordering has been defined so as to best support off-chain code.\\n  /// @dev This struct has been titled for version 1 to indicate that it should be used for CCTP V1 messages.\\n  struct SourceTokenDataPayloadV1 {\\n    uint64 nonce; // Nonce of the message returned from the depositForBurnWithCaller() call to the CCTP contracts.\\n    uint32 sourceDomain; // Source domain of the message.\\n  }\\n\\n  /// @dev This struct has been titled for version 2 to indicate that it should be used for CCTP V2 messages. Whether\\n  /// it is a slow or fast transfer is irrelevant as it will be routed to the same destination CCTP V2 pool regardless.\\n  struct SourceTokenDataPayloadV2 {\\n    uint32 sourceDomain;\\n    bytes32 depositHash;\\n  }\\n\\n  /// @notice Encodes the source token data payload into a bytes array.\\n  /// @dev By using abi.encodePacked(), significant amount of space on the source pool data is saved.\\n  /// since abi.encode pads every field to the nearest 32 bytes. While it adds some overhead during decoding, the\\n  /// benefits of saving space on the source pool data outweigh the overhead.\\n  /// @param sourceTokenDataPayload The source token data payload to encode.\\n  /// @return The encoded source token data payload.\\n  function _encodeSourceTokenDataPayloadV1(\\n    SourceTokenDataPayloadV1 memory sourceTokenDataPayload\\n  ) internal pure returns (bytes memory) {\\n    return abi.encodePacked(CCTP_VERSION_1_TAG, sourceTokenDataPayload.nonce, sourceTokenDataPayload.sourceDomain);\\n  }\\n\\n  /// @notice Encodes the source token data payload into a bytes array using the CCTP V2 tag.\\n  /// @param sourceTokenDataPayload The source token data payload to encode.\\n  /// @return The encoded source token data payload.\\n  function _encodeSourceTokenDataPayloadV2(\\n    SourceTokenDataPayloadV2 memory sourceTokenDataPayload\\n  ) internal pure returns (bytes memory) {\\n    return abi.encodePacked(CCTP_VERSION_2_TAG, sourceTokenDataPayload.sourceDomain, sourceTokenDataPayload.depositHash);\\n  }\\n\\n  /// @notice Encodes the source token data payload into a bytes array using the CCTP V2 CCV tag.\\n  /// @param sourceTokenDataPayload The source token data payload to encode.\\n  /// @return The encoded source token data payload.\\n  function _encodeSourceTokenDataPayloadV2CCV(\\n    SourceTokenDataPayloadV2 memory sourceTokenDataPayload\\n  ) internal pure returns (bytes memory) {\\n    return\\n      abi.encodePacked(CCTP_VERSION_2_CCV_TAG, sourceTokenDataPayload.sourceDomain, sourceTokenDataPayload.depositHash);\\n  }\\n\\n  /// @notice Decodes the abi.encodePacked() source pool data into its corresponding SourceTokenDataPayload struct.\\n  /// @param sourcePoolData The source pool data to decode in raw bytes.\\n  /// @return sourceTokenDataPayload The decoded source token data payload.\\n  function _decodeSourceTokenDataPayloadV2(\\n    bytes memory sourcePoolData\\n  ) internal pure returns (SourceTokenDataPayloadV2 memory sourceTokenDataPayload) {\\n    bytes4 version;\\n    uint32 sourceDomain;\\n    bytes32 depositHash;\\n\\n    assembly {\\n      // Load version (first 4 bytes of data, offset 32 to skip the length slot)\\n      version := mload(add(sourcePoolData, 32))\\n      // Load sourceDomain (next 4 bytes, offset 36 (32 + 4)) - shift right by 224 bits to get left-most 4 bytes\\n      // offset 36 = 32 (length slot) + 4 (uint32)\\n      // shift right by 224 = 256 - 32 (uint32)\\n      sourceDomain := shr(224, mload(add(sourcePoolData, 36)))\\n      // Load depositHash (next 32 bytes) - Since depositHash is a bytes32, no shifting is needed.\\n      // offset 40 = 32 (length slot) + 4 (bytes4) + 4 (uint32)\\n      depositHash := mload(add(sourcePoolData, 40))\\n    }\\n\\n    if (version != CCTP_VERSION_2_TAG \\u0026\\u0026 version != CCTP_VERSION_2_CCV_TAG) revert InvalidVersion(version);\\n\\n    sourceTokenDataPayload.sourceDomain = sourceDomain;\\n    sourceTokenDataPayload.depositHash = depositHash;\\n\\n    return sourceTokenDataPayload;\\n  }\\n\\n  /// @notice Decodes the abi.encodePacked() source pool data into its corresponding SourceTokenDataPayload struct.\\n  /// @param sourcePoolData The source pool data to decode in raw bytes.\\n  /// @return sourceTokenDataPayload The decoded source token data payload.\\n  function _decodeSourceTokenDataPayloadV1(\\n    bytes memory sourcePoolData\\n  ) internal pure returns (SourceTokenDataPayloadV1 memory sourceTokenDataPayload) {\\n    bytes4 version;\\n    uint64 nonce;\\n    uint32 sourceDomain;\\n\\n    assembly {\\n      // Load version (first 4 bytes of data, offset 32 to skip the length slot)\\n      version := mload(add(sourcePoolData, 32))\\n      // Load nonce (next 8 bytes, offset 36) - shift right by 192 bits to get left-most 8 bytes\\n      // offset 36 = 32 (length slot) + 4 (uint64)\\n      // shift right by 192 = 256 - 64 (uint64)\\n      nonce := shr(192, mload(add(sourcePoolData, 36)))\\n      // Load sourceDomain (next 4 bytes, offset 44) - shift right by 224 bits to get leftmost 4 bytes\\n      // offset 44 = 32 (length slot) + 4 (bytes4) 8 (uint64)\\n      // shift right by 224 = 256 - 32 (uint32)\\n      sourceDomain := shr(224, mload(add(sourcePoolData, 44)))\\n    }\\n\\n    if (version != CCTP_VERSION_1_TAG) revert InvalidVersion(version);\\n\\n    sourceTokenDataPayload.nonce = nonce;\\n    sourceTokenDataPayload.sourceDomain = sourceDomain;\\n\\n    return sourceTokenDataPayload;\\n  }\\n\\n  /// @notice Calculates the deposit hash for the source pool data.\\n  /// @param sourceDomain The source domain of the message.\\n  /// @param amount The amount of the message.\\n  /// @param destinationDomain The destination domain of the message.\\n  /// @param mintRecipient The mint recipient of the message.\\n  /// @param burnToken The burn token of the message.\\n  /// @param destinationCaller The destination caller of the message.\\n  /// @param maxFee The max fee of the message.\\n  /// @param minFinalityThreshold The min finality threshold of the message.\\n  /// @return depositHash The deposit hash of the source pool data which will be matched off-chain to its CCTP attestation.\\n  function _calculateDepositHash(\\n    uint32 sourceDomain,\\n    uint256 amount,\\n    uint32 destinationDomain,\\n    bytes32 mintRecipient,\\n    bytes32 burnToken,\\n    bytes32 destinationCaller,\\n    uint256 maxFee,\\n    uint32 minFinalityThreshold\\n  ) internal pure returns (bytes32) {\\n    return keccak256(\\n      abi.encode(\\n        sourceDomain,\\n        amount,\\n        destinationDomain,\\n        mintRecipient,\\n        burnToken,\\n        destinationCaller,\\n        maxFee,\\n        minFinalityThreshold\\n      )\\n    );\\n  }\\n}\\n\"},\"contracts/pools/TokenPool.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\nimport {IPoolV1} from \\\"../interfaces/IPool.sol\\\";\\nimport {IRMN} from \\\"../interfaces/IRMN.sol\\\";\\nimport {IRouter} from \\\"../interfaces/IRouter.sol\\\";\\n\\nimport {Pool} from \\\"../libraries/Pool.sol\\\";\\nimport {RateLimiter} from \\\"../libraries/RateLimiter.sol\\\";\\nimport {Ownable2StepMsgSender} from \\\"@chainlink/contracts/src/v0.8/shared/access/Ownable2StepMsgSender.sol\\\";\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts@4.8.3/token/ERC20/IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts@4.8.3/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport {IERC165} from \\\"@openzeppelin/contracts@5.0.2/utils/introspection/IERC165.sol\\\";\\nimport {EnumerableSet} from \\\"@openzeppelin/contracts@5.0.2/utils/structs/EnumerableSet.sol\\\";\\n\\n/// @notice Base abstract class with common functions for all token pools.\\n/// A token pool serves as isolated place for holding tokens and token specific logic\\n/// that may execute as tokens move across the bridge.\\n/// @dev This pool supports different decimals on different chains but using this feature could impact the total number\\n/// of tokens in circulation. Since all of the tokens are locked/burned on the source, and a rounded amount is\\n/// minted/released on the destination, the number of tokens minted/released could be less than the number of tokens\\n/// burned/locked. This is because the source chain does not know about the destination token decimals. This is not a\\n/// problem if the decimals are the same on both chains.\\n///\\n/// Example:\\n/// Assume there is a token with 6 decimals on chain A and 3 decimals on chain B.\\n/// - 1.234567 tokens are burned on chain A.\\n/// - 1.234    tokens are minted on chain B.\\n/// When sending the 1.234 tokens back to chain A, you will receive 1.234000 tokens on chain A, effectively losing\\n/// 0.000567 tokens.\\n/// In the case of a burnMint pool on chain A, these funds are burned in the pool on chain A.\\n/// In the case of a lockRelease pool on chain A, these funds accumulate in the pool on chain A.\\nabstract contract TokenPool is IPoolV1, Ownable2StepMsgSender {\\n  using EnumerableSet for EnumerableSet.Bytes32Set;\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n  using EnumerableSet for EnumerableSet.UintSet;\\n  using RateLimiter for RateLimiter.TokenBucket;\\n\\n  error CallerIsNotARampOnRouter(address caller);\\n  error ZeroAddressInvalid();\\n  error SenderNotAllowed(address sender);\\n  error AllowListNotEnabled();\\n  error NonExistentChain(uint64 remoteChainSelector);\\n  error ChainNotAllowed(uint64 remoteChainSelector);\\n  error CursedByRMN();\\n  error ChainAlreadyExists(uint64 chainSelector);\\n  error InvalidSourcePoolAddress(bytes sourcePoolAddress);\\n  error InvalidToken(address token);\\n  error Unauthorized(address caller);\\n  error PoolAlreadyAdded(uint64 remoteChainSelector, bytes remotePoolAddress);\\n  error InvalidRemotePoolForChain(uint64 remoteChainSelector, bytes remotePoolAddress);\\n  error InvalidRemoteChainDecimals(bytes sourcePoolData);\\n  error MismatchedArrayLengths();\\n  error OverflowDetected(uint8 remoteDecimals, uint8 localDecimals, uint256 remoteAmount);\\n  error InvalidDecimalArgs(uint8 expected, uint8 actual);\\n\\n  event LockedOrBurned(uint64 indexed remoteChainSelector, address token, address sender, uint256 amount);\\n  event ReleasedOrMinted(\\n    uint64 indexed remoteChainSelector, address token, address sender, address recipient, uint256 amount\\n  );\\n  event ChainAdded(\\n    uint64 remoteChainSelector,\\n    bytes remoteToken,\\n    RateLimiter.Config outboundRateLimiterConfig,\\n    RateLimiter.Config inboundRateLimiterConfig\\n  );\\n  event ChainConfigured(\\n    uint64 remoteChainSelector,\\n    RateLimiter.Config outboundRateLimiterConfig,\\n    RateLimiter.Config inboundRateLimiterConfig\\n  );\\n  event ChainRemoved(uint64 remoteChainSelector);\\n  event RemotePoolAdded(uint64 indexed remoteChainSelector, bytes remotePoolAddress);\\n  event RemotePoolRemoved(uint64 indexed remoteChainSelector, bytes remotePoolAddress);\\n  event AllowListAdd(address sender);\\n  event AllowListRemove(address sender);\\n  event RouterUpdated(address oldRouter, address newRouter);\\n  event RateLimitAdminSet(address rateLimitAdmin);\\n  event OutboundRateLimitConsumed(uint64 indexed remoteChainSelector, address token, uint256 amount);\\n  event InboundRateLimitConsumed(uint64 indexed remoteChainSelector, address token, uint256 amount);\\n\\n  struct ChainUpdate {\\n    uint64 remoteChainSelector; // Remote chain selector\\n    bytes[] remotePoolAddresses; // Address of the remote pool, ABI encoded in the case of a remote EVM chain.\\n    bytes remoteTokenAddress; // Address of the remote token, ABI encoded in the case of a remote EVM chain.\\n    RateLimiter.Config outboundRateLimiterConfig; // Outbound rate limited config, meaning the rate limits for all of the onRamps for the given chain\\n    RateLimiter.Config inboundRateLimiterConfig; // Inbound rate limited config, meaning the rate limits for all of the offRamps for the given chain\\n  }\\n\\n  struct RemoteChainConfig {\\n    RateLimiter.TokenBucket outboundRateLimiterConfig; // Outbound rate limited config, meaning the rate limits for all of the onRamps for the given chain\\n    RateLimiter.TokenBucket inboundRateLimiterConfig; // Inbound rate limited config, meaning the rate limits for all of the offRamps for the given chain\\n    bytes remoteTokenAddress; // Address of the remote token, ABI encoded in the case of a remote EVM chain.\\n    EnumerableSet.Bytes32Set remotePools; // Set of remote pool hashes, ABI encoded in the case of a remote EVM chain.\\n  }\\n\\n  /// @dev The bridgeable token that is managed by this pool. Pools could support multiple tokens at the same time if\\n  /// required, but this implementation only supports one token.\\n  IERC20 internal immutable i_token;\\n  /// @dev The number of decimals of the token managed by this pool.\\n  uint8 internal immutable i_tokenDecimals;\\n  /// @dev The address of the RMN proxy\\n  address internal immutable i_rmnProxy;\\n  /// @dev The immutable flag that indicates if the pool is access-controlled.\\n  bool internal immutable i_allowlistEnabled;\\n  /// @dev A set of addresses allowed to trigger lockOrBurn as original senders.\\n  /// Only takes effect if i_allowlistEnabled is true.\\n  /// This can be used to ensure only token-issuer specified addresses can move tokens.\\n  EnumerableSet.AddressSet internal s_allowlist;\\n  /// @dev The address of the router\\n  IRouter internal s_router;\\n  /// @dev A set of allowed chain selectors. We want the allowlist to be enumerable to\\n  /// be able to quickly determine (without parsing logs) who can access the pool.\\n  /// @dev The chain selectors are in uint256 format because of the EnumerableSet implementation.\\n  EnumerableSet.UintSet internal s_remoteChainSelectors;\\n  mapping(uint64 remoteChainSelector =\\u003e RemoteChainConfig) internal s_remoteChainConfigs;\\n  /// @notice A mapping of hashed pool addresses to their unhashed form. This is used to be able to find the actually\\n  /// configured pools and not just their hashed versions.\\n  mapping(bytes32 poolAddressHash =\\u003e bytes poolAddress) internal s_remotePoolAddresses;\\n  /// @notice The address of the rate limiter admin.\\n  /// @dev Can be address(0) if none is configured.\\n  address internal s_rateLimitAdmin;\\n\\n  constructor(IERC20 token, uint8 localTokenDecimals, address[] memory allowlist, address rmnProxy, address router) {\\n    if (address(token) == address(0) || router == address(0) || rmnProxy == address(0)) {\\n      revert ZeroAddressInvalid();\\n    }\\n    i_token = token;\\n    i_rmnProxy = rmnProxy;\\n\\n    try IERC20Metadata(address(token)).decimals() returns (uint8 actualTokenDecimals) {\\n      if (localTokenDecimals != actualTokenDecimals) {\\n        revert InvalidDecimalArgs(localTokenDecimals, actualTokenDecimals);\\n      }\\n    } catch {\\n      // The decimals function doesn't exist, which is possible since it's optional in the ERC20 spec. We skip the check and\\n      // assume the supplied token decimals are correct.\\n    }\\n    i_tokenDecimals = localTokenDecimals;\\n\\n    s_router = IRouter(router);\\n\\n    // Pool can be set as permissioned or permissionless at deployment time only to save hot-path gas.\\n    i_allowlistEnabled = allowlist.length \\u003e 0;\\n    if (i_allowlistEnabled) {\\n      _applyAllowListUpdates(new address[](0), allowlist);\\n    }\\n  }\\n\\n  /// @inheritdoc IPoolV1\\n  function isSupportedToken(\\n    address token\\n  ) public view virtual returns (bool) {\\n    return token == address(i_token);\\n  }\\n\\n  /// @notice Gets the IERC20 token that this pool can lock or burn.\\n  /// @return token The IERC20 token representation.\\n  function getToken() public view returns (IERC20 token) {\\n    return i_token;\\n  }\\n\\n  /// @notice Get RMN proxy address\\n  /// @return rmnProxy Address of RMN proxy\\n  function getRmnProxy() public view returns (address rmnProxy) {\\n    return i_rmnProxy;\\n  }\\n\\n  /// @notice Gets the pool's Router\\n  /// @return router The pool's Router\\n  function getRouter() public view virtual returns (address router) {\\n    return address(s_router);\\n  }\\n\\n  /// @notice Sets the pool's Router\\n  /// @param newRouter The new Router\\n  function setRouter(\\n    address newRouter\\n  ) public onlyOwner {\\n    if (newRouter == address(0)) revert ZeroAddressInvalid();\\n    address oldRouter = address(s_router);\\n    s_router = IRouter(newRouter);\\n\\n    emit RouterUpdated(oldRouter, newRouter);\\n  }\\n\\n  /// @notice Signals which version of the pool interface is supported\\n  function supportsInterface(\\n    bytes4 interfaceId\\n  ) public pure virtual override returns (bool) {\\n    return interfaceId == Pool.CCIP_POOL_V1 || interfaceId == type(IPoolV1).interfaceId\\n      || interfaceId == type(IERC165).interfaceId;\\n  }\\n\\n  // ================================================================\\n  // │                        Lock or Burn                          │\\n  // ================================================================\\n\\n  /// @notice Burn the token in the pool\\n  /// @dev The _validateLockOrBurn check is an essential security check\\n  function lockOrBurn(\\n    Pool.LockOrBurnInV1 calldata lockOrBurnIn\\n  ) public virtual override returns (Pool.LockOrBurnOutV1 memory) {\\n    _validateLockOrBurn(lockOrBurnIn);\\n\\n    _lockOrBurn(lockOrBurnIn.amount);\\n\\n    emit LockedOrBurned({\\n      remoteChainSelector: lockOrBurnIn.remoteChainSelector,\\n      token: address(i_token),\\n      sender: msg.sender,\\n      amount: lockOrBurnIn.amount\\n    });\\n\\n    return Pool.LockOrBurnOutV1({\\n      destTokenAddress: getRemoteToken(lockOrBurnIn.remoteChainSelector),\\n      destPoolData: _encodeLocalDecimals()\\n    });\\n  }\\n\\n  /// @notice Contains the specific lock or burn token logic for a pool.\\n  /// @dev overriding this method allows us to create pools with different lock/burn signatures\\n  /// without duplicating the underlying logic.\\n  function _lockOrBurn(\\n    uint256 amount\\n  ) internal virtual {}\\n\\n  // ================================================================\\n  // │                      Release or Mint                         │\\n  // ================================================================\\n\\n  /// @notice Mint tokens from the pool to the recipient\\n  /// @dev The _validateReleaseOrMint check is an essential security check\\n  function releaseOrMint(\\n    Pool.ReleaseOrMintInV1 calldata releaseOrMintIn\\n  ) public virtual override returns (Pool.ReleaseOrMintOutV1 memory) {\\n    // Calculate the local amount\\n    uint256 localAmount = _calculateLocalAmount(\\n      releaseOrMintIn.sourceDenominatedAmount, _parseRemoteDecimals(releaseOrMintIn.sourcePoolData)\\n    );\\n\\n    _validateReleaseOrMint(releaseOrMintIn, localAmount);\\n\\n    // Mint to the receiver\\n    _releaseOrMint(releaseOrMintIn.receiver, localAmount);\\n\\n    emit ReleasedOrMinted({\\n      remoteChainSelector: releaseOrMintIn.remoteChainSelector,\\n      token: address(i_token),\\n      sender: msg.sender,\\n      recipient: releaseOrMintIn.receiver,\\n      amount: localAmount\\n    });\\n\\n    return Pool.ReleaseOrMintOutV1({destinationAmount: localAmount});\\n  }\\n\\n  /// @notice Contains the specific release or mint token logic for a pool.\\n  /// @dev overriding this method allows us to create pools with different release/mint signatures\\n  /// without duplicating the underlying logic.\\n  function _releaseOrMint(address receiver, uint256 amount) internal virtual {}\\n\\n  // ================================================================\\n  // │                         Validation                           │\\n  // ================================================================\\n\\n  /// @notice Validates the lock or burn input for correctness on\\n  /// - token to be locked or burned\\n  /// - RMN curse status\\n  /// - allowlist status\\n  /// - if the sender is a valid onRamp\\n  /// - rate limit status\\n  /// @param lockOrBurnIn The input to validate.\\n  /// @dev This function should always be called before executing a lock or burn. Not doing so would allow\\n  /// for various exploits.\\n  function _validateLockOrBurn(\\n    Pool.LockOrBurnInV1 calldata lockOrBurnIn\\n  ) internal {\\n    if (!isSupportedToken(lockOrBurnIn.localToken)) revert InvalidToken(lockOrBurnIn.localToken);\\n    if (IRMN(i_rmnProxy).isCursed(bytes16(uint128(lockOrBurnIn.remoteChainSelector)))) revert CursedByRMN();\\n    _checkAllowList(lockOrBurnIn.originalSender);\\n\\n    _onlyOnRamp(lockOrBurnIn.remoteChainSelector);\\n    _consumeOutboundRateLimit(lockOrBurnIn.remoteChainSelector, lockOrBurnIn.amount);\\n  }\\n\\n  /// @notice Validates the release or mint input for correctness on\\n  /// - token to be released or minted\\n  /// - RMN curse status\\n  /// - if the sender is a valid offRamp\\n  /// - if the source pool is valid\\n  /// - rate limit status\\n  /// @param releaseOrMintIn The input to validate.\\n  /// @param localAmount The local amount to be released or minted.\\n  /// @dev This function should always be called before executing a release or mint. Not doing so would allow\\n  /// for various exploits.\\n  function _validateReleaseOrMint(Pool.ReleaseOrMintInV1 calldata releaseOrMintIn, uint256 localAmount) internal {\\n    if (!isSupportedToken(releaseOrMintIn.localToken)) revert InvalidToken(releaseOrMintIn.localToken);\\n    if (IRMN(i_rmnProxy).isCursed(bytes16(uint128(releaseOrMintIn.remoteChainSelector)))) revert CursedByRMN();\\n    _onlyOffRamp(releaseOrMintIn.remoteChainSelector);\\n\\n    // Validates that the source pool address is configured on this pool.\\n    if (!isRemotePool(releaseOrMintIn.remoteChainSelector, releaseOrMintIn.sourcePoolAddress)) {\\n      revert InvalidSourcePoolAddress(releaseOrMintIn.sourcePoolAddress);\\n    }\\n\\n    _consumeInboundRateLimit(releaseOrMintIn.remoteChainSelector, localAmount);\\n  }\\n\\n  // ================================================================\\n  // │                      Token decimals                          │\\n  // ================================================================\\n\\n  /// @notice Gets the IERC20 token decimals on the local chain.\\n  function getTokenDecimals() public view virtual returns (uint8 decimals) {\\n    return i_tokenDecimals;\\n  }\\n\\n  function _encodeLocalDecimals() internal view virtual returns (bytes memory) {\\n    return abi.encode(i_tokenDecimals);\\n  }\\n\\n  function _parseRemoteDecimals(\\n    bytes memory sourcePoolData\\n  ) internal view virtual returns (uint8) {\\n    // Fallback to the local token decimals if the source pool data is empty. This allows for backwards compatibility.\\n    if (sourcePoolData.length == 0) {\\n      return i_tokenDecimals;\\n    }\\n    if (sourcePoolData.length != 32) {\\n      revert InvalidRemoteChainDecimals(sourcePoolData);\\n    }\\n    uint256 remoteDecimals = abi.decode(sourcePoolData, (uint256));\\n    if (remoteDecimals \\u003e type(uint8).max) {\\n      revert InvalidRemoteChainDecimals(sourcePoolData);\\n    }\\n    return uint8(remoteDecimals);\\n  }\\n\\n  /// @notice Calculates the local amount based on the remote amount and decimals.\\n  /// @param remoteAmount The amount on the remote chain.\\n  /// @param remoteDecimals The decimals of the token on the remote chain.\\n  /// @return The local amount.\\n  /// @dev This function protects against overflows. If there is a transaction that hits the overflow check, it is\\n  /// probably incorrect as that means the amount cannot be represented on this chain. If the local decimals have been\\n  /// wrongly configured, the token issuer could redeploy the pool with the correct decimals and manually re-execute the\\n  /// CCIP tx to fix the issue.\\n  function _calculateLocalAmount(uint256 remoteAmount, uint8 remoteDecimals) internal view virtual returns (uint256) {\\n    if (remoteDecimals == i_tokenDecimals) {\\n      return remoteAmount;\\n    }\\n    if (remoteDecimals \\u003e i_tokenDecimals) {\\n      uint8 decimalsDiff = remoteDecimals - i_tokenDecimals;\\n      if (decimalsDiff \\u003e 77) {\\n        // This is a safety check to prevent overflow in the next calculation.\\n        revert OverflowDetected(remoteDecimals, i_tokenDecimals, remoteAmount);\\n      }\\n      // Solidity rounds down so there is no risk of minting more tokens than the remote chain sent.\\n      return remoteAmount / (10 ** decimalsDiff);\\n    }\\n\\n    // This is a safety check to prevent overflow in the next calculation.\\n    // More than 77 would never fit in a uint256 and would cause an overflow. We also check if the resulting amount\\n    // would overflow.\\n    uint8 diffDecimals = i_tokenDecimals - remoteDecimals;\\n    if (diffDecimals \\u003e 77 || remoteAmount \\u003e type(uint256).max / (10 ** diffDecimals)) {\\n      revert OverflowDetected(remoteDecimals, i_tokenDecimals, remoteAmount);\\n    }\\n\\n    return remoteAmount * (10 ** diffDecimals);\\n  }\\n\\n  // ================================================================\\n  // │                     Chain permissions                        │\\n  // ================================================================\\n\\n  /// @notice Gets the pool address on the remote chain.\\n  /// @param remoteChainSelector Remote chain selector.\\n  /// @dev To support non-evm chains, this value is encoded into bytes\\n  function getRemotePools(\\n    uint64 remoteChainSelector\\n  ) public view returns (bytes[] memory) {\\n    bytes32[] memory remotePoolHashes = s_remoteChainConfigs[remoteChainSelector].remotePools.values();\\n\\n    bytes[] memory remotePools = new bytes[](remotePoolHashes.length);\\n    for (uint256 i = 0; i \\u003c remotePoolHashes.length; ++i) {\\n      remotePools[i] = s_remotePoolAddresses[remotePoolHashes[i]];\\n    }\\n\\n    return remotePools;\\n  }\\n\\n  /// @notice Checks if the pool address is configured on the remote chain.\\n  /// @param remoteChainSelector Remote chain selector.\\n  /// @param remotePoolAddress The address of the remote pool.\\n  function isRemotePool(uint64 remoteChainSelector, bytes memory remotePoolAddress) public view returns (bool) {\\n    return s_remoteChainConfigs[remoteChainSelector].remotePools.contains(keccak256(remotePoolAddress));\\n  }\\n\\n  /// @notice Gets the token address on the remote chain.\\n  /// @param remoteChainSelector Remote chain selector.\\n  /// @dev To support non-evm chains, this value is encoded into bytes\\n  function getRemoteToken(\\n    uint64 remoteChainSelector\\n  ) public view returns (bytes memory) {\\n    return s_remoteChainConfigs[remoteChainSelector].remoteTokenAddress;\\n  }\\n\\n  /// @notice Adds a remote pool for a given chain selector. This could be due to a pool being upgraded on the remote\\n  /// chain. We don't simply want to replace the old pool as there could still be valid inflight messages from the old\\n  /// pool. This function allows for multiple pools to be added for a single chain selector.\\n  /// @param remoteChainSelector The remote chain selector for which the remote pool address is being added.\\n  /// @param remotePoolAddress The address of the new remote pool.\\n  function addRemotePool(uint64 remoteChainSelector, bytes calldata remotePoolAddress) external onlyOwner {\\n    if (!isSupportedChain(remoteChainSelector)) revert NonExistentChain(remoteChainSelector);\\n\\n    _setRemotePool(remoteChainSelector, remotePoolAddress);\\n  }\\n\\n  /// @notice Removes the remote pool address for a given chain selector.\\n  /// @dev All inflight txs from the remote pool will be rejected after it is removed. To ensure no loss of funds, there\\n  /// should be no inflight txs from the given pool.\\n  function removeRemotePool(uint64 remoteChainSelector, bytes calldata remotePoolAddress) external onlyOwner {\\n    if (!isSupportedChain(remoteChainSelector)) revert NonExistentChain(remoteChainSelector);\\n\\n    if (!s_remoteChainConfigs[remoteChainSelector].remotePools.remove(keccak256(remotePoolAddress))) {\\n      revert InvalidRemotePoolForChain(remoteChainSelector, remotePoolAddress);\\n    }\\n\\n    emit RemotePoolRemoved(remoteChainSelector, remotePoolAddress);\\n  }\\n\\n  /// @inheritdoc IPoolV1\\n  function isSupportedChain(\\n    uint64 remoteChainSelector\\n  ) public view returns (bool) {\\n    return s_remoteChainSelectors.contains(remoteChainSelector);\\n  }\\n\\n  /// @notice Get list of allowed chains\\n  /// @return list of chains.\\n  function getSupportedChains() public view returns (uint64[] memory) {\\n    uint256[] memory uint256ChainSelectors = s_remoteChainSelectors.values();\\n    uint64[] memory chainSelectors = new uint64[](uint256ChainSelectors.length);\\n    for (uint256 i = 0; i \\u003c uint256ChainSelectors.length; ++i) {\\n      chainSelectors[i] = uint64(uint256ChainSelectors[i]);\\n    }\\n\\n    return chainSelectors;\\n  }\\n\\n  /// @notice Sets the permissions for a list of chains selectors. Actual senders for these chains\\n  /// need to be allowed on the Router to interact with this pool.\\n  /// @param remoteChainSelectorsToRemove A list of chain selectors to remove.\\n  /// @param chainsToAdd A list of chains and their new permission status \\u0026 rate limits. Rate limits\\n  /// are only used when the chain is being added through `allowed` being true.\\n  /// @dev Only callable by the owner\\n  function applyChainUpdates(\\n    uint64[] calldata remoteChainSelectorsToRemove,\\n    ChainUpdate[] calldata chainsToAdd\\n  ) external virtual onlyOwner {\\n    for (uint256 i = 0; i \\u003c remoteChainSelectorsToRemove.length; ++i) {\\n      uint64 remoteChainSelectorToRemove = remoteChainSelectorsToRemove[i];\\n      // If the chain doesn't exist, revert\\n      if (!s_remoteChainSelectors.remove(remoteChainSelectorToRemove)) {\\n        revert NonExistentChain(remoteChainSelectorToRemove);\\n      }\\n\\n      // Remove all remote pool hashes for the chain\\n      bytes32[] memory remotePools = s_remoteChainConfigs[remoteChainSelectorToRemove].remotePools.values();\\n      for (uint256 j = 0; j \\u003c remotePools.length; ++j) {\\n        s_remoteChainConfigs[remoteChainSelectorToRemove].remotePools.remove(remotePools[j]);\\n      }\\n\\n      delete s_remoteChainConfigs[remoteChainSelectorToRemove];\\n\\n      emit ChainRemoved(remoteChainSelectorToRemove);\\n    }\\n\\n    for (uint256 i = 0; i \\u003c chainsToAdd.length; ++i) {\\n      ChainUpdate memory newChain = chainsToAdd[i];\\n      RateLimiter._validateTokenBucketConfig(newChain.outboundRateLimiterConfig);\\n      RateLimiter._validateTokenBucketConfig(newChain.inboundRateLimiterConfig);\\n\\n      if (newChain.remoteTokenAddress.length == 0) {\\n        revert ZeroAddressInvalid();\\n      }\\n\\n      // If the chain already exists, revert\\n      if (!s_remoteChainSelectors.add(newChain.remoteChainSelector)) {\\n        revert ChainAlreadyExists(newChain.remoteChainSelector);\\n      }\\n\\n      RemoteChainConfig storage remoteChainConfig = s_remoteChainConfigs[newChain.remoteChainSelector];\\n\\n      remoteChainConfig.outboundRateLimiterConfig = RateLimiter.TokenBucket({\\n        rate: newChain.outboundRateLimiterConfig.rate,\\n        capacity: newChain.outboundRateLimiterConfig.capacity,\\n        tokens: newChain.outboundRateLimiterConfig.capacity,\\n        lastUpdated: uint32(block.timestamp),\\n        isEnabled: newChain.outboundRateLimiterConfig.isEnabled\\n      });\\n      remoteChainConfig.inboundRateLimiterConfig = RateLimiter.TokenBucket({\\n        rate: newChain.inboundRateLimiterConfig.rate,\\n        capacity: newChain.inboundRateLimiterConfig.capacity,\\n        tokens: newChain.inboundRateLimiterConfig.capacity,\\n        lastUpdated: uint32(block.timestamp),\\n        isEnabled: newChain.inboundRateLimiterConfig.isEnabled\\n      });\\n      remoteChainConfig.remoteTokenAddress = newChain.remoteTokenAddress;\\n\\n      for (uint256 j = 0; j \\u003c newChain.remotePoolAddresses.length; ++j) {\\n        _setRemotePool(newChain.remoteChainSelector, newChain.remotePoolAddresses[j]);\\n      }\\n\\n      emit ChainAdded(\\n        newChain.remoteChainSelector,\\n        newChain.remoteTokenAddress,\\n        newChain.outboundRateLimiterConfig,\\n        newChain.inboundRateLimiterConfig\\n      );\\n    }\\n  }\\n\\n  /// @notice Adds a pool address to the allowed remote token pools for a particular chain.\\n  /// @param remoteChainSelector The remote chain selector for which the remote pool address is being added.\\n  /// @param remotePoolAddress The address of the new remote pool.\\n  function _setRemotePool(uint64 remoteChainSelector, bytes memory remotePoolAddress) internal {\\n    if (remotePoolAddress.length == 0) {\\n      revert ZeroAddressInvalid();\\n    }\\n\\n    bytes32 poolHash = keccak256(remotePoolAddress);\\n\\n    // Check if the pool already exists.\\n    if (!s_remoteChainConfigs[remoteChainSelector].remotePools.add(poolHash)) {\\n      revert PoolAlreadyAdded(remoteChainSelector, remotePoolAddress);\\n    }\\n\\n    // Add the pool to the mapping to be able to un-hash it later.\\n    s_remotePoolAddresses[poolHash] = remotePoolAddress;\\n\\n    emit RemotePoolAdded(remoteChainSelector, remotePoolAddress);\\n  }\\n\\n  // ================================================================\\n  // │                        Rate limiting                         │\\n  // ================================================================\\n\\n  /// @dev The inbound rate limits should be slightly higher than the outbound rate limits. This is because many chains\\n  /// finalize blocks in batches. CCIP also commits messages in batches: the commit plugin bundles multiple messages in\\n  /// a single merkle root.\\n  /// Imagine the following scenario.\\n  /// - Chain A has an inbound and outbound rate limit of 100 tokens capacity and 1 token per second refill rate.\\n  /// - Chain B has an inbound and outbound rate limit of 100 tokens capacity and 1 token per second refill rate.\\n  ///\\n  /// At time 0:\\n  /// - Chain A sends 100 tokens to Chain B.\\n  /// At time 5:\\n  /// - Chain A sends 5 tokens to Chain B.\\n  /// At time 6:\\n  /// The epoch that contains blocks [0-5] is finalized.\\n  /// Both transactions will be included in the same merkle root and become executable at the same time. This means\\n  /// the token pool on chain B requires a capacity of 105 to successfully execute both messages at the same time.\\n  /// The exact additional capacity required depends on the refill rate and the size of the source chain epochs and the\\n  /// CCIP round time. For simplicity, a 5-10% buffer should be sufficient in most cases.\\n\\n  /// @notice Sets the rate limiter admin address.\\n  /// @dev Only callable by the owner.\\n  /// @param rateLimitAdmin The new rate limiter admin address.\\n  function setRateLimitAdmin(\\n    address rateLimitAdmin\\n  ) external onlyOwner {\\n    s_rateLimitAdmin = rateLimitAdmin;\\n    emit RateLimitAdminSet(rateLimitAdmin);\\n  }\\n\\n  /// @notice Gets the rate limiter admin address.\\n  function getRateLimitAdmin() external view returns (address) {\\n    return s_rateLimitAdmin;\\n  }\\n\\n  /// @notice Consumes outbound rate limiting capacity in this pool\\n  function _consumeOutboundRateLimit(uint64 remoteChainSelector, uint256 amount) internal {\\n    s_remoteChainConfigs[remoteChainSelector].outboundRateLimiterConfig._consume(amount, address(i_token));\\n\\n    emit OutboundRateLimitConsumed({token: address(i_token), remoteChainSelector: remoteChainSelector, amount: amount});\\n  }\\n\\n  /// @notice Consumes inbound rate limiting capacity in this pool\\n  function _consumeInboundRateLimit(uint64 remoteChainSelector, uint256 amount) internal {\\n    s_remoteChainConfigs[remoteChainSelector].inboundRateLimiterConfig._consume(amount, address(i_token));\\n\\n    emit InboundRateLimitConsumed({token: address(i_token), remoteChainSelector: remoteChainSelector, amount: amount});\\n  }\\n\\n  /// @notice Gets the token bucket with its values for the block it was requested at.\\n  /// @return The token bucket.\\n  function getCurrentOutboundRateLimiterState(\\n    uint64 remoteChainSelector\\n  ) external view returns (RateLimiter.TokenBucket memory) {\\n    return s_remoteChainConfigs[remoteChainSelector].outboundRateLimiterConfig._currentTokenBucketState();\\n  }\\n\\n  /// @notice Gets the token bucket with its values for the block it was requested at.\\n  /// @return The token bucket.\\n  function getCurrentInboundRateLimiterState(\\n    uint64 remoteChainSelector\\n  ) external view returns (RateLimiter.TokenBucket memory) {\\n    return s_remoteChainConfigs[remoteChainSelector].inboundRateLimiterConfig._currentTokenBucketState();\\n  }\\n\\n  /// @notice Sets multiple chain rate limiter configs.\\n  /// @param remoteChainSelectors The remote chain selector for which the rate limits apply.\\n  /// @param outboundConfigs The new outbound rate limiter config, meaning the onRamp rate limits for the given chain.\\n  /// @param inboundConfigs The new inbound rate limiter config, meaning the offRamp rate limits for the given chain.\\n  function setChainRateLimiterConfigs(\\n    uint64[] calldata remoteChainSelectors,\\n    RateLimiter.Config[] calldata outboundConfigs,\\n    RateLimiter.Config[] calldata inboundConfigs\\n  ) external {\\n    if (msg.sender != s_rateLimitAdmin \\u0026\\u0026 msg.sender != owner()) revert Unauthorized(msg.sender);\\n    if (remoteChainSelectors.length != outboundConfigs.length || remoteChainSelectors.length != inboundConfigs.length) {\\n      revert MismatchedArrayLengths();\\n    }\\n\\n    for (uint256 i = 0; i \\u003c remoteChainSelectors.length; ++i) {\\n      _setRateLimitConfig(remoteChainSelectors[i], outboundConfigs[i], inboundConfigs[i]);\\n    }\\n  }\\n\\n  /// @notice Sets the chain rate limiter config.\\n  /// @param remoteChainSelector The remote chain selector for which the rate limits apply.\\n  /// @param outboundConfig The new outbound rate limiter config, meaning the onRamp rate limits for the given chain.\\n  /// @param inboundConfig The new inbound rate limiter config, meaning the offRamp rate limits for the given chain.\\n  function setChainRateLimiterConfig(\\n    uint64 remoteChainSelector,\\n    RateLimiter.Config memory outboundConfig,\\n    RateLimiter.Config memory inboundConfig\\n  ) external {\\n    if (msg.sender != s_rateLimitAdmin \\u0026\\u0026 msg.sender != owner()) revert Unauthorized(msg.sender);\\n\\n    _setRateLimitConfig(remoteChainSelector, outboundConfig, inboundConfig);\\n  }\\n\\n  function _setRateLimitConfig(\\n    uint64 remoteChainSelector,\\n    RateLimiter.Config memory outboundConfig,\\n    RateLimiter.Config memory inboundConfig\\n  ) internal {\\n    if (!isSupportedChain(remoteChainSelector)) revert NonExistentChain(remoteChainSelector);\\n    RateLimiter._validateTokenBucketConfig(outboundConfig);\\n    s_remoteChainConfigs[remoteChainSelector].outboundRateLimiterConfig._setTokenBucketConfig(outboundConfig);\\n    RateLimiter._validateTokenBucketConfig(inboundConfig);\\n    s_remoteChainConfigs[remoteChainSelector].inboundRateLimiterConfig._setTokenBucketConfig(inboundConfig);\\n    emit ChainConfigured(remoteChainSelector, outboundConfig, inboundConfig);\\n  }\\n\\n  // ================================================================\\n  // │                           Access                             │\\n  // ================================================================\\n\\n  /// @notice Checks whether remote chain selector is configured on this contract, and if the msg.sender\\n  /// is a permissioned onRamp for the given chain on the Router.\\n  /// @dev This function is marked virtual as other token pools may inherit from this contract, but do\\n  /// not receive calls from the ramps directly, instead receiving them from a proxy contract. In that\\n  /// situation this function must be overridden and the ramp-check removed and replaced with a different\\n  /// access-control scheme.\\n  function _onlyOnRamp(\\n    uint64 remoteChainSelector\\n  ) internal view virtual {\\n    if (!isSupportedChain(remoteChainSelector)) revert ChainNotAllowed(remoteChainSelector);\\n    if (!(msg.sender == s_router.getOnRamp(remoteChainSelector))) revert CallerIsNotARampOnRouter(msg.sender);\\n  }\\n\\n  /// @notice Checks whether remote chain selector is configured on this contract, and if the msg.sender\\n  /// is a permissioned offRamp for the given chain on the Router.\\n  /// @dev This function is marked virtual as other token pools may inherit from this contract, but do\\n  /// not receive calls from the ramps directly, instead receiving them from a proxy contract. In that\\n  /// situation this function must be overridden and the ramp-check removed and replaced with a different\\n  /// access-control scheme.\\n  function _onlyOffRamp(\\n    uint64 remoteChainSelector\\n  ) internal view virtual {\\n    if (!isSupportedChain(remoteChainSelector)) revert ChainNotAllowed(remoteChainSelector);\\n    if (!s_router.isOffRamp(remoteChainSelector, msg.sender)) revert CallerIsNotARampOnRouter(msg.sender);\\n  }\\n\\n  // ================================================================\\n  // │                          Allowlist                           │\\n  // ================================================================\\n\\n  function _checkAllowList(\\n    address sender\\n  ) internal view {\\n    if (i_allowlistEnabled) {\\n      if (!s_allowlist.contains(sender)) {\\n        revert SenderNotAllowed(sender);\\n      }\\n    }\\n  }\\n\\n  /// @notice Gets whether the allowlist functionality is enabled.\\n  /// @return true is enabled, false if not.\\n  function getAllowListEnabled() external view returns (bool) {\\n    return i_allowlistEnabled;\\n  }\\n\\n  /// @notice Gets the allowed addresses.\\n  /// @return The allowed addresses.\\n  function getAllowList() external view returns (address[] memory) {\\n    return s_allowlist.values();\\n  }\\n\\n  /// @notice Apply updates to the allow list.\\n  /// @param removes The addresses to be removed.\\n  /// @param adds The addresses to be added.\\n  function applyAllowListUpdates(address[] calldata removes, address[] calldata adds) external onlyOwner {\\n    _applyAllowListUpdates(removes, adds);\\n  }\\n\\n  /// @notice Internal version of applyAllowListUpdates to allow for reuse in the constructor.\\n  function _applyAllowListUpdates(address[] memory removes, address[] memory adds) internal {\\n    if (!i_allowlistEnabled) revert AllowListNotEnabled();\\n\\n    for (uint256 i = 0; i \\u003c removes.length; ++i) {\\n      address toRemove = removes[i];\\n      if (s_allowlist.remove(toRemove)) {\\n        emit AllowListRemove(toRemove);\\n      }\\n    }\\n    for (uint256 i = 0; i \\u003c adds.length; ++i) {\\n      address toAdd = adds[i];\\n      if (toAdd == address(0)) {\\n        continue;\\n      }\\n      if (s_allowlist.add(toAdd)) {\\n        emit AllowListAdd(toAdd);\\n      }\\n    }\\n  }\\n}\\n\"},\"contracts/pools/USDC/CCTPMessageTransmitterProxy.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\nimport {IMessageTransmitter} from \\\"./interfaces/IMessageTransmitter.sol\\\";\\nimport {ITokenMessenger} from \\\"./interfaces/ITokenMessenger.sol\\\";\\n\\nimport {Ownable2StepMsgSender} from \\\"@chainlink/contracts/src/v0.8/shared/access/Ownable2StepMsgSender.sol\\\";\\nimport {ITypeAndVersion} from \\\"@chainlink/contracts/src/v0.8/shared/interfaces/ITypeAndVersion.sol\\\";\\nimport {EnumerableSet} from \\\"@openzeppelin/contracts@5.0.2/utils/structs/EnumerableSet.sol\\\";\\n\\n/// @title CCTP Message Transmitter Proxy\\n/// @notice A proxy contract for handling messages transmitted via the Cross Chain Transfer Protocol (CCTP).\\n/// @dev This contract is responsible for sending messages to the `IMessageTransmitter` and ensuring only allowed callers can invoke it.\\ncontract CCTPMessageTransmitterProxy is Ownable2StepMsgSender, ITypeAndVersion {\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n\\n  /// @notice Error thrown when a function is called by an unauthorized address.\\n  error Unauthorized(address caller);\\n\\n  /// @notice Emitted when an allowed caller is added.\\n  event AllowedCallerAdded(address indexed caller);\\n  /// @notice Emitted when an allowed caller is removed.\\n  event AllowedCallerRemoved(address indexed caller);\\n\\n  string public constant override typeAndVersion = \\\"CCTPMessageTransmitterProxy 1.6.2\\\";\\n\\n  struct AllowedCallerConfigArgs {\\n    address caller;\\n    bool allowed;\\n  }\\n\\n  /// @notice Immutable reference to the `IMessageTransmitter` contract.\\n  IMessageTransmitter public immutable i_cctpTransmitter;\\n\\n  /// @notice Enumerable set of addresses allowed to call `receiveMessage`.\\n  EnumerableSet.AddressSet private s_allowedCallers;\\n\\n  /// @notice One-time cyclic dependency between TokenPool and MessageTransmitter.\\n  constructor(\\n    ITokenMessenger tokenMessenger\\n  ) {\\n    i_cctpTransmitter = IMessageTransmitter(tokenMessenger.localMessageTransmitter());\\n  }\\n\\n  /// @notice Receives a message from the `IMessageTransmitter` contract and validates it.\\n  /// @dev Can only be called by an allowed caller to process incoming messages.\\n  /// @param message The payload of the message being received.\\n  /// @param attestation The cryptographic proof validating the message.\\n  /// @return success A boolean indicating if the message was successfully processed.\\n  function receiveMessage(bytes calldata message, bytes calldata attestation) external returns (bool success) {\\n    if (!s_allowedCallers.contains(msg.sender)) {\\n      revert Unauthorized(msg.sender);\\n    }\\n    return i_cctpTransmitter.receiveMessage(message, attestation);\\n  }\\n\\n  /// @notice Configures the allowed callers for the `receiveMessage` function.\\n  /// @param configArgs An array of `AllowedCallerConfigArgs` structs.\\n  function configureAllowedCallers(\\n    AllowedCallerConfigArgs[] calldata configArgs\\n  ) external onlyOwner {\\n    for (uint256 i = 0; i \\u003c configArgs.length; ++i) {\\n      if (configArgs[i].allowed) {\\n        if (s_allowedCallers.add(configArgs[i].caller)) {\\n          emit AllowedCallerAdded(configArgs[i].caller);\\n        }\\n      } else {\\n        if (s_allowedCallers.remove(configArgs[i].caller)) {\\n          emit AllowedCallerRemoved(configArgs[i].caller);\\n        }\\n      }\\n    }\\n  }\\n\\n  /// @notice Checks if the caller is allowed to call the `receiveMessage` function.\\n  /// @param caller The address to check.\\n  /// @return allowed A boolean indicating if the caller is allowed.\\n  function isAllowedCaller(\\n    address caller\\n  ) external view returns (bool allowed) {\\n    return s_allowedCallers.contains(caller);\\n  }\\n\\n  /// @notice Returns an array of all allowed callers.\\n  /// @return allowedCallers An array of allowed caller addresses.\\n  function getAllowedCallers() external view returns (address[] memory allowedCallers) {\\n    return s_allowedCallers.values();\\n  }\\n}\\n\"},\"contracts/pools/USDC/USDCTokenPool.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\nimport {IMessageTransmitter} from \\\"./interfaces/IMessageTransmitter.sol\\\";\\nimport {ITokenMessenger} from \\\"./interfaces/ITokenMessenger.sol\\\";\\n\\nimport {Pool} from \\\"../../libraries/Pool.sol\\\";\\n\\nimport {USDCSourcePoolDataCodec} from \\\"../../libraries/USDCSourcePoolDataCodec.sol\\\";\\nimport {TokenPool} from \\\"../TokenPool.sol\\\";\\nimport {CCTPMessageTransmitterProxy} from \\\"./CCTPMessageTransmitterProxy.sol\\\";\\n\\nimport {AuthorizedCallers} from \\\"@chainlink/contracts/src/v0.8/shared/access/AuthorizedCallers.sol\\\";\\nimport {ITypeAndVersion} from \\\"@chainlink/contracts/src/v0.8/shared/interfaces/ITypeAndVersion.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts@4.8.3/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts@4.8.3/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {EnumerableSet} from \\\"@openzeppelin/contracts@4.8.3/utils/structs/EnumerableSet.sol\\\";\\n\\n/// @notice This pool mints and burns USDC tokens through the Cross Chain Transfer Protocol (CCTP).\\n/*\\n OnRamp\\n   |\\n   | lockOrBurn()\\n   v\\n+------------------+    depositForBurn()    +------------------+    burn(from, localAmount)    +-----------+\\n| USDC Token Pool  | ---------------------\\u003e | Token Messenger  | ----------------------------\\u003e |   USDC    |\\n+------------------+                        +------------------+                               +-----------+\\n\\n OffRamp\\n   |\\n   | releaseOrMint()\\n   v\\n USDC Token Pool\\n   |\\n   | receiveMessage()\\n   v\\n+------------------------+    receiveMessage()   +---------------------+    mint(amount, recipient)    +----------+\\n| CCTP Transmitter Proxy | --------------------\\u003e | Message Transmitter | ----------------------------\\u003e |   USDC   |\\n+------------------------+                       +---------------------+                               +----------+\\n*/\\n/// @dev This specific pool is used for CCTP V1. The CCTP V2 pool is a separate contract, which inherits many of the\\n/// state management from this contract, only overriding the functions absolutely necessary for supporting CCTP V2.\\ncontract USDCTokenPool is TokenPool, ITypeAndVersion, AuthorizedCallers {\\n  using SafeERC20 for IERC20;\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n\\n  event DomainsSet(DomainUpdate[]);\\n  event ConfigSet(address tokenMessenger);\\n\\n  error UnknownDomain(uint64 domain);\\n  error UnlockingUSDCFailed();\\n  error InvalidConfig();\\n  error InvalidDomain(DomainUpdate domain);\\n  error InvalidMessageVersion(uint32 expected, uint32 got);\\n  error InvalidTokenMessengerVersion(uint32 expected, uint32 got);\\n  error InvalidNonce(uint64 expected, uint64 got);\\n  error InvalidSourceDomain(uint32 expected, uint32 got);\\n  error InvalidDestinationDomain(uint32 expected, uint32 got);\\n  error InvalidReceiver(bytes receiver);\\n  error InvalidTransmitterInProxy();\\n  error InvalidPreviousPool();\\n  error InvalidMessageLength(uint256 length);\\n\\n  // This data is supplied from offchain and contains everything needed to mint the USDC tokens on the destination chain\\n  // through CCTP.\\n  struct MessageAndAttestation {\\n    bytes message;\\n    bytes attestation;\\n  }\\n\\n  // solhint-disable-next-line gas-struct-packing\\n  struct DomainUpdate {\\n    bytes32 allowedCaller; // Address allowed to mint on the domain (destination MessageTransmitterProxy)\\n    bytes32 mintRecipient; // Address to mint to on the destination chain\\n    uint32 domainIdentifier; // Unique domain ID\\n    uint64 destChainSelector; // The destination chain for this domain\\n    bool enabled; // Whether the domain is enabled\\n    bool useLegacySourcePoolDataFormat; // Whether to use the legacy source pool data format\\n  }\\n\\n  /// @notice The version of the USDC message format that this pool supports. Version 0 is the legacy version of CCTP.\\n  uint32 public immutable i_supportedUSDCVersion;\\n\\n  // The local USDC config.\\n  ITokenMessenger public immutable i_tokenMessenger;\\n  CCTPMessageTransmitterProxy public immutable i_messageTransmitterProxy;\\n  uint32 public immutable i_localDomainIdentifier;\\n\\n  /// A domain is a USDC representation of a destination chain.\\n  /// @dev Zero is a valid domain identifier.\\n  /// @dev The address to mint on the destination chain is the corresponding USDC pool.\\n  /// @dev The allowedCaller represents the contract authorized to call receiveMessage on the destination CCTP message\\n  /// transmitter. For dest pool version 1.6.1, this is the MessageTransmitterProxy of the destination chain. For dest\\n  /// pool version 1.5.1, this is the destination chain's token pool.\\n  // solhint-disable-next-line gas-struct-packing\\n  struct Domain {\\n    bytes32 allowedCaller; //                 Address allowed to mint on the domain\\n    bytes32 mintRecipient; //                 Address to mint to on the destination chain\\n    uint32 domainIdentifier; // ────────────╮ Unique domain ID\\n    bool enabled; //                        | Whether the domain is enabled\\n    bool useLegacySourcePoolDataFormat; // ─╯ Whether to use the legacy source pool data format for chains that\\n      // have not yet been updated to the new source pool data format.\\n  }\\n\\n  // A mapping of CCIP chain identifiers to destination domains\\n  mapping(uint64 chainSelector =\\u003e Domain CCTPDomain) internal s_chainToDomain;\\n\\n  /// @dev The authorized callers are set as empty since the USDCTokenPoolProxy is the only authorized caller,\\n  /// but cannot be deployed until after this contract is deployed. The allowed callers are set after deployment.\\n  constructor(\\n    ITokenMessenger tokenMessenger,\\n    CCTPMessageTransmitterProxy cctpMessageTransmitterProxy,\\n    IERC20 token,\\n    address[] memory allowlist,\\n    address rmnProxy,\\n    address router,\\n    uint32 supportedUSDCVersion\\n  ) TokenPool(token, 6, allowlist, rmnProxy, router) AuthorizedCallers(new address[](0)) {\\n    // The version of the USDC message format that this pool supports. Version 0 is the legacy version of CCTP.\\n    i_supportedUSDCVersion = supportedUSDCVersion;\\n\\n    // The token messenger, which is used for outgoing messages (burn operations), has a corresponding message transmitter\\n    // that is used for incoming messages (releaseOrMint).\\n    if (address(tokenMessenger) == address(0)) revert InvalidConfig();\\n    IMessageTransmitter transmitter = IMessageTransmitter(tokenMessenger.localMessageTransmitter());\\n\\n    uint32 transmitterVersion = transmitter.version();\\n\\n    // Check that the message transmitter version is supported by this version of the token pool.\\n    if (transmitterVersion != i_supportedUSDCVersion) {\\n      revert InvalidMessageVersion(i_supportedUSDCVersion, transmitterVersion);\\n    }\\n\\n    // Check that the token messenger version is supported by this version of the token pool.\\n    uint32 tokenMessengerVersion = tokenMessenger.messageBodyVersion();\\n\\n    // If the token messenger version is not supported, revert.\\n    if (tokenMessengerVersion != i_supportedUSDCVersion) {\\n      revert InvalidTokenMessengerVersion(i_supportedUSDCVersion, tokenMessengerVersion);\\n    }\\n\\n    // Check that the message transmitter proxy is configured to use the correct message transmitter for\\n    // incoming messages (releaseOrMint).\\n    if (cctpMessageTransmitterProxy.i_cctpTransmitter() != transmitter) revert InvalidTransmitterInProxy();\\n\\n    i_tokenMessenger = tokenMessenger;\\n    i_messageTransmitterProxy = cctpMessageTransmitterProxy;\\n    i_localDomainIdentifier = transmitter.localDomain();\\n\\n    // Allow the token messenger to burn tokens on behalf of this pool.\\n    i_token.safeIncreaseAllowance(address(i_tokenMessenger), type(uint256).max);\\n\\n    emit ConfigSet(address(tokenMessenger));\\n  }\\n\\n  /// @notice Using a function because constant state variables cannot be overridden by child contracts.\\n  function typeAndVersion() external pure virtual override returns (string memory) {\\n    return \\\"USDCTokenPool 1.6.x-dev\\\";\\n  }\\n\\n  /// @notice Burn tokens from the pool to initiate cross-chain transfer.\\n  /// @notice Outgoing messages (burn operations) are routed via `i_tokenMessenger.depositForBurnWithCaller`.\\n  /// The allowedCaller is preconfigured per destination domain and token pool version refer Domain struct.\\n  /// @dev Emits ITokenMessenger.DepositForBurn event.\\n  /// @dev Assumes caller has validated the destinationReceiver.\\n  function lockOrBurn(\\n    Pool.LockOrBurnInV1 calldata lockOrBurnIn\\n  ) public virtual override returns (Pool.LockOrBurnOutV1 memory) {\\n    _validateLockOrBurn(lockOrBurnIn);\\n\\n    Domain memory domain = s_chainToDomain[lockOrBurnIn.remoteChainSelector];\\n    if (!domain.enabled) revert UnknownDomain(lockOrBurnIn.remoteChainSelector);\\n\\n    if (lockOrBurnIn.receiver.length != 32) {\\n      revert InvalidReceiver(lockOrBurnIn.receiver);\\n    }\\n\\n    bytes32 decodedReceiver;\\n    // For EVM chains, the mintRecipient is not used, but is needed for Solana, where the mintRecipient will\\n    // be a PDA owned by the pool, and will forward the tokens to its final destination after minting.\\n    if (domain.mintRecipient != bytes32(0)) {\\n      decodedReceiver = domain.mintRecipient;\\n    } else {\\n      decodedReceiver = abi.decode(lockOrBurnIn.receiver, (bytes32));\\n    }\\n\\n    // Since this pool is the msg sender of the CCTP transaction, only this contract\\n    // is able to call replaceDepositForBurn. Since this contract does not implement\\n    // replaceDepositForBurn, the tokens cannot be maliciously re-routed to another address.\\n    uint64 nonce = i_tokenMessenger.depositForBurnWithCaller(\\n      lockOrBurnIn.amount, domain.domainIdentifier, decodedReceiver, address(i_token), domain.allowedCaller\\n    );\\n\\n    emit LockedOrBurned({\\n      remoteChainSelector: lockOrBurnIn.remoteChainSelector,\\n      token: address(i_token),\\n      sender: msg.sender,\\n      amount: lockOrBurnIn.amount\\n    });\\n\\n    bytes memory sourcePoolData;\\n    USDCSourcePoolDataCodec.SourceTokenDataPayloadV1 memory sourceTokenDataPayload =\\n      USDCSourcePoolDataCodec.SourceTokenDataPayloadV1({nonce: nonce, sourceDomain: i_localDomainIdentifier});\\n\\n    // The useLegacySourcePoolDataFormat flag is set to false for chains that have been updated to the new source pool\\n    // data format. When the lane is updated, the flag should be set to false.\\n    if (domain.useLegacySourcePoolDataFormat) {\\n      // Since not all lanes will be updated to the new source pool data format simultaneously, it is important to support\\n      // the legacy format until such a time as the lane can support it. Otherwise, the destination pool would not be able\\n      // to parse the source pool data and all messages originating from this updated token pool would be rejected.\\n\\n      // It is safe to have the legacy format still be supported temporarily, as the USDCTokenPoolProxy will convert\\n      // the legacy format to the new format before releaseOrMint() is called. Once all lanes in CCIP are updated to\\n      // the new format and CCTP V2, this branch can be safely removed.\\n      sourcePoolData = abi.encode(sourceTokenDataPayload);\\n    } else {\\n      sourcePoolData = USDCSourcePoolDataCodec._encodeSourceTokenDataPayloadV1(sourceTokenDataPayload);\\n    }\\n\\n    return Pool.LockOrBurnOutV1({\\n      destTokenAddress: getRemoteToken(lockOrBurnIn.remoteChainSelector),\\n      destPoolData: sourcePoolData\\n    });\\n  }\\n\\n  /// @notice Checks whether remote chain selector is configured on this contract, and if the msg.sender\\n  /// is a permissioned onRamp for the given chain on the Router.\\n  function _onlyOnRamp(\\n    uint64 remoteChainSelector\\n  ) internal view virtual override {\\n    if (!isSupportedChain(remoteChainSelector)) revert ChainNotAllowed(remoteChainSelector);\\n    _validateCaller();\\n  }\\n\\n  /// @notice Checks whether remote chain selector is configured on this contract, and if the msg.sender\\n  /// is a permissioned offRamp for the given chain on the Router.\\n  function _onlyOffRamp(\\n    uint64 remoteChainSelector\\n  ) internal view virtual override {\\n    if (!isSupportedChain(remoteChainSelector)) revert ChainNotAllowed(remoteChainSelector);\\n    _validateCaller();\\n  }\\n\\n  /// @inheritdoc TokenPool\\n  /// @dev This function proxies the message to the message transmitter, which will mint the tokens through CCTP's contracts.\\n  function releaseOrMint(\\n    Pool.ReleaseOrMintInV1 calldata releaseOrMintIn\\n  ) public virtual override returns (Pool.ReleaseOrMintOutV1 memory) {\\n    _validateReleaseOrMint(releaseOrMintIn, releaseOrMintIn.sourceDenominatedAmount);\\n\\n    MessageAndAttestation memory msgAndAttestation =\\n      abi.decode(releaseOrMintIn.offchainTokenData, (MessageAndAttestation));\\n\\n    // Decode the source pool data from its raw bytes into a SourceTokenDataPayloadV0 struct that can be\\n    // more easily validated. Since the USDCTokenPoolProxy that sits between this pool and the offRamp will convert\\n    // the legacy format to the new format, this operation is safe to perform, as a message originating from a legacy\\n    // pool will be converted to the new format before this decoding function is called.\\n    USDCSourcePoolDataCodec.SourceTokenDataPayloadV1 memory sourceTokenDataPayload =\\n      USDCSourcePoolDataCodec._decodeSourceTokenDataPayloadV1(releaseOrMintIn.sourcePoolData);\\n\\n    _validateMessage(msgAndAttestation.message, sourceTokenDataPayload);\\n\\n    // Proxy the message to the message transmitter, which will mint the tokens through CCTP's contracts.\\n    if (!i_messageTransmitterProxy.receiveMessage(msgAndAttestation.message, msgAndAttestation.attestation)) {\\n      revert UnlockingUSDCFailed();\\n    }\\n\\n    emit ReleasedOrMinted({\\n      remoteChainSelector: releaseOrMintIn.remoteChainSelector,\\n      token: address(i_token),\\n      sender: msg.sender,\\n      recipient: releaseOrMintIn.receiver,\\n      amount: releaseOrMintIn.sourceDenominatedAmount\\n    });\\n\\n    return Pool.ReleaseOrMintOutV1({destinationAmount: releaseOrMintIn.sourceDenominatedAmount});\\n  }\\n\\n  /// @notice Validates the USDC encoded message against the given parameters.\\n  /// @param usdcMessage The USDC encoded message\\n  /// @param sourceTokenData The expected source chain token data to check against\\n  /// @dev Only supports version SUPPORTED_USDC_VERSION of the CCTP message format\\n  /// @dev Message format for USDC:\\n  ///     * Field                 Bytes      Type       Index\\n  ///     * version               4          uint32     0\\n  ///     * sourceDomain          4          uint32     4\\n  ///     * destinationDomain     4          uint32     8\\n  ///     * nonce                 8          uint64     12\\n  ///     * sender                32         bytes32    20\\n  ///     * recipient             32         bytes32    52\\n  ///     * destinationCaller     32         bytes32    84\\n  ///     * messageBody           dynamic    bytes      116\\n  function _validateMessage(\\n    bytes memory usdcMessage,\\n    USDCSourcePoolDataCodec.SourceTokenDataPayloadV1 memory sourceTokenData\\n  ) internal view virtual {\\n    // 116 is the minimum length of a valid USDC message. Since destinationCaller must be checked for the\\n    // previous pool, this ensures it can be parsed correctly and that the message is not too short.\\n    // Since messageBody is dynamic and not always used, it is not checked.\\n    if (usdcMessage.length \\u003c 116) revert InvalidMessageLength(usdcMessage.length);\\n\\n    uint32 version;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      // We truncate using the datatype of the version variable, so only the first 4 bytes\\n      // of the message remain when cast to uint32. We want the lower 4 bytes to be the version\\n      // when cast to uint32, so we add 4. If you added 32 (to skip the first word containing\\n      // the length), version would be in the upper 4 bytes of the corresponding slot, which\\n      // would not be as easily parsed into a uint32.\\n      version := mload(add(usdcMessage, 4)) // 0 + 4 = 4\\n    }\\n    // This token pool only supports version 0 of the CCTP message format\\n    // We check the version prior to loading the rest of the message\\n    // to avoid unexpected reverts due to out-of-bounds reads.\\n    if (version != i_supportedUSDCVersion) revert InvalidMessageVersion(i_supportedUSDCVersion, version);\\n\\n    uint32 sourceDomain;\\n    uint32 destinationDomain;\\n    uint64 nonce;\\n\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      sourceDomain := mload(add(usdcMessage, 8)) // 4 + 4 = 8\\n      destinationDomain := mload(add(usdcMessage, 12)) // 8 + 4 = 12\\n      nonce := mload(add(usdcMessage, 20)) // 12 + 8 = 20\\n    }\\n\\n    if (sourceDomain != sourceTokenData.sourceDomain) {\\n      revert InvalidSourceDomain(sourceTokenData.sourceDomain, sourceDomain);\\n    }\\n\\n    if (destinationDomain != i_localDomainIdentifier) {\\n      revert InvalidDestinationDomain(i_localDomainIdentifier, destinationDomain);\\n    }\\n\\n    if (nonce != sourceTokenData.nonce) revert InvalidNonce(sourceTokenData.nonce, nonce);\\n  }\\n\\n  // ================================================================\\n  // │                           Config                             │\\n  // ================================================================\\n\\n  /// @notice Gets the CCTP domain for a given CCIP chain selector.\\n  /// @param chainSelector The CCIP chain selector to get the domain for.\\n  /// @return The CCTP domain for the given chain selector.\\n  function getDomain(\\n    uint64 chainSelector\\n  ) external view returns (Domain memory) {\\n    return s_chainToDomain[chainSelector];\\n  }\\n\\n  /// @notice Sets the CCTP domain for a CCIP chain selector.\\n  /// @param domains The array of DomainUpdate structs to set.\\n  /// @dev Must verify mapping of selectors -\\u003e (domain, caller) offchain.\\n  function setDomains(\\n    DomainUpdate[] calldata domains\\n  ) external onlyOwner {\\n    for (uint256 i = 0; i \\u003c domains.length; ++i) {\\n      DomainUpdate memory domain = domains[i];\\n      if (domain.allowedCaller == bytes32(0) || domain.destChainSelector == 0) revert InvalidDomain(domain);\\n\\n      s_chainToDomain[domain.destChainSelector] = Domain({\\n        allowedCaller: domain.allowedCaller,\\n        mintRecipient: domain.mintRecipient,\\n        domainIdentifier: domain.domainIdentifier,\\n        enabled: domain.enabled,\\n        useLegacySourcePoolDataFormat: domain.useLegacySourcePoolDataFormat\\n      });\\n    }\\n    emit DomainsSet(domains);\\n  }\\n}\\n\"},\"contracts/pools/USDC/USDCTokenPoolProxy.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.24;\\n\\nimport {IPoolV1} from \\\"../../interfaces/IPool.sol\\\";\\nimport {IRouter} from \\\"../../interfaces/IRouter.sol\\\";\\nimport {ITypeAndVersion} from \\\"@chainlink/contracts/src/v0.8/shared/interfaces/ITypeAndVersion.sol\\\";\\n\\nimport {ERC165CheckerReverting} from \\\"../../libraries/ERC165CheckerReverting.sol\\\";\\nimport {Pool} from \\\"../../libraries/Pool.sol\\\";\\n\\nimport {USDCSourcePoolDataCodec} from \\\"../../libraries/USDCSourcePoolDataCodec.sol\\\";\\nimport {USDCTokenPool} from \\\"./USDCTokenPool.sol\\\";\\nimport {Ownable2StepMsgSender} from \\\"@chainlink/contracts/src/v0.8/shared/access/Ownable2StepMsgSender.sol\\\";\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts@4.8.3/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts@4.8.3/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {IERC165} from \\\"@openzeppelin/contracts@4.8.3/utils/introspection/IERC165.sol\\\";\\n\\n/// @notice A token pool proxy for USDC that allows for routing of messages to the correct pool based on the correct\\n/// lock or burn mechanism. This includes CCTP v1, CCTP v2, and lock release.\\n/// @dev This contract will be listed in the Token Admin Registry as a token pool. All of the child pools which\\n/// receive the messages should have this contract set as an authorized caller. It does not inherit from the base\\n/// TokenPool contract but still implements the IPoolV1 interface.\\n/// @dev This token pool should have minimal state, as it is only used to route messages to the correct\\n/// pool. If more mechanisms are needed, such as a new CCTP version, then this contract should be updated\\n/// to include the proper routing logic and reference the appropriate child pool.\\n/// On/OffRamp\\n///     ↓\\n/// USDCPoolProxy\\n///     ├──→ LegacyCCTPV1Pool → CCTPV1\\n///     ├──→ CCTPV1Pool → MessageTransmitterProxy/TokenMessenger V1 → CCTPV1\\n///     ├──→ CCTPV2Pool → MessageTransmitterProxy/TokenMessenger V2 → CCTPV2\\n///     └──→ SiloedUSDCTokenPool → ERC20LockBox\\ncontract USDCTokenPoolProxy is Ownable2StepMsgSender, IPoolV1, ITypeAndVersion {\\n  using SafeERC20 for IERC20;\\n  using ERC165CheckerReverting for address;\\n\\n  error AddressCannotBeZero();\\n  error InvalidLockOrBurnMechanism(LockOrBurnMechanism mechanism);\\n  error InvalidMessageVersion(bytes4 version);\\n  error InvalidMessageLength(uint256 length);\\n  error MismatchedArrayLengths();\\n  error NoLockOrBurnMechanismSet(uint64 remoteChainSelector);\\n  error CallerIsNotARampOnRouter(address caller);\\n  error TokenPoolUnsupported(address pool);\\n\\n  event LockOrBurnMechanismUpdated(uint64 indexed remoteChainSelector, LockOrBurnMechanism mechanism);\\n  event PoolAddressesUpdated(PoolAddresses pools);\\n  event LockReleasePoolUpdated(uint64 indexed remoteChainSelector, address lockReleasePool);\\n\\n  struct PoolAddresses {\\n    address legacyCctpV1Pool; // A CCTP V1 token pool that did not utilize a message transmitter proxy.\\n    address cctpV1Pool;\\n    address cctpV2Pool;\\n  }\\n\\n  enum LockOrBurnMechanism {\\n    INVALID_MECHANISM,\\n    CCTP_V1,\\n    CCTP_V2,\\n    LOCK_RELEASE\\n  }\\n\\n  IERC20 internal immutable i_token;\\n  IRouter internal immutable i_router;\\n\\n  mapping(uint64 remoteChainSelector =\\u003e LockOrBurnMechanism mechanism) internal s_lockOrBurnMechanism;\\n  mapping(uint64 remoteChainSelector =\\u003e address lockReleasePool) internal s_lockReleasePools;\\n\\n  /// @dev The legacy CCTP V1, CCTP V1, and CCTP V2 pools which interact with CCTP contracts.\\n  PoolAddresses internal s_pools;\\n\\n  string public constant override typeAndVersion = \\\"USDCTokenPoolProxy 1.6.x-dev\\\";\\n\\n  constructor(IERC20 token, PoolAddresses memory pools, address router) {\\n    // Note: It is not required that every pool address be set, as this proxy may be deployed on a chain which does not\\n    // support a specific version of CCTP. As a result only the token and router are enforced to be non-zero.\\n    if (address(token) == address(0) || router == address(0)) {\\n      revert AddressCannotBeZero();\\n    }\\n\\n    i_token = token;\\n    s_pools = pools;\\n    i_router = IRouter(router);\\n  }\\n\\n  /// @notice Lock or Burn outgoing tokens to the correct pool based on the lock or burn mechanism.\\n  function lockOrBurn(\\n    Pool.LockOrBurnInV1 calldata lockOrBurnIn\\n  ) public virtual returns (Pool.LockOrBurnOutV1 memory) {\\n    // Since this contract does not inherit from the TokenPool contract, it must manually validate the caller as an onRamp.\\n    if (i_router.getOnRamp(lockOrBurnIn.remoteChainSelector) != msg.sender) {\\n      revert CallerIsNotARampOnRouter(msg.sender);\\n    }\\n\\n    LockOrBurnMechanism mechanism = s_lockOrBurnMechanism[lockOrBurnIn.remoteChainSelector];\\n\\n    // If a mechanism has not been configured for the remote chain selector, revert.\\n    if (mechanism == LockOrBurnMechanism.INVALID_MECHANISM) {\\n      revert InvalidLockOrBurnMechanism(mechanism);\\n    }\\n\\n    PoolAddresses memory pools = s_pools;\\n\\n    // The child pool which will perform the lock/burn operation.\\n    address childPool;\\n\\n    if (mechanism == LockOrBurnMechanism.CCTP_V2) {\\n      childPool = pools.cctpV2Pool;\\n    } else if (mechanism == LockOrBurnMechanism.CCTP_V1) {\\n      childPool = pools.cctpV1Pool;\\n    } else if (mechanism == LockOrBurnMechanism.LOCK_RELEASE) {\\n      childPool = s_lockReleasePools[lockOrBurnIn.remoteChainSelector];\\n    }\\n\\n    // If the destination pool is the zero address, then no mechanism has been configured for the outgoing tokens\\n    // and thus the destination chain is not supported and should revert.\\n    if (childPool == address(0)) {\\n      revert NoLockOrBurnMechanismSet(lockOrBurnIn.remoteChainSelector);\\n    }\\n\\n    // Transfer the tokens to the proper child pool, as this contract is only a proxy and will not perform\\n    // the lock/burn itself.\\n    i_token.safeTransfer(childPool, lockOrBurnIn.amount);\\n\\n    return USDCTokenPool(childPool).lockOrBurn(lockOrBurnIn);\\n  }\\n\\n  /// @inheritdoc IPoolV1\\n  function isSupportedChain(\\n    uint64 remoteChainSelector\\n  ) external view returns (bool) {\\n    // If the outgoing mechanism is not set for a chain, then the chain is not supported because there cannot be a lock\\n    // or burn operation.\\n    return s_lockOrBurnMechanism[remoteChainSelector] != LockOrBurnMechanism.INVALID_MECHANISM;\\n  }\\n\\n  /// @inheritdoc IPoolV1\\n  function isSupportedToken(\\n    address token\\n  ) external view returns (bool) {\\n    return address(i_token) == token;\\n  }\\n\\n  /// @notice Signals which version of the pool interface is supported\\n  function supportsInterface(\\n    bytes4 interfaceId\\n  ) public pure override returns (bool) {\\n    return interfaceId == type(IPoolV1).interfaceId || interfaceId == type(IERC165).interfaceId;\\n  }\\n\\n  /// @inheritdoc IPoolV1\\n  function releaseOrMint(\\n    Pool.ReleaseOrMintInV1 calldata releaseOrMintIn\\n  ) public virtual returns (Pool.ReleaseOrMintOutV1 memory) {\\n    // Since this proxy does not inherit from the TokenPool contract, it must manually validate the caller as an offRamp.\\n    if (!i_router.isOffRamp(releaseOrMintIn.remoteChainSelector, msg.sender)) {\\n      revert CallerIsNotARampOnRouter(msg.sender);\\n    }\\n\\n    // The first 4 bytes of source pool data are the version which can be extracted directly and cast into a uint32.\\n    bytes4 version = bytes4(releaseOrMintIn.sourcePoolData[:4]);\\n\\n    // If the source pool data is the lock release flag, use the lock release pool set for the remote chain selector.\\n    if (version == USDCSourcePoolDataCodec.LOCK_RELEASE_FLAG) {\\n      return USDCTokenPool(s_lockReleasePools[releaseOrMintIn.remoteChainSelector]).releaseOrMint(releaseOrMintIn);\\n    }\\n\\n    if (version == USDCSourcePoolDataCodec.CCTP_VERSION_1_TAG) {\\n      return USDCTokenPool(s_pools.cctpV1Pool).releaseOrMint(releaseOrMintIn);\\n    }\\n\\n    // Both tags will route to the same CCTP V2 pool, but will allow for pools to have greater granularity in deciding\\n    // the type of transfer (slow or fast) to use when depositing into CCTP.\\n    if (\\n      version == USDCSourcePoolDataCodec.CCTP_VERSION_2_TAG || version == USDCSourcePoolDataCodec.CCTP_VERSION_2_CCV_TAG\\n    ) {\\n      return USDCTokenPool(s_pools.cctpV2Pool).releaseOrMint(releaseOrMintIn);\\n    }\\n\\n    // In previous versions of the USDC Token Pool, the sourcePoolData only contained two fields, a uint64 and uint32.\\n    // For structs stored only in memory, the compiler assigns each field to its own 32-byte slot, instead of tightly\\n    // packing like in storage. This means that a message originating from a previous version of the pool will have a\\n    // sourcePoolData that is 64 bytes long, indicating an inflight message originating from a previous version of\\n    // the USDC Token pool.\\n    // This branch must come before a version check, because the first field would be a uint64 and thus if a version\\n    // was attempted to be extracted from the first 4-bytes of a uint64, it would be 0, and thus the message would be\\n    // routed to the CCTP V1 pool without first sanitizing the source pool data for proper formatting.\\n    // Note: It is possible for a future version of the source pool data to also be 64 bytes long. However, any future\\n    // version will have a version number in the first 4 bytes and will be routed to the proper pool before this check\\n    // is reached. Therefore this branch will only be triggerd for messages using the legacy source pool data format.\\n    if (releaseOrMintIn.sourcePoolData.length == 64) {\\n      // There are two possible scenarios for the legacy inflight messages:\\n      // 1. The legacy pool did not utilize a message transmitter proxy.\\n      // 2. The legacy pool utilized a message transmitter proxy, but the format of the sourcePoolTokenData was as described\\n      // in the comments above.\\n\\n      // In the first scenario, only the message's destinationCaller, I.E the legacy pool, can execute the mint, and so\\n      // the message needs to be routed to the legacy pool. In the second scenario, the destinationCaller will be the\\n      // message transmitter proxy, and the message needs to be routed to the appropriate V1-compatible pool.\\n      if (_checkForLegacyInflightMessages(releaseOrMintIn.offchainTokenData)) {\\n        // Note: Supporting this branch will require this proxy to be set as an offRamp in the router, which is a design\\n        // decision that is not ideal, but allows for a direct upgrade from the first version of the USDC Token Pool to\\n        // this version.\\n        return USDCTokenPool(s_pools.legacyCctpV1Pool).releaseOrMint(releaseOrMintIn);\\n      } else {\\n        // Since the new pool and the inflight message should utilize the same version of CCTP, and would have the same\\n        // destinationCaller (the message transmitter proxy), we can route the message to the v1 pool, but we first\\n        // need to turn the source pool data into the new format, otherwise the decoding scheme will fail. Once there is\\n        // confidence that no more messages are inflight, these branches can be safely removed.\\n\\n        // Since the CCTP v1 pool will have this contract set as an allowed caller, no additional configurations are\\n        // needed to route the message to the v1 pool.\\n        return USDCTokenPool(s_pools.cctpV1Pool).releaseOrMint(_generateNewReleaseOrMintIn(releaseOrMintIn));\\n      }\\n    }\\n\\n    revert InvalidMessageVersion(version);\\n  }\\n\\n  /// @notice Update the pool addresses that this token pool will route a message to.\\n  /// @param pools The new pool addresses to update the token pool proxy with. Since the legacy CCTP V1 pool may not be\\n  /// used, the zero address is a valid input and therefore input sanitization for it is not required.\\n  function updatePoolAddresses(\\n    PoolAddresses calldata pools\\n  ) external onlyOwner {\\n    if (pools.cctpV1Pool != address(0) \\u0026\\u0026 !pools.cctpV1Pool._supportsInterfaceReverting(type(IPoolV1).interfaceId)) {\\n      revert TokenPoolUnsupported(pools.cctpV1Pool);\\n    }\\n\\n    if (pools.cctpV2Pool != address(0) \\u0026\\u0026 !pools.cctpV2Pool._supportsInterfaceReverting(type(IPoolV1).interfaceId)) {\\n      revert TokenPoolUnsupported(pools.cctpV2Pool);\\n    }\\n\\n    // If the legacy CCTP V1 Pool is being used, then it must support the IPoolV1 interface. If it is not, don't check it.\\n    if (\\n      pools.legacyCctpV1Pool != address(0)\\n        \\u0026\\u0026 !pools.legacyCctpV1Pool._supportsInterfaceReverting(type(IPoolV1).interfaceId)\\n    ) {\\n      revert TokenPoolUnsupported(pools.legacyCctpV1Pool);\\n    }\\n\\n    s_pools = pools;\\n\\n    emit PoolAddressesUpdated(pools);\\n  }\\n\\n  /// @notice Get the current pool addresses that this token pool will route a message to.\\n  /// @return The current pool addresses that this token pool will route a message to.\\n  function getPools() public view returns (PoolAddresses memory) {\\n    return s_pools;\\n  }\\n\\n  /// @notice Get the lock or burn mechanism for a given remote chain selector.\\n  /// @param remoteChainSelector The remote chain selector to get the mechanism for.\\n  /// @return The lock or burn mechanism for the given remote chain selector, including CCTP V1/V2 and Lock/Release\\n  function getLockOrBurnMechanism(\\n    uint64 remoteChainSelector\\n  ) public view returns (LockOrBurnMechanism) {\\n    return s_lockOrBurnMechanism[remoteChainSelector];\\n  }\\n\\n  /// @notice Update the lock or burn mechanism for a list of remote chain selectors.\\n  /// @param remoteChainSelectors The remote chain selectors to update the lock or burn mechanism for.\\n  /// @param mechanisms The new lock or burn mechanisms for the given remote chain selectors.\\n  /// @dev Only callable by the owner.\\n  function updateLockOrBurnMechanisms(\\n    uint64[] calldata remoteChainSelectors,\\n    LockOrBurnMechanism[] calldata mechanisms\\n  ) external onlyOwner {\\n    if (remoteChainSelectors.length != mechanisms.length) {\\n      revert MismatchedArrayLengths();\\n    }\\n\\n    for (uint256 i = 0; i \\u003c remoteChainSelectors.length; ++i) {\\n      s_lockOrBurnMechanism[remoteChainSelectors[i]] = mechanisms[i];\\n      emit LockOrBurnMechanismUpdated(remoteChainSelectors[i], mechanisms[i]);\\n    }\\n  }\\n\\n  /// @notice Update the lock release pool addresses for a list of remote chain selectors.\\n  /// @param remoteChainSelectors The remote chain selectors to update the lock release pool addresses for.\\n  /// @param lockReleasePools The new lock release pool addresses for the given remote chain selectors.\\n  function updateLockReleasePoolAddresses(\\n    uint64[] calldata remoteChainSelectors,\\n    address[] calldata lockReleasePools\\n  ) external onlyOwner {\\n    if (remoteChainSelectors.length != lockReleasePools.length) {\\n      revert MismatchedArrayLengths();\\n    }\\n\\n    for (uint256 i = 0; i \\u003c remoteChainSelectors.length; ++i) {\\n      // If the token pool is being added, ensure that it supports the token pool v1 interface. If the pool is the zero address,\\n      // then it is being removed, as a migration from L/R to CCTP, and therefore no check is needed, as it was\\n      // already performed when originally added.\\n      if (\\n        lockReleasePools[i] != address(0) \\u0026\\u0026 !lockReleasePools[i]._supportsInterfaceReverting(type(IPoolV1).interfaceId)\\n      ) {\\n        revert TokenPoolUnsupported(lockReleasePools[i]);\\n      }\\n\\n      // Note: Since the lock release pool is only used for chains that do not have CCTP support, after a successful\\n      // migration to CCTP, the lock release pool may no longer be needed, and therefore the zero address is\\n      // a valid input and input validation is not required. It is also why no check for the mechanism being\\n      // LOCK_RELEASE is performed either, as after a migration this may no longer be the case.\\n      s_lockReleasePools[remoteChainSelectors[i]] = lockReleasePools[i];\\n      emit LockReleasePoolUpdated(remoteChainSelectors[i], lockReleasePools[i]);\\n    }\\n  }\\n\\n  /// @notice Get the lock release pool address for a given remote chain selector.\\n  /// @param remoteChainSelector The remote chain selector to get the lock release pool address for.\\n  /// @return The lock release pool address for the given remote chain selector.\\n  function getLockReleasePoolAddress(\\n    uint64 remoteChainSelector\\n  ) public view returns (address) {\\n    return s_lockReleasePools[remoteChainSelector];\\n  }\\n\\n  /// @notice Check if the releaseOrMintIn struct is an inflight message from a legacy pool that did not utilize a\\n  /// message transmitter proxy.\\n  /// @param offChainTokenData The off chain message and attestation needed to check for destinationCaller.\\n  /// @return True if the releaseOrMintIn struct is an inflight message from a legacy pool that did not utilize a\\n  /// message transmitter proxy, false otherwise.\\n  function _checkForLegacyInflightMessages(\\n    bytes calldata offChainTokenData\\n  ) internal view virtual returns (bool) {\\n    // Cache the legacy pool address to avoid multiple SLOADs.\\n    address legacyPool = s_pools.legacyCctpV1Pool;\\n\\n    // If the legacy pool without a proxy is not set, then there is no need to check the destinationCaller.\\n    if (legacyPool == address(0)) {\\n      return false;\\n    }\\n\\n    bytes memory messageBytes = abi.decode(offChainTokenData, (USDCTokenPool.MessageAndAttestation)).message;\\n\\n    bytes32 destinationCallerBytes32;\\n    assembly {\\n      // destinationCaller is a 32-byte word starting at position 84 in messageBytes body, so add 32 to skip the 1st word\\n      // representing bytes length.\\n      destinationCallerBytes32 := mload(add(messageBytes, 116)) // 84 + 32 = 116\\n    }\\n    address destinationCaller = address(uint160(uint256(destinationCallerBytes32)));\\n\\n    return destinationCaller == legacyPool;\\n  }\\n\\n  /// @notice Converts a legacy sourcePoolData struct into a new format that can be used to release or mint USDC on the\\n  /// previous pool. This is necessary because the sourcePoolData is stored in a different format in the previous pool,\\n  /// and must be in a properly decodable format.\\n  /// @param releaseOrMintIn The releaseOrMintIn struct to generate a new struct for.\\n  /// @return newReleaseOrMintIn The new releaseOrMintIn struct.\\n  function _generateNewReleaseOrMintIn(\\n    Pool.ReleaseOrMintInV1 calldata releaseOrMintIn\\n  ) internal pure returns (Pool.ReleaseOrMintInV1 memory newReleaseOrMintIn) {\\n    // Copy the releaseOrMintIn struct to the newReleaseOrMintIn struct. We do this to avoid having to copy each field\\n    // individually, which would be more gas intensive, as only the sourcePoolData field is going to be modified, as well\\n    // as the releaseOrMintIn struct is calldata, which cannot be modified in place.\\n    newReleaseOrMintIn = releaseOrMintIn;\\n\\n    // While the legacy source pool data struct uses the same fields as the current source pool data struct, it is\\n    // was initially encoded using abi.encode(sourceTokenDataPayload) instead of the encoding scheme used in the\\n    // USDCSourcePoolDataCodec library, and without a version tag. Therefore, we need to decode the source pool data\\n    // into a SourceTokenDataPayloadV1 struct and then re-encode it into a format that using the proper versioning\\n    // scheme whereby the CCTP V1 pool can process the message.\\n    newReleaseOrMintIn.sourcePoolData = USDCSourcePoolDataCodec._encodeSourceTokenDataPayloadV1(\\n      abi.decode(releaseOrMintIn.sourcePoolData, (USDCSourcePoolDataCodec.SourceTokenDataPayloadV1))\\n    );\\n\\n    return newReleaseOrMintIn;\\n  }\\n}\\n\"},\"contracts/pools/USDC/interfaces/IMessageTransmitter.sol\":{\"content\":\"/*\\n * Copyright (c) 2022, Circle Internet Financial Limited.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n * http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\npragma solidity ^0.8.0;\\n\\ninterface IMessageTransmitter {\\n  /// @notice Unlocks USDC tokens on the destination chain\\n  /// @param message The original message on the source chain\\n  ///     * Message format:\\n  ///     * Field                 Bytes      Type       Index\\n  ///     * version               4          uint32     0\\n  ///     * sourceDomain          4          uint32     4\\n  ///     * destinationDomain     4          uint32     8\\n  ///     * nonce                 8          uint64     12\\n  ///     * sender                32         bytes32    20\\n  ///     * recipient             32         bytes32    52\\n  ///     * destinationCaller     32         bytes32    84\\n  ///     * messageBody           dynamic    bytes      116\\n  /// param attestation A valid attestation is the concatenated 65-byte signature(s) of\\n  /// exactly `thresholdSignature` signatures, in increasing order of attester address.\\n  /// ***If the attester addresses recovered from signatures are not in increasing order,\\n  /// signature verification will fail.***\\n  /// If incorrect number of signatures or duplicate signatures are supplied,\\n  /// signature verification will fail.\\n  function receiveMessage(bytes calldata message, bytes calldata attestation) external returns (bool success);\\n\\n  /// Returns domain of chain on which the contract is deployed.\\n  /// @dev immutable\\n  function localDomain() external view returns (uint32);\\n\\n  /// Returns message format version.\\n  /// @dev immutable\\n  function version() external view returns (uint32);\\n}\\n\"},\"contracts/pools/USDC/interfaces/ITokenMessenger.sol\":{\"content\":\"/*\\n * Copyright (c) 2022, Circle Internet Financial Limited.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n * http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\npragma solidity ^0.8.0;\\n\\ninterface ITokenMessenger {\\n  /// @notice Emitted when a DepositForBurn message is sent\\n  /// @param nonce Unique nonce reserved by message\\n  /// @param burnToken Address of token burnt on source domain\\n  /// @param amount Deposit amount\\n  /// @param depositor Address where deposit is transferred from\\n  /// @param mintRecipient Address receiving minted tokens on destination domain as bytes32\\n  /// @param destinationDomain Destination domain\\n  /// @param destinationTokenMessenger Address of TokenMessenger on destination domain as bytes32\\n  /// @param destinationCaller Authorized caller as bytes32 of receiveMessage() on destination domain,\\n  /// if not equal to bytes32(0). If equal to bytes32(0), any address can call receiveMessage().\\n  event DepositForBurn(\\n    uint64 indexed nonce,\\n    address indexed burnToken,\\n    uint256 amount,\\n    address indexed depositor,\\n    bytes32 mintRecipient,\\n    uint32 destinationDomain,\\n    bytes32 destinationTokenMessenger,\\n    bytes32 destinationCaller\\n  );\\n\\n  /// @notice Burns the tokens on the source side to produce a nonce through\\n  /// Circles Cross Chain Transfer Protocol.\\n  /// @param amount Amount of tokens to deposit and burn.\\n  /// @param destinationDomain Destination domain identifier.\\n  /// @param mintRecipient Address of mint recipient on destination domain.\\n  /// @param burnToken Address of contract to burn deposited tokens, on local domain.\\n  /// @param destinationCaller Caller on the destination domain, as bytes32.\\n  /// @return nonce The unique nonce used in unlocking the funds on the destination chain.\\n  /// @dev emits DepositForBurn\\n  function depositForBurnWithCaller(\\n    uint256 amount,\\n    uint32 destinationDomain,\\n    bytes32 mintRecipient,\\n    address burnToken,\\n    bytes32 destinationCaller\\n  ) external returns (uint64 nonce);\\n\\n  /// @notice Emitted when a DepositForBurn message is sent on CCTP V2\\n  /// @notice Emitted when a DepositForBurn message is sent\\n  /// @param burnToken address of token burnt on source domain\\n  /// @param amount deposit amount\\n  /// @param depositor address where deposit is transferred from\\n  /// @param mintRecipient address receiving minted tokens on destination domain as bytes32\\n  /// @param destinationDomain destination domain\\n  /// @param destinationTokenMessenger address of TokenMessenger on destination domain as bytes32\\n  /// @param destinationCaller authorized caller as bytes32 of receiveMessage() on destination domain.\\n  /// If equal to bytes32(0), any address can broadcast the message.\\n  /// @param maxFee maximum fee to pay on destination domain, in units of burnToken\\n  /// @param minFinalityThreshold the minimum finality at which the message should be attested to.\\n  /// @param hookData optional hook for execution on destination domain\\n  event DepositForBurn(\\n    address indexed burnToken,\\n    uint256 amount,\\n    address indexed depositor,\\n    bytes32 mintRecipient,\\n    uint32 destinationDomain,\\n    bytes32 destinationTokenMessenger,\\n    bytes32 destinationCaller,\\n    uint32 maxFee,\\n    uint32 indexed minFinalityThreshold,\\n    bytes hookData\\n  );\\n\\n  /// @notice Burns the tokens on the source side through Circles Cross Chain Transfer Protocol V2.\\n  /// @param amount Amount of tokens to deposit and burn.\\n  /// @param destinationDomain Destination domain identifier.\\n  /// @param mintRecipient Address of mint recipient on destination domain.\\n  /// @param burnToken Address of contract to burn deposited tokens, on local domain.\\n  /// @param destinationCaller Caller on the destination domain, as bytes32.\\n  /// @param maxFee Maximum fee to be paid for fast burn, specified in burnToken. Should be 0 when using non-fast mode.\\n  /// @param minFinalityThreshold Minimum finality threshold at which the burn will be attested\\n  /// should be 2000 for Standard, 1000 for Fast.\\n  /// @dev This function is only available for CCTP V2.\\n  function depositForBurn(\\n    uint256 amount,\\n    uint32 destinationDomain,\\n    bytes32 mintRecipient,\\n    address burnToken,\\n    bytes32 destinationCaller,\\n    uint32 maxFee,\\n    uint32 minFinalityThreshold\\n  ) external;\\n\\n  /// Returns the version of the message body format.\\n  /// @dev immutable\\n  function messageBodyVersion() external view returns (uint32);\\n\\n  /// Returns local Message Transmitter responsible for sending and receiving messages\\n  /// to/from remote domainsmessage transmitter for this token messenger.\\n  /// @dev immutable\\n  function localMessageTransmitter() external view returns (address);\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/AuthorizedCallers.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.4;\\n\\nimport {Ownable2StepMsgSender} from \\\"./Ownable2StepMsgSender.sol\\\";\\nimport {EnumerableSet} from \\\"@openzeppelin/contracts@4.8.3/utils/structs/EnumerableSet.sol\\\";\\n\\n/// @title The AuthorizedCallers contract\\n/// @notice A contract that manages multiple authorized callers. Enables restricting access to certain functions to a\\n/// set of addresses.\\ncontract AuthorizedCallers is Ownable2StepMsgSender {\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n\\n  event AuthorizedCallerAdded(address caller);\\n  event AuthorizedCallerRemoved(address caller);\\n\\n  error UnauthorizedCaller(address caller);\\n  error ZeroAddressNotAllowed();\\n\\n  /// @notice Update args for changing the authorized callers\\n  struct AuthorizedCallerArgs {\\n    address[] addedCallers;\\n    address[] removedCallers;\\n  }\\n\\n  /// @dev Set of authorized callers\\n  EnumerableSet.AddressSet internal s_authorizedCallers;\\n\\n  /// @param authorizedCallers the authorized callers to set\\n  constructor(\\n    address[] memory authorizedCallers\\n  ) {\\n    _applyAuthorizedCallerUpdates(\\n      AuthorizedCallerArgs({addedCallers: authorizedCallers, removedCallers: new address[](0)})\\n    );\\n  }\\n\\n  /// @return authorizedCallers Returns all authorized callers\\n  function getAllAuthorizedCallers() external view returns (address[] memory) {\\n    return s_authorizedCallers.values();\\n  }\\n\\n  /// @notice Updates the list of authorized callers\\n  /// @param authorizedCallerArgs Callers to add and remove. Removals are performed first.\\n  function applyAuthorizedCallerUpdates(\\n    AuthorizedCallerArgs memory authorizedCallerArgs\\n  ) external onlyOwner {\\n    _applyAuthorizedCallerUpdates(authorizedCallerArgs);\\n  }\\n\\n  /// @notice Updates the list of authorized callers\\n  /// @param authorizedCallerArgs Callers to add and remove. Removals are performed first.\\n  function _applyAuthorizedCallerUpdates(\\n    AuthorizedCallerArgs memory authorizedCallerArgs\\n  ) internal {\\n    address[] memory removedCallers = authorizedCallerArgs.removedCallers;\\n    for (uint256 i = 0; i \\u003c removedCallers.length; ++i) {\\n      address caller = removedCallers[i];\\n\\n      if (s_authorizedCallers.remove(caller)) {\\n        emit AuthorizedCallerRemoved(caller);\\n      }\\n    }\\n\\n    address[] memory addedCallers = authorizedCallerArgs.addedCallers;\\n    for (uint256 i = 0; i \\u003c addedCallers.length; ++i) {\\n      address caller = addedCallers[i];\\n\\n      if (caller == address(0)) {\\n        revert ZeroAddressNotAllowed();\\n      }\\n\\n      s_authorizedCallers.add(caller);\\n      emit AuthorizedCallerAdded(caller);\\n    }\\n  }\\n\\n  /// @notice Checks the sender and reverts if it is anyone other than a listed authorized caller.\\n  function _validateCaller() internal view {\\n    if (!s_authorizedCallers.contains(msg.sender)) {\\n      revert UnauthorizedCaller(msg.sender);\\n    }\\n  }\\n\\n  /// @notice Checks the sender and reverts if it is anyone other than a listed authorized caller.\\n  modifier onlyAuthorizedCallers() {\\n    _validateCaller();\\n    _;\\n  }\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2Step.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {IOwnable} from \\\"../interfaces/IOwnable.sol\\\";\\n\\n/// @notice A minimal contract that implements 2-step ownership transfer and nothing more. It's made to be minimal\\n/// to reduce the impact of the bytecode size on any contract that inherits from it.\\ncontract Ownable2Step is IOwnable {\\n  /// @notice The pending owner is the address to which ownership may be transferred.\\n  address private s_pendingOwner;\\n  /// @notice The owner is the current owner of the contract.\\n  /// @dev The owner is the second storage variable so any implementing contract could pack other state with it\\n  /// instead of the much less used s_pendingOwner.\\n  address private s_owner;\\n\\n  error OwnerCannotBeZero();\\n  error MustBeProposedOwner();\\n  error CannotTransferToSelf();\\n  error OnlyCallableByOwner();\\n\\n  event OwnershipTransferRequested(address indexed from, address indexed to);\\n  event OwnershipTransferred(address indexed from, address indexed to);\\n\\n  constructor(address newOwner, address pendingOwner) {\\n    if (newOwner == address(0)) {\\n      revert OwnerCannotBeZero();\\n    }\\n\\n    s_owner = newOwner;\\n    if (pendingOwner != address(0)) {\\n      _transferOwnership(pendingOwner);\\n    }\\n  }\\n\\n  /// @notice Get the current owner\\n  function owner() public view override returns (address) {\\n    return s_owner;\\n  }\\n\\n  /// @notice Allows an owner to begin transferring ownership to a new address. The new owner needs to call\\n  /// `acceptOwnership` to accept the transfer before any permissions are changed.\\n  /// @param to The address to which ownership will be transferred.\\n  function transferOwnership(\\n    address to\\n  ) public override onlyOwner {\\n    _transferOwnership(to);\\n  }\\n\\n  /// @notice validate, transfer ownership, and emit relevant events\\n  /// @param to The address to which ownership will be transferred.\\n  function _transferOwnership(\\n    address to\\n  ) private {\\n    if (to == msg.sender) {\\n      revert CannotTransferToSelf();\\n    }\\n\\n    s_pendingOwner = to;\\n\\n    emit OwnershipTransferRequested(s_owner, to);\\n  }\\n\\n  /// @notice Allows an ownership transfer to be completed by the recipient.\\n  function acceptOwnership() external override {\\n    if (msg.sender != s_pendingOwner) {\\n      revert MustBeProposedOwner();\\n    }\\n\\n    address oldOwner = s_owner;\\n    s_owner = msg.sender;\\n    s_pendingOwner = address(0);\\n\\n    emit OwnershipTransferred(oldOwner, msg.sender);\\n  }\\n\\n  /// @notice validate access\\n  function _validateOwnership() internal view {\\n    if (msg.sender != s_owner) {\\n      revert OnlyCallableByOwner();\\n    }\\n  }\\n\\n  /// @notice Reverts if called by anyone other than the contract owner.\\n  modifier onlyOwner() {\\n    _validateOwnership();\\n    _;\\n  }\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/access/Ownable2StepMsgSender.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {Ownable2Step} from \\\"./Ownable2Step.sol\\\";\\n\\n/// @notice Sets the msg.sender to be the owner of the contract and does not set a pending owner.\\ncontract Ownable2StepMsgSender is Ownable2Step {\\n  constructor() Ownable2Step(msg.sender, address(0)) {}\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/IOwnable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IOwnable {\\n  function owner() external returns (address);\\n\\n  function transferOwnership(\\n    address recipient\\n  ) external;\\n\\n  function acceptOwnership() external;\\n}\\n\"},\"node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/ITypeAndVersion.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ITypeAndVersion {\\n  function typeAndVersion() external pure returns (string memory);\\n}\\n\"},\"node_modules/@openzeppelin/contracts-4.8.3/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"},\"node_modules/@openzeppelin/contracts-4.8.3/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"},\"node_modules/@openzeppelin/contracts-4.8.3/token/ERC20/extensions/draft-IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"},\"node_modules/@openzeppelin/contracts-4.8.3/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance \\u003e= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length \\u003e 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"},\"node_modules/@openzeppelin/contracts-4.8.3/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length \\u003e 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length \\u003e 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"},\"node_modules/@openzeppelin/contracts-4.8.3/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"},\"node_modules/@openzeppelin/contracts-4.8.3/utils/structs/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 =\\u003e uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.0.2/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"},\"node_modules/@openzeppelin/contracts-5.0.2/utils/structs/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position is the index of the value in the `values` array plus 1.\\n        // Position 0 is used to mean a value is not in the set.\\n        mapping(bytes32 value =\\u003e uint256) _positions;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._positions[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We cache the value's position to prevent multiple reads from the same storage slot\\n        uint256 position = set._positions[value];\\n\\n        if (position != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 valueIndex = position - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (valueIndex != lastIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the lastValue to the index where the value to delete is\\n                set._values[valueIndex] = lastValue;\\n                // Update the tracked position of the lastValue (that was just moved)\\n                set._positions[lastValue] = position;\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the tracked position for the deleted slot\\n            delete set._positions[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._positions[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"}}}"
