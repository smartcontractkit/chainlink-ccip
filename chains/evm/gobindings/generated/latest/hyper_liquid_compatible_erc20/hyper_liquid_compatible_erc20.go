// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package hyper_liquid_compatible_erc20

import (
	"errors"
	"fmt"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
	"github.com/smartcontractkit/chainlink-ccip/chains/evm/gobindings/generated"
)

var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

var HyperLiquidCompatibleERC20MetaData = &bind.MetaData{
	ABI: "[{\"type\":\"constructor\",\"inputs\":[{\"name\":\"name\",\"type\":\"string\",\"internalType\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\",\"internalType\":\"string\"},{\"name\":\"decimals\",\"type\":\"uint8\",\"internalType\":\"uint8\"},{\"name\":\"maxSupply\",\"type\":\"uint256\",\"internalType\":\"uint256\"},{\"name\":\"preMint\",\"type\":\"uint256\",\"internalType\":\"uint256\"},{\"name\":\"newOwner\",\"type\":\"address\",\"internalType\":\"address\"}],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"SPOT_BALANCE_PRECOMPILE\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\",\"internalType\":\"address\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"acceptOwnership\",\"inputs\":[],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"allowance\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"spender\",\"type\":\"address\",\"internalType\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"approve\",\"inputs\":[{\"name\":\"spender\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\",\"internalType\":\"bool\"}],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"balanceOf\",\"inputs\":[{\"name\":\"account\",\"type\":\"address\",\"internalType\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"burn\",\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"burn\",\"inputs\":[{\"name\":\"account\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"burnFrom\",\"inputs\":[{\"name\":\"account\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"decimals\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint8\",\"internalType\":\"uint8\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"decreaseAllowance\",\"inputs\":[{\"name\":\"spender\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"subtractedValue\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\",\"internalType\":\"bool\"}],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"decreaseApproval\",\"inputs\":[{\"name\":\"spender\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"subtractedValue\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[{\"name\":\"success\",\"type\":\"bool\",\"internalType\":\"bool\"}],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"getBurners\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address[]\",\"internalType\":\"address[]\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getCCIPAdmin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\",\"internalType\":\"address\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getHyperEVMLinker\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\",\"internalType\":\"address\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getMinters\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address[]\",\"internalType\":\"address[]\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"grantBurnRole\",\"inputs\":[{\"name\":\"burner\",\"type\":\"address\",\"internalType\":\"address\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"grantMintAndBurnRoles\",\"inputs\":[{\"name\":\"burnAndMinter\",\"type\":\"address\",\"internalType\":\"address\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"grantMintRole\",\"inputs\":[{\"name\":\"minter\",\"type\":\"address\",\"internalType\":\"address\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"increaseAllowance\",\"inputs\":[{\"name\":\"spender\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"addedValue\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\",\"internalType\":\"bool\"}],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"increaseApproval\",\"inputs\":[{\"name\":\"spender\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"addedValue\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"isBurner\",\"inputs\":[{\"name\":\"burner\",\"type\":\"address\",\"internalType\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\",\"internalType\":\"bool\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"isMinter\",\"inputs\":[{\"name\":\"minter\",\"type\":\"address\",\"internalType\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\",\"internalType\":\"bool\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"maxSupply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"mint\",\"inputs\":[{\"name\":\"account\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"name\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\",\"internalType\":\"string\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\",\"internalType\":\"address\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"revokeBurnRole\",\"inputs\":[{\"name\":\"burner\",\"type\":\"address\",\"internalType\":\"address\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"revokeMintRole\",\"inputs\":[{\"name\":\"minter\",\"type\":\"address\",\"internalType\":\"address\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"setCCIPAdmin\",\"inputs\":[{\"name\":\"newAdmin\",\"type\":\"address\",\"internalType\":\"address\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"setHyperEVMLinker\",\"inputs\":[{\"name\":\"newLinker\",\"type\":\"address\",\"internalType\":\"address\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"setRemoteToken\",\"inputs\":[{\"name\":\"remoteToken\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"remoteTokenDecimals\",\"type\":\"uint8\",\"internalType\":\"uint8\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"supportsInterface\",\"inputs\":[{\"name\":\"interfaceId\",\"type\":\"bytes4\",\"internalType\":\"bytes4\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\",\"internalType\":\"bool\"}],\"stateMutability\":\"pure\"},{\"type\":\"function\",\"name\":\"symbol\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\",\"internalType\":\"string\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"totalSupply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"transfer\",\"inputs\":[{\"name\":\"to\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\",\"internalType\":\"bool\"}],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"transferFrom\",\"inputs\":[{\"name\":\"from\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"to\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\",\"internalType\":\"bool\"}],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"transferOwnership\",\"inputs\":[{\"name\":\"to\",\"type\":\"address\",\"internalType\":\"address\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"event\",\"name\":\"Approval\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":true,\"internalType\":\"address\"},{\"name\":\"spender\",\"type\":\"address\",\"indexed\":true,\"internalType\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false,\"internalType\":\"uint256\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"BurnAccessGranted\",\"inputs\":[{\"name\":\"burner\",\"type\":\"address\",\"indexed\":false,\"internalType\":\"address\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"BurnAccessRevoked\",\"inputs\":[{\"name\":\"burner\",\"type\":\"address\",\"indexed\":false,\"internalType\":\"address\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"CCIPAdminTransferred\",\"inputs\":[{\"name\":\"previousAdmin\",\"type\":\"address\",\"indexed\":true,\"internalType\":\"address\"},{\"name\":\"newAdmin\",\"type\":\"address\",\"indexed\":true,\"internalType\":\"address\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"HyperEVMLinkerSet\",\"inputs\":[{\"name\":\"hyperEVMLinker\",\"type\":\"address\",\"indexed\":true,\"internalType\":\"address\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"MintAccessGranted\",\"inputs\":[{\"name\":\"minter\",\"type\":\"address\",\"indexed\":false,\"internalType\":\"address\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"MintAccessRevoked\",\"inputs\":[{\"name\":\"minter\",\"type\":\"address\",\"indexed\":false,\"internalType\":\"address\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"OwnershipTransferRequested\",\"inputs\":[{\"name\":\"from\",\"type\":\"address\",\"indexed\":true,\"internalType\":\"address\"},{\"name\":\"to\",\"type\":\"address\",\"indexed\":true,\"internalType\":\"address\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"OwnershipTransferred\",\"inputs\":[{\"name\":\"from\",\"type\":\"address\",\"indexed\":true,\"internalType\":\"address\"},{\"name\":\"to\",\"type\":\"address\",\"indexed\":true,\"internalType\":\"address\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"RemoteTokenSet\",\"inputs\":[{\"name\":\"remoteToken\",\"type\":\"address\",\"indexed\":true,\"internalType\":\"address\"},{\"name\":\"remoteTokenDecimals\",\"type\":\"uint8\",\"indexed\":true,\"internalType\":\"uint8\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"Transfer\",\"inputs\":[{\"name\":\"from\",\"type\":\"address\",\"indexed\":true,\"internalType\":\"address\"},{\"name\":\"to\",\"type\":\"address\",\"indexed\":true,\"internalType\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false,\"internalType\":\"uint256\"}],\"anonymous\":false},{\"type\":\"error\",\"name\":\"CannotTransferToSelf\",\"inputs\":[]},{\"type\":\"error\",\"name\":\"HyperEVMTransferFailed\",\"inputs\":[]},{\"type\":\"error\",\"name\":\"InsufficientSpotBalance\",\"inputs\":[]},{\"type\":\"error\",\"name\":\"LinkerAddressCannotBeZero\",\"inputs\":[]},{\"type\":\"error\",\"name\":\"MaxSupplyExceeded\",\"inputs\":[{\"name\":\"supplyAfterMint\",\"type\":\"uint256\",\"internalType\":\"uint256\"}]},{\"type\":\"error\",\"name\":\"MustBeProposedOwner\",\"inputs\":[]},{\"type\":\"error\",\"name\":\"OnlyCallableByOwner\",\"inputs\":[]},{\"type\":\"error\",\"name\":\"OverflowDetected\",\"inputs\":[{\"name\":\"remoteDecimals\",\"type\":\"uint8\",\"internalType\":\"uint8\"},{\"name\":\"localDecimals\",\"type\":\"uint8\",\"internalType\":\"uint8\"},{\"name\":\"remoteAmount\",\"type\":\"uint256\",\"internalType\":\"uint256\"}]},{\"type\":\"error\",\"name\":\"OwnerCannotBeZero\",\"inputs\":[]},{\"type\":\"error\",\"name\":\"SenderNotBurner\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\",\"internalType\":\"address\"}]},{\"type\":\"error\",\"name\":\"SenderNotMinter\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\",\"internalType\":\"address\"}]},{\"type\":\"error\",\"name\":\"ZeroAddressNotAllowed\",\"inputs\":[]}]",
	Bin: "0x60c0806040523461037457613244803803809161001c82856105ee565b833981019060c0818303126103745780516001600160401b038111610374578261004791830161062c565b602082015190926001600160401b0382116103745761006791830161062c565b604082015160ff811681036103745760608301519160a060808501519401519460018060a01b038616809603610374578051906001600160401b0382116104eb5760035490600182811c921680156105e4575b60208310146104cb5781601f849311610574575b50602090601f831160011461050c57600092610501575b50508160011b916000199060031b1c1916176003555b8051906001600160401b0382116104eb5760045490600182811c921680156104e1575b60208310146104cb5781601f84931161045b575b50602090601f83116001146103f3576000926103e8575b50508160011b916000199060031b1c1916176004555b33156103d7573360018060a01b0319600654161760065560805260a0528160018060a01b03196007541617600755806101c2575b604051612aa8908161079c82396080518181816117c00152612957015260a05181818161061b01526114ad0152f35b811561039257610800821461023e575b600254908082018092116102285760207fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9160009360025584845283825260408420818154019055604051908152a33880610193565b634e487b7160e01b600052601160045260246000fd5b7f8c306a6a12fff1951878e8621be6674add1102cd359dd968efbbe797629ef84f54600c54604080516001600160a01b03938416602082019081529383168183015290815290916000918291906102966060826105ee565b51906108005afa3d1561038a573d906102ae82610611565b916102bc60405193846105ee565b82523d6000602084013e5b15610379576060818051810103126103745760405160009290606081016001600160401b03811182821017610360579160ff916103459493604052604061032f60606103156020880161068c565b9687855261032484820161068c565b60208601520161068c565b91015260a01c16906001600160401b03166106c5565b821161035157506101d2565b63e08a99d760e01b8152600490fd5b634e487b7160e01b85526041600452602485fd5b600080fd5b63d1ba842760e01b60005260046000fd5b6060906102c7565b60405162461bcd60e51b815260206004820152601f60248201527f45524332303a206d696e7420746f20746865207a65726f2061646472657373006044820152606490fd5b639b15e16f60e01b60005260046000fd5b015190503880610149565b600460009081528281209350601f198516905b818110610443575090846001959493921061042a575b505050811b0160045561015f565b015160001960f88460031b161c1916905538808061041c565b92936020600181928786015181550195019301610406565b60046000529091507f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b601f840160051c810191602085106104c1575b90601f859493920160051c01905b8181106104b25750610132565b600081558493506001016104a5565b9091508190610497565b634e487b7160e01b600052602260045260246000fd5b91607f169161011e565b634e487b7160e01b600052604160045260246000fd5b0151905038806100e5565b600360009081528281209350601f198516905b81811061055c5750908460019594939210610543575b505050811b016003556100fb565b015160001960f88460031b161c19169055388080610535565b9293602060018192878601518155019501930161051f565b60036000529091507fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b601f840160051c810191602085106105da575b90601f859493920160051c01905b8181106105cb57506100ce565b600081558493506001016105be565b90915081906105b0565b91607f16916100ba565b601f909101601f19168101906001600160401b038211908210176104eb57604052565b6001600160401b0381116104eb57601f01601f191660200190565b81601f820112156103745780519061064382610611565b9261065160405194856105ee565b828452602083830101116103745760005b82811061067757505060206000918301015290565b80602080928401015182828701015201610662565b51906001600160401b038216820361037457565b9060ff8091169116039060ff821161022857565b60ff16604d811161022857600a0a90565b9060ff6080511660ff821691818314610795578180841161076a57906106ea916106a0565b91604d60ff8416118015610739575b61071c575050610708906106b4565b908181029181830414901517156102285790565b90915063a9cb113d60e01b60005260045260245260445260646000fd5b50610743836106b4565b8015610754576000190484116106f9565b634e487b7160e01b600052601260045260246000fd5b610773916106a0565b91604d60ff84161161071c57505061078a906106b4565b908115610754570490565b5050509056fe608080604052600436101561001357600080fd5b60003560e01c90816301ffc9a714611d375750806306fdde0314611c5a578063095ea7b314611a9d5780630c028a0614611a6257806318160ddd14611a2657806323b872dd146117e4578063313ce56714611788578063395093511461174c57806340c10f191461143657806342966c68146113df5780634334614a1461137a5780634f5632f8146112e95780636618846314610dc75780636b32810b1461125457806370a08231146111ef57806379ba50971461110657806379cc679014610dcc57806386fe8b43146110655780638da5cb5b146110135780638fd6a6ac14610fc157806395d89b4114610e645780639dc29fac14610dcc578063a457c2d714610dc7578063a8fa343c14610d1c578063a9059cbb146108e3578063aa271e1a14610874578063c2e3273d146107e3578063c630948d14610740578063c64d0ebc146106af578063cf30d4081461063e578063d5abeb01146105e5578063d73dd623146105a0578063dd62ed3e14610510578063ddd6bc561461040c578063dfc6a39b1461033c578063f2fde38b1461024c5763f81094f3146101b657600080fd5b346102475760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102475773ffffffffffffffffffffffffffffffffffffffff610202611eee565b61020a61238d565b166102148161274a565b61021a57005b60207fed998b960f6340d045f620c119730f7aa7995e7425c2401d3a5b64ff998a59e991604051908152a1005b600080fd5b346102475760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102475773ffffffffffffffffffffffffffffffffffffffff610298611eee565b6102a061238d565b1633811461031257807fffffffffffffffffffffffff0000000000000000000000000000000000000000600554161760055573ffffffffffffffffffffffffffffffffffffffff600654167fed8889f560326eb138920d842192f0eb3dd22b4f139c87a2c57538e05bae1278600080a3005b7fdad89dca0000000000000000000000000000000000000000000000000000000060005260046000fd5b346102475760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261024757610373611eee565b61037b61238d565b73ffffffffffffffffffffffffffffffffffffffff81169081156103e2577f8c306a6a12fff1951878e8621be6674add1102cd359dd968efbbe797629ef84f557f58dc48d21bdfdfd38a14ec5c284648779a185303f99274a36e229247ad554b00600080a2005b7f4496fa750000000000000000000000000000000000000000000000000000000060005260046000fd5b346102475760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261024757610443611eee565b60243560ff8116918282036102475773ffffffffffffffffffffffffffffffffffffffff9061047061238d565b169081156104e657817fffffffffffffffffffffff00000000000000000000000000000000000000000074ff0000000000000000000000000000000000000000600c549360a01b1692161717600c557fcaad7af228c332327e445ee0094747b901ce6003bf4ca2b0a1a7377f9bd22cb1600080a3005b7f8579befe0000000000000000000000000000000000000000000000000000000060005260046000fd5b346102475760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261024757610547611eee565b73ffffffffffffffffffffffffffffffffffffffff610564611f11565b9116600052600160205273ffffffffffffffffffffffffffffffffffffffff604060002091166000526020526020604060002054604051908152f35b346102475760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610247576105e36105da611eee565b60243590612193565b005b346102475760007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102475760206040517f00000000000000000000000000000000000000000000000000000000000000008152f35b346102475760007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102475760207f8c306a6a12fff1951878e8621be6674add1102cd359dd968efbbe797629ef84f5473ffffffffffffffffffffffffffffffffffffffff60405191168152f35b346102475760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102475773ffffffffffffffffffffffffffffffffffffffff6106fb611eee565b61070361238d565b1661070d816128d5565b61071357005b60207f92308bb7573b2a3d17ddb868b39d8ebec433f3194421abc22d084f89658c9bad91604051908152a1005b346102475760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102475773ffffffffffffffffffffffffffffffffffffffff61078c611eee565b61079461238d565b1661079e81612875565b6107b4575b6107ab61238d565b61070d816128d5565b7fe46fef8bbff1389d9010703cf8ebb363fb3daf5bf56edc27080b67bc8d9251ea6020604051838152a16107a3565b346102475760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102475773ffffffffffffffffffffffffffffffffffffffff61082f611eee565b61083761238d565b1661084181612875565b61084757005b60207fe46fef8bbff1389d9010703cf8ebb363fb3daf5bf56edc27080b67bc8d9251ea91604051908152a1005b346102475760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102475760206108d973ffffffffffffffffffffffffffffffffffffffff6108c5611eee565b166000526009602052604060002054151590565b6040519015158152f35b346102475760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102475761091a611eee565b73ffffffffffffffffffffffffffffffffffffffff16602435308214610247573315610c98578115610c14576108008214610a47575b3360005260006020526040600020548181106109c35781903360005260006020520360406000205581600052600060205260406000208181540190556040519081527fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef60203392a3602060405160018152f35b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f45524332303a207472616e7366657220616d6f756e742065786365656473206260448201527f616c616e636500000000000000000000000000000000000000000000000000006064820152fd5b7f8c306a6a12fff1951878e8621be6674add1102cd359dd968efbbe797629ef84f54600080600c549260405173ffffffffffffffffffffffffffffffffffffffff602082019216825273ffffffffffffffffffffffffffffffffffffffff8516604082015260408152610abb606082612116565b51906108005afa3d15610c0c573d9067ffffffffffffffff8211610bdd5760405191610b0f60207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8401160184612116565b82523d6000602084013e5b15610bb3576060818051810103126102475767ffffffffffffffff60ff610b8293604051610b47816120fa565b6040610b746060610b5a602089016123d8565b97888552610b698482016123d8565b6020860152016123d8565b91015260a01c169116612954565b811115610950577fe08a99d70000000000000000000000000000000000000000000000000000000060005260046000fd5b7fd1ba84270000000000000000000000000000000000000000000000000000000060005260046000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b606090610b1a565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602360248201527f45524332303a207472616e7366657220746f20746865207a65726f206164647260448201527f65737300000000000000000000000000000000000000000000000000000000006064820152fd5b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602560248201527f45524332303a207472616e736665722066726f6d20746865207a65726f20616460448201527f64726573730000000000000000000000000000000000000000000000000000006064820152fd5b346102475760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261024757610d53611eee565b610d5b61238d565b73ffffffffffffffffffffffffffffffffffffffff80600754921691827fffffffffffffffffffffffff0000000000000000000000000000000000000000821617600755167f9524c9e4b0b61eb018dd58a1cd856e3e74009528328ab4a613b434fa631d7242600080a3005b611f34565b346102475760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261024757610e03611eee565b602435610e1d33600052600b602052604060002054151590565b15610e36576105e391610e31823383612232565b6123ed565b7fc820b10b000000000000000000000000000000000000000000000000000000006000523360045260246000fd5b346102475760007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102475760405160006004548060011c90600181168015610fb7575b602083108114610f8a57828552908115610f485750600114610ee8575b610ee483610ed881850382612116565b60405191829182611e86565b0390f35b91905060046000527f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b916000905b808210610f2e57509091508101602001610ed8610ec8565b919260018160209254838588010152019101909291610f16565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001660208086019190915291151560051b84019091019150610ed89050610ec8565b6024847f4e487b710000000000000000000000000000000000000000000000000000000081526022600452fd5b91607f1691610eab565b346102475760007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261024757602073ffffffffffffffffffffffffffffffffffffffff60075416604051908152f35b346102475760007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261024757602073ffffffffffffffffffffffffffffffffffffffff60065416604051908152f35b346102475760007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261024757604051806020600a54918281520190600a6000527fc65a7bb8d6351c1cf70c95a316cc6a92839c986682d98bc35f958f4883f9d2a89060005b8181106110f057610ee4856110e481870382612116565b604051918291826120aa565b82548452602090930192600192830192016110cd565b346102475760007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102475760055473ffffffffffffffffffffffffffffffffffffffff811633036111c5577fffffffffffffffffffffffff00000000000000000000000000000000000000006006549133828416176006551660055573ffffffffffffffffffffffffffffffffffffffff3391167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0600080a3005b7f02b543c60000000000000000000000000000000000000000000000000000000060005260046000fd5b346102475760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102475773ffffffffffffffffffffffffffffffffffffffff61123b611eee565b1660005260006020526020604060002054604051908152f35b346102475760007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102475760405180602060085491828152019060086000527ff3f7a9fe364faab93b216da50a3214154f22a0a2b415b23a84c8169e8b636ee39060005b8181106112d357610ee4856110e481870382612116565b82548452602090930192600192830192016112bc565b346102475760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102475773ffffffffffffffffffffffffffffffffffffffff611335611eee565b61133d61238d565b16611347816125b4565b61134d57005b60207f0a675452746933cefe3d74182e78db7afe57ba60eaa4234b5d85e9aa41b0610c91604051908152a1005b346102475760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102475760206108d973ffffffffffffffffffffffffffffffffffffffff6113cb611eee565b16600052600b602052604060002054151590565b346102475760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102475761142533600052600b602052604060002054151590565b15610e36576105e3600435336123ed565b346102475760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102475761146d611eee565b60243590611488336000526009602052604060002054151590565b1561171e5773ffffffffffffffffffffffffffffffffffffffff1690308214610247577f00000000000000000000000000000000000000000000000000000000000000008015159081611709575b506116d0578115611672576108008214611539575b7fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef60208261151d600094600254612157565b60025584845283825260408420818154019055604051908152a3005b7f8c306a6a12fff1951878e8621be6674add1102cd359dd968efbbe797629ef84f54600080600c549260405173ffffffffffffffffffffffffffffffffffffffff602082019216825273ffffffffffffffffffffffffffffffffffffffff85166040820152604081526115ad606082612116565b51906108005afa3d1561166a573d9067ffffffffffffffff8211610bdd576040519161160160207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8401160184612116565b82523d6000602084013e5b15610bb3576060818051810103126102475767ffffffffffffffff60ff61163993604051610b47816120fa565b8111156114eb577fe08a99d70000000000000000000000000000000000000000000000000000000060005260046000fd5b60609061160c565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f45524332303a206d696e7420746f20746865207a65726f2061646472657373006044820152fd5b6116dc90600254612157565b7fcbbf11130000000000000000000000000000000000000000000000000000000060005260045260246000fd5b905061171782600254612157565b11836114d6565b7fe2c8c9d5000000000000000000000000000000000000000000000000000000006000523360045260246000fd5b346102475760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102475760206108d96105da611eee565b346102475760007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261024757602060405160ff7f0000000000000000000000000000000000000000000000000000000000000000168152f35b346102475760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102475761181b611eee565b611823611f11565b73ffffffffffffffffffffffffffffffffffffffff60443591611847833386612232565b16913083146102475773ffffffffffffffffffffffffffffffffffffffff16908115610c98578215610c145761080083146118ed575b8160005260006020526040600020548181106109c357817fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef9260209285600052600084520360406000205584600052600082526040600020818154019055604051908152a3602060405160018152f35b7f8c306a6a12fff1951878e8621be6674add1102cd359dd968efbbe797629ef84f54600080600c549260405173ffffffffffffffffffffffffffffffffffffffff602082019216825273ffffffffffffffffffffffffffffffffffffffff8516604082015260408152611961606082612116565b51906108005afa3d15611a1e573d9067ffffffffffffffff8211610bdd57604051916119b560207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8401160184612116565b82523d6000602084013e5b15610bb3576060818051810103126102475767ffffffffffffffff60ff6119ed93604051610b47816120fa565b81111561187d577fe08a99d70000000000000000000000000000000000000000000000000000000060005260046000fd5b6060906119c0565b346102475760007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610247576020600254604051908152f35b346102475760007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102475760206040516108008152f35b346102475760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261024757611ad4611eee565b73ffffffffffffffffffffffffffffffffffffffff16602435308214610247573315611bd7578115611b5357336000526001602052604060002082600052602052806040600020556040519081527f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560203392a3602060405160018152f35b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f45524332303a20617070726f766520746f20746865207a65726f20616464726560448201527f73730000000000000000000000000000000000000000000000000000000000006064820152fd5b60846040517f08c379a0000000000000000000000000000000000000000000000000000000008152602060048201526024808201527f45524332303a20617070726f76652066726f6d20746865207a65726f2061646460448201527f72657373000000000000000000000000000000000000000000000000000000006064820152fd5b346102475760007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102475760405160006003548060011c90600181168015611d2d575b602083108114610f8a57828552908115610f485750600114611ccd57610ee483610ed881850382612116565b91905060036000527fc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b916000905b808210611d1357509091508101602001610ed8610ec8565b919260018160209254838588010152019101909291611cfb565b91607f1691611ca1565b346102475760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261024757600435907fffffffff00000000000000000000000000000000000000000000000000000000821680920361024757817f36372b070000000000000000000000000000000000000000000000000000000060209314908115611e5c575b8115611e32575b8115611e08575b8115611dde575b5015158152f35b7f8fd6a6ac0000000000000000000000000000000000000000000000000000000091501483611dd7565b7f06e278470000000000000000000000000000000000000000000000000000000081149150611dd0565b7f01ffc9a70000000000000000000000000000000000000000000000000000000081149150611dc9565b7fe6599b4d0000000000000000000000000000000000000000000000000000000081149150611dc2565b9190916020815282519283602083015260005b848110611ed85750507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8460006040809697860101520116010190565b8060208092840101516040828601015201611e99565b6004359073ffffffffffffffffffffffffffffffffffffffff8216820361024757565b6024359073ffffffffffffffffffffffffffffffffffffffff8216820361024757565b346102475760407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261024757611f6b611eee565b6024359060009133835260016020526040832073ffffffffffffffffffffffffffffffffffffffff831684526020526040832054908082106120265773ffffffffffffffffffffffffffffffffffffffff9103911691308314612023573315611bd7578215611b535760408291338152600160205281812085825260205220556040519081527f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560203392a360206001604051908152f35b80fd5b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602560248201527f45524332303a2064656372656173656420616c6c6f77616e63652062656c6f7760448201527f207a65726f0000000000000000000000000000000000000000000000000000006064820152fd5b602060408183019282815284518094520192019060005b8181106120ce5750505090565b825173ffffffffffffffffffffffffffffffffffffffff168452602093840193909201916001016120c1565b6060810190811067ffffffffffffffff821117610bdd57604052565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff821117610bdd57604052565b9190820180921161216457565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b906121cf73ffffffffffffffffffffffffffffffffffffffff913360005260016020526040600020838516600052602052604060002054612157565b911690308214610247573315611bd7578115611b5357336000526001602052604060002082600052602052806040600020556040519081527f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560203392a3600190565b73ffffffffffffffffffffffffffffffffffffffff909291921690816000526001602052604060002073ffffffffffffffffffffffffffffffffffffffff8416600052602052604060002054907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036122ad575b50505050565b80821061232f5773ffffffffffffffffffffffffffffffffffffffff9103921691308314610247578115611bd7578215611b535760207f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925918360005260018252604060002085600052825280604060002055604051908152a3388080806122a7565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f45524332303a20696e73756666696369656e7420616c6c6f77616e63650000006044820152fd5b73ffffffffffffffffffffffffffffffffffffffff6006541633036123ae57565b7f2b5c74de0000000000000000000000000000000000000000000000000000000060005260046000fd5b519067ffffffffffffffff8216820361024757565b73ffffffffffffffffffffffffffffffffffffffff1680156124e95780600052600060205260406000205491808310612465576020817fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef926000958587528684520360408620558060025403600255604051908152a3565b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f45524332303a206275726e20616d6f756e7420657863656564732062616c616e60448201527f63650000000000000000000000000000000000000000000000000000000000006064820152fd5b60846040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602160248201527f45524332303a206275726e2066726f6d20746865207a65726f2061646472657360448201527f73000000000000000000000000000000000000000000000000000000000000006064820152fd5b80548210156125855760005260206000200190600090565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b6000818152600b60205260409020548015612743577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff810181811161216457600a54907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8201918211612164578181036126d4575b505050600a5480156126a5577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0161266281600a61256d565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82549160031b1b19169055600a55600052600b60205260006040812055600190565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603160045260246000fd5b61272b6126e56126f693600a61256d565b90549060031b1c928392600a61256d565b81939154907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9060031b92831b921b19161790565b9055600052600b602052604060002055388080612629565b5050600090565b6000818152600960205260409020548015612743577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff810181811161216457600854907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82019182116121645781810361283b575b50505060085480156126a5577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff016127f881600861256d565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82549160031b1b19169055600855600052600960205260006040812055600190565b61285d61284c6126f693600861256d565b90549060031b1c928392600861256d565b905560005260096020526040600020553880806127bf565b806000526009602052604060002054156000146128cf5760085468010000000000000000811015610bdd576128b66126f6826001859401600855600861256d565b9055600854906000526009602052604060002055600190565b50600090565b80600052600b602052604060002054156000146128cf57600a5468010000000000000000811015610bdd576129166126f6826001859401600a55600a61256d565b9055600a5490600052600b602052604060002055600190565b9060ff8091169116039060ff821161216457565b60ff16604d811161216457600a0a90565b907f00000000000000000000000000000000000000000000000000000000000000009060ff82169060ff811692828414612a9457828411612a6957906129999161292f565b91604d60ff8416118015612a01575b6129cb5750506129b790612943565b908181029181830414901517156121645790565b9091507fa9cb113d0000000000000000000000000000000000000000000000000000000060005260045260245260445260646000fd5b50612a0b83612943565b8015612a3a577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0484116129a8565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b612a729161292f565b91604d60ff8416116129cb575050612a8990612943565b908115612a3a570490565b505050509056fea164736f6c634300081a000a",
}

var HyperLiquidCompatibleERC20ABI = HyperLiquidCompatibleERC20MetaData.ABI

var HyperLiquidCompatibleERC20Bin = HyperLiquidCompatibleERC20MetaData.Bin

func DeployHyperLiquidCompatibleERC20(auth *bind.TransactOpts, backend bind.ContractBackend, name string, symbol string, decimals uint8, maxSupply *big.Int, preMint *big.Int, newOwner common.Address) (common.Address, *types.Transaction, *HyperLiquidCompatibleERC20, error) {
	parsed, err := HyperLiquidCompatibleERC20MetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(HyperLiquidCompatibleERC20Bin), backend, name, symbol, decimals, maxSupply, preMint, newOwner)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &HyperLiquidCompatibleERC20{address: address, abi: *parsed, HyperLiquidCompatibleERC20Caller: HyperLiquidCompatibleERC20Caller{contract: contract}, HyperLiquidCompatibleERC20Transactor: HyperLiquidCompatibleERC20Transactor{contract: contract}, HyperLiquidCompatibleERC20Filterer: HyperLiquidCompatibleERC20Filterer{contract: contract}}, nil
}

type HyperLiquidCompatibleERC20 struct {
	address common.Address
	abi     abi.ABI
	HyperLiquidCompatibleERC20Caller
	HyperLiquidCompatibleERC20Transactor
	HyperLiquidCompatibleERC20Filterer
}

type HyperLiquidCompatibleERC20Caller struct {
	contract *bind.BoundContract
}

type HyperLiquidCompatibleERC20Transactor struct {
	contract *bind.BoundContract
}

type HyperLiquidCompatibleERC20Filterer struct {
	contract *bind.BoundContract
}

type HyperLiquidCompatibleERC20Session struct {
	Contract     *HyperLiquidCompatibleERC20
	CallOpts     bind.CallOpts
	TransactOpts bind.TransactOpts
}

type HyperLiquidCompatibleERC20CallerSession struct {
	Contract *HyperLiquidCompatibleERC20Caller
	CallOpts bind.CallOpts
}

type HyperLiquidCompatibleERC20TransactorSession struct {
	Contract     *HyperLiquidCompatibleERC20Transactor
	TransactOpts bind.TransactOpts
}

type HyperLiquidCompatibleERC20Raw struct {
	Contract *HyperLiquidCompatibleERC20
}

type HyperLiquidCompatibleERC20CallerRaw struct {
	Contract *HyperLiquidCompatibleERC20Caller
}

type HyperLiquidCompatibleERC20TransactorRaw struct {
	Contract *HyperLiquidCompatibleERC20Transactor
}

func NewHyperLiquidCompatibleERC20(address common.Address, backend bind.ContractBackend) (*HyperLiquidCompatibleERC20, error) {
	abi, err := abi.JSON(strings.NewReader(HyperLiquidCompatibleERC20ABI))
	if err != nil {
		return nil, err
	}
	contract, err := bindHyperLiquidCompatibleERC20(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &HyperLiquidCompatibleERC20{address: address, abi: abi, HyperLiquidCompatibleERC20Caller: HyperLiquidCompatibleERC20Caller{contract: contract}, HyperLiquidCompatibleERC20Transactor: HyperLiquidCompatibleERC20Transactor{contract: contract}, HyperLiquidCompatibleERC20Filterer: HyperLiquidCompatibleERC20Filterer{contract: contract}}, nil
}

func NewHyperLiquidCompatibleERC20Caller(address common.Address, caller bind.ContractCaller) (*HyperLiquidCompatibleERC20Caller, error) {
	contract, err := bindHyperLiquidCompatibleERC20(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &HyperLiquidCompatibleERC20Caller{contract: contract}, nil
}

func NewHyperLiquidCompatibleERC20Transactor(address common.Address, transactor bind.ContractTransactor) (*HyperLiquidCompatibleERC20Transactor, error) {
	contract, err := bindHyperLiquidCompatibleERC20(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &HyperLiquidCompatibleERC20Transactor{contract: contract}, nil
}

func NewHyperLiquidCompatibleERC20Filterer(address common.Address, filterer bind.ContractFilterer) (*HyperLiquidCompatibleERC20Filterer, error) {
	contract, err := bindHyperLiquidCompatibleERC20(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &HyperLiquidCompatibleERC20Filterer{contract: contract}, nil
}

func bindHyperLiquidCompatibleERC20(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := HyperLiquidCompatibleERC20MetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Raw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _HyperLiquidCompatibleERC20.Contract.HyperLiquidCompatibleERC20Caller.contract.Call(opts, result, method, params...)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.HyperLiquidCompatibleERC20Transactor.contract.Transfer(opts)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.HyperLiquidCompatibleERC20Transactor.contract.Transact(opts, method, params...)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20CallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _HyperLiquidCompatibleERC20.Contract.contract.Call(opts, result, method, params...)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.contract.Transfer(opts)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.contract.Transact(opts, method, params...)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Caller) SPOTBALANCEPRECOMPILE(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _HyperLiquidCompatibleERC20.contract.Call(opts, &out, "SPOT_BALANCE_PRECOMPILE")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) SPOTBALANCEPRECOMPILE() (common.Address, error) {
	return _HyperLiquidCompatibleERC20.Contract.SPOTBALANCEPRECOMPILE(&_HyperLiquidCompatibleERC20.CallOpts)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20CallerSession) SPOTBALANCEPRECOMPILE() (common.Address, error) {
	return _HyperLiquidCompatibleERC20.Contract.SPOTBALANCEPRECOMPILE(&_HyperLiquidCompatibleERC20.CallOpts)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Caller) Allowance(opts *bind.CallOpts, owner common.Address, spender common.Address) (*big.Int, error) {
	var out []interface{}
	err := _HyperLiquidCompatibleERC20.contract.Call(opts, &out, "allowance", owner, spender)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _HyperLiquidCompatibleERC20.Contract.Allowance(&_HyperLiquidCompatibleERC20.CallOpts, owner, spender)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20CallerSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _HyperLiquidCompatibleERC20.Contract.Allowance(&_HyperLiquidCompatibleERC20.CallOpts, owner, spender)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Caller) BalanceOf(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var out []interface{}
	err := _HyperLiquidCompatibleERC20.contract.Call(opts, &out, "balanceOf", account)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) BalanceOf(account common.Address) (*big.Int, error) {
	return _HyperLiquidCompatibleERC20.Contract.BalanceOf(&_HyperLiquidCompatibleERC20.CallOpts, account)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20CallerSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _HyperLiquidCompatibleERC20.Contract.BalanceOf(&_HyperLiquidCompatibleERC20.CallOpts, account)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Caller) Decimals(opts *bind.CallOpts) (uint8, error) {
	var out []interface{}
	err := _HyperLiquidCompatibleERC20.contract.Call(opts, &out, "decimals")

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) Decimals() (uint8, error) {
	return _HyperLiquidCompatibleERC20.Contract.Decimals(&_HyperLiquidCompatibleERC20.CallOpts)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20CallerSession) Decimals() (uint8, error) {
	return _HyperLiquidCompatibleERC20.Contract.Decimals(&_HyperLiquidCompatibleERC20.CallOpts)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Caller) GetBurners(opts *bind.CallOpts) ([]common.Address, error) {
	var out []interface{}
	err := _HyperLiquidCompatibleERC20.contract.Call(opts, &out, "getBurners")

	if err != nil {
		return *new([]common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new([]common.Address)).(*[]common.Address)

	return out0, err

}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) GetBurners() ([]common.Address, error) {
	return _HyperLiquidCompatibleERC20.Contract.GetBurners(&_HyperLiquidCompatibleERC20.CallOpts)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20CallerSession) GetBurners() ([]common.Address, error) {
	return _HyperLiquidCompatibleERC20.Contract.GetBurners(&_HyperLiquidCompatibleERC20.CallOpts)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Caller) GetCCIPAdmin(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _HyperLiquidCompatibleERC20.contract.Call(opts, &out, "getCCIPAdmin")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) GetCCIPAdmin() (common.Address, error) {
	return _HyperLiquidCompatibleERC20.Contract.GetCCIPAdmin(&_HyperLiquidCompatibleERC20.CallOpts)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20CallerSession) GetCCIPAdmin() (common.Address, error) {
	return _HyperLiquidCompatibleERC20.Contract.GetCCIPAdmin(&_HyperLiquidCompatibleERC20.CallOpts)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Caller) GetHyperEVMLinker(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _HyperLiquidCompatibleERC20.contract.Call(opts, &out, "getHyperEVMLinker")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) GetHyperEVMLinker() (common.Address, error) {
	return _HyperLiquidCompatibleERC20.Contract.GetHyperEVMLinker(&_HyperLiquidCompatibleERC20.CallOpts)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20CallerSession) GetHyperEVMLinker() (common.Address, error) {
	return _HyperLiquidCompatibleERC20.Contract.GetHyperEVMLinker(&_HyperLiquidCompatibleERC20.CallOpts)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Caller) GetMinters(opts *bind.CallOpts) ([]common.Address, error) {
	var out []interface{}
	err := _HyperLiquidCompatibleERC20.contract.Call(opts, &out, "getMinters")

	if err != nil {
		return *new([]common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new([]common.Address)).(*[]common.Address)

	return out0, err

}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) GetMinters() ([]common.Address, error) {
	return _HyperLiquidCompatibleERC20.Contract.GetMinters(&_HyperLiquidCompatibleERC20.CallOpts)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20CallerSession) GetMinters() ([]common.Address, error) {
	return _HyperLiquidCompatibleERC20.Contract.GetMinters(&_HyperLiquidCompatibleERC20.CallOpts)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Caller) IsBurner(opts *bind.CallOpts, burner common.Address) (bool, error) {
	var out []interface{}
	err := _HyperLiquidCompatibleERC20.contract.Call(opts, &out, "isBurner", burner)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) IsBurner(burner common.Address) (bool, error) {
	return _HyperLiquidCompatibleERC20.Contract.IsBurner(&_HyperLiquidCompatibleERC20.CallOpts, burner)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20CallerSession) IsBurner(burner common.Address) (bool, error) {
	return _HyperLiquidCompatibleERC20.Contract.IsBurner(&_HyperLiquidCompatibleERC20.CallOpts, burner)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Caller) IsMinter(opts *bind.CallOpts, minter common.Address) (bool, error) {
	var out []interface{}
	err := _HyperLiquidCompatibleERC20.contract.Call(opts, &out, "isMinter", minter)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) IsMinter(minter common.Address) (bool, error) {
	return _HyperLiquidCompatibleERC20.Contract.IsMinter(&_HyperLiquidCompatibleERC20.CallOpts, minter)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20CallerSession) IsMinter(minter common.Address) (bool, error) {
	return _HyperLiquidCompatibleERC20.Contract.IsMinter(&_HyperLiquidCompatibleERC20.CallOpts, minter)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Caller) MaxSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _HyperLiquidCompatibleERC20.contract.Call(opts, &out, "maxSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) MaxSupply() (*big.Int, error) {
	return _HyperLiquidCompatibleERC20.Contract.MaxSupply(&_HyperLiquidCompatibleERC20.CallOpts)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20CallerSession) MaxSupply() (*big.Int, error) {
	return _HyperLiquidCompatibleERC20.Contract.MaxSupply(&_HyperLiquidCompatibleERC20.CallOpts)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Caller) Name(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _HyperLiquidCompatibleERC20.contract.Call(opts, &out, "name")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) Name() (string, error) {
	return _HyperLiquidCompatibleERC20.Contract.Name(&_HyperLiquidCompatibleERC20.CallOpts)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20CallerSession) Name() (string, error) {
	return _HyperLiquidCompatibleERC20.Contract.Name(&_HyperLiquidCompatibleERC20.CallOpts)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Caller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _HyperLiquidCompatibleERC20.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) Owner() (common.Address, error) {
	return _HyperLiquidCompatibleERC20.Contract.Owner(&_HyperLiquidCompatibleERC20.CallOpts)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20CallerSession) Owner() (common.Address, error) {
	return _HyperLiquidCompatibleERC20.Contract.Owner(&_HyperLiquidCompatibleERC20.CallOpts)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Caller) SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error) {
	var out []interface{}
	err := _HyperLiquidCompatibleERC20.contract.Call(opts, &out, "supportsInterface", interfaceId)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _HyperLiquidCompatibleERC20.Contract.SupportsInterface(&_HyperLiquidCompatibleERC20.CallOpts, interfaceId)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20CallerSession) SupportsInterface(interfaceId [4]byte) (bool, error) {
	return _HyperLiquidCompatibleERC20.Contract.SupportsInterface(&_HyperLiquidCompatibleERC20.CallOpts, interfaceId)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Caller) Symbol(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _HyperLiquidCompatibleERC20.contract.Call(opts, &out, "symbol")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) Symbol() (string, error) {
	return _HyperLiquidCompatibleERC20.Contract.Symbol(&_HyperLiquidCompatibleERC20.CallOpts)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20CallerSession) Symbol() (string, error) {
	return _HyperLiquidCompatibleERC20.Contract.Symbol(&_HyperLiquidCompatibleERC20.CallOpts)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Caller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _HyperLiquidCompatibleERC20.contract.Call(opts, &out, "totalSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) TotalSupply() (*big.Int, error) {
	return _HyperLiquidCompatibleERC20.Contract.TotalSupply(&_HyperLiquidCompatibleERC20.CallOpts)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20CallerSession) TotalSupply() (*big.Int, error) {
	return _HyperLiquidCompatibleERC20.Contract.TotalSupply(&_HyperLiquidCompatibleERC20.CallOpts)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Transactor) AcceptOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.contract.Transact(opts, "acceptOwnership")
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) AcceptOwnership() (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.AcceptOwnership(&_HyperLiquidCompatibleERC20.TransactOpts)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20TransactorSession) AcceptOwnership() (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.AcceptOwnership(&_HyperLiquidCompatibleERC20.TransactOpts)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Transactor) Approve(opts *bind.TransactOpts, spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.contract.Transact(opts, "approve", spender, amount)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.Approve(&_HyperLiquidCompatibleERC20.TransactOpts, spender, amount)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20TransactorSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.Approve(&_HyperLiquidCompatibleERC20.TransactOpts, spender, amount)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Transactor) Burn(opts *bind.TransactOpts, amount *big.Int) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.contract.Transact(opts, "burn", amount)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) Burn(amount *big.Int) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.Burn(&_HyperLiquidCompatibleERC20.TransactOpts, amount)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20TransactorSession) Burn(amount *big.Int) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.Burn(&_HyperLiquidCompatibleERC20.TransactOpts, amount)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Transactor) Burn0(opts *bind.TransactOpts, account common.Address, amount *big.Int) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.contract.Transact(opts, "burn0", account, amount)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) Burn0(account common.Address, amount *big.Int) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.Burn0(&_HyperLiquidCompatibleERC20.TransactOpts, account, amount)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20TransactorSession) Burn0(account common.Address, amount *big.Int) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.Burn0(&_HyperLiquidCompatibleERC20.TransactOpts, account, amount)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Transactor) BurnFrom(opts *bind.TransactOpts, account common.Address, amount *big.Int) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.contract.Transact(opts, "burnFrom", account, amount)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) BurnFrom(account common.Address, amount *big.Int) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.BurnFrom(&_HyperLiquidCompatibleERC20.TransactOpts, account, amount)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20TransactorSession) BurnFrom(account common.Address, amount *big.Int) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.BurnFrom(&_HyperLiquidCompatibleERC20.TransactOpts, account, amount)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Transactor) DecreaseAllowance(opts *bind.TransactOpts, spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.contract.Transact(opts, "decreaseAllowance", spender, subtractedValue)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) DecreaseAllowance(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.DecreaseAllowance(&_HyperLiquidCompatibleERC20.TransactOpts, spender, subtractedValue)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20TransactorSession) DecreaseAllowance(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.DecreaseAllowance(&_HyperLiquidCompatibleERC20.TransactOpts, spender, subtractedValue)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Transactor) DecreaseApproval(opts *bind.TransactOpts, spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.contract.Transact(opts, "decreaseApproval", spender, subtractedValue)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) DecreaseApproval(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.DecreaseApproval(&_HyperLiquidCompatibleERC20.TransactOpts, spender, subtractedValue)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20TransactorSession) DecreaseApproval(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.DecreaseApproval(&_HyperLiquidCompatibleERC20.TransactOpts, spender, subtractedValue)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Transactor) GrantBurnRole(opts *bind.TransactOpts, burner common.Address) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.contract.Transact(opts, "grantBurnRole", burner)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) GrantBurnRole(burner common.Address) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.GrantBurnRole(&_HyperLiquidCompatibleERC20.TransactOpts, burner)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20TransactorSession) GrantBurnRole(burner common.Address) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.GrantBurnRole(&_HyperLiquidCompatibleERC20.TransactOpts, burner)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Transactor) GrantMintAndBurnRoles(opts *bind.TransactOpts, burnAndMinter common.Address) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.contract.Transact(opts, "grantMintAndBurnRoles", burnAndMinter)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) GrantMintAndBurnRoles(burnAndMinter common.Address) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.GrantMintAndBurnRoles(&_HyperLiquidCompatibleERC20.TransactOpts, burnAndMinter)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20TransactorSession) GrantMintAndBurnRoles(burnAndMinter common.Address) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.GrantMintAndBurnRoles(&_HyperLiquidCompatibleERC20.TransactOpts, burnAndMinter)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Transactor) GrantMintRole(opts *bind.TransactOpts, minter common.Address) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.contract.Transact(opts, "grantMintRole", minter)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) GrantMintRole(minter common.Address) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.GrantMintRole(&_HyperLiquidCompatibleERC20.TransactOpts, minter)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20TransactorSession) GrantMintRole(minter common.Address) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.GrantMintRole(&_HyperLiquidCompatibleERC20.TransactOpts, minter)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Transactor) IncreaseAllowance(opts *bind.TransactOpts, spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.contract.Transact(opts, "increaseAllowance", spender, addedValue)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) IncreaseAllowance(spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.IncreaseAllowance(&_HyperLiquidCompatibleERC20.TransactOpts, spender, addedValue)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20TransactorSession) IncreaseAllowance(spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.IncreaseAllowance(&_HyperLiquidCompatibleERC20.TransactOpts, spender, addedValue)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Transactor) IncreaseApproval(opts *bind.TransactOpts, spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.contract.Transact(opts, "increaseApproval", spender, addedValue)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) IncreaseApproval(spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.IncreaseApproval(&_HyperLiquidCompatibleERC20.TransactOpts, spender, addedValue)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20TransactorSession) IncreaseApproval(spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.IncreaseApproval(&_HyperLiquidCompatibleERC20.TransactOpts, spender, addedValue)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Transactor) Mint(opts *bind.TransactOpts, account common.Address, amount *big.Int) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.contract.Transact(opts, "mint", account, amount)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) Mint(account common.Address, amount *big.Int) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.Mint(&_HyperLiquidCompatibleERC20.TransactOpts, account, amount)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20TransactorSession) Mint(account common.Address, amount *big.Int) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.Mint(&_HyperLiquidCompatibleERC20.TransactOpts, account, amount)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Transactor) RevokeBurnRole(opts *bind.TransactOpts, burner common.Address) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.contract.Transact(opts, "revokeBurnRole", burner)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) RevokeBurnRole(burner common.Address) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.RevokeBurnRole(&_HyperLiquidCompatibleERC20.TransactOpts, burner)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20TransactorSession) RevokeBurnRole(burner common.Address) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.RevokeBurnRole(&_HyperLiquidCompatibleERC20.TransactOpts, burner)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Transactor) RevokeMintRole(opts *bind.TransactOpts, minter common.Address) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.contract.Transact(opts, "revokeMintRole", minter)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) RevokeMintRole(minter common.Address) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.RevokeMintRole(&_HyperLiquidCompatibleERC20.TransactOpts, minter)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20TransactorSession) RevokeMintRole(minter common.Address) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.RevokeMintRole(&_HyperLiquidCompatibleERC20.TransactOpts, minter)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Transactor) SetCCIPAdmin(opts *bind.TransactOpts, newAdmin common.Address) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.contract.Transact(opts, "setCCIPAdmin", newAdmin)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) SetCCIPAdmin(newAdmin common.Address) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.SetCCIPAdmin(&_HyperLiquidCompatibleERC20.TransactOpts, newAdmin)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20TransactorSession) SetCCIPAdmin(newAdmin common.Address) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.SetCCIPAdmin(&_HyperLiquidCompatibleERC20.TransactOpts, newAdmin)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Transactor) SetHyperEVMLinker(opts *bind.TransactOpts, newLinker common.Address) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.contract.Transact(opts, "setHyperEVMLinker", newLinker)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) SetHyperEVMLinker(newLinker common.Address) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.SetHyperEVMLinker(&_HyperLiquidCompatibleERC20.TransactOpts, newLinker)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20TransactorSession) SetHyperEVMLinker(newLinker common.Address) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.SetHyperEVMLinker(&_HyperLiquidCompatibleERC20.TransactOpts, newLinker)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Transactor) SetRemoteToken(opts *bind.TransactOpts, remoteToken common.Address, remoteTokenDecimals uint8) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.contract.Transact(opts, "setRemoteToken", remoteToken, remoteTokenDecimals)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) SetRemoteToken(remoteToken common.Address, remoteTokenDecimals uint8) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.SetRemoteToken(&_HyperLiquidCompatibleERC20.TransactOpts, remoteToken, remoteTokenDecimals)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20TransactorSession) SetRemoteToken(remoteToken common.Address, remoteTokenDecimals uint8) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.SetRemoteToken(&_HyperLiquidCompatibleERC20.TransactOpts, remoteToken, remoteTokenDecimals)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Transactor) Transfer(opts *bind.TransactOpts, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.contract.Transact(opts, "transfer", to, amount)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.Transfer(&_HyperLiquidCompatibleERC20.TransactOpts, to, amount)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20TransactorSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.Transfer(&_HyperLiquidCompatibleERC20.TransactOpts, to, amount)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Transactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.contract.Transact(opts, "transferFrom", from, to, amount)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.TransferFrom(&_HyperLiquidCompatibleERC20.TransactOpts, from, to, amount)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20TransactorSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.TransferFrom(&_HyperLiquidCompatibleERC20.TransactOpts, from, to, amount)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Transactor) TransferOwnership(opts *bind.TransactOpts, to common.Address) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.contract.Transact(opts, "transferOwnership", to)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Session) TransferOwnership(to common.Address) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.TransferOwnership(&_HyperLiquidCompatibleERC20.TransactOpts, to)
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20TransactorSession) TransferOwnership(to common.Address) (*types.Transaction, error) {
	return _HyperLiquidCompatibleERC20.Contract.TransferOwnership(&_HyperLiquidCompatibleERC20.TransactOpts, to)
}

type HyperLiquidCompatibleERC20ApprovalIterator struct {
	Event *HyperLiquidCompatibleERC20Approval

	contract *bind.BoundContract
	event    string

	logs chan types.Log
	sub  ethereum.Subscription
	done bool
	fail error
}

func (it *HyperLiquidCompatibleERC20ApprovalIterator) Next() bool {

	if it.fail != nil {
		return false
	}

	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(HyperLiquidCompatibleERC20Approval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}

	select {
	case log := <-it.logs:
		it.Event = new(HyperLiquidCompatibleERC20Approval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

func (it *HyperLiquidCompatibleERC20ApprovalIterator) Error() error {
	return it.fail
}

func (it *HyperLiquidCompatibleERC20ApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

type HyperLiquidCompatibleERC20Approval struct {
	Owner   common.Address
	Spender common.Address
	Value   *big.Int
	Raw     types.Log
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Filterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, spender []common.Address) (*HyperLiquidCompatibleERC20ApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _HyperLiquidCompatibleERC20.contract.FilterLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return &HyperLiquidCompatibleERC20ApprovalIterator{contract: _HyperLiquidCompatibleERC20.contract, event: "Approval", logs: logs, sub: sub}, nil
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Filterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *HyperLiquidCompatibleERC20Approval, owner []common.Address, spender []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _HyperLiquidCompatibleERC20.contract.WatchLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:

				event := new(HyperLiquidCompatibleERC20Approval)
				if err := _HyperLiquidCompatibleERC20.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Filterer) ParseApproval(log types.Log) (*HyperLiquidCompatibleERC20Approval, error) {
	event := new(HyperLiquidCompatibleERC20Approval)
	if err := _HyperLiquidCompatibleERC20.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

type HyperLiquidCompatibleERC20BurnAccessGrantedIterator struct {
	Event *HyperLiquidCompatibleERC20BurnAccessGranted

	contract *bind.BoundContract
	event    string

	logs chan types.Log
	sub  ethereum.Subscription
	done bool
	fail error
}

func (it *HyperLiquidCompatibleERC20BurnAccessGrantedIterator) Next() bool {

	if it.fail != nil {
		return false
	}

	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(HyperLiquidCompatibleERC20BurnAccessGranted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}

	select {
	case log := <-it.logs:
		it.Event = new(HyperLiquidCompatibleERC20BurnAccessGranted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

func (it *HyperLiquidCompatibleERC20BurnAccessGrantedIterator) Error() error {
	return it.fail
}

func (it *HyperLiquidCompatibleERC20BurnAccessGrantedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

type HyperLiquidCompatibleERC20BurnAccessGranted struct {
	Burner common.Address
	Raw    types.Log
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Filterer) FilterBurnAccessGranted(opts *bind.FilterOpts) (*HyperLiquidCompatibleERC20BurnAccessGrantedIterator, error) {

	logs, sub, err := _HyperLiquidCompatibleERC20.contract.FilterLogs(opts, "BurnAccessGranted")
	if err != nil {
		return nil, err
	}
	return &HyperLiquidCompatibleERC20BurnAccessGrantedIterator{contract: _HyperLiquidCompatibleERC20.contract, event: "BurnAccessGranted", logs: logs, sub: sub}, nil
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Filterer) WatchBurnAccessGranted(opts *bind.WatchOpts, sink chan<- *HyperLiquidCompatibleERC20BurnAccessGranted) (event.Subscription, error) {

	logs, sub, err := _HyperLiquidCompatibleERC20.contract.WatchLogs(opts, "BurnAccessGranted")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:

				event := new(HyperLiquidCompatibleERC20BurnAccessGranted)
				if err := _HyperLiquidCompatibleERC20.contract.UnpackLog(event, "BurnAccessGranted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Filterer) ParseBurnAccessGranted(log types.Log) (*HyperLiquidCompatibleERC20BurnAccessGranted, error) {
	event := new(HyperLiquidCompatibleERC20BurnAccessGranted)
	if err := _HyperLiquidCompatibleERC20.contract.UnpackLog(event, "BurnAccessGranted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

type HyperLiquidCompatibleERC20BurnAccessRevokedIterator struct {
	Event *HyperLiquidCompatibleERC20BurnAccessRevoked

	contract *bind.BoundContract
	event    string

	logs chan types.Log
	sub  ethereum.Subscription
	done bool
	fail error
}

func (it *HyperLiquidCompatibleERC20BurnAccessRevokedIterator) Next() bool {

	if it.fail != nil {
		return false
	}

	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(HyperLiquidCompatibleERC20BurnAccessRevoked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}

	select {
	case log := <-it.logs:
		it.Event = new(HyperLiquidCompatibleERC20BurnAccessRevoked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

func (it *HyperLiquidCompatibleERC20BurnAccessRevokedIterator) Error() error {
	return it.fail
}

func (it *HyperLiquidCompatibleERC20BurnAccessRevokedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

type HyperLiquidCompatibleERC20BurnAccessRevoked struct {
	Burner common.Address
	Raw    types.Log
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Filterer) FilterBurnAccessRevoked(opts *bind.FilterOpts) (*HyperLiquidCompatibleERC20BurnAccessRevokedIterator, error) {

	logs, sub, err := _HyperLiquidCompatibleERC20.contract.FilterLogs(opts, "BurnAccessRevoked")
	if err != nil {
		return nil, err
	}
	return &HyperLiquidCompatibleERC20BurnAccessRevokedIterator{contract: _HyperLiquidCompatibleERC20.contract, event: "BurnAccessRevoked", logs: logs, sub: sub}, nil
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Filterer) WatchBurnAccessRevoked(opts *bind.WatchOpts, sink chan<- *HyperLiquidCompatibleERC20BurnAccessRevoked) (event.Subscription, error) {

	logs, sub, err := _HyperLiquidCompatibleERC20.contract.WatchLogs(opts, "BurnAccessRevoked")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:

				event := new(HyperLiquidCompatibleERC20BurnAccessRevoked)
				if err := _HyperLiquidCompatibleERC20.contract.UnpackLog(event, "BurnAccessRevoked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Filterer) ParseBurnAccessRevoked(log types.Log) (*HyperLiquidCompatibleERC20BurnAccessRevoked, error) {
	event := new(HyperLiquidCompatibleERC20BurnAccessRevoked)
	if err := _HyperLiquidCompatibleERC20.contract.UnpackLog(event, "BurnAccessRevoked", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

type HyperLiquidCompatibleERC20CCIPAdminTransferredIterator struct {
	Event *HyperLiquidCompatibleERC20CCIPAdminTransferred

	contract *bind.BoundContract
	event    string

	logs chan types.Log
	sub  ethereum.Subscription
	done bool
	fail error
}

func (it *HyperLiquidCompatibleERC20CCIPAdminTransferredIterator) Next() bool {

	if it.fail != nil {
		return false
	}

	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(HyperLiquidCompatibleERC20CCIPAdminTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}

	select {
	case log := <-it.logs:
		it.Event = new(HyperLiquidCompatibleERC20CCIPAdminTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

func (it *HyperLiquidCompatibleERC20CCIPAdminTransferredIterator) Error() error {
	return it.fail
}

func (it *HyperLiquidCompatibleERC20CCIPAdminTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

type HyperLiquidCompatibleERC20CCIPAdminTransferred struct {
	PreviousAdmin common.Address
	NewAdmin      common.Address
	Raw           types.Log
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Filterer) FilterCCIPAdminTransferred(opts *bind.FilterOpts, previousAdmin []common.Address, newAdmin []common.Address) (*HyperLiquidCompatibleERC20CCIPAdminTransferredIterator, error) {

	var previousAdminRule []interface{}
	for _, previousAdminItem := range previousAdmin {
		previousAdminRule = append(previousAdminRule, previousAdminItem)
	}
	var newAdminRule []interface{}
	for _, newAdminItem := range newAdmin {
		newAdminRule = append(newAdminRule, newAdminItem)
	}

	logs, sub, err := _HyperLiquidCompatibleERC20.contract.FilterLogs(opts, "CCIPAdminTransferred", previousAdminRule, newAdminRule)
	if err != nil {
		return nil, err
	}
	return &HyperLiquidCompatibleERC20CCIPAdminTransferredIterator{contract: _HyperLiquidCompatibleERC20.contract, event: "CCIPAdminTransferred", logs: logs, sub: sub}, nil
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Filterer) WatchCCIPAdminTransferred(opts *bind.WatchOpts, sink chan<- *HyperLiquidCompatibleERC20CCIPAdminTransferred, previousAdmin []common.Address, newAdmin []common.Address) (event.Subscription, error) {

	var previousAdminRule []interface{}
	for _, previousAdminItem := range previousAdmin {
		previousAdminRule = append(previousAdminRule, previousAdminItem)
	}
	var newAdminRule []interface{}
	for _, newAdminItem := range newAdmin {
		newAdminRule = append(newAdminRule, newAdminItem)
	}

	logs, sub, err := _HyperLiquidCompatibleERC20.contract.WatchLogs(opts, "CCIPAdminTransferred", previousAdminRule, newAdminRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:

				event := new(HyperLiquidCompatibleERC20CCIPAdminTransferred)
				if err := _HyperLiquidCompatibleERC20.contract.UnpackLog(event, "CCIPAdminTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Filterer) ParseCCIPAdminTransferred(log types.Log) (*HyperLiquidCompatibleERC20CCIPAdminTransferred, error) {
	event := new(HyperLiquidCompatibleERC20CCIPAdminTransferred)
	if err := _HyperLiquidCompatibleERC20.contract.UnpackLog(event, "CCIPAdminTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

type HyperLiquidCompatibleERC20HyperEVMLinkerSetIterator struct {
	Event *HyperLiquidCompatibleERC20HyperEVMLinkerSet

	contract *bind.BoundContract
	event    string

	logs chan types.Log
	sub  ethereum.Subscription
	done bool
	fail error
}

func (it *HyperLiquidCompatibleERC20HyperEVMLinkerSetIterator) Next() bool {

	if it.fail != nil {
		return false
	}

	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(HyperLiquidCompatibleERC20HyperEVMLinkerSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}

	select {
	case log := <-it.logs:
		it.Event = new(HyperLiquidCompatibleERC20HyperEVMLinkerSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

func (it *HyperLiquidCompatibleERC20HyperEVMLinkerSetIterator) Error() error {
	return it.fail
}

func (it *HyperLiquidCompatibleERC20HyperEVMLinkerSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

type HyperLiquidCompatibleERC20HyperEVMLinkerSet struct {
	HyperEVMLinker common.Address
	Raw            types.Log
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Filterer) FilterHyperEVMLinkerSet(opts *bind.FilterOpts, hyperEVMLinker []common.Address) (*HyperLiquidCompatibleERC20HyperEVMLinkerSetIterator, error) {

	var hyperEVMLinkerRule []interface{}
	for _, hyperEVMLinkerItem := range hyperEVMLinker {
		hyperEVMLinkerRule = append(hyperEVMLinkerRule, hyperEVMLinkerItem)
	}

	logs, sub, err := _HyperLiquidCompatibleERC20.contract.FilterLogs(opts, "HyperEVMLinkerSet", hyperEVMLinkerRule)
	if err != nil {
		return nil, err
	}
	return &HyperLiquidCompatibleERC20HyperEVMLinkerSetIterator{contract: _HyperLiquidCompatibleERC20.contract, event: "HyperEVMLinkerSet", logs: logs, sub: sub}, nil
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Filterer) WatchHyperEVMLinkerSet(opts *bind.WatchOpts, sink chan<- *HyperLiquidCompatibleERC20HyperEVMLinkerSet, hyperEVMLinker []common.Address) (event.Subscription, error) {

	var hyperEVMLinkerRule []interface{}
	for _, hyperEVMLinkerItem := range hyperEVMLinker {
		hyperEVMLinkerRule = append(hyperEVMLinkerRule, hyperEVMLinkerItem)
	}

	logs, sub, err := _HyperLiquidCompatibleERC20.contract.WatchLogs(opts, "HyperEVMLinkerSet", hyperEVMLinkerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:

				event := new(HyperLiquidCompatibleERC20HyperEVMLinkerSet)
				if err := _HyperLiquidCompatibleERC20.contract.UnpackLog(event, "HyperEVMLinkerSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Filterer) ParseHyperEVMLinkerSet(log types.Log) (*HyperLiquidCompatibleERC20HyperEVMLinkerSet, error) {
	event := new(HyperLiquidCompatibleERC20HyperEVMLinkerSet)
	if err := _HyperLiquidCompatibleERC20.contract.UnpackLog(event, "HyperEVMLinkerSet", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

type HyperLiquidCompatibleERC20MintAccessGrantedIterator struct {
	Event *HyperLiquidCompatibleERC20MintAccessGranted

	contract *bind.BoundContract
	event    string

	logs chan types.Log
	sub  ethereum.Subscription
	done bool
	fail error
}

func (it *HyperLiquidCompatibleERC20MintAccessGrantedIterator) Next() bool {

	if it.fail != nil {
		return false
	}

	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(HyperLiquidCompatibleERC20MintAccessGranted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}

	select {
	case log := <-it.logs:
		it.Event = new(HyperLiquidCompatibleERC20MintAccessGranted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

func (it *HyperLiquidCompatibleERC20MintAccessGrantedIterator) Error() error {
	return it.fail
}

func (it *HyperLiquidCompatibleERC20MintAccessGrantedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

type HyperLiquidCompatibleERC20MintAccessGranted struct {
	Minter common.Address
	Raw    types.Log
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Filterer) FilterMintAccessGranted(opts *bind.FilterOpts) (*HyperLiquidCompatibleERC20MintAccessGrantedIterator, error) {

	logs, sub, err := _HyperLiquidCompatibleERC20.contract.FilterLogs(opts, "MintAccessGranted")
	if err != nil {
		return nil, err
	}
	return &HyperLiquidCompatibleERC20MintAccessGrantedIterator{contract: _HyperLiquidCompatibleERC20.contract, event: "MintAccessGranted", logs: logs, sub: sub}, nil
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Filterer) WatchMintAccessGranted(opts *bind.WatchOpts, sink chan<- *HyperLiquidCompatibleERC20MintAccessGranted) (event.Subscription, error) {

	logs, sub, err := _HyperLiquidCompatibleERC20.contract.WatchLogs(opts, "MintAccessGranted")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:

				event := new(HyperLiquidCompatibleERC20MintAccessGranted)
				if err := _HyperLiquidCompatibleERC20.contract.UnpackLog(event, "MintAccessGranted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Filterer) ParseMintAccessGranted(log types.Log) (*HyperLiquidCompatibleERC20MintAccessGranted, error) {
	event := new(HyperLiquidCompatibleERC20MintAccessGranted)
	if err := _HyperLiquidCompatibleERC20.contract.UnpackLog(event, "MintAccessGranted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

type HyperLiquidCompatibleERC20MintAccessRevokedIterator struct {
	Event *HyperLiquidCompatibleERC20MintAccessRevoked

	contract *bind.BoundContract
	event    string

	logs chan types.Log
	sub  ethereum.Subscription
	done bool
	fail error
}

func (it *HyperLiquidCompatibleERC20MintAccessRevokedIterator) Next() bool {

	if it.fail != nil {
		return false
	}

	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(HyperLiquidCompatibleERC20MintAccessRevoked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}

	select {
	case log := <-it.logs:
		it.Event = new(HyperLiquidCompatibleERC20MintAccessRevoked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

func (it *HyperLiquidCompatibleERC20MintAccessRevokedIterator) Error() error {
	return it.fail
}

func (it *HyperLiquidCompatibleERC20MintAccessRevokedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

type HyperLiquidCompatibleERC20MintAccessRevoked struct {
	Minter common.Address
	Raw    types.Log
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Filterer) FilterMintAccessRevoked(opts *bind.FilterOpts) (*HyperLiquidCompatibleERC20MintAccessRevokedIterator, error) {

	logs, sub, err := _HyperLiquidCompatibleERC20.contract.FilterLogs(opts, "MintAccessRevoked")
	if err != nil {
		return nil, err
	}
	return &HyperLiquidCompatibleERC20MintAccessRevokedIterator{contract: _HyperLiquidCompatibleERC20.contract, event: "MintAccessRevoked", logs: logs, sub: sub}, nil
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Filterer) WatchMintAccessRevoked(opts *bind.WatchOpts, sink chan<- *HyperLiquidCompatibleERC20MintAccessRevoked) (event.Subscription, error) {

	logs, sub, err := _HyperLiquidCompatibleERC20.contract.WatchLogs(opts, "MintAccessRevoked")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:

				event := new(HyperLiquidCompatibleERC20MintAccessRevoked)
				if err := _HyperLiquidCompatibleERC20.contract.UnpackLog(event, "MintAccessRevoked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Filterer) ParseMintAccessRevoked(log types.Log) (*HyperLiquidCompatibleERC20MintAccessRevoked, error) {
	event := new(HyperLiquidCompatibleERC20MintAccessRevoked)
	if err := _HyperLiquidCompatibleERC20.contract.UnpackLog(event, "MintAccessRevoked", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

type HyperLiquidCompatibleERC20OwnershipTransferRequestedIterator struct {
	Event *HyperLiquidCompatibleERC20OwnershipTransferRequested

	contract *bind.BoundContract
	event    string

	logs chan types.Log
	sub  ethereum.Subscription
	done bool
	fail error
}

func (it *HyperLiquidCompatibleERC20OwnershipTransferRequestedIterator) Next() bool {

	if it.fail != nil {
		return false
	}

	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(HyperLiquidCompatibleERC20OwnershipTransferRequested)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}

	select {
	case log := <-it.logs:
		it.Event = new(HyperLiquidCompatibleERC20OwnershipTransferRequested)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

func (it *HyperLiquidCompatibleERC20OwnershipTransferRequestedIterator) Error() error {
	return it.fail
}

func (it *HyperLiquidCompatibleERC20OwnershipTransferRequestedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

type HyperLiquidCompatibleERC20OwnershipTransferRequested struct {
	From common.Address
	To   common.Address
	Raw  types.Log
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Filterer) FilterOwnershipTransferRequested(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*HyperLiquidCompatibleERC20OwnershipTransferRequestedIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _HyperLiquidCompatibleERC20.contract.FilterLogs(opts, "OwnershipTransferRequested", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &HyperLiquidCompatibleERC20OwnershipTransferRequestedIterator{contract: _HyperLiquidCompatibleERC20.contract, event: "OwnershipTransferRequested", logs: logs, sub: sub}, nil
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Filterer) WatchOwnershipTransferRequested(opts *bind.WatchOpts, sink chan<- *HyperLiquidCompatibleERC20OwnershipTransferRequested, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _HyperLiquidCompatibleERC20.contract.WatchLogs(opts, "OwnershipTransferRequested", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:

				event := new(HyperLiquidCompatibleERC20OwnershipTransferRequested)
				if err := _HyperLiquidCompatibleERC20.contract.UnpackLog(event, "OwnershipTransferRequested", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Filterer) ParseOwnershipTransferRequested(log types.Log) (*HyperLiquidCompatibleERC20OwnershipTransferRequested, error) {
	event := new(HyperLiquidCompatibleERC20OwnershipTransferRequested)
	if err := _HyperLiquidCompatibleERC20.contract.UnpackLog(event, "OwnershipTransferRequested", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

type HyperLiquidCompatibleERC20OwnershipTransferredIterator struct {
	Event *HyperLiquidCompatibleERC20OwnershipTransferred

	contract *bind.BoundContract
	event    string

	logs chan types.Log
	sub  ethereum.Subscription
	done bool
	fail error
}

func (it *HyperLiquidCompatibleERC20OwnershipTransferredIterator) Next() bool {

	if it.fail != nil {
		return false
	}

	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(HyperLiquidCompatibleERC20OwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}

	select {
	case log := <-it.logs:
		it.Event = new(HyperLiquidCompatibleERC20OwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

func (it *HyperLiquidCompatibleERC20OwnershipTransferredIterator) Error() error {
	return it.fail
}

func (it *HyperLiquidCompatibleERC20OwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

type HyperLiquidCompatibleERC20OwnershipTransferred struct {
	From common.Address
	To   common.Address
	Raw  types.Log
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Filterer) FilterOwnershipTransferred(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*HyperLiquidCompatibleERC20OwnershipTransferredIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _HyperLiquidCompatibleERC20.contract.FilterLogs(opts, "OwnershipTransferred", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &HyperLiquidCompatibleERC20OwnershipTransferredIterator{contract: _HyperLiquidCompatibleERC20.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Filterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *HyperLiquidCompatibleERC20OwnershipTransferred, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _HyperLiquidCompatibleERC20.contract.WatchLogs(opts, "OwnershipTransferred", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:

				event := new(HyperLiquidCompatibleERC20OwnershipTransferred)
				if err := _HyperLiquidCompatibleERC20.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Filterer) ParseOwnershipTransferred(log types.Log) (*HyperLiquidCompatibleERC20OwnershipTransferred, error) {
	event := new(HyperLiquidCompatibleERC20OwnershipTransferred)
	if err := _HyperLiquidCompatibleERC20.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

type HyperLiquidCompatibleERC20RemoteTokenSetIterator struct {
	Event *HyperLiquidCompatibleERC20RemoteTokenSet

	contract *bind.BoundContract
	event    string

	logs chan types.Log
	sub  ethereum.Subscription
	done bool
	fail error
}

func (it *HyperLiquidCompatibleERC20RemoteTokenSetIterator) Next() bool {

	if it.fail != nil {
		return false
	}

	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(HyperLiquidCompatibleERC20RemoteTokenSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}

	select {
	case log := <-it.logs:
		it.Event = new(HyperLiquidCompatibleERC20RemoteTokenSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

func (it *HyperLiquidCompatibleERC20RemoteTokenSetIterator) Error() error {
	return it.fail
}

func (it *HyperLiquidCompatibleERC20RemoteTokenSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

type HyperLiquidCompatibleERC20RemoteTokenSet struct {
	RemoteToken         common.Address
	RemoteTokenDecimals uint8
	Raw                 types.Log
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Filterer) FilterRemoteTokenSet(opts *bind.FilterOpts, remoteToken []common.Address, remoteTokenDecimals []uint8) (*HyperLiquidCompatibleERC20RemoteTokenSetIterator, error) {

	var remoteTokenRule []interface{}
	for _, remoteTokenItem := range remoteToken {
		remoteTokenRule = append(remoteTokenRule, remoteTokenItem)
	}
	var remoteTokenDecimalsRule []interface{}
	for _, remoteTokenDecimalsItem := range remoteTokenDecimals {
		remoteTokenDecimalsRule = append(remoteTokenDecimalsRule, remoteTokenDecimalsItem)
	}

	logs, sub, err := _HyperLiquidCompatibleERC20.contract.FilterLogs(opts, "RemoteTokenSet", remoteTokenRule, remoteTokenDecimalsRule)
	if err != nil {
		return nil, err
	}
	return &HyperLiquidCompatibleERC20RemoteTokenSetIterator{contract: _HyperLiquidCompatibleERC20.contract, event: "RemoteTokenSet", logs: logs, sub: sub}, nil
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Filterer) WatchRemoteTokenSet(opts *bind.WatchOpts, sink chan<- *HyperLiquidCompatibleERC20RemoteTokenSet, remoteToken []common.Address, remoteTokenDecimals []uint8) (event.Subscription, error) {

	var remoteTokenRule []interface{}
	for _, remoteTokenItem := range remoteToken {
		remoteTokenRule = append(remoteTokenRule, remoteTokenItem)
	}
	var remoteTokenDecimalsRule []interface{}
	for _, remoteTokenDecimalsItem := range remoteTokenDecimals {
		remoteTokenDecimalsRule = append(remoteTokenDecimalsRule, remoteTokenDecimalsItem)
	}

	logs, sub, err := _HyperLiquidCompatibleERC20.contract.WatchLogs(opts, "RemoteTokenSet", remoteTokenRule, remoteTokenDecimalsRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:

				event := new(HyperLiquidCompatibleERC20RemoteTokenSet)
				if err := _HyperLiquidCompatibleERC20.contract.UnpackLog(event, "RemoteTokenSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Filterer) ParseRemoteTokenSet(log types.Log) (*HyperLiquidCompatibleERC20RemoteTokenSet, error) {
	event := new(HyperLiquidCompatibleERC20RemoteTokenSet)
	if err := _HyperLiquidCompatibleERC20.contract.UnpackLog(event, "RemoteTokenSet", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

type HyperLiquidCompatibleERC20TransferIterator struct {
	Event *HyperLiquidCompatibleERC20Transfer

	contract *bind.BoundContract
	event    string

	logs chan types.Log
	sub  ethereum.Subscription
	done bool
	fail error
}

func (it *HyperLiquidCompatibleERC20TransferIterator) Next() bool {

	if it.fail != nil {
		return false
	}

	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(HyperLiquidCompatibleERC20Transfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}

	select {
	case log := <-it.logs:
		it.Event = new(HyperLiquidCompatibleERC20Transfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

func (it *HyperLiquidCompatibleERC20TransferIterator) Error() error {
	return it.fail
}

func (it *HyperLiquidCompatibleERC20TransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

type HyperLiquidCompatibleERC20Transfer struct {
	From  common.Address
	To    common.Address
	Value *big.Int
	Raw   types.Log
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Filterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*HyperLiquidCompatibleERC20TransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _HyperLiquidCompatibleERC20.contract.FilterLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &HyperLiquidCompatibleERC20TransferIterator{contract: _HyperLiquidCompatibleERC20.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Filterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *HyperLiquidCompatibleERC20Transfer, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _HyperLiquidCompatibleERC20.contract.WatchLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:

				event := new(HyperLiquidCompatibleERC20Transfer)
				if err := _HyperLiquidCompatibleERC20.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20Filterer) ParseTransfer(log types.Log) (*HyperLiquidCompatibleERC20Transfer, error) {
	event := new(HyperLiquidCompatibleERC20Transfer)
	if err := _HyperLiquidCompatibleERC20.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20) ParseLog(log types.Log) (generated.AbigenLog, error) {
	switch log.Topics[0] {
	case _HyperLiquidCompatibleERC20.abi.Events["Approval"].ID:
		return _HyperLiquidCompatibleERC20.ParseApproval(log)
	case _HyperLiquidCompatibleERC20.abi.Events["BurnAccessGranted"].ID:
		return _HyperLiquidCompatibleERC20.ParseBurnAccessGranted(log)
	case _HyperLiquidCompatibleERC20.abi.Events["BurnAccessRevoked"].ID:
		return _HyperLiquidCompatibleERC20.ParseBurnAccessRevoked(log)
	case _HyperLiquidCompatibleERC20.abi.Events["CCIPAdminTransferred"].ID:
		return _HyperLiquidCompatibleERC20.ParseCCIPAdminTransferred(log)
	case _HyperLiquidCompatibleERC20.abi.Events["HyperEVMLinkerSet"].ID:
		return _HyperLiquidCompatibleERC20.ParseHyperEVMLinkerSet(log)
	case _HyperLiquidCompatibleERC20.abi.Events["MintAccessGranted"].ID:
		return _HyperLiquidCompatibleERC20.ParseMintAccessGranted(log)
	case _HyperLiquidCompatibleERC20.abi.Events["MintAccessRevoked"].ID:
		return _HyperLiquidCompatibleERC20.ParseMintAccessRevoked(log)
	case _HyperLiquidCompatibleERC20.abi.Events["OwnershipTransferRequested"].ID:
		return _HyperLiquidCompatibleERC20.ParseOwnershipTransferRequested(log)
	case _HyperLiquidCompatibleERC20.abi.Events["OwnershipTransferred"].ID:
		return _HyperLiquidCompatibleERC20.ParseOwnershipTransferred(log)
	case _HyperLiquidCompatibleERC20.abi.Events["RemoteTokenSet"].ID:
		return _HyperLiquidCompatibleERC20.ParseRemoteTokenSet(log)
	case _HyperLiquidCompatibleERC20.abi.Events["Transfer"].ID:
		return _HyperLiquidCompatibleERC20.ParseTransfer(log)

	default:
		return nil, fmt.Errorf("abigen wrapper received unknown log topic: %v", log.Topics[0])
	}
}

func (HyperLiquidCompatibleERC20Approval) Topic() common.Hash {
	return common.HexToHash("0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925")
}

func (HyperLiquidCompatibleERC20BurnAccessGranted) Topic() common.Hash {
	return common.HexToHash("0x92308bb7573b2a3d17ddb868b39d8ebec433f3194421abc22d084f89658c9bad")
}

func (HyperLiquidCompatibleERC20BurnAccessRevoked) Topic() common.Hash {
	return common.HexToHash("0x0a675452746933cefe3d74182e78db7afe57ba60eaa4234b5d85e9aa41b0610c")
}

func (HyperLiquidCompatibleERC20CCIPAdminTransferred) Topic() common.Hash {
	return common.HexToHash("0x9524c9e4b0b61eb018dd58a1cd856e3e74009528328ab4a613b434fa631d7242")
}

func (HyperLiquidCompatibleERC20HyperEVMLinkerSet) Topic() common.Hash {
	return common.HexToHash("0x58dc48d21bdfdfd38a14ec5c284648779a185303f99274a36e229247ad554b00")
}

func (HyperLiquidCompatibleERC20MintAccessGranted) Topic() common.Hash {
	return common.HexToHash("0xe46fef8bbff1389d9010703cf8ebb363fb3daf5bf56edc27080b67bc8d9251ea")
}

func (HyperLiquidCompatibleERC20MintAccessRevoked) Topic() common.Hash {
	return common.HexToHash("0xed998b960f6340d045f620c119730f7aa7995e7425c2401d3a5b64ff998a59e9")
}

func (HyperLiquidCompatibleERC20OwnershipTransferRequested) Topic() common.Hash {
	return common.HexToHash("0xed8889f560326eb138920d842192f0eb3dd22b4f139c87a2c57538e05bae1278")
}

func (HyperLiquidCompatibleERC20OwnershipTransferred) Topic() common.Hash {
	return common.HexToHash("0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0")
}

func (HyperLiquidCompatibleERC20RemoteTokenSet) Topic() common.Hash {
	return common.HexToHash("0xcaad7af228c332327e445ee0094747b901ce6003bf4ca2b0a1a7377f9bd22cb1")
}

func (HyperLiquidCompatibleERC20Transfer) Topic() common.Hash {
	return common.HexToHash("0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef")
}

func (_HyperLiquidCompatibleERC20 *HyperLiquidCompatibleERC20) Address() common.Address {
	return _HyperLiquidCompatibleERC20.address
}

type HyperLiquidCompatibleERC20Interface interface {
	SPOTBALANCEPRECOMPILE(opts *bind.CallOpts) (common.Address, error)

	Allowance(opts *bind.CallOpts, owner common.Address, spender common.Address) (*big.Int, error)

	BalanceOf(opts *bind.CallOpts, account common.Address) (*big.Int, error)

	Decimals(opts *bind.CallOpts) (uint8, error)

	GetBurners(opts *bind.CallOpts) ([]common.Address, error)

	GetCCIPAdmin(opts *bind.CallOpts) (common.Address, error)

	GetHyperEVMLinker(opts *bind.CallOpts) (common.Address, error)

	GetMinters(opts *bind.CallOpts) ([]common.Address, error)

	IsBurner(opts *bind.CallOpts, burner common.Address) (bool, error)

	IsMinter(opts *bind.CallOpts, minter common.Address) (bool, error)

	MaxSupply(opts *bind.CallOpts) (*big.Int, error)

	Name(opts *bind.CallOpts) (string, error)

	Owner(opts *bind.CallOpts) (common.Address, error)

	SupportsInterface(opts *bind.CallOpts, interfaceId [4]byte) (bool, error)

	Symbol(opts *bind.CallOpts) (string, error)

	TotalSupply(opts *bind.CallOpts) (*big.Int, error)

	AcceptOwnership(opts *bind.TransactOpts) (*types.Transaction, error)

	Approve(opts *bind.TransactOpts, spender common.Address, amount *big.Int) (*types.Transaction, error)

	Burn(opts *bind.TransactOpts, amount *big.Int) (*types.Transaction, error)

	Burn0(opts *bind.TransactOpts, account common.Address, amount *big.Int) (*types.Transaction, error)

	BurnFrom(opts *bind.TransactOpts, account common.Address, amount *big.Int) (*types.Transaction, error)

	DecreaseAllowance(opts *bind.TransactOpts, spender common.Address, subtractedValue *big.Int) (*types.Transaction, error)

	DecreaseApproval(opts *bind.TransactOpts, spender common.Address, subtractedValue *big.Int) (*types.Transaction, error)

	GrantBurnRole(opts *bind.TransactOpts, burner common.Address) (*types.Transaction, error)

	GrantMintAndBurnRoles(opts *bind.TransactOpts, burnAndMinter common.Address) (*types.Transaction, error)

	GrantMintRole(opts *bind.TransactOpts, minter common.Address) (*types.Transaction, error)

	IncreaseAllowance(opts *bind.TransactOpts, spender common.Address, addedValue *big.Int) (*types.Transaction, error)

	IncreaseApproval(opts *bind.TransactOpts, spender common.Address, addedValue *big.Int) (*types.Transaction, error)

	Mint(opts *bind.TransactOpts, account common.Address, amount *big.Int) (*types.Transaction, error)

	RevokeBurnRole(opts *bind.TransactOpts, burner common.Address) (*types.Transaction, error)

	RevokeMintRole(opts *bind.TransactOpts, minter common.Address) (*types.Transaction, error)

	SetCCIPAdmin(opts *bind.TransactOpts, newAdmin common.Address) (*types.Transaction, error)

	SetHyperEVMLinker(opts *bind.TransactOpts, newLinker common.Address) (*types.Transaction, error)

	SetRemoteToken(opts *bind.TransactOpts, remoteToken common.Address, remoteTokenDecimals uint8) (*types.Transaction, error)

	Transfer(opts *bind.TransactOpts, to common.Address, amount *big.Int) (*types.Transaction, error)

	TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error)

	TransferOwnership(opts *bind.TransactOpts, to common.Address) (*types.Transaction, error)

	FilterApproval(opts *bind.FilterOpts, owner []common.Address, spender []common.Address) (*HyperLiquidCompatibleERC20ApprovalIterator, error)

	WatchApproval(opts *bind.WatchOpts, sink chan<- *HyperLiquidCompatibleERC20Approval, owner []common.Address, spender []common.Address) (event.Subscription, error)

	ParseApproval(log types.Log) (*HyperLiquidCompatibleERC20Approval, error)

	FilterBurnAccessGranted(opts *bind.FilterOpts) (*HyperLiquidCompatibleERC20BurnAccessGrantedIterator, error)

	WatchBurnAccessGranted(opts *bind.WatchOpts, sink chan<- *HyperLiquidCompatibleERC20BurnAccessGranted) (event.Subscription, error)

	ParseBurnAccessGranted(log types.Log) (*HyperLiquidCompatibleERC20BurnAccessGranted, error)

	FilterBurnAccessRevoked(opts *bind.FilterOpts) (*HyperLiquidCompatibleERC20BurnAccessRevokedIterator, error)

	WatchBurnAccessRevoked(opts *bind.WatchOpts, sink chan<- *HyperLiquidCompatibleERC20BurnAccessRevoked) (event.Subscription, error)

	ParseBurnAccessRevoked(log types.Log) (*HyperLiquidCompatibleERC20BurnAccessRevoked, error)

	FilterCCIPAdminTransferred(opts *bind.FilterOpts, previousAdmin []common.Address, newAdmin []common.Address) (*HyperLiquidCompatibleERC20CCIPAdminTransferredIterator, error)

	WatchCCIPAdminTransferred(opts *bind.WatchOpts, sink chan<- *HyperLiquidCompatibleERC20CCIPAdminTransferred, previousAdmin []common.Address, newAdmin []common.Address) (event.Subscription, error)

	ParseCCIPAdminTransferred(log types.Log) (*HyperLiquidCompatibleERC20CCIPAdminTransferred, error)

	FilterHyperEVMLinkerSet(opts *bind.FilterOpts, hyperEVMLinker []common.Address) (*HyperLiquidCompatibleERC20HyperEVMLinkerSetIterator, error)

	WatchHyperEVMLinkerSet(opts *bind.WatchOpts, sink chan<- *HyperLiquidCompatibleERC20HyperEVMLinkerSet, hyperEVMLinker []common.Address) (event.Subscription, error)

	ParseHyperEVMLinkerSet(log types.Log) (*HyperLiquidCompatibleERC20HyperEVMLinkerSet, error)

	FilterMintAccessGranted(opts *bind.FilterOpts) (*HyperLiquidCompatibleERC20MintAccessGrantedIterator, error)

	WatchMintAccessGranted(opts *bind.WatchOpts, sink chan<- *HyperLiquidCompatibleERC20MintAccessGranted) (event.Subscription, error)

	ParseMintAccessGranted(log types.Log) (*HyperLiquidCompatibleERC20MintAccessGranted, error)

	FilterMintAccessRevoked(opts *bind.FilterOpts) (*HyperLiquidCompatibleERC20MintAccessRevokedIterator, error)

	WatchMintAccessRevoked(opts *bind.WatchOpts, sink chan<- *HyperLiquidCompatibleERC20MintAccessRevoked) (event.Subscription, error)

	ParseMintAccessRevoked(log types.Log) (*HyperLiquidCompatibleERC20MintAccessRevoked, error)

	FilterOwnershipTransferRequested(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*HyperLiquidCompatibleERC20OwnershipTransferRequestedIterator, error)

	WatchOwnershipTransferRequested(opts *bind.WatchOpts, sink chan<- *HyperLiquidCompatibleERC20OwnershipTransferRequested, from []common.Address, to []common.Address) (event.Subscription, error)

	ParseOwnershipTransferRequested(log types.Log) (*HyperLiquidCompatibleERC20OwnershipTransferRequested, error)

	FilterOwnershipTransferred(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*HyperLiquidCompatibleERC20OwnershipTransferredIterator, error)

	WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *HyperLiquidCompatibleERC20OwnershipTransferred, from []common.Address, to []common.Address) (event.Subscription, error)

	ParseOwnershipTransferred(log types.Log) (*HyperLiquidCompatibleERC20OwnershipTransferred, error)

	FilterRemoteTokenSet(opts *bind.FilterOpts, remoteToken []common.Address, remoteTokenDecimals []uint8) (*HyperLiquidCompatibleERC20RemoteTokenSetIterator, error)

	WatchRemoteTokenSet(opts *bind.WatchOpts, sink chan<- *HyperLiquidCompatibleERC20RemoteTokenSet, remoteToken []common.Address, remoteTokenDecimals []uint8) (event.Subscription, error)

	ParseRemoteTokenSet(log types.Log) (*HyperLiquidCompatibleERC20RemoteTokenSet, error)

	FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*HyperLiquidCompatibleERC20TransferIterator, error)

	WatchTransfer(opts *bind.WatchOpts, sink chan<- *HyperLiquidCompatibleERC20Transfer, from []common.Address, to []common.Address) (event.Subscription, error)

	ParseTransfer(log types.Log) (*HyperLiquidCompatibleERC20Transfer, error)

	ParseLog(log types.Log) (generated.AbigenLog, error)

	Address() common.Address
}
