# Test Plan for OffRampOverSuperchainInterop

## Executive Summary

This test plan outlines the strategy for testing OffRampOverSuperchainInterop, which is a modified version of the regular OffRamp contract that uses Optimism's Superchain Interop for cross-chain message verification instead of OCR3-based merkle root commits. The plan emphasizes avoiding test duplication while ensuring comprehensive coverage of both inherited and new functionality.

## Contract Analysis

### Key Differences from Regular OffRamp
1. **No OCR3 inheritance**: Uses Ownable2StepMsgSender instead of MultiOCR3Base
2. **CrossL2Inbox validation**: Replaces merkle root verification with CrossL2Inbox.validateMessage
3. **Allowed transmitters**: Manual transmitter management instead of OCR3 signers
4. **Chain mapping**: New chainSelector to chainId mapping functionality
5. **Execution flow**: Different execute() and manuallyExecute() signatures
6. **No commit phase**: Messages are validated directly without a separate commit step

### Unchanged Functionality (Lines 558-1003)
- Execution state management (getExecutionState, _setExecutionState)
- Trial execution (_trialExecute)
- Single message execution (executeSingleMessage)
- Token handling (_releaseOrMintSingleToken, _releaseOrMintTokens, _getBalanceOfReceiver)
- Configuration management (getDynamicConfig, setDynamicConfig, applySourceChainConfigUpdates)
- ccipReceive (always reverts)

## Test Strategy to Avoid Duplication

### 1. Create Abstract Base Test Contract

```solidity
// contracts/test/offRamp/OffRampCommonTests.t.sol
abstract contract OffRampCommonTests is BaseTest {
    // Abstract functions that implementations must override
    function _deployOffRamp() internal virtual returns (address);
    function _executeMessage(Internal.Any2EVMRampMessage memory message) internal virtual;
    function _generateValidExecutionContext(Internal.Any2EVMRampMessage memory message) 
        internal virtual returns (bytes memory);
    function _setupExecutionEnvironment() internal virtual;
    
    // Common test functions for unchanged functionality
    function test_getExecutionState() public { }
    function test_setExecutionState() public { }
    function test_releaseOrMintSingleToken_Success() public { }
    function test_releaseOrMintSingleToken_PoolDoesNotExist() public { }
    function test_releaseOrMintSingleToken_BalanceMismatch() public { }
    function test_releaseOrMintTokens_MultipleTokens() public { }
    function test_trialExecute_Success() public { }
    function test_trialExecute_Failure() public { }
    function test_executeSingleMessage_NoTokens() public { }
    function test_executeSingleMessage_WithTokens() public { }
    function test_executeSingleMessage_MessageInterceptor() public { }
    function test_setDynamicConfig() public { }
    function test_applySourceChainConfigUpdates() public { }
    function test_ccipReceive_AlwaysReverts() public { }
}
```

### 2. Implementation for OffRampOverSuperchainInterop

```solidity
// contracts/test/offRamp/OffRampOverSuperchainInterop/OffRampOverSuperchainInterop_CommonFunctionality.t.sol
contract OffRampOverSuperchainInterop_CommonFunctionality is OffRampCommonTests, OffRampOverSuperchainInteropSetup {
    function _deployOffRamp() internal override returns (address) {
        return address(s_offRamp);
    }
    
    function _executeMessage(Internal.Any2EVMRampMessage memory message) internal override {
        SuperchainInterop.ExecutionReport memory report = _generateExecutionReport(message);
        vm.prank(s_allowedTransmitter);
        s_offRamp.execute(report);
    }
    
    function _generateValidExecutionContext(Internal.Any2EVMRampMessage memory message) 
        internal override returns (bytes memory) {
        return _generateValidLogData(message);
    }
    
    function _setupExecutionEnvironment() internal override {
        // Setup CrossL2Inbox mocks
        // Add allowed transmitters
        // Configure chain mappings
    }
}
```

### 3. Test Only New/Changed Functionality

Create dedicated test files for features unique to OffRampOverSuperchainInterop:

```
contracts/test/offRamp/OffRampOverSuperchainInterop/
├── OffRampOverSuperchainInteropSetup.t.sol
├── OffRampOverSuperchainInterop.constructor.t.sol
├── OffRampOverSuperchainInterop.execute.t.sol
├── OffRampOverSuperchainInterop.manuallyExecute.t.sol
├── OffRampOverSuperchainInterop.decodeLogDataIntoMessage.t.sol
├── OffRampOverSuperchainInterop.executeSingleReport.t.sol
├── OffRampOverSuperchainInterop.applyAllowedTransmitterUpdates.t.sol
├── OffRampOverSuperchainInterop.applyChainSelectorToChainIdConfigUpdates.t.sol
├── OffRampOverSuperchainInterop.getStaticConfig.t.sol
├── OffRampOverSuperchainInterop.whenChainNotForked.t.sol
└── OffRampOverSuperchainInterop_CommonFunctionality.t.sol
```

## Detailed Test Coverage

### Constructor Tests (OffRampOverSuperchainInterop.constructor.t.sol)
- Valid deployment with all parameters
- Zero address validation for crossL2Inbox
- Zero address validation for tokenAdminRegistry
- Zero address validation for nonceManager
- Zero chain selector validation
- Initial allowed transmitters setup
- Initial chain selector to chain ID mapping
- Chain ID capture at deployment
- Event emissions (StaticConfigSet, DynamicConfigSet, etc.)

### Execute Function Tests (OffRampOverSuperchainInterop.execute.t.sol)
- Success: Valid execution by allowed transmitter
- Success: Multiple messages execution
- Revert: Unauthorized transmitter
- Gas estimation sender bypass
- Event emissions

### Manual Execute Tests (OffRampOverSuperchainInterop.manuallyExecute.t.sol)
- Success: Manual execution after threshold time
- Success: Manual execution of previously failed message
- Success: Gas limit override
- Success: Token gas overrides
- Revert: Manual execution before threshold
- Revert: Invalid gas limit (lower than original)
- Revert: Invalid token gas override
- Revert: Gas amount count mismatch

### Message Decoding Tests (OffRampOverSuperchainInterop.decodeLogDataIntoMessage.t.sol)
- Success: Valid log data decoding
- Revert: Invalid selector
- Revert: Destination chain selector mismatch
- Revert: Sequence number mismatch
- Edge case: Malformed log data

### Execute Single Report Tests (OffRampOverSuperchainInterop.executeSingleReport.t.sol)
- Success: Valid report execution
- Success: State transitions (UNTOUCHED -> SUCCESS/FAILURE)
- Success: Nonce management for ordered messages
- Success: Skip already executed messages
- Revert: Invalid destination chain selector
- Revert: Invalid source OnRamp
- Revert: Chain ID not configured
- Revert: Chain ID mismatch
- CrossL2Inbox validation integration
- Event emissions with correct message hash

### Transmitter Management Tests (OffRampOverSuperchainInterop.applyAllowedTransmitterUpdates.t.sol)
- Add single transmitter
- Add multiple transmitters
- Remove transmitter
- Add and remove in same call
- Zero address validation
- Duplicate transmitter handling
- Event emissions

### Chain Mapping Tests (OffRampOverSuperchainInterop.applyChainSelectorToChainIdConfigUpdates.t.sol)
- Set single mapping
- Set multiple mappings
- Unset mapping
- Update existing mapping
- Zero chain ID validation
- Zero chain selector validation
- Event emissions

### Static Config Tests (OffRampOverSuperchainInterop.getStaticConfig.t.sol)
- Verify all static config values
- CrossL2Inbox address included

### Fork Detection Tests (OffRampOverSuperchainInterop.whenChainNotForked.t.sol)
- Success: Same chain ID
- Revert: Chain fork detected

## Test Data Helpers

### Setup Contract Structure

```solidity
contract OffRampOverSuperchainInteropSetup is BaseTest, TokenSetup {
    OffRampOverSuperchainInterop internal s_offRamp;
    ICrossL2Inbox internal s_mockCrossL2Inbox;
    
    address internal s_allowedTransmitter = makeAddr("transmitter");
    uint64 internal SOURCE_CHAIN_SELECTOR = 1;
    uint256 internal SOURCE_CHAIN_ID = 10; // Optimism
    
    function setUp() public virtual override {
        super.setUp();
        
        // Deploy mock CrossL2Inbox
        s_mockCrossL2Inbox = new MockCrossL2Inbox();
        
        // Deploy OffRampOverSuperchainInterop
        OffRampOverSuperchainInterop.StaticConfig memory staticConfig = 
            OffRampOverSuperchainInterop.StaticConfig({
                chainSelector: DEST_CHAIN_SELECTOR,
                gasForCallExactCheck: 5000,
                crossL2Inbox: s_mockCrossL2Inbox,
                tokenAdminRegistry: address(s_tokenAdminRegistry),
                nonceManager: address(s_nonceManager)
            });
            
        // ... continue setup
    }
    
    // Helper functions
    function _generateExecutionReport(
        Internal.Any2EVMRampMessage memory message
    ) internal returns (SuperchainInterop.ExecutionReport memory);
    
    function _generateValidLogData(
        Internal.Any2EVMRampMessage memory message
    ) internal returns (bytes memory);
    
    function _mockCrossL2InboxValidation(
        Identifier memory identifier,
        bytes32 messageHash,
        bool shouldSucceed
    ) internal;
}
```

## Integration Test Scenarios

### CrossL2Inbox Integration
1. Mock successful validation
2. Mock validation failure
3. Test with different identifiers
4. Verify correct message hash calculation

### Message Flow Tests
1. End-to-end message execution with tokens
2. Message execution without tokens
3. Failed message retry with manual execution
4. Concurrent execution attempts

### Gas Limit Tests
1. Exact gas usage for token transfers
2. Receiver execution gas limits
3. Gas estimation mode behavior

## Benefits of This Approach

1. **80% Test Reuse**: Most functionality tests are written once and inherited
2. **Clear Separation**: New features are tested in isolation
3. **Maintainability**: Changes to common tests automatically apply to both contracts
4. **No Duplication**: Common test logic exists in one place
5. **Flexibility**: Can add contract-specific assertions as needed

## Execution Timeline

### Phase 1: Infrastructure (Day 1)
- Create OffRampCommonTests abstract contract
- Set up OffRampOverSuperchainInteropSetup
- Create test data helpers

### Phase 2: Common Tests Migration (Day 2-3)
- Migrate execution state tests
- Migrate token handling tests
- Migrate configuration tests
- Implement abstract methods for both contracts

### Phase 3: New Functionality Tests (Day 4-5)
- Constructor and static config
- Execute and manual execute
- Message decoding
- Transmitter management
- Chain mapping

### Phase 4: Integration Tests (Day 6)
- CrossL2Inbox integration
- End-to-end scenarios
- Edge cases and error paths

### Phase 5: Validation (Day 7)
- Coverage analysis
- Gas optimization tests
- Final review and cleanup

## Success Metrics

- 100% code coverage for new functionality
- 95%+ code coverage for inherited functionality
- Zero test duplication between OffRamp and OffRampOverSuperchainInterop
- All critical security paths tested
- Clear documentation and maintainable test structure