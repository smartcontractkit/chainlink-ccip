// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package mcm

import (
	"encoding/json"
	"errors"
	"fmt"
	ag_jsonrpc "github.com/gagliardetto/solana-go/rpc/jsonrpc"
)

var (
	_ *json.Encoder        = nil
	_ *ag_jsonrpc.RPCError = nil
	_ fmt.Formatter        = nil
	_                      = errors.ErrUnsupported
)
var (
	ErrInvalidInputs = &customErrorDef{
		code: 6000,
		msg:  "Invalid inputs",
		name: "InvalidInputs",
	}
	ErrOverflow = &customErrorDef{
		code: 6001,
		msg:  "overflow occurred.",
		name: "Overflow",
	}
	ErrWrongMultiSig = &customErrorDef{
		code: 6002,
		msg:  "Invalid multisig",
		name: "WrongMultiSig",
	}
	ErrWrongChainId = &customErrorDef{
		code: 6003,
		msg:  "Invalid chainID",
		name: "WrongChainId",
	}
	ErrFailedEcdsaRecover = &customErrorDef{
		code: 6004,
		msg:  "Failed ECDSA recover",
		name: "FailedEcdsaRecover",
	}
	ErrSignersNotFinalized = &customErrorDef{
		code: 6005,
		msg:  "Config signers not finalized",
		name: "SignersNotFinalized",
	}
	ErrSignersAlreadyFinalized = &customErrorDef{
		code: 6006,
		msg:  "Config signers already finalized",
		name: "SignersAlreadyFinalized",
	}
	ErrSignaturesAlreadyFinalized = &customErrorDef{
		code: 6007,
		msg:  "Signatures already finalized",
		name: "SignaturesAlreadyFinalized",
	}
	ErrSignatureCountMismatch = &customErrorDef{
		code: 6008,
		msg:  "Uploaded signatures count mismatch",
		name: "SignatureCountMismatch",
	}
	ErrTooManySignatures = &customErrorDef{
		code: 6009,
		msg:  "Too many signatures",
		name: "TooManySignatures",
	}
	ErrSignaturesNotFinalized = &customErrorDef{
		code: 6010,
		msg:  "Signatures not finalized",
		name: "SignaturesNotFinalized",
	}
	ErrMismatchedInputSignerVectorsLength = &customErrorDef{
		code: 6200,
		msg:  "The input vectors for signer addresses and signer groups must have the same length",
		name: "MismatchedInputSignerVectorsLength",
	}
	ErrOutOfBoundsNumOfSigners = &customErrorDef{
		code: 6201,
		msg:  "The number of signers is 0 or greater than MAX_NUM_SIGNERS",
		name: "OutOfBoundsNumOfSigners",
	}
	ErrMismatchedInputGroupArraysLength = &customErrorDef{
		code: 6202,
		msg:  "The input arrays for group parents and group quorums must be of length NUM_GROUPS",
		name: "MismatchedInputGroupArraysLength",
	}
	ErrGroupTreeNotWellFormed = &customErrorDef{
		code: 6203,
		msg:  "the group tree isn't well-formed.",
		name: "GroupTreeNotWellFormed",
	}
	ErrSignerInDisabledGroup = &customErrorDef{
		code: 6204,
		msg:  "a disabled group contains a signer.",
		name: "SignerInDisabledGroup",
	}
	ErrOutOfBoundsGroupQuorum = &customErrorDef{
		code: 6205,
		msg:  "the quorum of some group is larger than the number of signers in it.",
		name: "OutOfBoundsGroupQuorum",
	}
	ErrSignersAddressesMustBeStrictlyIncreasing = &customErrorDef{
		code: 6206,
		msg:  "the signers' addresses are not a strictly increasing monotone sequence.",
		name: "SignersAddressesMustBeStrictlyIncreasing",
	}
	ErrSignedHashAlreadySeen = &customErrorDef{
		code: 6207,
		msg:  "The combination of signature and valid_until has already been seen",
		name: "SignedHashAlreadySeen",
	}
	ErrInvalidSigner = &customErrorDef{
		code: 6208,
		msg:  "Invalid signer",
		name: "InvalidSigner",
	}
	ErrMissingConfig = &customErrorDef{
		code: 6209,
		msg:  "Missing configuration",
		name: "MissingConfig",
	}
	ErrInsufficientSigners = &customErrorDef{
		code: 6210,
		msg:  "Insufficient signers",
		name: "InsufficientSigners",
	}
	ErrValidUntilHasAlreadyPassed = &customErrorDef{
		code: 6211,
		msg:  "Valid until has already passed",
		name: "ValidUntilHasAlreadyPassed",
	}
	ErrProofCannotBeVerified = &customErrorDef{
		code: 6212,
		msg:  "Proof cannot be verified",
		name: "ProofCannotBeVerified",
	}
	ErrPendingOps = &customErrorDef{
		code: 6213,
		msg:  "Pending operations",
		name: "PendingOps",
	}
	ErrWrongPreOpCount = &customErrorDef{
		code: 6214,
		msg:  "Wrong pre-operation count",
		name: "WrongPreOpCount",
	}
	ErrWrongPostOpCount = &customErrorDef{
		code: 6215,
		msg:  "Wrong post-operation count",
		name: "WrongPostOpCount",
	}
	ErrPostOpCountReached = &customErrorDef{
		code: 6216,
		msg:  "Post-operation count reached",
		name: "PostOpCountReached",
	}
	ErrRootExpired = &customErrorDef{
		code: 6217,
		msg:  "Root expired",
		name: "RootExpired",
	}
	ErrWrongNonce = &customErrorDef{
		code: 6218,
		msg:  "Wrong nonce",
		name: "WrongNonce",
	}
	Errors = map[int]CustomError{
		6000: ErrInvalidInputs,
		6001: ErrOverflow,
		6002: ErrWrongMultiSig,
		6003: ErrWrongChainId,
		6004: ErrFailedEcdsaRecover,
		6005: ErrSignersNotFinalized,
		6006: ErrSignersAlreadyFinalized,
		6007: ErrSignaturesAlreadyFinalized,
		6008: ErrSignatureCountMismatch,
		6009: ErrTooManySignatures,
		6010: ErrSignaturesNotFinalized,
		6200: ErrMismatchedInputSignerVectorsLength,
		6201: ErrOutOfBoundsNumOfSigners,
		6202: ErrMismatchedInputGroupArraysLength,
		6203: ErrGroupTreeNotWellFormed,
		6204: ErrSignerInDisabledGroup,
		6205: ErrOutOfBoundsGroupQuorum,
		6206: ErrSignersAddressesMustBeStrictlyIncreasing,
		6207: ErrSignedHashAlreadySeen,
		6208: ErrInvalidSigner,
		6209: ErrMissingConfig,
		6210: ErrInsufficientSigners,
		6211: ErrValidUntilHasAlreadyPassed,
		6212: ErrProofCannotBeVerified,
		6213: ErrPendingOps,
		6214: ErrWrongPreOpCount,
		6215: ErrWrongPostOpCount,
		6216: ErrPostOpCountReached,
		6217: ErrRootExpired,
		6218: ErrWrongNonce,
	}
)

type CustomError interface {
	Code() int
	Name() string
	Error() string
}

type customErrorDef struct {
	code int
	name string
	msg  string
}

func (e *customErrorDef) Code() int {
	return e.code
}

func (e *customErrorDef) Name() string {
	return e.name
}

func (e *customErrorDef) Error() string {
	return fmt.Sprintf("%s(%d): %s", e.name, e.code, e.msg)
}

func DecodeCustomError(rpcErr error) (err error, ok bool) {
	if errCode, o := decodeErrorCode(rpcErr); o {
		if customErr, o := Errors[errCode]; o {
			err = customErr
			ok = true
			return
		}
	}
	return
}

func decodeErrorCode(rpcErr error) (errorCode int, ok bool) {
	var jErr *ag_jsonrpc.RPCError
	if errors.As(rpcErr, &jErr) && jErr.Data != nil {
		if root, o := jErr.Data.(map[string]interface{}); o {
			if rootErr, o := root["err"].(map[string]interface{}); o {
				if rootErrInstructionError, o := rootErr["InstructionError"]; o {
					if rootErrInstructionErrorItems, o := rootErrInstructionError.([]interface{}); o {
						if len(rootErrInstructionErrorItems) == 2 {
							if v, o := rootErrInstructionErrorItems[1].(map[string]interface{}); o {
								if v2, o := v["Custom"].(json.Number); o {
									if code, err := v2.Int64(); err == nil {
										ok = true
										errorCode = int(code)
									}
								} else if v2, o := v["Custom"].(float64); o {
									ok = true
									errorCode = int(v2)
								}
							}
						}
					}
				}
			}
		}
	}
	return
}
