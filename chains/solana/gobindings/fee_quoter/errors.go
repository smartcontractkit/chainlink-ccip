// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package fee_quoter

import (
	"encoding/json"
	"errors"
	"fmt"
	ag_jsonrpc "github.com/gagliardetto/solana-go/rpc/jsonrpc"
)

var (
	_ *json.Encoder        = nil
	_ *ag_jsonrpc.RPCError = nil
	_ fmt.Formatter        = nil
	_                      = errors.ErrUnsupported
)
var (
	ErrUnauthorized = &customErrorDef{
		code: 8000,
		msg:  "The signer is unauthorized",
		name: "Unauthorized",
	}
	ErrInvalidInputs = &customErrorDef{
		code: 8001,
		msg:  "Invalid inputs",
		name: "InvalidInputs",
	}
	ErrZeroGasLimit = &customErrorDef{
		code: 8002,
		msg:  "Gas limit is zero",
		name: "ZeroGasLimit",
	}
	ErrDefaultGasLimitExceedsMaximum = &customErrorDef{
		code: 8003,
		msg:  "Default gas limit exceeds the maximum",
		name: "DefaultGasLimitExceedsMaximum",
	}
	ErrInvalidVersion = &customErrorDef{
		code: 8004,
		msg:  "Invalid version of the onchain state",
		name: "InvalidVersion",
	}
	ErrRedundantOwnerProposal = &customErrorDef{
		code: 8005,
		msg:  "Proposed owner is the current owner",
		name: "RedundantOwnerProposal",
	}
	ErrInvalidInputsMissingWritable = &customErrorDef{
		code: 8006,
		msg:  "Account should be writable",
		name: "InvalidInputsMissingWritable",
	}
	ErrInvalidInputsChainSelector = &customErrorDef{
		code: 8007,
		msg:  "Chain selector is invalid",
		name: "InvalidInputsChainSelector",
	}
	ErrInvalidInputsMint = &customErrorDef{
		code: 8008,
		msg:  "Mint account input is invalid",
		name: "InvalidInputsMint",
	}
	ErrInvalidInputsMintOwner = &customErrorDef{
		code: 8009,
		msg:  "Mint account input has an invalid owner",
		name: "InvalidInputsMintOwner",
	}
	ErrInvalidInputsTokenConfigAccount = &customErrorDef{
		code: 8010,
		msg:  "Token config account is invalid",
		name: "InvalidInputsTokenConfigAccount",
	}
	ErrInvalidInputsMissingExtraArgs = &customErrorDef{
		code: 8011,
		msg:  "Missing extra args in message to SVM receiver",
		name: "InvalidInputsMissingExtraArgs",
	}
	ErrInvalidInputsMissingDataAfterExtraArgs = &customErrorDef{
		code: 8012,
		msg:  "Missing data after extra args tag",
		name: "InvalidInputsMissingDataAfterExtraArgs",
	}
	ErrInvalidInputsDestChainStateAccount = &customErrorDef{
		code: 8013,
		msg:  "Destination chain state account is invalid",
		name: "InvalidInputsDestChainStateAccount",
	}
	ErrInvalidInputsPerChainPerTokenConfig = &customErrorDef{
		code: 8014,
		msg:  "Per chain per token config account is invalid",
		name: "InvalidInputsPerChainPerTokenConfig",
	}
	ErrInvalidInputsBillingTokenConfig = &customErrorDef{
		code: 8015,
		msg:  "Billing token config account is invalid",
		name: "InvalidInputsBillingTokenConfig",
	}
	ErrInvalidInputsAccountCount = &customErrorDef{
		code: 8016,
		msg:  "Number of accounts provided is incorrect",
		name: "InvalidInputsAccountCount",
	}
	ErrInvalidInputsNoUpdates = &customErrorDef{
		code: 8017,
		msg:  "No price or gas update provided",
		name: "InvalidInputsNoUpdates",
	}
	ErrInvalidInputsTokenAccounts = &customErrorDef{
		code: 8018,
		msg:  "Invalid token accounts",
		name: "InvalidInputsTokenAccounts",
	}
	ErrDestinationChainDisabled = &customErrorDef{
		code: 8019,
		msg:  "Destination chain disabled",
		name: "DestinationChainDisabled",
	}
	ErrFeeTokenDisabled = &customErrorDef{
		code: 8020,
		msg:  "Fee token disabled",
		name: "FeeTokenDisabled",
	}
	ErrMessageTooLarge = &customErrorDef{
		code: 8021,
		msg:  "Message exceeds maximum data size",
		name: "MessageTooLarge",
	}
	ErrUnsupportedNumberOfTokens = &customErrorDef{
		code: 8022,
		msg:  "Message contains an unsupported number of tokens",
		name: "UnsupportedNumberOfTokens",
	}
	ErrInvalidTokenPrice = &customErrorDef{
		code: 8023,
		msg:  "Invalid token price",
		name: "InvalidTokenPrice",
	}
	ErrStaleGasPrice = &customErrorDef{
		code: 8024,
		msg:  "Stale gas price",
		name: "StaleGasPrice",
	}
	ErrInvalidInputsMissingTokenConfig = &customErrorDef{
		code: 8025,
		msg:  "Inputs are missing token configuration",
		name: "InvalidInputsMissingTokenConfig",
	}
	ErrMessageFeeTooHigh = &customErrorDef{
		code: 8026,
		msg:  "Message fee is too high",
		name: "MessageFeeTooHigh",
	}
	ErrMessageGasLimitTooHigh = &customErrorDef{
		code: 8027,
		msg:  "Message gas limit too high",
		name: "MessageGasLimitTooHigh",
	}
	ErrExtraArgOutOfOrderExecutionMustBeTrue = &customErrorDef{
		code: 8028,
		msg:  "Extra arg out of order execution must be true",
		name: "ExtraArgOutOfOrderExecutionMustBeTrue",
	}
	ErrInvalidExtraArgsTag = &customErrorDef{
		code: 8029,
		msg:  "Invalid extra args tag",
		name: "InvalidExtraArgsTag",
	}
	ErrInvalidExtraArgsAccounts = &customErrorDef{
		code: 8030,
		msg:  "Invalid amount of accounts in extra args",
		name: "InvalidExtraArgsAccounts",
	}
	ErrInvalidExtraArgsWritabilityBitmap = &customErrorDef{
		code: 8031,
		msg:  "Invalid writability bitmap in extra args",
		name: "InvalidExtraArgsWritabilityBitmap",
	}
	ErrInvalidTokenReceiver = &customErrorDef{
		code: 8032,
		msg:  "Invalid token receiver",
		name: "InvalidTokenReceiver",
	}
	ErrUnauthorizedPriceUpdater = &customErrorDef{
		code: 8033,
		msg:  "The caller is not an authorized price updater",
		name: "UnauthorizedPriceUpdater",
	}
	ErrInvalidTokenTransferFeeMaxMin = &customErrorDef{
		code: 8034,
		msg:  "Minimum token transfer fee exceeds maximum",
		name: "InvalidTokenTransferFeeMaxMin",
	}
	ErrInvalidTokenTransferFeeDestBytesOverhead = &customErrorDef{
		code: 8035,
		msg:  "Insufficient dest bytes overhead on transfer fee config",
		name: "InvalidTokenTransferFeeDestBytesOverhead",
	}
	ErrInvalidCodeVersion = &customErrorDef{
		code: 8036,
		msg:  "Invalid code version",
		name: "InvalidCodeVersion",
	}
	Errors = map[int]CustomError{
		8000: ErrUnauthorized,
		8001: ErrInvalidInputs,
		8002: ErrZeroGasLimit,
		8003: ErrDefaultGasLimitExceedsMaximum,
		8004: ErrInvalidVersion,
		8005: ErrRedundantOwnerProposal,
		8006: ErrInvalidInputsMissingWritable,
		8007: ErrInvalidInputsChainSelector,
		8008: ErrInvalidInputsMint,
		8009: ErrInvalidInputsMintOwner,
		8010: ErrInvalidInputsTokenConfigAccount,
		8011: ErrInvalidInputsMissingExtraArgs,
		8012: ErrInvalidInputsMissingDataAfterExtraArgs,
		8013: ErrInvalidInputsDestChainStateAccount,
		8014: ErrInvalidInputsPerChainPerTokenConfig,
		8015: ErrInvalidInputsBillingTokenConfig,
		8016: ErrInvalidInputsAccountCount,
		8017: ErrInvalidInputsNoUpdates,
		8018: ErrInvalidInputsTokenAccounts,
		8019: ErrDestinationChainDisabled,
		8020: ErrFeeTokenDisabled,
		8021: ErrMessageTooLarge,
		8022: ErrUnsupportedNumberOfTokens,
		8023: ErrInvalidTokenPrice,
		8024: ErrStaleGasPrice,
		8025: ErrInvalidInputsMissingTokenConfig,
		8026: ErrMessageFeeTooHigh,
		8027: ErrMessageGasLimitTooHigh,
		8028: ErrExtraArgOutOfOrderExecutionMustBeTrue,
		8029: ErrInvalidExtraArgsTag,
		8030: ErrInvalidExtraArgsAccounts,
		8031: ErrInvalidExtraArgsWritabilityBitmap,
		8032: ErrInvalidTokenReceiver,
		8033: ErrUnauthorizedPriceUpdater,
		8034: ErrInvalidTokenTransferFeeMaxMin,
		8035: ErrInvalidTokenTransferFeeDestBytesOverhead,
		8036: ErrInvalidCodeVersion,
	}
)

type CustomError interface {
	Code() int
	Name() string
	Error() string
}

type customErrorDef struct {
	code int
	name string
	msg  string
}

func (e *customErrorDef) Code() int {
	return e.code
}

func (e *customErrorDef) Name() string {
	return e.name
}

func (e *customErrorDef) Error() string {
	return fmt.Sprintf("%s(%d): %s", e.name, e.code, e.msg)
}

func DecodeCustomError(rpcErr error) (err error, ok bool) {
	if errCode, o := decodeErrorCode(rpcErr); o {
		if customErr, o := Errors[errCode]; o {
			err = customErr
			ok = true
			return
		}
	}
	return
}

func decodeErrorCode(rpcErr error) (errorCode int, ok bool) {
	var jErr *ag_jsonrpc.RPCError
	if errors.As(rpcErr, &jErr) && jErr.Data != nil {
		if root, o := jErr.Data.(map[string]interface{}); o {
			if rootErr, o := root["err"].(map[string]interface{}); o {
				if rootErrInstructionError, o := rootErr["InstructionError"]; o {
					if rootErrInstructionErrorItems, o := rootErrInstructionError.([]interface{}); o {
						if len(rootErrInstructionErrorItems) == 2 {
							if v, o := rootErrInstructionErrorItems[1].(map[string]interface{}); o {
								if v2, o := v["Custom"].(json.Number); o {
									if code, err := v2.Int64(); err == nil {
										ok = true
										errorCode = int(code)
									}
								} else if v2, o := v["Custom"].(float64); o {
									ok = true
									errorCode = int(v2)
								}
							}
						}
					}
				}
			}
		}
	}
	return
}
