// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package ccip_router

import (
	"encoding/json"
	"errors"
	"fmt"
	ag_jsonrpc "github.com/gagliardetto/solana-go/rpc/jsonrpc"
)

var (
	_ *json.Encoder        = nil
	_ *ag_jsonrpc.RPCError = nil
	_ fmt.Formatter        = nil
	_                      = errors.ErrUnsupported
)
var (
	ErrUnauthorized = &customErrorDef{
		code: 7000,
		msg:  "The signer is unauthorized",
		name: "Unauthorized",
	}
	ErrInvalidRMNRemoteAddress = &customErrorDef{
		code: 7001,
		msg:  "Invalid RMN Remote Address",
		name: "InvalidRMNRemoteAddress",
	}
	ErrInvalidInputsMint = &customErrorDef{
		code: 7002,
		msg:  "Mint account input is invalid",
		name: "InvalidInputsMint",
	}
	ErrInvalidVersion = &customErrorDef{
		code: 7003,
		msg:  "Invalid version of the onchain state",
		name: "InvalidVersion",
	}
	ErrFeeTokenMismatch = &customErrorDef{
		code: 7004,
		msg:  "Fee token doesn't match transfer token",
		name: "FeeTokenMismatch",
	}
	ErrRedundantOwnerProposal = &customErrorDef{
		code: 7005,
		msg:  "Proposed owner is the current owner",
		name: "RedundantOwnerProposal",
	}
	ErrReachedMaxSequenceNumber = &customErrorDef{
		code: 7006,
		msg:  "Reached max sequence number",
		name: "ReachedMaxSequenceNumber",
	}
	ErrInvalidInputsTokenIndices = &customErrorDef{
		code: 7007,
		msg:  "Invalid pool account account indices",
		name: "InvalidInputsTokenIndices",
	}
	ErrInvalidInputsPoolAccounts = &customErrorDef{
		code: 7008,
		msg:  "Invalid pool accounts",
		name: "InvalidInputsPoolAccounts",
	}
	ErrInvalidInputsTokenAccounts = &customErrorDef{
		code: 7009,
		msg:  "Invalid token accounts",
		name: "InvalidInputsTokenAccounts",
	}
	ErrInvalidInputsTokenAdminRegistryAccounts = &customErrorDef{
		code: 7010,
		msg:  "Invalid Token Admin Registry account",
		name: "InvalidInputsTokenAdminRegistryAccounts",
	}
	ErrInvalidInputsLookupTableAccounts = &customErrorDef{
		code: 7011,
		msg:  "Invalid LookupTable account",
		name: "InvalidInputsLookupTableAccounts",
	}
	ErrInvalidInputsLookupTableAccountWritable = &customErrorDef{
		code: 7012,
		msg:  "Invalid LookupTable account writable access",
		name: "InvalidInputsLookupTableAccountWritable",
	}
	ErrInvalidInputsTokenAmount = &customErrorDef{
		code: 7013,
		msg:  "Cannot send zero tokens",
		name: "InvalidInputsTokenAmount",
	}
	ErrInvalidInputsTransferAllAmount = &customErrorDef{
		code: 7014,
		msg:  "Must specify zero amount to send alongside transfer_all",
		name: "InvalidInputsTransferAllAmount",
	}
	ErrInvalidInputsAtaAddress = &customErrorDef{
		code: 7015,
		msg:  "Invalid Associated Token Account address",
		name: "InvalidInputsAtaAddress",
	}
	ErrInvalidInputsAtaWritable = &customErrorDef{
		code: 7016,
		msg:  "Invalid Associated Token Account writable flag",
		name: "InvalidInputsAtaWritable",
	}
	ErrInvalidInputsChainSelector = &customErrorDef{
		code: 7017,
		msg:  "Chain selector is invalid",
		name: "InvalidInputsChainSelector",
	}
	ErrInsufficientLamports = &customErrorDef{
		code: 7018,
		msg:  "Insufficient lamports",
		name: "InsufficientLamports",
	}
	ErrInsufficientFunds = &customErrorDef{
		code: 7019,
		msg:  "Insufficient funds",
		name: "InsufficientFunds",
	}
	ErrSourceTokenDataTooLarge = &customErrorDef{
		code: 7020,
		msg:  "Source token data is too large",
		name: "SourceTokenDataTooLarge",
	}
	ErrInvalidTokenAdminRegistryInputsZeroAddress = &customErrorDef{
		code: 7021,
		msg:  "New Admin can not be zero address",
		name: "InvalidTokenAdminRegistryInputsZeroAddress",
	}
	ErrInvalidTokenAdminRegistryProposedAdmin = &customErrorDef{
		code: 7022,
		msg:  "An already owned registry can not be proposed",
		name: "InvalidTokenAdminRegistryProposedAdmin",
	}
	ErrSenderNotAllowed = &customErrorDef{
		code: 7023,
		msg:  "Sender not allowed for that destination chain",
		name: "SenderNotAllowed",
	}
	ErrInvalidCodeVersion = &customErrorDef{
		code: 7024,
		msg:  "Invalid code version",
		name: "InvalidCodeVersion",
	}
	ErrInvalidCcipVersionRollback = &customErrorDef{
		code: 7025,
		msg:  "Invalid rollback attempt on the CCIP version of the onramp to the destination chain",
		name: "InvalidCcipVersionRollback",
	}
	Errors = map[int]CustomError{
		7000: ErrUnauthorized,
		7001: ErrInvalidRMNRemoteAddress,
		7002: ErrInvalidInputsMint,
		7003: ErrInvalidVersion,
		7004: ErrFeeTokenMismatch,
		7005: ErrRedundantOwnerProposal,
		7006: ErrReachedMaxSequenceNumber,
		7007: ErrInvalidInputsTokenIndices,
		7008: ErrInvalidInputsPoolAccounts,
		7009: ErrInvalidInputsTokenAccounts,
		7010: ErrInvalidInputsTokenAdminRegistryAccounts,
		7011: ErrInvalidInputsLookupTableAccounts,
		7012: ErrInvalidInputsLookupTableAccountWritable,
		7013: ErrInvalidInputsTokenAmount,
		7014: ErrInvalidInputsTransferAllAmount,
		7015: ErrInvalidInputsAtaAddress,
		7016: ErrInvalidInputsAtaWritable,
		7017: ErrInvalidInputsChainSelector,
		7018: ErrInsufficientLamports,
		7019: ErrInsufficientFunds,
		7020: ErrSourceTokenDataTooLarge,
		7021: ErrInvalidTokenAdminRegistryInputsZeroAddress,
		7022: ErrInvalidTokenAdminRegistryProposedAdmin,
		7023: ErrSenderNotAllowed,
		7024: ErrInvalidCodeVersion,
		7025: ErrInvalidCcipVersionRollback,
	}
)

type CustomError interface {
	Code() int
	Name() string
	Error() string
}

type customErrorDef struct {
	code int
	name string
	msg  string
}

func (e *customErrorDef) Code() int {
	return e.code
}

func (e *customErrorDef) Name() string {
	return e.name
}

func (e *customErrorDef) Error() string {
	return fmt.Sprintf("%s(%d): %s", e.name, e.code, e.msg)
}

func DecodeCustomError(rpcErr error) (err error, ok bool) {
	if errCode, o := decodeErrorCode(rpcErr); o {
		if customErr, o := Errors[errCode]; o {
			err = customErr
			ok = true
			return
		}
	}
	return
}

func decodeErrorCode(rpcErr error) (errorCode int, ok bool) {
	var jErr *ag_jsonrpc.RPCError
	if errors.As(rpcErr, &jErr) && jErr.Data != nil {
		if root, o := jErr.Data.(map[string]interface{}); o {
			if rootErr, o := root["err"].(map[string]interface{}); o {
				if rootErrInstructionError, o := rootErr["InstructionError"]; o {
					if rootErrInstructionErrorItems, o := rootErrInstructionError.([]interface{}); o {
						if len(rootErrInstructionErrorItems) == 2 {
							if v, o := rootErrInstructionErrorItems[1].(map[string]interface{}); o {
								if v2, o := v["Custom"].(json.Number); o {
									if code, err := v2.Int64(); err == nil {
										ok = true
										errorCode = int(code)
									}
								} else if v2, o := v["Custom"].(float64); o {
									ok = true
									errorCode = int(v2)
								}
							}
						}
					}
				}
			}
		}
	}
	return
}
