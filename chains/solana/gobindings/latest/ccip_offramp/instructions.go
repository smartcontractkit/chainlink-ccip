// Code generated by https://github.com/Unheilbar/anchor-go. DO NOT EDIT.
// This file contains instructions and instruction parsers.

package ccip_offramp

import (
	"bytes"
	"fmt"
	errors "github.com/Unheilbar/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "accept_ownership" instruction.
// Accepts the ownership of the router by the proposed owner. //  // Shared func signature with other programs //  // # Arguments //  // * `ctx` - The context containing the accounts required for accepting ownership. // The new owner must be a signer of the transaction.
func NewAcceptOwnershipInstruction(
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AcceptOwnership[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "add_source_chain" instruction.
// Adds a new source chain selector with its config to the offramp. //  // The Admin needs to add any new chain supported. // When adding a new chain, the Admin needs to specify if it's enabled or not. //  // # Arguments
func NewAddSourceChainInstruction(
	// Params:
	newChainSelectorParam uint64,
	sourceChainConfigParam SourceChainConfig,

	// Accounts:
	sourceChainAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AddSourceChain[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newChainSelectorParam`:
		err = enc__.Encode(newChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("newChainSelectorParam", err)
		}
		// Serialize `sourceChainConfigParam`:
		err = enc__.Encode(sourceChainConfigParam)
		if err != nil {
			return nil, errors.NewField("sourceChainConfigParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "source_chain": Writable, Non-signer, Required
		// Adding a chain selector implies initializing the state for a new chain
		accounts__.Append(solanago.NewAccountMeta(sourceChainAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "buffer_execution_report" instruction.
// Initializes and/or inserts a chunk of report data to an execution report buffer. //  // When execution reports are too large to fit in a single transaction, they can be chopped // up in chunks first (as a special case, one chunk is also acceptable), and pre-buffered // via multiple calls to this instruction. //  // There's no need to pre-initialize the buffer: all chunks can be sent concurrently, and the // first one to arrive will initialize the buffer. //  // To benefit from buffering, the eventual call to `execute` or `manually_execute` must // include an additional `remaining_account` with the PDA derived from // ["execution_report_buffer", <buffer_id>, <caller_pubkey>]. //  // # Arguments //  // * `ctx` - The context containing the accounts required for buffering. // * `buffer_id` - An arbitrary buffer id defined by the caller (could be the message_id). Max 32 bytes. // * `report_length` - Total length in bytes of the execution report. // * `chunk` - The specific chunk to add to the buffer. Chunk must have a consistent size, except // the last one in the buffer, which may be smaller. // * `chunk_index` - The index of this chunk. // * `num_chunks` - The total number of chunks in the report.
func NewBufferExecutionReportInstruction(
	// Params:
	bufferIdParam []byte,
	reportLengthParam uint32,
	chunkParam []byte,
	chunkIndexParam uint8,
	numChunksParam uint8,

	// Accounts:
	executionReportBufferAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_BufferExecutionReport[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `bufferIdParam`:
		err = enc__.Encode(bufferIdParam)
		if err != nil {
			return nil, errors.NewField("bufferIdParam", err)
		}
		// Serialize `reportLengthParam`:
		err = enc__.Encode(reportLengthParam)
		if err != nil {
			return nil, errors.NewField("reportLengthParam", err)
		}
		// Serialize `chunkParam`:
		err = enc__.Encode(chunkParam)
		if err != nil {
			return nil, errors.NewField("chunkParam", err)
		}
		// Serialize `chunkIndexParam`:
		err = enc__.Encode(chunkIndexParam)
		if err != nil {
			return nil, errors.NewField("chunkIndexParam", err)
		}
		// Serialize `numChunksParam`:
		err = enc__.Encode(numChunksParam)
		if err != nil {
			return nil, errors.NewField("numChunksParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "execution_report_buffer": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(executionReportBufferAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "close_commit_report_account" instruction.
func NewCloseCommitReportAccountInstruction(
	// Params:
	sourceChainSelectorParam uint64,
	rootParam []byte,

	// Accounts:
	configAccount solanago.PublicKey,
	commitReportAccount solanago.PublicKey,
	referenceAddressesAccount solanago.PublicKey,
	wsolMintAccount solanago.PublicKey,
	feeTokenReceiverAccount solanago.PublicKey,
	feeBillingSignerAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CloseCommitReportAccount[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `sourceChainSelectorParam`:
		err = enc__.Encode(sourceChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("sourceChainSelectorParam", err)
		}
		// Serialize `rootParam`:
		err = enc__.Encode(rootParam)
		if err != nil {
			return nil, errors.NewField("rootParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "commit_report": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(commitReportAccount, true, false))
		// Account 2 "reference_addresses": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(referenceAddressesAccount, false, false))
		// Account 3 "wsol_mint": Read-only, Non-signer, Required, Address: So11111111111111111111111111111111111111112
		accounts__.Append(solanago.NewAccountMeta(wsolMintAccount, false, false))
		// Account 4 "fee_token_receiver": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeTokenReceiverAccount, true, false))
		// Account 5 "fee_billing_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeBillingSignerAccount, false, false))
		// Account 6 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "close_execution_report_buffer" instruction.
// Closes the execution report buffer to reclaim funds. //  // Note this is only necessary when aborting a buffered transaction, or when a mistake // was made when buffering data. The buffer account will otherwise automatically close // and return funds to the caller whenever buffered execution succeeds.
func NewCloseExecutionReportBufferInstruction(
	// Params:
	bufferIdParam []byte,

	// Accounts:
	executionReportBufferAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CloseExecutionReportBuffer[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `bufferIdParam`:
		err = enc__.Encode(bufferIdParam)
		if err != nil {
			return nil, errors.NewField("bufferIdParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "execution_report_buffer": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(executionReportBufferAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "commit" instruction.
// Off Ramp Flow // // Commits a report to the router, containing a Merkle Root. //  // The method name needs to be commit with Anchor encoding. //  // This function is called by the OffChain when committing one Report to the SVM Router. // In this Flow only one report is sent, the Commit Report. This is different as EVM does, // this is because here all the chain state is stored in one account per Merkle Tree Root. // So, to avoid having to send a dynamic size array of accounts, in this message only one Commit Report Account is sent. // This message validates the signatures of the report and stores the Merkle Root in the Commit Report Account. // The Report must contain an interval of messages, and the min of them must be the next sequence number expected. // The max size of the interval is 64. // This message emits two events: CommitReportAccepted and Transmitted. //  // # Arguments //  // * `ctx` - The context containing the accounts required for the commit. // * `report_context_byte_words` - consists of: // * report_context_byte_words[0]: ConfigDigest // * report_context_byte_words[1]: 24 byte padding, 8 byte sequence number // * `raw_report` - The serialized commit input report, single merkle root with RMN signatures and price updates // * `rs` - slice of R components of signatures // * `ss` - slice of S components of signatures // * `raw_vs` - array of V components of signatures
func NewCommitInstruction(
	// Params:
	reportContextByteWordsParam [2][32]uint8,
	rawReportParam []byte,
	rsParam [][32]uint8,
	ssParam [][32]uint8,
	rawVsParam [32]uint8,

	// Accounts:
	configAccount solanago.PublicKey,
	referenceAddressesAccount solanago.PublicKey,
	sourceChainAccount solanago.PublicKey,
	commitReportAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	sysvarInstructionsAccount solanago.PublicKey,
	feeBillingSignerAccount solanago.PublicKey,
	feeQuoterAccount solanago.PublicKey,
	feeQuoterAllowedPriceUpdaterAccount solanago.PublicKey,
	feeQuoterConfigAccount solanago.PublicKey,
	rmnRemoteAccount solanago.PublicKey,
	rmnRemoteCursesAccount solanago.PublicKey,
	rmnRemoteConfigAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Commit[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `reportContextByteWordsParam`:
		err = enc__.Encode(reportContextByteWordsParam)
		if err != nil {
			return nil, errors.NewField("reportContextByteWordsParam", err)
		}
		// Serialize `rawReportParam`:
		err = enc__.Encode(rawReportParam)
		if err != nil {
			return nil, errors.NewField("rawReportParam", err)
		}
		// Serialize `rsParam`:
		err = enc__.Encode(rsParam)
		if err != nil {
			return nil, errors.NewField("rsParam", err)
		}
		// Serialize `ssParam`:
		err = enc__.Encode(ssParam)
		if err != nil {
			return nil, errors.NewField("ssParam", err)
		}
		// Serialize `rawVsParam`:
		err = enc__.Encode(rawVsParam)
		if err != nil {
			return nil, errors.NewField("rawVsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "reference_addresses": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(referenceAddressesAccount, false, false))
		// Account 2 "source_chain": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(sourceChainAccount, true, false))
		// Account 3 "commit_report": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(commitReportAccount, true, false))
		// Account 4 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 5 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 6 "sysvar_instructions": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(sysvarInstructionsAccount, false, false))
		// Account 7 "fee_billing_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeBillingSignerAccount, false, false))
		// Account 8 "fee_quoter": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeQuoterAccount, false, false))
		// Account 9 "fee_quoter_allowed_price_updater": Read-only, Non-signer, Required
		// so that it can authorize the call made by this offramp
		accounts__.Append(solanago.NewAccountMeta(feeQuoterAllowedPriceUpdaterAccount, false, false))
		// Account 10 "fee_quoter_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeQuoterConfigAccount, false, false))
		// Account 11 "rmn_remote": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteAccount, false, false))
		// Account 12 "rmn_remote_curses": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteCursesAccount, false, false))
		// Account 13 "rmn_remote_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteConfigAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "commit_price_only" instruction.
// Commits a report to the router, with price updates only. //  // The method name needs to be commit with Anchor encoding. //  // This function is called by the OffChain when committing one Report to the SVM Router, // containing only price updates and no merkle root. //  // # Arguments //  // * `ctx` - The context containing the accounts required for the commit. // * `report_context_byte_words` - consists of: // * report_context_byte_words[0]: ConfigDigest // * report_context_byte_words[1]: 24 byte padding, 8 byte sequence number // * `raw_report` - The serialized commit input report containing the price updates, // with no merkle root. // * `rs` - slice of R components of signatures // * `ss` - slice of S components of signatures // * `raw_vs` - array of V components of signatures
func NewCommitPriceOnlyInstruction(
	// Params:
	reportContextByteWordsParam [2][32]uint8,
	rawReportParam []byte,
	rsParam [][32]uint8,
	ssParam [][32]uint8,
	rawVsParam [32]uint8,

	// Accounts:
	configAccount solanago.PublicKey,
	referenceAddressesAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	sysvarInstructionsAccount solanago.PublicKey,
	feeBillingSignerAccount solanago.PublicKey,
	feeQuoterAccount solanago.PublicKey,
	feeQuoterAllowedPriceUpdaterAccount solanago.PublicKey,
	feeQuoterConfigAccount solanago.PublicKey,
	rmnRemoteAccount solanago.PublicKey,
	rmnRemoteCursesAccount solanago.PublicKey,
	rmnRemoteConfigAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CommitPriceOnly[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `reportContextByteWordsParam`:
		err = enc__.Encode(reportContextByteWordsParam)
		if err != nil {
			return nil, errors.NewField("reportContextByteWordsParam", err)
		}
		// Serialize `rawReportParam`:
		err = enc__.Encode(rawReportParam)
		if err != nil {
			return nil, errors.NewField("rawReportParam", err)
		}
		// Serialize `rsParam`:
		err = enc__.Encode(rsParam)
		if err != nil {
			return nil, errors.NewField("rsParam", err)
		}
		// Serialize `ssParam`:
		err = enc__.Encode(ssParam)
		if err != nil {
			return nil, errors.NewField("ssParam", err)
		}
		// Serialize `rawVsParam`:
		err = enc__.Encode(rawVsParam)
		if err != nil {
			return nil, errors.NewField("rawVsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "reference_addresses": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(referenceAddressesAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 4 "sysvar_instructions": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(sysvarInstructionsAccount, false, false))
		// Account 5 "fee_billing_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeBillingSignerAccount, false, false))
		// Account 6 "fee_quoter": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeQuoterAccount, false, false))
		// Account 7 "fee_quoter_allowed_price_updater": Read-only, Non-signer, Required
		// so that it can authorize the call made by this offramp
		accounts__.Append(solanago.NewAccountMeta(feeQuoterAllowedPriceUpdaterAccount, false, false))
		// Account 8 "fee_quoter_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeQuoterConfigAccount, false, false))
		// Account 9 "rmn_remote": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteAccount, false, false))
		// Account 10 "rmn_remote_curses": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteCursesAccount, false, false))
		// Account 11 "rmn_remote_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteConfigAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "derive_accounts_execute" instruction.
// Automatically derives all acounts required to call `ccip_execute`. //  // This method receives the bare minimum amount of information needed to construct // the entire account list to execute a transaction, and builds it iteratively // over the course of multiple calls. //  // The return type contains: //  // * `accounts_to_save`: The caller must append these accounts to a list they maintain. // When complete, this list will contain all accounts needed to call `ccip_execute`. // * `ask_again_with`: When `next_stage` is not empty, the caller must call `derive_accounts_execute` // again, including exactly these accounts as the `remaining_accounts`. // * `lookup_tables_to_save`: The caller must save those LUTs. They can be used for `ccip_execute`. // * `current_stage`: A string describing the current stage of the derivation process. When the stage // is "TokenTransferStaticAccounts/<N>/0", it means the `accounts_to_save` block in this response contains // all accounts relating to the Nth token being transferred. Use this information to construct // the `token_indexes` vector that `execute` requires. // * `next_stage`: If nonempty, this means the instruction must get called again with this value // as the `stage` argument. //  // Therefore, and starting with an empty `remaining_accounts` list, the caller must repeteadly // call `derive_accounts_execute` until `next_stage` is returned empty. //  // # Arguments //  // * `ctx`: Context containing only the offramp config. // * `stage`: Requested derivation stage. Pass "Start" the first time, then for each subsequent // call, pass the value returned in `response.next_stage` until empty. // * `params`: // * `execute_caller`: Public key of the account that will sign the call to `ccip_execute`. // * `message_accounts`: If the transaction involves messaging, the message accounts. // * `source_chain_selector`: CCIP chain selector for the source chain. // * `mints_of_transferred_token`: List of all token mints for tokens being transferred (i.e. // the entries in `report.message.token_amounts.destination_address`.) // * `merkle_root`: Merkle root as per the commit report. // * `buffer_id`: If the execution will be buffered, the buffer id that will be used by the // `execute_caller`: If the execution will not be buffered, this should be empty. // * `token_receiver`: Receiver of token transfers, if any (i.e. report.message.token_receiver)
func NewDeriveAccountsExecuteInstruction(
	// Params:
	paramsParam DeriveAccountsExecuteParams,
	stageParam string,

	// Accounts:
	configAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_DeriveAccountsExecute[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
		// Serialize `stageParam`:
		err = enc__.Encode(stageParam)
		if err != nil {
			return nil, errors.NewField("stageParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "disable_source_chain_selector" instruction.
// Disables the source chain selector. //  // The Admin is the only one able to disable the chain selector as source. This method is thought of as an emergency kill-switch. //  // # Arguments //  // * `ctx` - The context containing the accounts required for disabling the chain selector. // * `source_chain_selector` - The source chain selector to be disabled.
func NewDisableSourceChainSelectorInstruction(
	// Params:
	sourceChainSelectorParam uint64,

	// Accounts:
	sourceChainAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_DisableSourceChainSelector[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `sourceChainSelectorParam`:
		err = enc__.Encode(sourceChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("sourceChainSelectorParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "source_chain": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(sourceChainAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "execute" instruction.
// Executes a message on the destination chain. //  // The method name needs to be execute with Anchor encoding. //  // This function is called by the OffChain when executing one Report to the SVM Router. // In this Flow only one message is sent, the Execution Report. This is different as EVM does, // this is because there is no try/catch mechanism to allow batch execution. // This message validates that the Merkle Tree Proof of the given message is correct and is stored in the Commit Report Account. // The message must be untouched to be executed. // This message emits the event ExecutionStateChanged with the new state of the message. // Finally, executes the CPI instruction to the receiver program in the ccip_receive message. //  // # Arguments //  // * `ctx` - The context containing the accounts required for the execute. // * `raw_execution_report` - the serialized execution report containing only one message and proofs // * `report_context_byte_words` - report_context after execution_report to match context for manually execute (proper decoding order) // *  consists of: // * report_context_byte_words[0]: ConfigDigest // * report_context_byte_words[1]: 24 byte padding, 8 byte sequence number
func NewExecuteInstruction(
	// Params:
	rawExecutionReportParam []byte,
	reportContextByteWordsParam [2][32]uint8,
	tokenIndexesParam []byte,

	// Accounts:
	configAccount solanago.PublicKey,
	referenceAddressesAccount solanago.PublicKey,
	sourceChainAccount solanago.PublicKey,
	commitReportAccount solanago.PublicKey,
	offrampAccount solanago.PublicKey,
	allowedOfframpAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	sysvarInstructionsAccount solanago.PublicKey,
	rmnRemoteAccount solanago.PublicKey,
	rmnRemoteCursesAccount solanago.PublicKey,
	rmnRemoteConfigAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Execute[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `rawExecutionReportParam`:
		err = enc__.Encode(rawExecutionReportParam)
		if err != nil {
			return nil, errors.NewField("rawExecutionReportParam", err)
		}
		// Serialize `reportContextByteWordsParam`:
		err = enc__.Encode(reportContextByteWordsParam)
		if err != nil {
			return nil, errors.NewField("reportContextByteWordsParam", err)
		}
		// Serialize `tokenIndexesParam`:
		err = enc__.Encode(tokenIndexesParam)
		if err != nil {
			return nil, errors.NewField("tokenIndexesParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "reference_addresses": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(referenceAddressesAccount, false, false))
		// Account 2 "source_chain": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(sourceChainAccount, false, false))
		// Account 3 "commit_report": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(commitReportAccount, true, false))
		// Account 4 "offramp": Read-only, Non-signer, Required, Address: offqSMQWgQud6WJz694LRzkeN5kMYpCHTpXQr3Rkcjm
		accounts__.Append(solanago.NewAccountMeta(offrampAccount, false, false))
		// Account 5 "allowed_offramp": Read-only, Non-signer, Required
		// CHECK PDA of the router program verifying the signer is an allowed offramp.
		// If PDA does not exist, the router doesn't allow this offramp. This is just used
		// so that token pools and receivers can then check that the caller is an actual offramp that
		// has been registered in the router as such for that source chain.
		accounts__.Append(solanago.NewAccountMeta(allowedOfframpAccount, false, false))
		// Account 6 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 7 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 8 "sysvar_instructions": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(sysvarInstructionsAccount, false, false))
		// Account 9 "rmn_remote": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteAccount, false, false))
		// Account 10 "rmn_remote_curses": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteCursesAccount, false, false))
		// Account 11 "rmn_remote_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteConfigAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize" instruction.
// Initialization Flow // // Initializes the CCIP Offramp, except for the config account (due to stack size limitations). //  // The initialization of the Offramp is responsibility of Admin, nothing more than calling these // initialization methods should be done first. //  // # Arguments //  // * `ctx` - The context containing the accounts required for initialization.
func NewInitializeInstruction(
	referenceAddressesAccount solanago.PublicKey,
	routerAccount solanago.PublicKey,
	feeQuoterAccount solanago.PublicKey,
	rmnRemoteAccount solanago.PublicKey,
	offrampLookupTableAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
	programDataAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Initialize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "reference_addresses": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(referenceAddressesAccount, true, false))
		// Account 1 "router": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(routerAccount, false, false))
		// Account 2 "fee_quoter": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeQuoterAccount, false, false))
		// Account 3 "rmn_remote": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteAccount, false, false))
		// Account 4 "offramp_lookup_table": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(offrampLookupTableAccount, false, false))
		// Account 5 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 6 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 7 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 8 "program": Read-only, Non-signer, Required, Address: offqSMQWgQud6WJz694LRzkeN5kMYpCHTpXQr3Rkcjm
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
		// Account 9 "program_data": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programDataAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_config" instruction.
// Initializes the CCIP Offramp Config account. //  // The initialization of the Offramp is responsibility of Admin, nothing more than calling these // initialization methods should be done first. //  // # Arguments //  // * `ctx` - The context containing the accounts required for initialization of the config. // * `svm_chain_selector` - The chain selector for SVM. // * `enable_execution_after` - The minimum amount of time required between a message has been committed and can be manually executed.
func NewInitializeConfigInstruction(
	// Params:
	svmChainSelectorParam uint64,
	enableExecutionAfterParam int64,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
	programDataAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `svmChainSelectorParam`:
		err = enc__.Encode(svmChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("svmChainSelectorParam", err)
		}
		// Serialize `enableExecutionAfterParam`:
		err = enc__.Encode(enableExecutionAfterParam)
		if err != nil {
			return nil, errors.NewField("enableExecutionAfterParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 3 "program": Read-only, Non-signer, Required, Address: offqSMQWgQud6WJz694LRzkeN5kMYpCHTpXQr3Rkcjm
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
		// Account 4 "program_data": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programDataAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "manually_execute" instruction.
// Manually executes a report to the router. //  // When a message is not being executed, then the user can trigger the execution manually. // No verification over the transmitter, but the message needs to be in some commit report. // It validates that the required time has passed since the commit and then executes the report. //  // # Arguments //  // * `ctx` - The context containing the accounts required for the execution. // * `raw_execution_report` - The serialized execution report containing the message and proofs.
func NewManuallyExecuteInstruction(
	// Params:
	rawExecutionReportParam []byte,
	tokenIndexesParam []byte,

	// Accounts:
	configAccount solanago.PublicKey,
	referenceAddressesAccount solanago.PublicKey,
	sourceChainAccount solanago.PublicKey,
	commitReportAccount solanago.PublicKey,
	offrampAccount solanago.PublicKey,
	allowedOfframpAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	sysvarInstructionsAccount solanago.PublicKey,
	rmnRemoteAccount solanago.PublicKey,
	rmnRemoteCursesAccount solanago.PublicKey,
	rmnRemoteConfigAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ManuallyExecute[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `rawExecutionReportParam`:
		err = enc__.Encode(rawExecutionReportParam)
		if err != nil {
			return nil, errors.NewField("rawExecutionReportParam", err)
		}
		// Serialize `tokenIndexesParam`:
		err = enc__.Encode(tokenIndexesParam)
		if err != nil {
			return nil, errors.NewField("tokenIndexesParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "reference_addresses": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(referenceAddressesAccount, false, false))
		// Account 2 "source_chain": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(sourceChainAccount, false, false))
		// Account 3 "commit_report": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(commitReportAccount, true, false))
		// Account 4 "offramp": Read-only, Non-signer, Required, Address: offqSMQWgQud6WJz694LRzkeN5kMYpCHTpXQr3Rkcjm
		accounts__.Append(solanago.NewAccountMeta(offrampAccount, false, false))
		// Account 5 "allowed_offramp": Read-only, Non-signer, Required
		// CHECK PDA of the router program verifying the signer is an allowed offramp.
		// If PDA does not exist, the router doesn't allow this offramp. This is just used
		// so that token pools and receivers can then check that the caller is an actual offramp that
		// has been registered in the router as such for that source chain.
		accounts__.Append(solanago.NewAccountMeta(allowedOfframpAccount, false, false))
		// Account 6 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 7 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 8 "sysvar_instructions": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(sysvarInstructionsAccount, false, false))
		// Account 9 "rmn_remote": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteAccount, false, false))
		// Account 10 "rmn_remote_curses": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteCursesAccount, false, false))
		// Account 11 "rmn_remote_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteConfigAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_default_code_version" instruction.
// Sets the default code version to be used. This is then used by the slim routing layer to determine // which version of the versioned business logic module (`instructions`) to use. Only the admin may set this. //  // Shared func signature with other programs //  // # Arguments //  // * `ctx` - The context containing the accounts required for updating the configuration. // * `code_version` - The new code version to be set as default.
func NewSetDefaultCodeVersionInstruction(
	// Params:
	codeVersionParam CodeVersion,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetDefaultCodeVersion[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `codeVersionParam`:
		err = enc__.Encode(codeVersionParam)
		if err != nil {
			return nil, errors.NewField("codeVersionParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_ocr_config" instruction.
// Sets the OCR configuration. // Only CCIP Admin can set the OCR configuration. //  // # Arguments //  // * `ctx` - The context containing the accounts required for setting the OCR configuration. // * `plugin_type` - The type of OCR plugin [0: Commit, 1: Execution]. // * `config_info` - The OCR configuration information. // * `signers` - The list of signers. // * `transmitters` - The list of transmitters.
func NewSetOcrConfigInstruction(
	// Params:
	pluginTypeParam OcrPluginType,
	configInfoParam Ocr3ConfigInfoInput,
	signersParam [][20]uint8,
	transmittersParam []solanago.PublicKey,

	// Accounts:
	configAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetOcrConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `pluginTypeParam`:
		err = enc__.Encode(pluginTypeParam)
		if err != nil {
			return nil, errors.NewField("pluginTypeParam", err)
		}
		// Serialize `configInfoParam`:
		err = enc__.Encode(configInfoParam)
		if err != nil {
			return nil, errors.NewField("configInfoParam", err)
		}
		// Serialize `signersParam`:
		err = enc__.Encode(signersParam)
		if err != nil {
			return nil, errors.NewField("signersParam", err)
		}
		// Serialize `transmittersParam`:
		err = enc__.Encode(transmittersParam)
		if err != nil {
			return nil, errors.NewField("transmittersParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "transfer_ownership" instruction.
// Transfers the ownership of the router to a new proposed owner. //  // Shared func signature with other programs //  // # Arguments //  // * `ctx` - The context containing the accounts required for the transfer. // * `proposed_owner` - The public key of the new proposed owner.
func NewTransferOwnershipInstruction(
	// Params:
	proposedOwnerParam solanago.PublicKey,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_TransferOwnership[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `proposedOwnerParam`:
		err = enc__.Encode(proposedOwnerParam)
		if err != nil {
			return nil, errors.NewField("proposedOwnerParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "type_version" instruction.
// Returns the program type (name) and version. // Used by offchain code to easily determine which program & version is being interacted with. //  // # Arguments // * `ctx` - The context
func NewTypeVersionInstruction(
	clockAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_TypeVersion[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "clock": Read-only, Non-signer, Required, Address: SysvarC1ock11111111111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(clockAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_enable_manual_execution_after" instruction.
// Updates the minimum amount of time required between a message being committed and when it can be manually executed. //  // This is part of the OffRamp Configuration for SVM. // The Admin is the only one able to update this config. //  // # Arguments //  // * `ctx` - The context containing the accounts required for updating the configuration. // * `new_enable_manual_execution_after` - The new minimum amount of time required.
func NewUpdateEnableManualExecutionAfterInstruction(
	// Params:
	newEnableManualExecutionAfterParam int64,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateEnableManualExecutionAfter[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newEnableManualExecutionAfterParam`:
		err = enc__.Encode(newEnableManualExecutionAfterParam)
		if err != nil {
			return nil, errors.NewField("newEnableManualExecutionAfterParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_reference_addresses" instruction.
// Updates reference addresses in the offramp contract, such as // the CCIP router, Fee Quoter, and the Offramp Lookup Table. // Only the Admin may update these addresses. //  // # Arguments //  // * `ctx` - The context containing the accounts required for updating the reference addresses. // * `router` - The router address to be set. // * `fee_quoter` - The fee_quoter address to be set. // * `offramp_lookup_table` - The offramp_lookup_table address to be set. // * `rmn_remote` - The rmn_remote address to be set.
func NewUpdateReferenceAddressesInstruction(
	// Params:
	routerParam solanago.PublicKey,
	feeQuoterParam solanago.PublicKey,
	offrampLookupTableParam solanago.PublicKey,
	rmnRemoteParam solanago.PublicKey,

	// Accounts:
	configAccount solanago.PublicKey,
	referenceAddressesAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateReferenceAddresses[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `routerParam`:
		err = enc__.Encode(routerParam)
		if err != nil {
			return nil, errors.NewField("routerParam", err)
		}
		// Serialize `feeQuoterParam`:
		err = enc__.Encode(feeQuoterParam)
		if err != nil {
			return nil, errors.NewField("feeQuoterParam", err)
		}
		// Serialize `offrampLookupTableParam`:
		err = enc__.Encode(offrampLookupTableParam)
		if err != nil {
			return nil, errors.NewField("offrampLookupTableParam", err)
		}
		// Serialize `rmnRemoteParam`:
		err = enc__.Encode(rmnRemoteParam)
		if err != nil {
			return nil, errors.NewField("rmnRemoteParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "reference_addresses": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(referenceAddressesAccount, true, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_source_chain_config" instruction.
// Updates the configuration of the source chain selector. //  // The Admin is the only one able to update the source chain config. //  // # Arguments //  // * `ctx` - The context containing the accounts required for updating the chain selector. // * `source_chain_selector` - The source chain selector to be updated. // * `source_chain_config` - The new configuration for the source chain.
func NewUpdateSourceChainConfigInstruction(
	// Params:
	sourceChainSelectorParam uint64,
	sourceChainConfigParam SourceChainConfig,

	// Accounts:
	sourceChainAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateSourceChainConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `sourceChainSelectorParam`:
		err = enc__.Encode(sourceChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("sourceChainSelectorParam", err)
		}
		// Serialize `sourceChainConfigParam`:
		err = enc__.Encode(sourceChainConfigParam)
		if err != nil {
			return nil, errors.NewField("sourceChainConfigParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "source_chain": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(sourceChainAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_svm_chain_selector" instruction.
// Updates the SVM chain selector in the offramp configuration. //  // This method should only be used if there was an error with the initial configuration or if the solana chain selector changes. //  // # Arguments //  // * `ctx` - The context containing the accounts required for updating the configuration. // * `new_chain_selector` - The new chain selector for SVM.
func NewUpdateSvmChainSelectorInstruction(
	// Params:
	newChainSelectorParam uint64,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateSvmChainSelector[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newChainSelectorParam`:
		err = enc__.Encode(newChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("newChainSelectorParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

type AcceptOwnershipInstruction struct {

	// Accounts:
	Config          solanago.PublicKey `json:"config"`
	ConfigWritable  bool               `json:"config_writable"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
}

func (obj *AcceptOwnershipInstruction) GetDiscriminator() []byte {
	return Instruction_AcceptOwnership[:]
}

// UnmarshalWithDecoder unmarshals the AcceptOwnershipInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *AcceptOwnershipInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "AcceptOwnershipInstruction", err)
	}
	if discriminator != Instruction_AcceptOwnership {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "AcceptOwnershipInstruction", Instruction_AcceptOwnership, discriminator)
	}
	return nil
}

func (obj *AcceptOwnershipInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AcceptOwnershipInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 2 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 2, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AcceptOwnershipInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the AcceptOwnershipInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *AcceptOwnershipInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AcceptOwnershipInstruction: %w", err)
	}
	return nil
}

// UnmarshalAcceptOwnershipInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalAcceptOwnershipInstruction(buf []byte) (*AcceptOwnershipInstruction, error) {
	obj := new(AcceptOwnershipInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type AddSourceChainInstruction struct {
	NewChainSelector  uint64            `json:"new_chain_selector"`
	SourceChainConfig SourceChainConfig `json:"source_chain_config"`

	// Accounts:
	SourceChain         solanago.PublicKey `json:"source_chain"`
	SourceChainWritable bool               `json:"source_chain_writable"`
	Config              solanago.PublicKey `json:"config"`
	Authority           solanago.PublicKey `json:"authority"`
	AuthorityWritable   bool               `json:"authority_writable"`
	AuthoritySigner     bool               `json:"authority_signer"`
	SystemProgram       solanago.PublicKey `json:"system_program"`
}

func (obj *AddSourceChainInstruction) GetDiscriminator() []byte {
	return Instruction_AddSourceChain[:]
}

// UnmarshalWithDecoder unmarshals the AddSourceChainInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *AddSourceChainInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "AddSourceChainInstruction", err)
	}
	if discriminator != Instruction_AddSourceChain {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "AddSourceChainInstruction", Instruction_AddSourceChain, discriminator)
	}
	// Deserialize `NewChainSelector`:
	err = decoder.Decode(&obj.NewChainSelector)
	if err != nil {
		return err
	}
	// Deserialize `SourceChainConfig`:
	err = decoder.Decode(&obj.SourceChainConfig)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AddSourceChainInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from source_chain account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "source_chain", err)
	}
	indices = append(indices, index)
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AddSourceChainInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set source_chain account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "source_chain", len(accountKeys)-1)
	}
	obj.SourceChain = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AddSourceChainInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.SourceChain)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the AddSourceChainInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *AddSourceChainInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AddSourceChainInstruction: %w", err)
	}
	return nil
}

// UnmarshalAddSourceChainInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalAddSourceChainInstruction(buf []byte) (*AddSourceChainInstruction, error) {
	obj := new(AddSourceChainInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type BufferExecutionReportInstruction struct {
	BufferId     []byte `json:"buffer_id"`
	ReportLength uint32 `json:"report_length"`
	Chunk        []byte `json:"chunk"`
	ChunkIndex   uint8  `json:"chunk_index"`
	NumChunks    uint8  `json:"num_chunks"`

	// Accounts:
	ExecutionReportBuffer         solanago.PublicKey `json:"execution_report_buffer"`
	ExecutionReportBufferWritable bool               `json:"execution_report_buffer_writable"`
	Config                        solanago.PublicKey `json:"config"`
	Authority                     solanago.PublicKey `json:"authority"`
	AuthorityWritable             bool               `json:"authority_writable"`
	AuthoritySigner               bool               `json:"authority_signer"`
	SystemProgram                 solanago.PublicKey `json:"system_program"`
}

func (obj *BufferExecutionReportInstruction) GetDiscriminator() []byte {
	return Instruction_BufferExecutionReport[:]
}

// UnmarshalWithDecoder unmarshals the BufferExecutionReportInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *BufferExecutionReportInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "BufferExecutionReportInstruction", err)
	}
	if discriminator != Instruction_BufferExecutionReport {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "BufferExecutionReportInstruction", Instruction_BufferExecutionReport, discriminator)
	}
	// Deserialize `BufferId`:
	err = decoder.Decode(&obj.BufferId)
	if err != nil {
		return err
	}
	// Deserialize `ReportLength`:
	err = decoder.Decode(&obj.ReportLength)
	if err != nil {
		return err
	}
	// Deserialize `Chunk`:
	err = decoder.Decode(&obj.Chunk)
	if err != nil {
		return err
	}
	// Deserialize `ChunkIndex`:
	err = decoder.Decode(&obj.ChunkIndex)
	if err != nil {
		return err
	}
	// Deserialize `NumChunks`:
	err = decoder.Decode(&obj.NumChunks)
	if err != nil {
		return err
	}
	return nil
}

func (obj *BufferExecutionReportInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from execution_report_buffer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "execution_report_buffer", err)
	}
	indices = append(indices, index)
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *BufferExecutionReportInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set execution_report_buffer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "execution_report_buffer", len(accountKeys)-1)
	}
	obj.ExecutionReportBuffer = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *BufferExecutionReportInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.ExecutionReportBuffer)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the BufferExecutionReportInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *BufferExecutionReportInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling BufferExecutionReportInstruction: %w", err)
	}
	return nil
}

// UnmarshalBufferExecutionReportInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalBufferExecutionReportInstruction(buf []byte) (*BufferExecutionReportInstruction, error) {
	obj := new(BufferExecutionReportInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type CloseCommitReportAccountInstruction struct {
	SourceChainSelector uint64 `json:"source_chain_selector"`
	Root                []byte `json:"root"`

	// Accounts:
	Config                   solanago.PublicKey `json:"config"`
	CommitReport             solanago.PublicKey `json:"commit_report"`
	CommitReportWritable     bool               `json:"commit_report_writable"`
	ReferenceAddresses       solanago.PublicKey `json:"reference_addresses"`
	WsolMint                 solanago.PublicKey `json:"wsol_mint"`
	FeeTokenReceiver         solanago.PublicKey `json:"fee_token_receiver"`
	FeeTokenReceiverWritable bool               `json:"fee_token_receiver_writable"`
	FeeBillingSigner         solanago.PublicKey `json:"fee_billing_signer"`
	TokenProgram             solanago.PublicKey `json:"token_program"`
}

func (obj *CloseCommitReportAccountInstruction) GetDiscriminator() []byte {
	return Instruction_CloseCommitReportAccount[:]
}

// UnmarshalWithDecoder unmarshals the CloseCommitReportAccountInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *CloseCommitReportAccountInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "CloseCommitReportAccountInstruction", err)
	}
	if discriminator != Instruction_CloseCommitReportAccount {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "CloseCommitReportAccountInstruction", Instruction_CloseCommitReportAccount, discriminator)
	}
	// Deserialize `SourceChainSelector`:
	err = decoder.Decode(&obj.SourceChainSelector)
	if err != nil {
		return err
	}
	// Deserialize `Root`:
	err = decoder.Decode(&obj.Root)
	if err != nil {
		return err
	}
	return nil
}

func (obj *CloseCommitReportAccountInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from commit_report account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "commit_report", err)
	}
	indices = append(indices, index)
	// Decode from reference_addresses account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reference_addresses", err)
	}
	indices = append(indices, index)
	// Decode from wsol_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "wsol_mint", err)
	}
	indices = append(indices, index)
	// Decode from fee_token_receiver account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_token_receiver", err)
	}
	indices = append(indices, index)
	// Decode from fee_billing_signer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_billing_signer", err)
	}
	indices = append(indices, index)
	// Decode from token_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *CloseCommitReportAccountInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 7 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 7, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set commit_report account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "commit_report", len(accountKeys)-1)
	}
	obj.CommitReport = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reference_addresses account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reference_addresses", len(accountKeys)-1)
	}
	obj.ReferenceAddresses = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set wsol_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "wsol_mint", len(accountKeys)-1)
	}
	obj.WsolMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_token_receiver account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_token_receiver", len(accountKeys)-1)
	}
	obj.FeeTokenReceiver = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_billing_signer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_billing_signer", len(accountKeys)-1)
	}
	obj.FeeBillingSigner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_program", len(accountKeys)-1)
	}
	obj.TokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *CloseCommitReportAccountInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.CommitReport)
	keys = append(keys, obj.ReferenceAddresses)
	keys = append(keys, obj.WsolMint)
	keys = append(keys, obj.FeeTokenReceiver)
	keys = append(keys, obj.FeeBillingSigner)
	keys = append(keys, obj.TokenProgram)
	return keys
}

// Unmarshal unmarshals the CloseCommitReportAccountInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *CloseCommitReportAccountInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CloseCommitReportAccountInstruction: %w", err)
	}
	return nil
}

// UnmarshalCloseCommitReportAccountInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalCloseCommitReportAccountInstruction(buf []byte) (*CloseCommitReportAccountInstruction, error) {
	obj := new(CloseCommitReportAccountInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type CloseExecutionReportBufferInstruction struct {
	BufferId []byte `json:"_buffer_id"`

	// Accounts:
	ExecutionReportBuffer         solanago.PublicKey `json:"execution_report_buffer"`
	ExecutionReportBufferWritable bool               `json:"execution_report_buffer_writable"`
	Config                        solanago.PublicKey `json:"config"`
	Authority                     solanago.PublicKey `json:"authority"`
	AuthorityWritable             bool               `json:"authority_writable"`
	AuthoritySigner               bool               `json:"authority_signer"`
	SystemProgram                 solanago.PublicKey `json:"system_program"`
}

func (obj *CloseExecutionReportBufferInstruction) GetDiscriminator() []byte {
	return Instruction_CloseExecutionReportBuffer[:]
}

// UnmarshalWithDecoder unmarshals the CloseExecutionReportBufferInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *CloseExecutionReportBufferInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "CloseExecutionReportBufferInstruction", err)
	}
	if discriminator != Instruction_CloseExecutionReportBuffer {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "CloseExecutionReportBufferInstruction", Instruction_CloseExecutionReportBuffer, discriminator)
	}
	// Deserialize `BufferId`:
	err = decoder.Decode(&obj.BufferId)
	if err != nil {
		return err
	}
	return nil
}

func (obj *CloseExecutionReportBufferInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from execution_report_buffer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "execution_report_buffer", err)
	}
	indices = append(indices, index)
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *CloseExecutionReportBufferInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set execution_report_buffer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "execution_report_buffer", len(accountKeys)-1)
	}
	obj.ExecutionReportBuffer = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *CloseExecutionReportBufferInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.ExecutionReportBuffer)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the CloseExecutionReportBufferInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *CloseExecutionReportBufferInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CloseExecutionReportBufferInstruction: %w", err)
	}
	return nil
}

// UnmarshalCloseExecutionReportBufferInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalCloseExecutionReportBufferInstruction(buf []byte) (*CloseExecutionReportBufferInstruction, error) {
	obj := new(CloseExecutionReportBufferInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type CommitInstruction struct {
	ReportContextByteWords [2][32]uint8 `json:"_report_context_byte_words"`
	RawReport              []byte       `json:"_raw_report"`
	Rs                     [][32]uint8  `json:"_rs"`
	Ss                     [][32]uint8  `json:"_ss"`
	RawVs                  [32]uint8    `json:"_raw_vs"`

	// Accounts:
	Config                       solanago.PublicKey `json:"config"`
	ReferenceAddresses           solanago.PublicKey `json:"reference_addresses"`
	SourceChain                  solanago.PublicKey `json:"source_chain"`
	SourceChainWritable          bool               `json:"source_chain_writable"`
	CommitReport                 solanago.PublicKey `json:"commit_report"`
	CommitReportWritable         bool               `json:"commit_report_writable"`
	Authority                    solanago.PublicKey `json:"authority"`
	AuthorityWritable            bool               `json:"authority_writable"`
	AuthoritySigner              bool               `json:"authority_signer"`
	SystemProgram                solanago.PublicKey `json:"system_program"`
	SysvarInstructions           solanago.PublicKey `json:"sysvar_instructions"`
	FeeBillingSigner             solanago.PublicKey `json:"fee_billing_signer"`
	FeeQuoter                    solanago.PublicKey `json:"fee_quoter"`
	FeeQuoterAllowedPriceUpdater solanago.PublicKey `json:"fee_quoter_allowed_price_updater"`
	FeeQuoterConfig              solanago.PublicKey `json:"fee_quoter_config"`
	RmnRemote                    solanago.PublicKey `json:"rmn_remote"`
	RmnRemoteCurses              solanago.PublicKey `json:"rmn_remote_curses"`
	RmnRemoteConfig              solanago.PublicKey `json:"rmn_remote_config"`
}

func (obj *CommitInstruction) GetDiscriminator() []byte {
	return Instruction_Commit[:]
}

// UnmarshalWithDecoder unmarshals the CommitInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *CommitInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "CommitInstruction", err)
	}
	if discriminator != Instruction_Commit {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "CommitInstruction", Instruction_Commit, discriminator)
	}
	// Deserialize `ReportContextByteWords`:
	err = decoder.Decode(&obj.ReportContextByteWords)
	if err != nil {
		return err
	}
	// Deserialize `RawReport`:
	err = decoder.Decode(&obj.RawReport)
	if err != nil {
		return err
	}
	// Deserialize `Rs`:
	err = decoder.Decode(&obj.Rs)
	if err != nil {
		return err
	}
	// Deserialize `Ss`:
	err = decoder.Decode(&obj.Ss)
	if err != nil {
		return err
	}
	// Deserialize `RawVs`:
	err = decoder.Decode(&obj.RawVs)
	if err != nil {
		return err
	}
	return nil
}

func (obj *CommitInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from reference_addresses account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reference_addresses", err)
	}
	indices = append(indices, index)
	// Decode from source_chain account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "source_chain", err)
	}
	indices = append(indices, index)
	// Decode from commit_report account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "commit_report", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	// Decode from sysvar_instructions account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "sysvar_instructions", err)
	}
	indices = append(indices, index)
	// Decode from fee_billing_signer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_billing_signer", err)
	}
	indices = append(indices, index)
	// Decode from fee_quoter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_quoter", err)
	}
	indices = append(indices, index)
	// Decode from fee_quoter_allowed_price_updater account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_quoter_allowed_price_updater", err)
	}
	indices = append(indices, index)
	// Decode from fee_quoter_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_quoter_config", err)
	}
	indices = append(indices, index)
	// Decode from rmn_remote account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rmn_remote", err)
	}
	indices = append(indices, index)
	// Decode from rmn_remote_curses account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rmn_remote_curses", err)
	}
	indices = append(indices, index)
	// Decode from rmn_remote_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rmn_remote_config", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *CommitInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 14 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 14, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reference_addresses account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reference_addresses", len(accountKeys)-1)
	}
	obj.ReferenceAddresses = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set source_chain account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "source_chain", len(accountKeys)-1)
	}
	obj.SourceChain = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set commit_report account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "commit_report", len(accountKeys)-1)
	}
	obj.CommitReport = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set sysvar_instructions account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "sysvar_instructions", len(accountKeys)-1)
	}
	obj.SysvarInstructions = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_billing_signer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_billing_signer", len(accountKeys)-1)
	}
	obj.FeeBillingSigner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_quoter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_quoter", len(accountKeys)-1)
	}
	obj.FeeQuoter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_quoter_allowed_price_updater account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_quoter_allowed_price_updater", len(accountKeys)-1)
	}
	obj.FeeQuoterAllowedPriceUpdater = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_quoter_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_quoter_config", len(accountKeys)-1)
	}
	obj.FeeQuoterConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rmn_remote account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rmn_remote", len(accountKeys)-1)
	}
	obj.RmnRemote = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rmn_remote_curses account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rmn_remote_curses", len(accountKeys)-1)
	}
	obj.RmnRemoteCurses = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rmn_remote_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rmn_remote_config", len(accountKeys)-1)
	}
	obj.RmnRemoteConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *CommitInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.ReferenceAddresses)
	keys = append(keys, obj.SourceChain)
	keys = append(keys, obj.CommitReport)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.SysvarInstructions)
	keys = append(keys, obj.FeeBillingSigner)
	keys = append(keys, obj.FeeQuoter)
	keys = append(keys, obj.FeeQuoterAllowedPriceUpdater)
	keys = append(keys, obj.FeeQuoterConfig)
	keys = append(keys, obj.RmnRemote)
	keys = append(keys, obj.RmnRemoteCurses)
	keys = append(keys, obj.RmnRemoteConfig)
	return keys
}

// Unmarshal unmarshals the CommitInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *CommitInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CommitInstruction: %w", err)
	}
	return nil
}

// UnmarshalCommitInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalCommitInstruction(buf []byte) (*CommitInstruction, error) {
	obj := new(CommitInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type CommitPriceOnlyInstruction struct {
	ReportContextByteWords [2][32]uint8 `json:"report_context_byte_words"`
	RawReport              []byte       `json:"raw_report"`
	Rs                     [][32]uint8  `json:"rs"`
	Ss                     [][32]uint8  `json:"ss"`
	RawVs                  [32]uint8    `json:"raw_vs"`

	// Accounts:
	Config                       solanago.PublicKey `json:"config"`
	ReferenceAddresses           solanago.PublicKey `json:"reference_addresses"`
	Authority                    solanago.PublicKey `json:"authority"`
	AuthorityWritable            bool               `json:"authority_writable"`
	AuthoritySigner              bool               `json:"authority_signer"`
	SystemProgram                solanago.PublicKey `json:"system_program"`
	SysvarInstructions           solanago.PublicKey `json:"sysvar_instructions"`
	FeeBillingSigner             solanago.PublicKey `json:"fee_billing_signer"`
	FeeQuoter                    solanago.PublicKey `json:"fee_quoter"`
	FeeQuoterAllowedPriceUpdater solanago.PublicKey `json:"fee_quoter_allowed_price_updater"`
	FeeQuoterConfig              solanago.PublicKey `json:"fee_quoter_config"`
	RmnRemote                    solanago.PublicKey `json:"rmn_remote"`
	RmnRemoteCurses              solanago.PublicKey `json:"rmn_remote_curses"`
	RmnRemoteConfig              solanago.PublicKey `json:"rmn_remote_config"`
}

func (obj *CommitPriceOnlyInstruction) GetDiscriminator() []byte {
	return Instruction_CommitPriceOnly[:]
}

// UnmarshalWithDecoder unmarshals the CommitPriceOnlyInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *CommitPriceOnlyInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "CommitPriceOnlyInstruction", err)
	}
	if discriminator != Instruction_CommitPriceOnly {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "CommitPriceOnlyInstruction", Instruction_CommitPriceOnly, discriminator)
	}
	// Deserialize `ReportContextByteWords`:
	err = decoder.Decode(&obj.ReportContextByteWords)
	if err != nil {
		return err
	}
	// Deserialize `RawReport`:
	err = decoder.Decode(&obj.RawReport)
	if err != nil {
		return err
	}
	// Deserialize `Rs`:
	err = decoder.Decode(&obj.Rs)
	if err != nil {
		return err
	}
	// Deserialize `Ss`:
	err = decoder.Decode(&obj.Ss)
	if err != nil {
		return err
	}
	// Deserialize `RawVs`:
	err = decoder.Decode(&obj.RawVs)
	if err != nil {
		return err
	}
	return nil
}

func (obj *CommitPriceOnlyInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from reference_addresses account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reference_addresses", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	// Decode from sysvar_instructions account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "sysvar_instructions", err)
	}
	indices = append(indices, index)
	// Decode from fee_billing_signer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_billing_signer", err)
	}
	indices = append(indices, index)
	// Decode from fee_quoter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_quoter", err)
	}
	indices = append(indices, index)
	// Decode from fee_quoter_allowed_price_updater account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_quoter_allowed_price_updater", err)
	}
	indices = append(indices, index)
	// Decode from fee_quoter_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_quoter_config", err)
	}
	indices = append(indices, index)
	// Decode from rmn_remote account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rmn_remote", err)
	}
	indices = append(indices, index)
	// Decode from rmn_remote_curses account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rmn_remote_curses", err)
	}
	indices = append(indices, index)
	// Decode from rmn_remote_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rmn_remote_config", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *CommitPriceOnlyInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 12 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 12, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reference_addresses account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reference_addresses", len(accountKeys)-1)
	}
	obj.ReferenceAddresses = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set sysvar_instructions account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "sysvar_instructions", len(accountKeys)-1)
	}
	obj.SysvarInstructions = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_billing_signer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_billing_signer", len(accountKeys)-1)
	}
	obj.FeeBillingSigner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_quoter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_quoter", len(accountKeys)-1)
	}
	obj.FeeQuoter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_quoter_allowed_price_updater account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_quoter_allowed_price_updater", len(accountKeys)-1)
	}
	obj.FeeQuoterAllowedPriceUpdater = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_quoter_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_quoter_config", len(accountKeys)-1)
	}
	obj.FeeQuoterConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rmn_remote account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rmn_remote", len(accountKeys)-1)
	}
	obj.RmnRemote = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rmn_remote_curses account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rmn_remote_curses", len(accountKeys)-1)
	}
	obj.RmnRemoteCurses = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rmn_remote_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rmn_remote_config", len(accountKeys)-1)
	}
	obj.RmnRemoteConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *CommitPriceOnlyInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.ReferenceAddresses)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.SysvarInstructions)
	keys = append(keys, obj.FeeBillingSigner)
	keys = append(keys, obj.FeeQuoter)
	keys = append(keys, obj.FeeQuoterAllowedPriceUpdater)
	keys = append(keys, obj.FeeQuoterConfig)
	keys = append(keys, obj.RmnRemote)
	keys = append(keys, obj.RmnRemoteCurses)
	keys = append(keys, obj.RmnRemoteConfig)
	return keys
}

// Unmarshal unmarshals the CommitPriceOnlyInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *CommitPriceOnlyInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CommitPriceOnlyInstruction: %w", err)
	}
	return nil
}

// UnmarshalCommitPriceOnlyInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalCommitPriceOnlyInstruction(buf []byte) (*CommitPriceOnlyInstruction, error) {
	obj := new(CommitPriceOnlyInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type DeriveAccountsExecuteInstruction struct {
	Params DeriveAccountsExecuteParams `json:"params"`
	Stage  string                      `json:"stage"`

	// Accounts:
	Config solanago.PublicKey `json:"config"`
}

func (obj *DeriveAccountsExecuteInstruction) GetDiscriminator() []byte {
	return Instruction_DeriveAccountsExecute[:]
}

// UnmarshalWithDecoder unmarshals the DeriveAccountsExecuteInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *DeriveAccountsExecuteInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "DeriveAccountsExecuteInstruction", err)
	}
	if discriminator != Instruction_DeriveAccountsExecute {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "DeriveAccountsExecuteInstruction", Instruction_DeriveAccountsExecute, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	// Deserialize `Stage`:
	err = decoder.Decode(&obj.Stage)
	if err != nil {
		return err
	}
	return nil
}

func (obj *DeriveAccountsExecuteInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *DeriveAccountsExecuteInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 1 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 1, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *DeriveAccountsExecuteInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	return keys
}

// Unmarshal unmarshals the DeriveAccountsExecuteInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *DeriveAccountsExecuteInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling DeriveAccountsExecuteInstruction: %w", err)
	}
	return nil
}

// UnmarshalDeriveAccountsExecuteInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalDeriveAccountsExecuteInstruction(buf []byte) (*DeriveAccountsExecuteInstruction, error) {
	obj := new(DeriveAccountsExecuteInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type DisableSourceChainSelectorInstruction struct {
	SourceChainSelector uint64 `json:"source_chain_selector"`

	// Accounts:
	SourceChain         solanago.PublicKey `json:"source_chain"`
	SourceChainWritable bool               `json:"source_chain_writable"`
	Config              solanago.PublicKey `json:"config"`
	Authority           solanago.PublicKey `json:"authority"`
	AuthorityWritable   bool               `json:"authority_writable"`
	AuthoritySigner     bool               `json:"authority_signer"`
}

func (obj *DisableSourceChainSelectorInstruction) GetDiscriminator() []byte {
	return Instruction_DisableSourceChainSelector[:]
}

// UnmarshalWithDecoder unmarshals the DisableSourceChainSelectorInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *DisableSourceChainSelectorInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "DisableSourceChainSelectorInstruction", err)
	}
	if discriminator != Instruction_DisableSourceChainSelector {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "DisableSourceChainSelectorInstruction", Instruction_DisableSourceChainSelector, discriminator)
	}
	// Deserialize `SourceChainSelector`:
	err = decoder.Decode(&obj.SourceChainSelector)
	if err != nil {
		return err
	}
	return nil
}

func (obj *DisableSourceChainSelectorInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from source_chain account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "source_chain", err)
	}
	indices = append(indices, index)
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *DisableSourceChainSelectorInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set source_chain account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "source_chain", len(accountKeys)-1)
	}
	obj.SourceChain = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *DisableSourceChainSelectorInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.SourceChain)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the DisableSourceChainSelectorInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *DisableSourceChainSelectorInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling DisableSourceChainSelectorInstruction: %w", err)
	}
	return nil
}

// UnmarshalDisableSourceChainSelectorInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalDisableSourceChainSelectorInstruction(buf []byte) (*DisableSourceChainSelectorInstruction, error) {
	obj := new(DisableSourceChainSelectorInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ExecuteInstruction struct {
	RawExecutionReport     []byte       `json:"raw_execution_report"`
	ReportContextByteWords [2][32]uint8 `json:"report_context_byte_words"`
	TokenIndexes           []byte       `json:"token_indexes"`

	// Accounts:
	Config               solanago.PublicKey `json:"config"`
	ReferenceAddresses   solanago.PublicKey `json:"reference_addresses"`
	SourceChain          solanago.PublicKey `json:"source_chain"`
	CommitReport         solanago.PublicKey `json:"commit_report"`
	CommitReportWritable bool               `json:"commit_report_writable"`
	Offramp              solanago.PublicKey `json:"offramp"`
	AllowedOfframp       solanago.PublicKey `json:"allowed_offramp"`
	Authority            solanago.PublicKey `json:"authority"`
	AuthorityWritable    bool               `json:"authority_writable"`
	AuthoritySigner      bool               `json:"authority_signer"`
	SystemProgram        solanago.PublicKey `json:"system_program"`
	SysvarInstructions   solanago.PublicKey `json:"sysvar_instructions"`
	RmnRemote            solanago.PublicKey `json:"rmn_remote"`
	RmnRemoteCurses      solanago.PublicKey `json:"rmn_remote_curses"`
	RmnRemoteConfig      solanago.PublicKey `json:"rmn_remote_config"`
}

func (obj *ExecuteInstruction) GetDiscriminator() []byte {
	return Instruction_Execute[:]
}

// UnmarshalWithDecoder unmarshals the ExecuteInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *ExecuteInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "ExecuteInstruction", err)
	}
	if discriminator != Instruction_Execute {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "ExecuteInstruction", Instruction_Execute, discriminator)
	}
	// Deserialize `RawExecutionReport`:
	err = decoder.Decode(&obj.RawExecutionReport)
	if err != nil {
		return err
	}
	// Deserialize `ReportContextByteWords`:
	err = decoder.Decode(&obj.ReportContextByteWords)
	if err != nil {
		return err
	}
	// Deserialize `TokenIndexes`:
	err = decoder.Decode(&obj.TokenIndexes)
	if err != nil {
		return err
	}
	return nil
}

func (obj *ExecuteInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from reference_addresses account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reference_addresses", err)
	}
	indices = append(indices, index)
	// Decode from source_chain account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "source_chain", err)
	}
	indices = append(indices, index)
	// Decode from commit_report account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "commit_report", err)
	}
	indices = append(indices, index)
	// Decode from offramp account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "offramp", err)
	}
	indices = append(indices, index)
	// Decode from allowed_offramp account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "allowed_offramp", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	// Decode from sysvar_instructions account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "sysvar_instructions", err)
	}
	indices = append(indices, index)
	// Decode from rmn_remote account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rmn_remote", err)
	}
	indices = append(indices, index)
	// Decode from rmn_remote_curses account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rmn_remote_curses", err)
	}
	indices = append(indices, index)
	// Decode from rmn_remote_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rmn_remote_config", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *ExecuteInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 12 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 12, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reference_addresses account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reference_addresses", len(accountKeys)-1)
	}
	obj.ReferenceAddresses = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set source_chain account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "source_chain", len(accountKeys)-1)
	}
	obj.SourceChain = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set commit_report account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "commit_report", len(accountKeys)-1)
	}
	obj.CommitReport = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set offramp account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "offramp", len(accountKeys)-1)
	}
	obj.Offramp = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set allowed_offramp account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "allowed_offramp", len(accountKeys)-1)
	}
	obj.AllowedOfframp = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set sysvar_instructions account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "sysvar_instructions", len(accountKeys)-1)
	}
	obj.SysvarInstructions = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rmn_remote account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rmn_remote", len(accountKeys)-1)
	}
	obj.RmnRemote = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rmn_remote_curses account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rmn_remote_curses", len(accountKeys)-1)
	}
	obj.RmnRemoteCurses = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rmn_remote_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rmn_remote_config", len(accountKeys)-1)
	}
	obj.RmnRemoteConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *ExecuteInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.ReferenceAddresses)
	keys = append(keys, obj.SourceChain)
	keys = append(keys, obj.CommitReport)
	keys = append(keys, obj.Offramp)
	keys = append(keys, obj.AllowedOfframp)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.SysvarInstructions)
	keys = append(keys, obj.RmnRemote)
	keys = append(keys, obj.RmnRemoteCurses)
	keys = append(keys, obj.RmnRemoteConfig)
	return keys
}

// Unmarshal unmarshals the ExecuteInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *ExecuteInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ExecuteInstruction: %w", err)
	}
	return nil
}

// UnmarshalExecuteInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalExecuteInstruction(buf []byte) (*ExecuteInstruction, error) {
	obj := new(ExecuteInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitializeInstruction struct {

	// Accounts:
	ReferenceAddresses         solanago.PublicKey `json:"reference_addresses"`
	ReferenceAddressesWritable bool               `json:"reference_addresses_writable"`
	Router                     solanago.PublicKey `json:"router"`
	FeeQuoter                  solanago.PublicKey `json:"fee_quoter"`
	RmnRemote                  solanago.PublicKey `json:"rmn_remote"`
	OfframpLookupTable         solanago.PublicKey `json:"offramp_lookup_table"`
	State                      solanago.PublicKey `json:"state"`
	StateWritable              bool               `json:"state_writable"`
	Authority                  solanago.PublicKey `json:"authority"`
	AuthorityWritable          bool               `json:"authority_writable"`
	AuthoritySigner            bool               `json:"authority_signer"`
	SystemProgram              solanago.PublicKey `json:"system_program"`
	Program                    solanago.PublicKey `json:"program"`
	ProgramData                solanago.PublicKey `json:"program_data"`
}

func (obj *InitializeInstruction) GetDiscriminator() []byte {
	return Instruction_Initialize[:]
}

// UnmarshalWithDecoder unmarshals the InitializeInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *InitializeInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "InitializeInstruction", err)
	}
	if discriminator != Instruction_Initialize {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "InitializeInstruction", Instruction_Initialize, discriminator)
	}
	return nil
}

func (obj *InitializeInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from reference_addresses account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reference_addresses", err)
	}
	indices = append(indices, index)
	// Decode from router account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "router", err)
	}
	indices = append(indices, index)
	// Decode from fee_quoter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_quoter", err)
	}
	indices = append(indices, index)
	// Decode from rmn_remote account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rmn_remote", err)
	}
	indices = append(indices, index)
	// Decode from offramp_lookup_table account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "offramp_lookup_table", err)
	}
	indices = append(indices, index)
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	// Decode from program_data account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program_data", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitializeInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 10 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 10, len(indices))
	}
	indexOffset := 0
	// Set reference_addresses account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reference_addresses", len(accountKeys)-1)
	}
	obj.ReferenceAddresses = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set router account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "router", len(accountKeys)-1)
	}
	obj.Router = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_quoter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_quoter", len(accountKeys)-1)
	}
	obj.FeeQuoter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rmn_remote account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rmn_remote", len(accountKeys)-1)
	}
	obj.RmnRemote = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set offramp_lookup_table account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "offramp_lookup_table", len(accountKeys)-1)
	}
	obj.OfframpLookupTable = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program_data account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program_data", len(accountKeys)-1)
	}
	obj.ProgramData = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitializeInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.ReferenceAddresses)
	keys = append(keys, obj.Router)
	keys = append(keys, obj.FeeQuoter)
	keys = append(keys, obj.RmnRemote)
	keys = append(keys, obj.OfframpLookupTable)
	keys = append(keys, obj.State)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.Program)
	keys = append(keys, obj.ProgramData)
	return keys
}

// Unmarshal unmarshals the InitializeInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *InitializeInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitializeInstruction: %w", err)
	}
	return nil
}

// UnmarshalInitializeInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalInitializeInstruction(buf []byte) (*InitializeInstruction, error) {
	obj := new(InitializeInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitializeConfigInstruction struct {
	SvmChainSelector     uint64 `json:"svm_chain_selector"`
	EnableExecutionAfter int64  `json:"enable_execution_after"`

	// Accounts:
	Config            solanago.PublicKey `json:"config"`
	ConfigWritable    bool               `json:"config_writable"`
	Authority         solanago.PublicKey `json:"authority"`
	AuthorityWritable bool               `json:"authority_writable"`
	AuthoritySigner   bool               `json:"authority_signer"`
	SystemProgram     solanago.PublicKey `json:"system_program"`
	Program           solanago.PublicKey `json:"program"`
	ProgramData       solanago.PublicKey `json:"program_data"`
}

func (obj *InitializeConfigInstruction) GetDiscriminator() []byte {
	return Instruction_InitializeConfig[:]
}

// UnmarshalWithDecoder unmarshals the InitializeConfigInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *InitializeConfigInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "InitializeConfigInstruction", err)
	}
	if discriminator != Instruction_InitializeConfig {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "InitializeConfigInstruction", Instruction_InitializeConfig, discriminator)
	}
	// Deserialize `SvmChainSelector`:
	err = decoder.Decode(&obj.SvmChainSelector)
	if err != nil {
		return err
	}
	// Deserialize `EnableExecutionAfter`:
	err = decoder.Decode(&obj.EnableExecutionAfter)
	if err != nil {
		return err
	}
	return nil
}

func (obj *InitializeConfigInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	// Decode from program_data account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program_data", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitializeConfigInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 5 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 5, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program_data account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program_data", len(accountKeys)-1)
	}
	obj.ProgramData = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitializeConfigInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.Program)
	keys = append(keys, obj.ProgramData)
	return keys
}

// Unmarshal unmarshals the InitializeConfigInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *InitializeConfigInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitializeConfigInstruction: %w", err)
	}
	return nil
}

// UnmarshalInitializeConfigInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalInitializeConfigInstruction(buf []byte) (*InitializeConfigInstruction, error) {
	obj := new(InitializeConfigInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ManuallyExecuteInstruction struct {
	RawExecutionReport []byte `json:"raw_execution_report"`
	TokenIndexes       []byte `json:"token_indexes"`

	// Accounts:
	Config               solanago.PublicKey `json:"config"`
	ReferenceAddresses   solanago.PublicKey `json:"reference_addresses"`
	SourceChain          solanago.PublicKey `json:"source_chain"`
	CommitReport         solanago.PublicKey `json:"commit_report"`
	CommitReportWritable bool               `json:"commit_report_writable"`
	Offramp              solanago.PublicKey `json:"offramp"`
	AllowedOfframp       solanago.PublicKey `json:"allowed_offramp"`
	Authority            solanago.PublicKey `json:"authority"`
	AuthorityWritable    bool               `json:"authority_writable"`
	AuthoritySigner      bool               `json:"authority_signer"`
	SystemProgram        solanago.PublicKey `json:"system_program"`
	SysvarInstructions   solanago.PublicKey `json:"sysvar_instructions"`
	RmnRemote            solanago.PublicKey `json:"rmn_remote"`
	RmnRemoteCurses      solanago.PublicKey `json:"rmn_remote_curses"`
	RmnRemoteConfig      solanago.PublicKey `json:"rmn_remote_config"`
}

func (obj *ManuallyExecuteInstruction) GetDiscriminator() []byte {
	return Instruction_ManuallyExecute[:]
}

// UnmarshalWithDecoder unmarshals the ManuallyExecuteInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *ManuallyExecuteInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "ManuallyExecuteInstruction", err)
	}
	if discriminator != Instruction_ManuallyExecute {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "ManuallyExecuteInstruction", Instruction_ManuallyExecute, discriminator)
	}
	// Deserialize `RawExecutionReport`:
	err = decoder.Decode(&obj.RawExecutionReport)
	if err != nil {
		return err
	}
	// Deserialize `TokenIndexes`:
	err = decoder.Decode(&obj.TokenIndexes)
	if err != nil {
		return err
	}
	return nil
}

func (obj *ManuallyExecuteInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from reference_addresses account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reference_addresses", err)
	}
	indices = append(indices, index)
	// Decode from source_chain account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "source_chain", err)
	}
	indices = append(indices, index)
	// Decode from commit_report account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "commit_report", err)
	}
	indices = append(indices, index)
	// Decode from offramp account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "offramp", err)
	}
	indices = append(indices, index)
	// Decode from allowed_offramp account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "allowed_offramp", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	// Decode from sysvar_instructions account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "sysvar_instructions", err)
	}
	indices = append(indices, index)
	// Decode from rmn_remote account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rmn_remote", err)
	}
	indices = append(indices, index)
	// Decode from rmn_remote_curses account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rmn_remote_curses", err)
	}
	indices = append(indices, index)
	// Decode from rmn_remote_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rmn_remote_config", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *ManuallyExecuteInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 12 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 12, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reference_addresses account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reference_addresses", len(accountKeys)-1)
	}
	obj.ReferenceAddresses = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set source_chain account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "source_chain", len(accountKeys)-1)
	}
	obj.SourceChain = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set commit_report account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "commit_report", len(accountKeys)-1)
	}
	obj.CommitReport = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set offramp account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "offramp", len(accountKeys)-1)
	}
	obj.Offramp = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set allowed_offramp account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "allowed_offramp", len(accountKeys)-1)
	}
	obj.AllowedOfframp = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set sysvar_instructions account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "sysvar_instructions", len(accountKeys)-1)
	}
	obj.SysvarInstructions = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rmn_remote account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rmn_remote", len(accountKeys)-1)
	}
	obj.RmnRemote = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rmn_remote_curses account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rmn_remote_curses", len(accountKeys)-1)
	}
	obj.RmnRemoteCurses = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rmn_remote_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rmn_remote_config", len(accountKeys)-1)
	}
	obj.RmnRemoteConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *ManuallyExecuteInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.ReferenceAddresses)
	keys = append(keys, obj.SourceChain)
	keys = append(keys, obj.CommitReport)
	keys = append(keys, obj.Offramp)
	keys = append(keys, obj.AllowedOfframp)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.SysvarInstructions)
	keys = append(keys, obj.RmnRemote)
	keys = append(keys, obj.RmnRemoteCurses)
	keys = append(keys, obj.RmnRemoteConfig)
	return keys
}

// Unmarshal unmarshals the ManuallyExecuteInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *ManuallyExecuteInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ManuallyExecuteInstruction: %w", err)
	}
	return nil
}

// UnmarshalManuallyExecuteInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalManuallyExecuteInstruction(buf []byte) (*ManuallyExecuteInstruction, error) {
	obj := new(ManuallyExecuteInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SetDefaultCodeVersionInstruction struct {
	CodeVersion CodeVersion `json:"code_version"`

	// Accounts:
	Config          solanago.PublicKey `json:"config"`
	ConfigWritable  bool               `json:"config_writable"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
}

func (obj *SetDefaultCodeVersionInstruction) GetDiscriminator() []byte {
	return Instruction_SetDefaultCodeVersion[:]
}

// UnmarshalWithDecoder unmarshals the SetDefaultCodeVersionInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *SetDefaultCodeVersionInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "SetDefaultCodeVersionInstruction", err)
	}
	if discriminator != Instruction_SetDefaultCodeVersion {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "SetDefaultCodeVersionInstruction", Instruction_SetDefaultCodeVersion, discriminator)
	}
	// Deserialize `CodeVersion`:
	err = decoder.Decode(&obj.CodeVersion)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SetDefaultCodeVersionInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SetDefaultCodeVersionInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 2 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 2, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SetDefaultCodeVersionInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the SetDefaultCodeVersionInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *SetDefaultCodeVersionInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SetDefaultCodeVersionInstruction: %w", err)
	}
	return nil
}

// UnmarshalSetDefaultCodeVersionInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalSetDefaultCodeVersionInstruction(buf []byte) (*SetDefaultCodeVersionInstruction, error) {
	obj := new(SetDefaultCodeVersionInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SetOcrConfigInstruction struct {
	PluginType   OcrPluginType        `json:"plugin_type"`
	ConfigInfo   Ocr3ConfigInfoInput  `json:"config_info"`
	Signers      [][20]uint8          `json:"signers"`
	Transmitters []solanago.PublicKey `json:"transmitters"`

	// Accounts:
	Config          solanago.PublicKey `json:"config"`
	ConfigWritable  bool               `json:"config_writable"`
	State           solanago.PublicKey `json:"state"`
	StateWritable   bool               `json:"state_writable"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
}

func (obj *SetOcrConfigInstruction) GetDiscriminator() []byte {
	return Instruction_SetOcrConfig[:]
}

// UnmarshalWithDecoder unmarshals the SetOcrConfigInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *SetOcrConfigInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "SetOcrConfigInstruction", err)
	}
	if discriminator != Instruction_SetOcrConfig {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "SetOcrConfigInstruction", Instruction_SetOcrConfig, discriminator)
	}
	// Deserialize `PluginType`:
	err = decoder.Decode(&obj.PluginType)
	if err != nil {
		return err
	}
	// Deserialize `ConfigInfo`:
	err = decoder.Decode(&obj.ConfigInfo)
	if err != nil {
		return err
	}
	// Deserialize `Signers`:
	err = decoder.Decode(&obj.Signers)
	if err != nil {
		return err
	}
	// Deserialize `Transmitters`:
	err = decoder.Decode(&obj.Transmitters)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SetOcrConfigInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SetOcrConfigInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SetOcrConfigInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.State)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the SetOcrConfigInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *SetOcrConfigInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SetOcrConfigInstruction: %w", err)
	}
	return nil
}

// UnmarshalSetOcrConfigInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalSetOcrConfigInstruction(buf []byte) (*SetOcrConfigInstruction, error) {
	obj := new(SetOcrConfigInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type TransferOwnershipInstruction struct {
	ProposedOwner solanago.PublicKey `json:"proposed_owner"`

	// Accounts:
	Config          solanago.PublicKey `json:"config"`
	ConfigWritable  bool               `json:"config_writable"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
}

func (obj *TransferOwnershipInstruction) GetDiscriminator() []byte {
	return Instruction_TransferOwnership[:]
}

// UnmarshalWithDecoder unmarshals the TransferOwnershipInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *TransferOwnershipInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "TransferOwnershipInstruction", err)
	}
	if discriminator != Instruction_TransferOwnership {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "TransferOwnershipInstruction", Instruction_TransferOwnership, discriminator)
	}
	// Deserialize `ProposedOwner`:
	err = decoder.Decode(&obj.ProposedOwner)
	if err != nil {
		return err
	}
	return nil
}

func (obj *TransferOwnershipInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *TransferOwnershipInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 2 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 2, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *TransferOwnershipInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the TransferOwnershipInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *TransferOwnershipInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling TransferOwnershipInstruction: %w", err)
	}
	return nil
}

// UnmarshalTransferOwnershipInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalTransferOwnershipInstruction(buf []byte) (*TransferOwnershipInstruction, error) {
	obj := new(TransferOwnershipInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type TypeVersionInstruction struct {

	// Accounts:
	Clock solanago.PublicKey `json:"clock"`
}

func (obj *TypeVersionInstruction) GetDiscriminator() []byte {
	return Instruction_TypeVersion[:]
}

// UnmarshalWithDecoder unmarshals the TypeVersionInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *TypeVersionInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "TypeVersionInstruction", err)
	}
	if discriminator != Instruction_TypeVersion {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "TypeVersionInstruction", Instruction_TypeVersion, discriminator)
	}
	return nil
}

func (obj *TypeVersionInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from clock account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "clock", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *TypeVersionInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 1 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 1, len(indices))
	}
	indexOffset := 0
	// Set clock account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "clock", len(accountKeys)-1)
	}
	obj.Clock = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *TypeVersionInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Clock)
	return keys
}

// Unmarshal unmarshals the TypeVersionInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *TypeVersionInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling TypeVersionInstruction: %w", err)
	}
	return nil
}

// UnmarshalTypeVersionInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalTypeVersionInstruction(buf []byte) (*TypeVersionInstruction, error) {
	obj := new(TypeVersionInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UpdateEnableManualExecutionAfterInstruction struct {
	NewEnableManualExecutionAfter int64 `json:"new_enable_manual_execution_after"`

	// Accounts:
	Config          solanago.PublicKey `json:"config"`
	ConfigWritable  bool               `json:"config_writable"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
}

func (obj *UpdateEnableManualExecutionAfterInstruction) GetDiscriminator() []byte {
	return Instruction_UpdateEnableManualExecutionAfter[:]
}

// UnmarshalWithDecoder unmarshals the UpdateEnableManualExecutionAfterInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *UpdateEnableManualExecutionAfterInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "UpdateEnableManualExecutionAfterInstruction", err)
	}
	if discriminator != Instruction_UpdateEnableManualExecutionAfter {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "UpdateEnableManualExecutionAfterInstruction", Instruction_UpdateEnableManualExecutionAfter, discriminator)
	}
	// Deserialize `NewEnableManualExecutionAfter`:
	err = decoder.Decode(&obj.NewEnableManualExecutionAfter)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UpdateEnableManualExecutionAfterInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *UpdateEnableManualExecutionAfterInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 2 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 2, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *UpdateEnableManualExecutionAfterInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the UpdateEnableManualExecutionAfterInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *UpdateEnableManualExecutionAfterInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdateEnableManualExecutionAfterInstruction: %w", err)
	}
	return nil
}

// UnmarshalUpdateEnableManualExecutionAfterInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalUpdateEnableManualExecutionAfterInstruction(buf []byte) (*UpdateEnableManualExecutionAfterInstruction, error) {
	obj := new(UpdateEnableManualExecutionAfterInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UpdateReferenceAddressesInstruction struct {
	Router             solanago.PublicKey `json:"router"`
	FeeQuoter          solanago.PublicKey `json:"fee_quoter"`
	OfframpLookupTable solanago.PublicKey `json:"offramp_lookup_table"`
	RmnRemote          solanago.PublicKey `json:"rmn_remote"`

	// Accounts:
	Config                     solanago.PublicKey `json:"config"`
	ReferenceAddresses         solanago.PublicKey `json:"reference_addresses"`
	ReferenceAddressesWritable bool               `json:"reference_addresses_writable"`
	Authority                  solanago.PublicKey `json:"authority"`
	AuthoritySigner            bool               `json:"authority_signer"`
}

func (obj *UpdateReferenceAddressesInstruction) GetDiscriminator() []byte {
	return Instruction_UpdateReferenceAddresses[:]
}

// UnmarshalWithDecoder unmarshals the UpdateReferenceAddressesInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *UpdateReferenceAddressesInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "UpdateReferenceAddressesInstruction", err)
	}
	if discriminator != Instruction_UpdateReferenceAddresses {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "UpdateReferenceAddressesInstruction", Instruction_UpdateReferenceAddresses, discriminator)
	}
	// Deserialize `Router`:
	err = decoder.Decode(&obj.Router)
	if err != nil {
		return err
	}
	// Deserialize `FeeQuoter`:
	err = decoder.Decode(&obj.FeeQuoter)
	if err != nil {
		return err
	}
	// Deserialize `OfframpLookupTable`:
	err = decoder.Decode(&obj.OfframpLookupTable)
	if err != nil {
		return err
	}
	// Deserialize `RmnRemote`:
	err = decoder.Decode(&obj.RmnRemote)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UpdateReferenceAddressesInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from reference_addresses account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "reference_addresses", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *UpdateReferenceAddressesInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set reference_addresses account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "reference_addresses", len(accountKeys)-1)
	}
	obj.ReferenceAddresses = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *UpdateReferenceAddressesInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.ReferenceAddresses)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the UpdateReferenceAddressesInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *UpdateReferenceAddressesInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdateReferenceAddressesInstruction: %w", err)
	}
	return nil
}

// UnmarshalUpdateReferenceAddressesInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalUpdateReferenceAddressesInstruction(buf []byte) (*UpdateReferenceAddressesInstruction, error) {
	obj := new(UpdateReferenceAddressesInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UpdateSourceChainConfigInstruction struct {
	SourceChainSelector uint64            `json:"source_chain_selector"`
	SourceChainConfig   SourceChainConfig `json:"source_chain_config"`

	// Accounts:
	SourceChain         solanago.PublicKey `json:"source_chain"`
	SourceChainWritable bool               `json:"source_chain_writable"`
	Config              solanago.PublicKey `json:"config"`
	Authority           solanago.PublicKey `json:"authority"`
	AuthorityWritable   bool               `json:"authority_writable"`
	AuthoritySigner     bool               `json:"authority_signer"`
}

func (obj *UpdateSourceChainConfigInstruction) GetDiscriminator() []byte {
	return Instruction_UpdateSourceChainConfig[:]
}

// UnmarshalWithDecoder unmarshals the UpdateSourceChainConfigInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *UpdateSourceChainConfigInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "UpdateSourceChainConfigInstruction", err)
	}
	if discriminator != Instruction_UpdateSourceChainConfig {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "UpdateSourceChainConfigInstruction", Instruction_UpdateSourceChainConfig, discriminator)
	}
	// Deserialize `SourceChainSelector`:
	err = decoder.Decode(&obj.SourceChainSelector)
	if err != nil {
		return err
	}
	// Deserialize `SourceChainConfig`:
	err = decoder.Decode(&obj.SourceChainConfig)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UpdateSourceChainConfigInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from source_chain account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "source_chain", err)
	}
	indices = append(indices, index)
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *UpdateSourceChainConfigInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set source_chain account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "source_chain", len(accountKeys)-1)
	}
	obj.SourceChain = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *UpdateSourceChainConfigInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.SourceChain)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the UpdateSourceChainConfigInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *UpdateSourceChainConfigInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdateSourceChainConfigInstruction: %w", err)
	}
	return nil
}

// UnmarshalUpdateSourceChainConfigInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalUpdateSourceChainConfigInstruction(buf []byte) (*UpdateSourceChainConfigInstruction, error) {
	obj := new(UpdateSourceChainConfigInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UpdateSvmChainSelectorInstruction struct {
	NewChainSelector uint64 `json:"new_chain_selector"`

	// Accounts:
	Config          solanago.PublicKey `json:"config"`
	ConfigWritable  bool               `json:"config_writable"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
}

func (obj *UpdateSvmChainSelectorInstruction) GetDiscriminator() []byte {
	return Instruction_UpdateSvmChainSelector[:]
}

// UnmarshalWithDecoder unmarshals the UpdateSvmChainSelectorInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *UpdateSvmChainSelectorInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "UpdateSvmChainSelectorInstruction", err)
	}
	if discriminator != Instruction_UpdateSvmChainSelector {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "UpdateSvmChainSelectorInstruction", Instruction_UpdateSvmChainSelector, discriminator)
	}
	// Deserialize `NewChainSelector`:
	err = decoder.Decode(&obj.NewChainSelector)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UpdateSvmChainSelectorInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *UpdateSvmChainSelectorInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 2 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 2, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *UpdateSvmChainSelectorInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the UpdateSvmChainSelectorInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *UpdateSvmChainSelectorInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdateSvmChainSelectorInstruction: %w", err)
	}
	return nil
}

// UnmarshalUpdateSvmChainSelectorInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalUpdateSvmChainSelectorInstruction(buf []byte) (*UpdateSvmChainSelectorInstruction, error) {
	obj := new(UpdateSvmChainSelectorInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Instruction interface defines common methods for all instruction types
type Instruction interface {
	GetDiscriminator() []byte

	UnmarshalWithDecoder(decoder *binary.Decoder) error

	UnmarshalAccountIndices(buf []byte) ([]uint8, error)

	PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error

	GetAccountKeys() []solanago.PublicKey
}

// ParseInstruction parses instruction data and optionally populates accounts
// If accountIndicesData is nil or empty, accounts will not be populated
func ParseInstruction(instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (Instruction, error) {
	// Validate inputs
	if len(instructionData) < 8 {
		return nil, fmt.Errorf("instruction data too short: expected at least 8 bytes, got %d", len(instructionData))
	}
	// Extract discriminator
	discriminator := [8]byte{}
	copy(discriminator[:], instructionData[0:8])
	// Parse based on discriminator
	switch discriminator {
	case Instruction_AcceptOwnership:
		instruction := new(AcceptOwnershipInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AcceptOwnershipInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_AddSourceChain:
		instruction := new(AddSourceChainInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AddSourceChainInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_BufferExecutionReport:
		instruction := new(BufferExecutionReportInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as BufferExecutionReportInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_CloseCommitReportAccount:
		instruction := new(CloseCommitReportAccountInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as CloseCommitReportAccountInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_CloseExecutionReportBuffer:
		instruction := new(CloseExecutionReportBufferInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as CloseExecutionReportBufferInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_Commit:
		instruction := new(CommitInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as CommitInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_CommitPriceOnly:
		instruction := new(CommitPriceOnlyInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as CommitPriceOnlyInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_DeriveAccountsExecute:
		instruction := new(DeriveAccountsExecuteInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as DeriveAccountsExecuteInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_DisableSourceChainSelector:
		instruction := new(DisableSourceChainSelectorInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as DisableSourceChainSelectorInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_Execute:
		instruction := new(ExecuteInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as ExecuteInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_Initialize:
		instruction := new(InitializeInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitializeInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_InitializeConfig:
		instruction := new(InitializeConfigInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitializeConfigInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_ManuallyExecute:
		instruction := new(ManuallyExecuteInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as ManuallyExecuteInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SetDefaultCodeVersion:
		instruction := new(SetDefaultCodeVersionInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SetDefaultCodeVersionInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SetOcrConfig:
		instruction := new(SetOcrConfigInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SetOcrConfigInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_TransferOwnership:
		instruction := new(TransferOwnershipInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as TransferOwnershipInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_TypeVersion:
		instruction := new(TypeVersionInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as TypeVersionInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_UpdateEnableManualExecutionAfter:
		instruction := new(UpdateEnableManualExecutionAfterInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as UpdateEnableManualExecutionAfterInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_UpdateReferenceAddresses:
		instruction := new(UpdateReferenceAddressesInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as UpdateReferenceAddressesInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_UpdateSourceChainConfig:
		instruction := new(UpdateSourceChainConfigInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as UpdateSourceChainConfigInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_UpdateSvmChainSelector:
		instruction := new(UpdateSvmChainSelectorInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as UpdateSvmChainSelectorInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	default:
		return nil, fmt.Errorf("unknown instruction discriminator: %s", binary.FormatDiscriminator(discriminator))
	}
}

// ParseInstructionTyped parses instruction data and returns a specific instruction type // T must implement the Instruction interface
func ParseInstructionTyped[T Instruction](instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (T, error) {
	instruction, err := ParseInstruction(instructionData, accountIndicesData, accountKeys)
	if err != nil {
		return *new(T), err
	}
	typed, ok := instruction.(T)
	if !ok {
		return *new(T), fmt.Errorf("instruction is not of expected type")
	}
	return typed, nil
}

// ParseInstructionWithoutAccounts parses instruction data without account information
func ParseInstructionWithoutAccounts(instructionData []byte) (Instruction, error) {
	return ParseInstruction(instructionData, nil, []solanago.PublicKey{})
}

// ParseInstructionWithAccounts parses instruction data with account information
func ParseInstructionWithAccounts(instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (Instruction, error) {
	return ParseInstruction(instructionData, accountIndicesData, accountKeys)
}
