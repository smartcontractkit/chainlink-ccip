// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains instructions.

package ccip_offramp

import (
	"bytes"
	"fmt"
	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "accept_ownership" instruction.
// Accepts the ownership of the router by the proposed owner. //  // Shared func signature with other programs //  // # Arguments //  // * `ctx` - The context containing the accounts required for accepting ownership. // The new owner must be a signer of the transaction.
func NewAcceptOwnershipInstruction(
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "add_source_chain" instruction.
// Adds a new source chain selector with its config to the offramp. //  // The Admin needs to add any new chain supported. // When adding a new chain, the Admin needs to specify if it's enabled or not. //  // # Arguments
func NewAddSourceChainInstruction(
	// Params:
	newChainSelectorParam uint64,
	sourceChainConfigParam SourceChainConfig,

	// Accounts:
	sourceChainAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AddSourceChain[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newChainSelectorParam`:
		err = enc__.Encode(newChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("newChainSelectorParam", err)
		}
		// Serialize `sourceChainConfigParam`:
		err = enc__.Encode(sourceChainConfigParam)
		if err != nil {
			return nil, errors.NewField("sourceChainConfigParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "source_chain": Writable, Non-signer, Required
		// Adding a chain selector implies initializing the state for a new chain
		accounts__.Append(solanago.NewAccountMeta(sourceChainAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "buffer_execution_report" instruction.
// Initializes and/or inserts a chunk of report data to an execution report buffer. //  // When execution reports are too large to fit in a single transaction, they can be chopped // up in chunks first (as a special case, one chunk is also acceptable), and pre-buffered // via multiple calls to this instruction. //  // There's no need to pre-initialize the buffer: all chunks can be sent concurrently, and the // first one to arrive will initialize the buffer. //  // To benefit from buffering, the eventual call to `execute` or `manually_execute` must // include an additional `remaining_account` with the PDA derived from // ["execution_report_buffer", <buffer_id>, <caller_pubkey>]. //  // # Arguments //  // * `ctx` - The context containing the accounts required for buffering. // * `buffer_id` - An arbitrary buffer id defined by the caller (could be the message_id). Max 32 bytes. // * `report_length` - Total length in bytes of the execution report. // * `chunk` - The specific chunk to add to the buffer. Chunk must have a consistent size, except // the last one in the buffer, which may be smaller. // * `chunk_index` - The index of this chunk. // * `num_chunks` - The total number of chunks in the report.
func NewBufferExecutionReportInstruction(
	// Params:
	bufferIdParam []byte,
	reportLengthParam uint32,
	chunkParam []byte,
	chunkIndexParam uint8,
	numChunksParam uint8,

	// Accounts:
	executionReportBufferAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_BufferExecutionReport[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `bufferIdParam`:
		err = enc__.Encode(bufferIdParam)
		if err != nil {
			return nil, errors.NewField("bufferIdParam", err)
		}
		// Serialize `reportLengthParam`:
		err = enc__.Encode(reportLengthParam)
		if err != nil {
			return nil, errors.NewField("reportLengthParam", err)
		}
		// Serialize `chunkParam`:
		err = enc__.Encode(chunkParam)
		if err != nil {
			return nil, errors.NewField("chunkParam", err)
		}
		// Serialize `chunkIndexParam`:
		err = enc__.Encode(chunkIndexParam)
		if err != nil {
			return nil, errors.NewField("chunkIndexParam", err)
		}
		// Serialize `numChunksParam`:
		err = enc__.Encode(numChunksParam)
		if err != nil {
			return nil, errors.NewField("numChunksParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "execution_report_buffer": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(executionReportBufferAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "close_commit_report_account" instruction.
func NewCloseCommitReportAccountInstruction(
	// Params:
	sourceChainSelectorParam uint64,
	rootParam []byte,

	// Accounts:
	configAccount solanago.PublicKey,
	commitReportAccount solanago.PublicKey,
	referenceAddressesAccount solanago.PublicKey,
	wsolMintAccount solanago.PublicKey,
	feeTokenReceiverAccount solanago.PublicKey,
	feeBillingSignerAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CloseCommitReportAccount[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `sourceChainSelectorParam`:
		err = enc__.Encode(sourceChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("sourceChainSelectorParam", err)
		}
		// Serialize `rootParam`:
		err = enc__.Encode(rootParam)
		if err != nil {
			return nil, errors.NewField("rootParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "commit_report": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(commitReportAccount, true, false))
		// Account 2 "reference_addresses": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(referenceAddressesAccount, false, false))
		// Account 3 "wsol_mint": Read-only, Non-signer, Required, Address: So11111111111111111111111111111111111111112
		accounts__.Append(solanago.NewAccountMeta(wsolMintAccount, false, false))
		// Account 4 "fee_token_receiver": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeTokenReceiverAccount, true, false))
		// Account 5 "fee_billing_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeBillingSignerAccount, false, false))
		// Account 6 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "close_execution_report_buffer" instruction.
// Closes the execution report buffer to reclaim funds. //  // Note this is only necessary when aborting a buffered transaction, or when a mistake // was made when buffering data. The buffer account will otherwise automatically close // and return funds to the caller whenever buffered execution succeeds.
func NewCloseExecutionReportBufferInstruction(
	// Params:
	bufferIdParam []byte,

	// Accounts:
	executionReportBufferAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CloseExecutionReportBuffer[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `bufferIdParam`:
		err = enc__.Encode(bufferIdParam)
		if err != nil {
			return nil, errors.NewField("bufferIdParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "execution_report_buffer": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(executionReportBufferAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "commit" instruction.
// Off Ramp Flow // // Commits a report to the router, containing a Merkle Root. //  // The method name needs to be commit with Anchor encoding. //  // This function is called by the OffChain when committing one Report to the SVM Router. // In this Flow only one report is sent, the Commit Report. This is different as EVM does, // this is because here all the chain state is stored in one account per Merkle Tree Root. // So, to avoid having to send a dynamic size array of accounts, in this message only one Commit Report Account is sent. // This message validates the signatures of the report and stores the Merkle Root in the Commit Report Account. // The Report must contain an interval of messages, and the min of them must be the next sequence number expected. // The max size of the interval is 64. // This message emits two events: CommitReportAccepted and Transmitted. //  // # Arguments //  // * `ctx` - The context containing the accounts required for the commit. // * `report_context_byte_words` - consists of: // * report_context_byte_words[0]: ConfigDigest // * report_context_byte_words[1]: 24 byte padding, 8 byte sequence number // * `raw_report` - The serialized commit input report, single merkle root with RMN signatures and price updates // * `rs` - slice of R components of signatures // * `ss` - slice of S components of signatures // * `raw_vs` - array of V components of signatures
func NewCommitInstruction(
	// Params:
	reportContextByteWordsParam [2][32]uint8,
	rawReportParam []byte,
	rsParam [][32]uint8,
	ssParam [][32]uint8,
	rawVsParam [32]uint8,

	// Accounts:
	configAccount solanago.PublicKey,
	referenceAddressesAccount solanago.PublicKey,
	sourceChainAccount solanago.PublicKey,
	commitReportAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	sysvarInstructionsAccount solanago.PublicKey,
	feeBillingSignerAccount solanago.PublicKey,
	feeQuoterAccount solanago.PublicKey,
	feeQuoterAllowedPriceUpdaterAccount solanago.PublicKey,
	feeQuoterConfigAccount solanago.PublicKey,
	rmnRemoteAccount solanago.PublicKey,
	rmnRemoteCursesAccount solanago.PublicKey,
	rmnRemoteConfigAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Commit[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `reportContextByteWordsParam`:
		err = enc__.Encode(reportContextByteWordsParam)
		if err != nil {
			return nil, errors.NewField("reportContextByteWordsParam", err)
		}
		// Serialize `rawReportParam`:
		err = enc__.Encode(rawReportParam)
		if err != nil {
			return nil, errors.NewField("rawReportParam", err)
		}
		// Serialize `rsParam`:
		err = enc__.Encode(rsParam)
		if err != nil {
			return nil, errors.NewField("rsParam", err)
		}
		// Serialize `ssParam`:
		err = enc__.Encode(ssParam)
		if err != nil {
			return nil, errors.NewField("ssParam", err)
		}
		// Serialize `rawVsParam`:
		err = enc__.Encode(rawVsParam)
		if err != nil {
			return nil, errors.NewField("rawVsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "reference_addresses": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(referenceAddressesAccount, false, false))
		// Account 2 "source_chain": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(sourceChainAccount, false, false))
		// Account 3 "commit_report": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(commitReportAccount, true, false))
		// Account 4 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 5 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 6 "sysvar_instructions": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(sysvarInstructionsAccount, false, false))
		// Account 7 "fee_billing_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeBillingSignerAccount, false, false))
		// Account 8 "fee_quoter": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeQuoterAccount, false, false))
		// Account 9 "fee_quoter_allowed_price_updater": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeQuoterAllowedPriceUpdaterAccount, false, false))
		// Account 10 "fee_quoter_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeQuoterConfigAccount, false, false))
		// Account 11 "rmn_remote": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteAccount, false, false))
		// Account 12 "rmn_remote_curses": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteCursesAccount, false, false))
		// Account 13 "rmn_remote_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteConfigAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "commit_price_only" instruction.
// Commits a report to the router, with price updates only. //  // The method name needs to be commit with Anchor encoding. //  // This function is called by the OffChain when committing one Report to the SVM Router, // containing only price updates and no merkle root. //  // # Arguments //  // * `ctx` - The context containing the accounts required for the commit. // * `report_context_byte_words` - consists of: // * report_context_byte_words[0]: ConfigDigest // * report_context_byte_words[1]: 24 byte padding, 8 byte sequence number // * `raw_report` - The serialized commit input report containing the price updates, // with no merkle root. // * `rs` - slice of R components of signatures // * `ss` - slice of S components of signatures // * `raw_vs` - array of V components of signatures
func NewCommitPriceOnlyInstruction(
	// Params:
	reportContextByteWordsParam [2][32]uint8,
	rawReportParam []byte,
	rsParam [][32]uint8,
	ssParam [][32]uint8,
	rawVsParam [32]uint8,

	// Accounts:
	configAccount solanago.PublicKey,
	referenceAddressesAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	sysvarInstructionsAccount solanago.PublicKey,
	feeBillingSignerAccount solanago.PublicKey,
	feeQuoterAccount solanago.PublicKey,
	feeQuoterAllowedPriceUpdaterAccount solanago.PublicKey,
	feeQuoterConfigAccount solanago.PublicKey,
	rmnRemoteAccount solanago.PublicKey,
	rmnRemoteCursesAccount solanago.PublicKey,
	rmnRemoteConfigAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CommitPriceOnly[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `reportContextByteWordsParam`:
		err = enc__.Encode(reportContextByteWordsParam)
		if err != nil {
			return nil, errors.NewField("reportContextByteWordsParam", err)
		}
		// Serialize `rawReportParam`:
		err = enc__.Encode(rawReportParam)
		if err != nil {
			return nil, errors.NewField("rawReportParam", err)
		}
		// Serialize `rsParam`:
		err = enc__.Encode(rsParam)
		if err != nil {
			return nil, errors.NewField("rsParam", err)
		}
		// Serialize `ssParam`:
		err = enc__.Encode(ssParam)
		if err != nil {
			return nil, errors.NewField("ssParam", err)
		}
		// Serialize `rawVsParam`:
		err = enc__.Encode(rawVsParam)
		if err != nil {
			return nil, errors.NewField("rawVsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "reference_addresses": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(referenceAddressesAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 4 "sysvar_instructions": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(sysvarInstructionsAccount, false, false))
		// Account 5 "fee_billing_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeBillingSignerAccount, false, false))
		// Account 6 "fee_quoter": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeQuoterAccount, false, false))
		// Account 7 "fee_quoter_allowed_price_updater": Read-only, Non-signer, Required
		// so that it can authorize the call made by this offramp
		accounts__.Append(solanago.NewAccountMeta(feeQuoterAllowedPriceUpdaterAccount, false, false))
		// Account 8 "fee_quoter_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeQuoterConfigAccount, false, false))
		// Account 9 "rmn_remote": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteAccount, false, false))
		// Account 10 "rmn_remote_curses": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteCursesAccount, false, false))
		// Account 11 "rmn_remote_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteConfigAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "derive_accounts_execute" instruction.
// Automatically derives all acounts required to call `ccip_execute`. //  // This method receives the bare minimum amount of information needed to construct // the entire account list to execute a transaction, and builds it iteratively // over the course of multiple calls. //  // The return type contains: //  // * `accounts_to_save`: The caller must append these accounts to a list they maintain. // When complete, this list will contain all accounts needed to call `ccip_execute`. // * `ask_again_with`: When `next_stage` is not empty, the caller must call `derive_accounts_execute` // again, including exactly these accounts as the `remaining_accounts`. // * `lookup_tables_to_save`: The caller must save those LUTs. They can be used for `ccip_execute`. // * `current_stage`: A string describing the current stage of the derivation process. When the stage // is "TokenTransferStaticAccounts/<N>/0", it means the `accounts_to_save` block in this response contains // all accounts relating to the Nth token being transferred. Use this information to construct // the `token_indexes` vector that `execute` requires. // * `next_stage`: If nonempty, this means the instruction must get called again with this value // as the `stage` argument. //  // Therefore, and starting with an empty `remaining_accounts` list, the caller must repeteadly // call `derive_accounts_execute` until `next_stage` is returned empty. //  // # Arguments //  // * `ctx`: Context containing only the offramp config. // * `stage`: Requested derivation stage. Pass "Start" the first time, then for each subsequent // call, pass the value returned in `response.next_stage` until empty. // * `params`: // * `execute_caller`: Public key of the account that will sign the call to `ccip_execute`. // * `message_accounts`: If the transaction involves messaging, the message accounts. // * `source_chain_selector`: CCIP chain selector for the source chain. // * `mints_of_transferred_token`: List of all token mints for tokens being transferred (i.e. // the entries in `report.message.token_amounts.destination_address`.) // * `merkle_root`: Merkle root as per the commit report. // * `buffer_id`: If the execution will be buffered, the buffer id that will be used by the // `execute_caller`: If the execution will not be buffered, this should be empty. // * `token_receiver`: Receiver of token transfers, if any (i.e. report.message.token_receiver)
func NewDeriveAccountsExecuteInstruction(
	// Params:
	paramsParam DeriveAccountsExecuteParams,
	stageParam string,

	// Accounts:
	configAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_DeriveAccountsExecute[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
		// Serialize `stageParam`:
		err = enc__.Encode(stageParam)
		if err != nil {
			return nil, errors.NewField("stageParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "disable_source_chain_selector" instruction.
// Disables the source chain selector. //  // The Admin is the only one able to disable the chain selector as source. This method is thought of as an emergency kill-switch. //  // # Arguments //  // * `ctx` - The context containing the accounts required for disabling the chain selector. // * `source_chain_selector` - The source chain selector to be disabled.
func NewDisableSourceChainSelectorInstruction(
	// Params:
	sourceChainSelectorParam uint64,

	// Accounts:
	sourceChainAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_DisableSourceChainSelector[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `sourceChainSelectorParam`:
		err = enc__.Encode(sourceChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("sourceChainSelectorParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "source_chain": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(sourceChainAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "execute" instruction.
// Executes a message on the destination chain. //  // The method name needs to be execute with Anchor encoding. //  // This function is called by the OffChain when executing one Report to the SVM Router. // In this Flow only one message is sent, the Execution Report. This is different as EVM does, // this is because there is no try/catch mechanism to allow batch execution. // This message validates that the Merkle Tree Proof of the given message is correct and is stored in the Commit Report Account. // The message must be untouched to be executed. // This message emits the event ExecutionStateChanged with the new state of the message. // Finally, executes the CPI instruction to the receiver program in the ccip_receive message. //  // # Arguments //  // * `ctx` - The context containing the accounts required for the execute. // * `raw_execution_report` - the serialized execution report containing only one message and proofs // * `report_context_byte_words` - report_context after execution_report to match context for manually execute (proper decoding order) // *  consists of: // * report_context_byte_words[0]: ConfigDigest // * report_context_byte_words[1]: 24 byte padding, 8 byte sequence number
func NewExecuteInstruction(
	// Params:
	rawExecutionReportParam []byte,
	reportContextByteWordsParam [2][32]uint8,
	tokenIndexesParam []byte,

	// Accounts:
	configAccount solanago.PublicKey,
	referenceAddressesAccount solanago.PublicKey,
	sourceChainAccount solanago.PublicKey,
	commitReportAccount solanago.PublicKey,
	offrampAccount solanago.PublicKey,
	allowedOfframpAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	sysvarInstructionsAccount solanago.PublicKey,
	rmnRemoteAccount solanago.PublicKey,
	rmnRemoteCursesAccount solanago.PublicKey,
	rmnRemoteConfigAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Execute[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `rawExecutionReportParam`:
		err = enc__.Encode(rawExecutionReportParam)
		if err != nil {
			return nil, errors.NewField("rawExecutionReportParam", err)
		}
		// Serialize `reportContextByteWordsParam`:
		err = enc__.Encode(reportContextByteWordsParam)
		if err != nil {
			return nil, errors.NewField("reportContextByteWordsParam", err)
		}
		// Serialize `tokenIndexesParam`:
		err = enc__.Encode(tokenIndexesParam)
		if err != nil {
			return nil, errors.NewField("tokenIndexesParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "reference_addresses": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(referenceAddressesAccount, false, false))
		// Account 2 "source_chain": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(sourceChainAccount, false, false))
		// Account 3 "commit_report": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(commitReportAccount, true, false))
		// Account 4 "offramp": Read-only, Non-signer, Required, Address: offqSMQWgQud6WJz694LRzkeN5kMYpCHTpXQr3Rkcjm
		accounts__.Append(solanago.NewAccountMeta(offrampAccount, false, false))
		// Account 5 "allowed_offramp": Read-only, Non-signer, Required
		// CHECK PDA of the router program verifying the signer is an allowed offramp.
		// If PDA does not exist, the router doesn't allow this offramp. This is just used
		// so that token pools and receivers can then check that the caller is an actual offramp that
		// has been registered in the router as such for that source chain.
		accounts__.Append(solanago.NewAccountMeta(allowedOfframpAccount, false, false))
		// Account 6 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 7 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 8 "sysvar_instructions": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(sysvarInstructionsAccount, false, false))
		// Account 9 "rmn_remote": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteAccount, false, false))
		// Account 10 "rmn_remote_curses": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteCursesAccount, false, false))
		// Account 11 "rmn_remote_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteConfigAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize" instruction.
// Initialization Flow // // Initializes the CCIP Offramp, except for the config account (due to stack size limitations). //  // The initialization of the Offramp is responsibility of Admin, nothing more than calling these // initialization methods should be done first. //  // # Arguments //  // * `ctx` - The context containing the accounts required for initialization.
func NewInitializeInstruction(
	referenceAddressesAccount solanago.PublicKey,
	routerAccount solanago.PublicKey,
	feeQuoterAccount solanago.PublicKey,
	rmnRemoteAccount solanago.PublicKey,
	offrampLookupTableAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
	programDataAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "reference_addresses": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(referenceAddressesAccount, true, false))
		// Account 1 "router": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(routerAccount, false, false))
		// Account 2 "fee_quoter": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeQuoterAccount, false, false))
		// Account 3 "rmn_remote": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteAccount, false, false))
		// Account 4 "offramp_lookup_table": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(offrampLookupTableAccount, false, false))
		// Account 5 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 6 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 7 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 8 "program": Read-only, Non-signer, Required, Address: offqSMQWgQud6WJz694LRzkeN5kMYpCHTpXQr3Rkcjm
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
		// Account 9 "program_data": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programDataAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "initialize_config" instruction.
// Initializes the CCIP Offramp Config account. //  // The initialization of the Offramp is responsibility of Admin, nothing more than calling these // initialization methods should be done first. //  // # Arguments //  // * `ctx` - The context containing the accounts required for initialization of the config. // * `svm_chain_selector` - The chain selector for SVM. // * `enable_execution_after` - The minimum amount of time required between a message has been committed and can be manually executed.
func NewInitializeConfigInstruction(
	// Params:
	svmChainSelectorParam uint64,
	enableExecutionAfterParam int64,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
	programDataAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `svmChainSelectorParam`:
		err = enc__.Encode(svmChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("svmChainSelectorParam", err)
		}
		// Serialize `enableExecutionAfterParam`:
		err = enc__.Encode(enableExecutionAfterParam)
		if err != nil {
			return nil, errors.NewField("enableExecutionAfterParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 3 "program": Read-only, Non-signer, Required, Address: offqSMQWgQud6WJz694LRzkeN5kMYpCHTpXQr3Rkcjm
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
		// Account 4 "program_data": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programDataAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "manually_execute" instruction.
// Manually executes a report to the router. //  // When a message is not being executed, then the user can trigger the execution manually. // No verification over the transmitter, but the message needs to be in some commit report. // It validates that the required time has passed since the commit and then executes the report. //  // # Arguments //  // * `ctx` - The context containing the accounts required for the execution. // * `raw_execution_report` - The serialized execution report containing the message and proofs.
func NewManuallyExecuteInstruction(
	// Params:
	rawExecutionReportParam []byte,
	tokenIndexesParam []byte,

	// Accounts:
	configAccount solanago.PublicKey,
	referenceAddressesAccount solanago.PublicKey,
	sourceChainAccount solanago.PublicKey,
	commitReportAccount solanago.PublicKey,
	offrampAccount solanago.PublicKey,
	allowedOfframpAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	sysvarInstructionsAccount solanago.PublicKey,
	rmnRemoteAccount solanago.PublicKey,
	rmnRemoteCursesAccount solanago.PublicKey,
	rmnRemoteConfigAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ManuallyExecute[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `rawExecutionReportParam`:
		err = enc__.Encode(rawExecutionReportParam)
		if err != nil {
			return nil, errors.NewField("rawExecutionReportParam", err)
		}
		// Serialize `tokenIndexesParam`:
		err = enc__.Encode(tokenIndexesParam)
		if err != nil {
			return nil, errors.NewField("tokenIndexesParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "reference_addresses": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(referenceAddressesAccount, false, false))
		// Account 2 "source_chain": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(sourceChainAccount, false, false))
		// Account 3 "commit_report": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(commitReportAccount, true, false))
		// Account 4 "offramp": Read-only, Non-signer, Required, Address: offqSMQWgQud6WJz694LRzkeN5kMYpCHTpXQr3Rkcjm
		accounts__.Append(solanago.NewAccountMeta(offrampAccount, false, false))
		// Account 5 "allowed_offramp": Read-only, Non-signer, Required
		// CHECK PDA of the router program verifying the signer is an allowed offramp.
		// If PDA does not exist, the router doesn't allow this offramp. This is just used
		// so that token pools and receivers can then check that the caller is an actual offramp that
		// has been registered in the router as such for that source chain.
		accounts__.Append(solanago.NewAccountMeta(allowedOfframpAccount, false, false))
		// Account 6 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 7 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 8 "sysvar_instructions": Read-only, Non-signer, Required, Address: Sysvar1nstructions1111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(sysvarInstructionsAccount, false, false))
		// Account 9 "rmn_remote": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteAccount, false, false))
		// Account 10 "rmn_remote_curses": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteCursesAccount, false, false))
		// Account 11 "rmn_remote_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteConfigAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_default_code_version" instruction.
// Sets the default code version to be used. This is then used by the slim routing layer to determine // which version of the versioned business logic module (`instructions`) to use. Only the admin may set this. //  // Shared func signature with other programs //  // # Arguments //  // * `ctx` - The context containing the accounts required for updating the configuration. // * `code_version` - The new code version to be set as default.
func NewSetDefaultCodeVersionInstruction(
	// Params:
	codeVersionParam CodeVersion,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetDefaultCodeVersion[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `codeVersionParam`:
		err = enc__.Encode(codeVersionParam)
		if err != nil {
			return nil, errors.NewField("codeVersionParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_ocr_config" instruction.
// Sets the OCR configuration. // Only CCIP Admin can set the OCR configuration. //  // # Arguments //  // * `ctx` - The context containing the accounts required for setting the OCR configuration. // * `plugin_type` - The type of OCR plugin [0: Commit, 1: Execution]. // * `config_info` - The OCR configuration information. // * `signers` - The list of signers. // * `transmitters` - The list of transmitters.
func NewSetOcrConfigInstruction(
	// Params:
	pluginTypeParam OcrPluginType,
	configInfoParam Ocr3ConfigInfoInput,
	signersParam [][20]uint8,
	transmittersParam []solanago.PublicKey,

	// Accounts:
	configAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetOcrConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `pluginTypeParam`:
		err = enc__.Encode(pluginTypeParam)
		if err != nil {
			return nil, errors.NewField("pluginTypeParam", err)
		}
		// Serialize `configInfoParam`:
		err = enc__.Encode(configInfoParam)
		if err != nil {
			return nil, errors.NewField("configInfoParam", err)
		}
		// Serialize `signersParam`:
		err = enc__.Encode(signersParam)
		if err != nil {
			return nil, errors.NewField("signersParam", err)
		}
		// Serialize `transmittersParam`:
		err = enc__.Encode(transmittersParam)
		if err != nil {
			return nil, errors.NewField("transmittersParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "transfer_ownership" instruction.
// Transfers the ownership of the router to a new proposed owner. //  // Shared func signature with other programs //  // # Arguments //  // * `ctx` - The context containing the accounts required for the transfer. // * `proposed_owner` - The public key of the new proposed owner.
func NewTransferOwnershipInstruction(
	// Params:
	proposedOwnerParam solanago.PublicKey,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_TransferOwnership[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `proposedOwnerParam`:
		err = enc__.Encode(proposedOwnerParam)
		if err != nil {
			return nil, errors.NewField("proposedOwnerParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "type_version" instruction.
// Returns the program type (name) and version. // Used by offchain code to easily determine which program & version is being interacted with. //  // # Arguments // * `ctx` - The context
func NewTypeVersionInstruction(
	clockAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "clock": Read-only, Non-signer, Required, Address: SysvarC1ock11111111111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(clockAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "update_enable_manual_execution_after" instruction.
// Updates the minimum amount of time required between a message being committed and when it can be manually executed. //  // This is part of the OffRamp Configuration for SVM. // The Admin is the only one able to update this config. //  // # Arguments //  // * `ctx` - The context containing the accounts required for updating the configuration. // * `new_enable_manual_execution_after` - The new minimum amount of time required.
func NewUpdateEnableManualExecutionAfterInstruction(
	// Params:
	newEnableManualExecutionAfterParam int64,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateEnableManualExecutionAfter[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newEnableManualExecutionAfterParam`:
		err = enc__.Encode(newEnableManualExecutionAfterParam)
		if err != nil {
			return nil, errors.NewField("newEnableManualExecutionAfterParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_reference_addresses" instruction.
// Updates reference addresses in the offramp contract, such as // the CCIP router, Fee Quoter, and the Offramp Lookup Table. // Only the Admin may update these addresses. //  // # Arguments //  // * `ctx` - The context containing the accounts required for updating the reference addresses. // * `router` - The router address to be set. // * `fee_quoter` - The fee_quoter address to be set. // * `offramp_lookup_table` - The offramp_lookup_table address to be set. // * `rmn_remote` - The rmn_remote address to be set.
func NewUpdateReferenceAddressesInstruction(
	// Params:
	routerParam solanago.PublicKey,
	feeQuoterParam solanago.PublicKey,
	offrampLookupTableParam solanago.PublicKey,
	rmnRemoteParam solanago.PublicKey,

	// Accounts:
	configAccount solanago.PublicKey,
	referenceAddressesAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateReferenceAddresses[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `routerParam`:
		err = enc__.Encode(routerParam)
		if err != nil {
			return nil, errors.NewField("routerParam", err)
		}
		// Serialize `feeQuoterParam`:
		err = enc__.Encode(feeQuoterParam)
		if err != nil {
			return nil, errors.NewField("feeQuoterParam", err)
		}
		// Serialize `offrampLookupTableParam`:
		err = enc__.Encode(offrampLookupTableParam)
		if err != nil {
			return nil, errors.NewField("offrampLookupTableParam", err)
		}
		// Serialize `rmnRemoteParam`:
		err = enc__.Encode(rmnRemoteParam)
		if err != nil {
			return nil, errors.NewField("rmnRemoteParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "reference_addresses": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(referenceAddressesAccount, true, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_source_chain_config" instruction.
// Updates the configuration of the source chain selector. //  // The Admin is the only one able to update the source chain config. //  // # Arguments //  // * `ctx` - The context containing the accounts required for updating the chain selector. // * `source_chain_selector` - The source chain selector to be updated. // * `source_chain_config` - The new configuration for the source chain.
func NewUpdateSourceChainConfigInstruction(
	// Params:
	sourceChainSelectorParam uint64,
	sourceChainConfigParam SourceChainConfig,

	// Accounts:
	sourceChainAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateSourceChainConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `sourceChainSelectorParam`:
		err = enc__.Encode(sourceChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("sourceChainSelectorParam", err)
		}
		// Serialize `sourceChainConfigParam`:
		err = enc__.Encode(sourceChainConfigParam)
		if err != nil {
			return nil, errors.NewField("sourceChainConfigParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "source_chain": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(sourceChainAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_svm_chain_selector" instruction.
// Updates the SVM chain selector in the offramp configuration. //  // This method should only be used if there was an error with the initial configuration or if the solana chain selector changes. //  // # Arguments //  // * `ctx` - The context containing the accounts required for updating the configuration. // * `new_chain_selector` - The new chain selector for SVM.
func NewUpdateSvmChainSelectorInstruction(
	// Params:
	newChainSelectorParam uint64,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateSvmChainSelector[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newChainSelectorParam`:
		err = enc__.Encode(newChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("newChainSelectorParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}
