// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains parsers for the types defined in the IDL.

package ccip_offramp

import (
	"bytes"
	"fmt"
	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

type Any2SvmTokenTransfer struct {
	SourcePoolAddress []byte             `json:"sourcePoolAddress"`
	DestTokenAddress  solanago.PublicKey `json:"destTokenAddress"`
	DestGasAmount     uint32             `json:"destGasAmount"`
	ExtraData         []byte             `json:"extraData"`
	Amount            CrossChainAmount   `json:"amount"`
}

func (obj Any2SvmTokenTransfer) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `SourcePoolAddress`:
	err = encoder.Encode(obj.SourcePoolAddress)
	if err != nil {
		return errors.NewField("SourcePoolAddress", err)
	}
	// Serialize `DestTokenAddress`:
	err = encoder.Encode(obj.DestTokenAddress)
	if err != nil {
		return errors.NewField("DestTokenAddress", err)
	}
	// Serialize `DestGasAmount`:
	err = encoder.Encode(obj.DestGasAmount)
	if err != nil {
		return errors.NewField("DestGasAmount", err)
	}
	// Serialize `ExtraData`:
	err = encoder.Encode(obj.ExtraData)
	if err != nil {
		return errors.NewField("ExtraData", err)
	}
	// Serialize `Amount`:
	err = encoder.Encode(obj.Amount)
	if err != nil {
		return errors.NewField("Amount", err)
	}
	return nil
}

func (obj Any2SvmTokenTransfer) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Any2SvmTokenTransfer: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Any2SvmTokenTransfer) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `SourcePoolAddress`:
	err = decoder.Decode(&obj.SourcePoolAddress)
	if err != nil {
		return errors.NewField("SourcePoolAddress", err)
	}
	// Deserialize `DestTokenAddress`:
	err = decoder.Decode(&obj.DestTokenAddress)
	if err != nil {
		return errors.NewField("DestTokenAddress", err)
	}
	// Deserialize `DestGasAmount`:
	err = decoder.Decode(&obj.DestGasAmount)
	if err != nil {
		return errors.NewField("DestGasAmount", err)
	}
	// Deserialize `ExtraData`:
	err = decoder.Decode(&obj.ExtraData)
	if err != nil {
		return errors.NewField("ExtraData", err)
	}
	// Deserialize `Amount`:
	err = decoder.Decode(&obj.Amount)
	if err != nil {
		return errors.NewField("Amount", err)
	}
	return nil
}

func (obj *Any2SvmTokenTransfer) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Any2SvmTokenTransfer: %w", err)
	}
	return nil
}

func UnmarshalAny2SvmTokenTransfer(buf []byte) (*Any2SvmTokenTransfer, error) {
	obj := new(Any2SvmTokenTransfer)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type CcipAccountMeta struct {
	Pubkey     solanago.PublicKey `json:"pubkey"`
	IsSigner   bool               `json:"isSigner"`
	IsWritable bool               `json:"isWritable"`
}

func (obj CcipAccountMeta) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Pubkey`:
	err = encoder.Encode(obj.Pubkey)
	if err != nil {
		return errors.NewField("Pubkey", err)
	}
	// Serialize `IsSigner`:
	err = encoder.Encode(obj.IsSigner)
	if err != nil {
		return errors.NewField("IsSigner", err)
	}
	// Serialize `IsWritable`:
	err = encoder.Encode(obj.IsWritable)
	if err != nil {
		return errors.NewField("IsWritable", err)
	}
	return nil
}

func (obj CcipAccountMeta) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding CcipAccountMeta: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *CcipAccountMeta) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Pubkey`:
	err = decoder.Decode(&obj.Pubkey)
	if err != nil {
		return errors.NewField("Pubkey", err)
	}
	// Deserialize `IsSigner`:
	err = decoder.Decode(&obj.IsSigner)
	if err != nil {
		return errors.NewField("IsSigner", err)
	}
	// Deserialize `IsWritable`:
	err = decoder.Decode(&obj.IsWritable)
	if err != nil {
		return errors.NewField("IsWritable", err)
	}
	return nil
}

func (obj *CcipAccountMeta) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CcipAccountMeta: %w", err)
	}
	return nil
}

func UnmarshalCcipAccountMeta(buf []byte) (*CcipAccountMeta, error) {
	obj := new(CcipAccountMeta)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type CodeVersion binary.BorshEnum

const (
	CodeVersion_Default CodeVersion = iota
	CodeVersion_V1
)

func (value CodeVersion) String() string {
	switch value {
	case CodeVersion_Default:
		return "Default"
	case CodeVersion_V1:
		return "V1"
	default:
		return ""
	}
}

type CommitReport struct {
	Version         uint8          `json:"version"`
	ChainSelector   uint64         `json:"chainSelector"`
	MerkleRoot      [32]uint8      `json:"merkleRoot"`
	Timestamp       int64          `json:"timestamp"`
	MinMsgNr        uint64         `json:"minMsgNr"`
	MaxMsgNr        uint64         `json:"maxMsgNr"`
	ExecutionStates binary.Uint128 `json:"executionStates"`
}

func (obj CommitReport) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Version`:
	err = encoder.Encode(obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Serialize `ChainSelector`:
	err = encoder.Encode(obj.ChainSelector)
	if err != nil {
		return errors.NewField("ChainSelector", err)
	}
	// Serialize `MerkleRoot`:
	err = encoder.Encode(obj.MerkleRoot)
	if err != nil {
		return errors.NewField("MerkleRoot", err)
	}
	// Serialize `Timestamp`:
	err = encoder.Encode(obj.Timestamp)
	if err != nil {
		return errors.NewField("Timestamp", err)
	}
	// Serialize `MinMsgNr`:
	err = encoder.Encode(obj.MinMsgNr)
	if err != nil {
		return errors.NewField("MinMsgNr", err)
	}
	// Serialize `MaxMsgNr`:
	err = encoder.Encode(obj.MaxMsgNr)
	if err != nil {
		return errors.NewField("MaxMsgNr", err)
	}
	// Serialize `ExecutionStates`:
	err = encoder.Encode(obj.ExecutionStates)
	if err != nil {
		return errors.NewField("ExecutionStates", err)
	}
	return nil
}

func (obj CommitReport) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding CommitReport: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *CommitReport) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Version`:
	err = decoder.Decode(&obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Deserialize `ChainSelector`:
	err = decoder.Decode(&obj.ChainSelector)
	if err != nil {
		return errors.NewField("ChainSelector", err)
	}
	// Deserialize `MerkleRoot`:
	err = decoder.Decode(&obj.MerkleRoot)
	if err != nil {
		return errors.NewField("MerkleRoot", err)
	}
	// Deserialize `Timestamp`:
	err = decoder.Decode(&obj.Timestamp)
	if err != nil {
		return errors.NewField("Timestamp", err)
	}
	// Deserialize `MinMsgNr`:
	err = decoder.Decode(&obj.MinMsgNr)
	if err != nil {
		return errors.NewField("MinMsgNr", err)
	}
	// Deserialize `MaxMsgNr`:
	err = decoder.Decode(&obj.MaxMsgNr)
	if err != nil {
		return errors.NewField("MaxMsgNr", err)
	}
	// Deserialize `ExecutionStates`:
	err = decoder.Decode(&obj.ExecutionStates)
	if err != nil {
		return errors.NewField("ExecutionStates", err)
	}
	return nil
}

func (obj *CommitReport) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CommitReport: %w", err)
	}
	return nil
}

func UnmarshalCommitReport(buf []byte) (*CommitReport, error) {
	obj := new(CommitReport)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type CommitReportAccepted struct {
	MerkleRoot   *MerkleRoot  `bin:"optional" json:"merkleRoot,omitempty"`
	PriceUpdates PriceUpdates `json:"priceUpdates"`
}

func (obj CommitReportAccepted) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `MerkleRoot` (optional):
	{
		if obj.MerkleRoot == nil {
			err = encoder.WriteOption(false)
			if err != nil {
				return errors.NewOption("MerkleRoot", fmt.Errorf("error while encoding optionality: %w", err))
			}
		} else {
			err = encoder.WriteOption(true)
			if err != nil {
				return errors.NewOption("MerkleRoot", fmt.Errorf("error while encoding optionality: %w", err))
			}
			err = encoder.Encode(obj.MerkleRoot)
			if err != nil {
				return errors.NewField("MerkleRoot", err)
			}
		}
	}
	// Serialize `PriceUpdates`:
	err = encoder.Encode(obj.PriceUpdates)
	if err != nil {
		return errors.NewField("PriceUpdates", err)
	}
	return nil
}

func (obj CommitReportAccepted) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding CommitReportAccepted: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *CommitReportAccepted) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `MerkleRoot` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return errors.NewOption("MerkleRoot", fmt.Errorf("error while reading optionality: %w", err))
		}
		if ok {
			err = decoder.Decode(&obj.MerkleRoot)
			if err != nil {
				return errors.NewField("MerkleRoot", err)
			}
		}
	}
	// Deserialize `PriceUpdates`:
	err = decoder.Decode(&obj.PriceUpdates)
	if err != nil {
		return errors.NewField("PriceUpdates", err)
	}
	return nil
}

func (obj *CommitReportAccepted) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CommitReportAccepted: %w", err)
	}
	return nil
}

func UnmarshalCommitReportAccepted(buf []byte) (*CommitReportAccepted, error) {
	obj := new(CommitReportAccepted)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type CommitReportPdaClosed struct {
	SourceChainSelector uint64    `json:"sourceChainSelector"`
	MerkleRoot          [32]uint8 `json:"merkleRoot"`
}

func (obj CommitReportPdaClosed) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `SourceChainSelector`:
	err = encoder.Encode(obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Serialize `MerkleRoot`:
	err = encoder.Encode(obj.MerkleRoot)
	if err != nil {
		return errors.NewField("MerkleRoot", err)
	}
	return nil
}

func (obj CommitReportPdaClosed) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding CommitReportPdaClosed: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *CommitReportPdaClosed) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `SourceChainSelector`:
	err = decoder.Decode(&obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Deserialize `MerkleRoot`:
	err = decoder.Decode(&obj.MerkleRoot)
	if err != nil {
		return errors.NewField("MerkleRoot", err)
	}
	return nil
}

func (obj *CommitReportPdaClosed) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CommitReportPdaClosed: %w", err)
	}
	return nil
}

func UnmarshalCommitReportPdaClosed(buf []byte) (*CommitReportPdaClosed, error) {
	obj := new(CommitReportPdaClosed)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type Config struct {
	Version                    uint8              `json:"version"`
	DefaultCodeVersion         uint8              `json:"defaultCodeVersion"`
	Padding0                   [6]uint8           `json:"padding0"`
	SvmChainSelector           uint64             `json:"svmChainSelector"`
	EnableManualExecutionAfter int64              `json:"enableManualExecutionAfter"`
	Padding1                   [8]uint8           `json:"padding1"`
	Owner                      solanago.PublicKey `json:"owner"`
	ProposedOwner              solanago.PublicKey `json:"proposedOwner"`
	Padding2                   [8]uint8           `json:"padding2"`
	Ocr3                       [2]Ocr3Config      `json:"ocr3"`
}

func (obj Config) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Version`:
	err = encoder.Encode(obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Serialize `DefaultCodeVersion`:
	err = encoder.Encode(obj.DefaultCodeVersion)
	if err != nil {
		return errors.NewField("DefaultCodeVersion", err)
	}
	// Serialize `Padding0`:
	err = encoder.Encode(obj.Padding0)
	if err != nil {
		return errors.NewField("Padding0", err)
	}
	// Serialize `SvmChainSelector`:
	err = encoder.Encode(obj.SvmChainSelector)
	if err != nil {
		return errors.NewField("SvmChainSelector", err)
	}
	// Serialize `EnableManualExecutionAfter`:
	err = encoder.Encode(obj.EnableManualExecutionAfter)
	if err != nil {
		return errors.NewField("EnableManualExecutionAfter", err)
	}
	// Serialize `Padding1`:
	err = encoder.Encode(obj.Padding1)
	if err != nil {
		return errors.NewField("Padding1", err)
	}
	// Serialize `Owner`:
	err = encoder.Encode(obj.Owner)
	if err != nil {
		return errors.NewField("Owner", err)
	}
	// Serialize `ProposedOwner`:
	err = encoder.Encode(obj.ProposedOwner)
	if err != nil {
		return errors.NewField("ProposedOwner", err)
	}
	// Serialize `Padding2`:
	err = encoder.Encode(obj.Padding2)
	if err != nil {
		return errors.NewField("Padding2", err)
	}
	// Serialize `Ocr3`:
	err = encoder.Encode(obj.Ocr3)
	if err != nil {
		return errors.NewField("Ocr3", err)
	}
	return nil
}

func (obj Config) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Config: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Config) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Version`:
	err = decoder.Decode(&obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Deserialize `DefaultCodeVersion`:
	err = decoder.Decode(&obj.DefaultCodeVersion)
	if err != nil {
		return errors.NewField("DefaultCodeVersion", err)
	}
	// Deserialize `Padding0`:
	err = decoder.Decode(&obj.Padding0)
	if err != nil {
		return errors.NewField("Padding0", err)
	}
	// Deserialize `SvmChainSelector`:
	err = decoder.Decode(&obj.SvmChainSelector)
	if err != nil {
		return errors.NewField("SvmChainSelector", err)
	}
	// Deserialize `EnableManualExecutionAfter`:
	err = decoder.Decode(&obj.EnableManualExecutionAfter)
	if err != nil {
		return errors.NewField("EnableManualExecutionAfter", err)
	}
	// Deserialize `Padding1`:
	err = decoder.Decode(&obj.Padding1)
	if err != nil {
		return errors.NewField("Padding1", err)
	}
	// Deserialize `Owner`:
	err = decoder.Decode(&obj.Owner)
	if err != nil {
		return errors.NewField("Owner", err)
	}
	// Deserialize `ProposedOwner`:
	err = decoder.Decode(&obj.ProposedOwner)
	if err != nil {
		return errors.NewField("ProposedOwner", err)
	}
	// Deserialize `Padding2`:
	err = decoder.Decode(&obj.Padding2)
	if err != nil {
		return errors.NewField("Padding2", err)
	}
	// Deserialize `Ocr3`:
	err = decoder.Decode(&obj.Ocr3)
	if err != nil {
		return errors.NewField("Ocr3", err)
	}
	return nil
}

func (obj *Config) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Config: %w", err)
	}
	return nil
}

func UnmarshalConfig(buf []byte) (*Config, error) {
	obj := new(Config)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// It's not possible to store enums in zero_copy accounts, so we wrap the discriminant
// in a struct to store in config.
type ConfigOcrPluginType struct {
	Discriminant uint8 `json:"discriminant"`
}

func (obj ConfigOcrPluginType) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Discriminant`:
	err = encoder.Encode(obj.Discriminant)
	if err != nil {
		return errors.NewField("Discriminant", err)
	}
	return nil
}

func (obj ConfigOcrPluginType) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding ConfigOcrPluginType: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *ConfigOcrPluginType) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Discriminant`:
	err = decoder.Decode(&obj.Discriminant)
	if err != nil {
		return errors.NewField("Discriminant", err)
	}
	return nil
}

func (obj *ConfigOcrPluginType) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ConfigOcrPluginType: %w", err)
	}
	return nil
}

func UnmarshalConfigOcrPluginType(buf []byte) (*ConfigOcrPluginType, error) {
	obj := new(ConfigOcrPluginType)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ConfigSet struct {
	SvmChainSelector           uint64 `json:"svmChainSelector"`
	EnableManualExecutionAfter int64  `json:"enableManualExecutionAfter"`
}

func (obj ConfigSet) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `SvmChainSelector`:
	err = encoder.Encode(obj.SvmChainSelector)
	if err != nil {
		return errors.NewField("SvmChainSelector", err)
	}
	// Serialize `EnableManualExecutionAfter`:
	err = encoder.Encode(obj.EnableManualExecutionAfter)
	if err != nil {
		return errors.NewField("EnableManualExecutionAfter", err)
	}
	return nil
}

func (obj ConfigSet) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding ConfigSet: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *ConfigSet) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `SvmChainSelector`:
	err = decoder.Decode(&obj.SvmChainSelector)
	if err != nil {
		return errors.NewField("SvmChainSelector", err)
	}
	// Deserialize `EnableManualExecutionAfter`:
	err = decoder.Decode(&obj.EnableManualExecutionAfter)
	if err != nil {
		return errors.NewField("EnableManualExecutionAfter", err)
	}
	return nil
}

func (obj *ConfigSet) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ConfigSet: %w", err)
	}
	return nil
}

func UnmarshalConfigSet(buf []byte) (*ConfigSet, error) {
	obj := new(ConfigSet)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type CrossChainAmount struct {
	LeBytes [32]uint8 `json:"leBytes"`
}

func (obj CrossChainAmount) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `LeBytes`:
	err = encoder.Encode(obj.LeBytes)
	if err != nil {
		return errors.NewField("LeBytes", err)
	}
	return nil
}

func (obj CrossChainAmount) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding CrossChainAmount: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *CrossChainAmount) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `LeBytes`:
	err = decoder.Decode(&obj.LeBytes)
	if err != nil {
		return errors.NewField("LeBytes", err)
	}
	return nil
}

func (obj *CrossChainAmount) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CrossChainAmount: %w", err)
	}
	return nil
}

func UnmarshalCrossChainAmount(buf []byte) (*CrossChainAmount, error) {
	obj := new(CrossChainAmount)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type DeriveAccountsExecuteParams struct {
	ExecuteCaller       solanago.PublicKey             `json:"executeCaller"`
	TokenReceiver       solanago.PublicKey             `json:"tokenReceiver"`
	TokenTransfers      []TokenTransferAndOffchainData `json:"tokenTransfers"`
	MessageAccounts     []CcipAccountMeta              `json:"messageAccounts"`
	SourceChainSelector uint64                         `json:"sourceChainSelector"`
	OriginalSender      []byte                         `json:"originalSender"`
	MerkleRoot          [32]uint8                      `json:"merkleRoot"`
	BufferId            []byte                         `json:"bufferId"`
}

func (obj DeriveAccountsExecuteParams) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `ExecuteCaller`:
	err = encoder.Encode(obj.ExecuteCaller)
	if err != nil {
		return errors.NewField("ExecuteCaller", err)
	}
	// Serialize `TokenReceiver`:
	err = encoder.Encode(obj.TokenReceiver)
	if err != nil {
		return errors.NewField("TokenReceiver", err)
	}
	// Serialize `TokenTransfers`:
	err = encoder.Encode(obj.TokenTransfers)
	if err != nil {
		return errors.NewField("TokenTransfers", err)
	}
	// Serialize `MessageAccounts`:
	err = encoder.Encode(obj.MessageAccounts)
	if err != nil {
		return errors.NewField("MessageAccounts", err)
	}
	// Serialize `SourceChainSelector`:
	err = encoder.Encode(obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Serialize `OriginalSender`:
	err = encoder.Encode(obj.OriginalSender)
	if err != nil {
		return errors.NewField("OriginalSender", err)
	}
	// Serialize `MerkleRoot`:
	err = encoder.Encode(obj.MerkleRoot)
	if err != nil {
		return errors.NewField("MerkleRoot", err)
	}
	// Serialize `BufferId`:
	err = encoder.Encode(obj.BufferId)
	if err != nil {
		return errors.NewField("BufferId", err)
	}
	return nil
}

func (obj DeriveAccountsExecuteParams) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding DeriveAccountsExecuteParams: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *DeriveAccountsExecuteParams) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `ExecuteCaller`:
	err = decoder.Decode(&obj.ExecuteCaller)
	if err != nil {
		return errors.NewField("ExecuteCaller", err)
	}
	// Deserialize `TokenReceiver`:
	err = decoder.Decode(&obj.TokenReceiver)
	if err != nil {
		return errors.NewField("TokenReceiver", err)
	}
	// Deserialize `TokenTransfers`:
	err = decoder.Decode(&obj.TokenTransfers)
	if err != nil {
		return errors.NewField("TokenTransfers", err)
	}
	// Deserialize `MessageAccounts`:
	err = decoder.Decode(&obj.MessageAccounts)
	if err != nil {
		return errors.NewField("MessageAccounts", err)
	}
	// Deserialize `SourceChainSelector`:
	err = decoder.Decode(&obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Deserialize `OriginalSender`:
	err = decoder.Decode(&obj.OriginalSender)
	if err != nil {
		return errors.NewField("OriginalSender", err)
	}
	// Deserialize `MerkleRoot`:
	err = decoder.Decode(&obj.MerkleRoot)
	if err != nil {
		return errors.NewField("MerkleRoot", err)
	}
	// Deserialize `BufferId`:
	err = decoder.Decode(&obj.BufferId)
	if err != nil {
		return errors.NewField("BufferId", err)
	}
	return nil
}

func (obj *DeriveAccountsExecuteParams) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling DeriveAccountsExecuteParams: %w", err)
	}
	return nil
}

func UnmarshalDeriveAccountsExecuteParams(buf []byte) (*DeriveAccountsExecuteParams, error) {
	obj := new(DeriveAccountsExecuteParams)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type DeriveAccountsResponse struct {
	// If this vector is not empty, you must call the `derive_` method again including
	// exactly these accounts as the `remaining_accounts` field.
	AskAgainWith []CcipAccountMeta `json:"askAgainWith"`

	// You must append these accounts at the end of a separate list. When `next_stage`
	// is finally empty, this separate list will contain all the accounts to use for the
	// instruction of interest.
	AccountsToSave []CcipAccountMeta `json:"accountsToSave"`

	// Append these look up tables at the end of a list. It will contain all LUTs
	// that the instruction of interest can use.
	LookUpTablesToSave []solanago.PublicKey `json:"lookUpTablesToSave"`

	// Identifies the derivation stage.
	CurrentStage string `json:"currentStage"`

	// Identifies the next derivation stage. If empty, the derivation is complete.
	NextStage string `json:"nextStage"`
}

func (obj DeriveAccountsResponse) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `AskAgainWith`:
	err = encoder.Encode(obj.AskAgainWith)
	if err != nil {
		return errors.NewField("AskAgainWith", err)
	}
	// Serialize `AccountsToSave`:
	err = encoder.Encode(obj.AccountsToSave)
	if err != nil {
		return errors.NewField("AccountsToSave", err)
	}
	// Serialize `LookUpTablesToSave`:
	err = encoder.Encode(obj.LookUpTablesToSave)
	if err != nil {
		return errors.NewField("LookUpTablesToSave", err)
	}
	// Serialize `CurrentStage`:
	err = encoder.Encode(obj.CurrentStage)
	if err != nil {
		return errors.NewField("CurrentStage", err)
	}
	// Serialize `NextStage`:
	err = encoder.Encode(obj.NextStage)
	if err != nil {
		return errors.NewField("NextStage", err)
	}
	return nil
}

func (obj DeriveAccountsResponse) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding DeriveAccountsResponse: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *DeriveAccountsResponse) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `AskAgainWith`:
	err = decoder.Decode(&obj.AskAgainWith)
	if err != nil {
		return errors.NewField("AskAgainWith", err)
	}
	// Deserialize `AccountsToSave`:
	err = decoder.Decode(&obj.AccountsToSave)
	if err != nil {
		return errors.NewField("AccountsToSave", err)
	}
	// Deserialize `LookUpTablesToSave`:
	err = decoder.Decode(&obj.LookUpTablesToSave)
	if err != nil {
		return errors.NewField("LookUpTablesToSave", err)
	}
	// Deserialize `CurrentStage`:
	err = decoder.Decode(&obj.CurrentStage)
	if err != nil {
		return errors.NewField("CurrentStage", err)
	}
	// Deserialize `NextStage`:
	err = decoder.Decode(&obj.NextStage)
	if err != nil {
		return errors.NewField("NextStage", err)
	}
	return nil
}

func (obj *DeriveAccountsResponse) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling DeriveAccountsResponse: %w", err)
	}
	return nil
}

func UnmarshalDeriveAccountsResponse(buf []byte) (*DeriveAccountsResponse, error) {
	obj := new(DeriveAccountsResponse)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ExecutionReportBuffer struct {
	Version     uint8  `json:"version"`
	ChunkBitmap uint64 `json:"chunkBitmap"`
	NumChunks   uint8  `json:"numChunks"`
	ChunkLength uint32 `json:"chunkLength"`
	Data        []byte `json:"data"`
}

func (obj ExecutionReportBuffer) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Version`:
	err = encoder.Encode(obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Serialize `ChunkBitmap`:
	err = encoder.Encode(obj.ChunkBitmap)
	if err != nil {
		return errors.NewField("ChunkBitmap", err)
	}
	// Serialize `NumChunks`:
	err = encoder.Encode(obj.NumChunks)
	if err != nil {
		return errors.NewField("NumChunks", err)
	}
	// Serialize `ChunkLength`:
	err = encoder.Encode(obj.ChunkLength)
	if err != nil {
		return errors.NewField("ChunkLength", err)
	}
	// Serialize `Data`:
	err = encoder.Encode(obj.Data)
	if err != nil {
		return errors.NewField("Data", err)
	}
	return nil
}

func (obj ExecutionReportBuffer) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding ExecutionReportBuffer: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *ExecutionReportBuffer) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Version`:
	err = decoder.Decode(&obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Deserialize `ChunkBitmap`:
	err = decoder.Decode(&obj.ChunkBitmap)
	if err != nil {
		return errors.NewField("ChunkBitmap", err)
	}
	// Deserialize `NumChunks`:
	err = decoder.Decode(&obj.NumChunks)
	if err != nil {
		return errors.NewField("NumChunks", err)
	}
	// Deserialize `ChunkLength`:
	err = decoder.Decode(&obj.ChunkLength)
	if err != nil {
		return errors.NewField("ChunkLength", err)
	}
	// Deserialize `Data`:
	err = decoder.Decode(&obj.Data)
	if err != nil {
		return errors.NewField("Data", err)
	}
	return nil
}

func (obj *ExecutionReportBuffer) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ExecutionReportBuffer: %w", err)
	}
	return nil
}

func UnmarshalExecutionReportBuffer(buf []byte) (*ExecutionReportBuffer, error) {
	obj := new(ExecutionReportBuffer)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ExecutionStateChanged struct {
	SourceChainSelector uint64                `json:"sourceChainSelector"`
	SequenceNumber      uint64                `json:"sequenceNumber"`
	MessageId           [32]uint8             `json:"messageId"`
	MessageHash         [32]uint8             `json:"messageHash"`
	State               MessageExecutionState `json:"state"`
}

func (obj ExecutionStateChanged) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `SourceChainSelector`:
	err = encoder.Encode(obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Serialize `SequenceNumber`:
	err = encoder.Encode(obj.SequenceNumber)
	if err != nil {
		return errors.NewField("SequenceNumber", err)
	}
	// Serialize `MessageId`:
	err = encoder.Encode(obj.MessageId)
	if err != nil {
		return errors.NewField("MessageId", err)
	}
	// Serialize `MessageHash`:
	err = encoder.Encode(obj.MessageHash)
	if err != nil {
		return errors.NewField("MessageHash", err)
	}
	// Serialize `State`:
	err = encoder.Encode(obj.State)
	if err != nil {
		return errors.NewField("State", err)
	}
	return nil
}

func (obj ExecutionStateChanged) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding ExecutionStateChanged: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *ExecutionStateChanged) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `SourceChainSelector`:
	err = decoder.Decode(&obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Deserialize `SequenceNumber`:
	err = decoder.Decode(&obj.SequenceNumber)
	if err != nil {
		return errors.NewField("SequenceNumber", err)
	}
	// Deserialize `MessageId`:
	err = decoder.Decode(&obj.MessageId)
	if err != nil {
		return errors.NewField("MessageId", err)
	}
	// Deserialize `MessageHash`:
	err = decoder.Decode(&obj.MessageHash)
	if err != nil {
		return errors.NewField("MessageHash", err)
	}
	// Deserialize `State`:
	err = decoder.Decode(&obj.State)
	if err != nil {
		return errors.NewField("State", err)
	}
	return nil
}

func (obj *ExecutionStateChanged) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ExecutionStateChanged: %w", err)
	}
	return nil
}

func UnmarshalExecutionStateChanged(buf []byte) (*ExecutionStateChanged, error) {
	obj := new(ExecutionStateChanged)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Gas price for a given chain in USD; its value may contain tightly packed fields.
type GasPriceUpdate struct {
	DestChainSelector uint64    `json:"destChainSelector"`
	UsdPerUnitGas     [28]uint8 `json:"usdPerUnitGas"`
}

func (obj GasPriceUpdate) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `DestChainSelector`:
	err = encoder.Encode(obj.DestChainSelector)
	if err != nil {
		return errors.NewField("DestChainSelector", err)
	}
	// Serialize `UsdPerUnitGas`:
	err = encoder.Encode(obj.UsdPerUnitGas)
	if err != nil {
		return errors.NewField("UsdPerUnitGas", err)
	}
	return nil
}

func (obj GasPriceUpdate) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding GasPriceUpdate: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *GasPriceUpdate) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `DestChainSelector`:
	err = decoder.Decode(&obj.DestChainSelector)
	if err != nil {
		return errors.NewField("DestChainSelector", err)
	}
	// Deserialize `UsdPerUnitGas`:
	err = decoder.Decode(&obj.UsdPerUnitGas)
	if err != nil {
		return errors.NewField("UsdPerUnitGas", err)
	}
	return nil
}

func (obj *GasPriceUpdate) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling GasPriceUpdate: %w", err)
	}
	return nil
}

func UnmarshalGasPriceUpdate(buf []byte) (*GasPriceUpdate, error) {
	obj := new(GasPriceUpdate)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type GlobalState struct {
	LatestPriceSequenceNumber uint64 `json:"latestPriceSequenceNumber"`
}

func (obj GlobalState) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `LatestPriceSequenceNumber`:
	err = encoder.Encode(obj.LatestPriceSequenceNumber)
	if err != nil {
		return errors.NewField("LatestPriceSequenceNumber", err)
	}
	return nil
}

func (obj GlobalState) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding GlobalState: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *GlobalState) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `LatestPriceSequenceNumber`:
	err = decoder.Decode(&obj.LatestPriceSequenceNumber)
	if err != nil {
		return errors.NewField("LatestPriceSequenceNumber", err)
	}
	return nil
}

func (obj *GlobalState) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling GlobalState: %w", err)
	}
	return nil
}

func UnmarshalGlobalState(buf []byte) (*GlobalState, error) {
	obj := new(GlobalState)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Struct to hold a merkle root and an interval for a source chain
type MerkleRoot struct {
	SourceChainSelector uint64    `json:"sourceChainSelector"`
	OnRampAddress       []byte    `json:"onRampAddress"`
	MinSeqNr            uint64    `json:"minSeqNr"`
	MaxSeqNr            uint64    `json:"maxSeqNr"`
	MerkleRoot          [32]uint8 `json:"merkleRoot"`
}

func (obj MerkleRoot) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `SourceChainSelector`:
	err = encoder.Encode(obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Serialize `OnRampAddress`:
	err = encoder.Encode(obj.OnRampAddress)
	if err != nil {
		return errors.NewField("OnRampAddress", err)
	}
	// Serialize `MinSeqNr`:
	err = encoder.Encode(obj.MinSeqNr)
	if err != nil {
		return errors.NewField("MinSeqNr", err)
	}
	// Serialize `MaxSeqNr`:
	err = encoder.Encode(obj.MaxSeqNr)
	if err != nil {
		return errors.NewField("MaxSeqNr", err)
	}
	// Serialize `MerkleRoot`:
	err = encoder.Encode(obj.MerkleRoot)
	if err != nil {
		return errors.NewField("MerkleRoot", err)
	}
	return nil
}

func (obj MerkleRoot) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding MerkleRoot: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *MerkleRoot) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `SourceChainSelector`:
	err = decoder.Decode(&obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Deserialize `OnRampAddress`:
	err = decoder.Decode(&obj.OnRampAddress)
	if err != nil {
		return errors.NewField("OnRampAddress", err)
	}
	// Deserialize `MinSeqNr`:
	err = decoder.Decode(&obj.MinSeqNr)
	if err != nil {
		return errors.NewField("MinSeqNr", err)
	}
	// Deserialize `MaxSeqNr`:
	err = decoder.Decode(&obj.MaxSeqNr)
	if err != nil {
		return errors.NewField("MaxSeqNr", err)
	}
	// Deserialize `MerkleRoot`:
	err = decoder.Decode(&obj.MerkleRoot)
	if err != nil {
		return errors.NewField("MerkleRoot", err)
	}
	return nil
}

func (obj *MerkleRoot) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling MerkleRoot: %w", err)
	}
	return nil
}

func UnmarshalMerkleRoot(buf []byte) (*MerkleRoot, error) {
	obj := new(MerkleRoot)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type MessageExecutionState binary.BorshEnum

const (
	MessageExecutionState_Untouched MessageExecutionState = iota
	MessageExecutionState_InProgress
	MessageExecutionState_Success
	MessageExecutionState_Failure
)

func (value MessageExecutionState) String() string {
	switch value {
	case MessageExecutionState_Untouched:
		return "Untouched"
	case MessageExecutionState_InProgress:
		return "InProgress"
	case MessageExecutionState_Success:
		return "Success"
	case MessageExecutionState_Failure:
		return "Failure"
	default:
		return ""
	}
}

type Ocr3Config struct {
	PluginType   ConfigOcrPluginType `json:"pluginType"`
	ConfigInfo   Ocr3ConfigInfo      `json:"configInfo"`
	Signers      [16][20]uint8       `json:"signers"`
	Transmitters [16][32]uint8       `json:"transmitters"`
}

func (obj Ocr3Config) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `PluginType`:
	err = encoder.Encode(obj.PluginType)
	if err != nil {
		return errors.NewField("PluginType", err)
	}
	// Serialize `ConfigInfo`:
	err = encoder.Encode(obj.ConfigInfo)
	if err != nil {
		return errors.NewField("ConfigInfo", err)
	}
	// Serialize `Signers`:
	err = encoder.Encode(obj.Signers)
	if err != nil {
		return errors.NewField("Signers", err)
	}
	// Serialize `Transmitters`:
	err = encoder.Encode(obj.Transmitters)
	if err != nil {
		return errors.NewField("Transmitters", err)
	}
	return nil
}

func (obj Ocr3Config) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Ocr3Config: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Ocr3Config) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `PluginType`:
	err = decoder.Decode(&obj.PluginType)
	if err != nil {
		return errors.NewField("PluginType", err)
	}
	// Deserialize `ConfigInfo`:
	err = decoder.Decode(&obj.ConfigInfo)
	if err != nil {
		return errors.NewField("ConfigInfo", err)
	}
	// Deserialize `Signers`:
	err = decoder.Decode(&obj.Signers)
	if err != nil {
		return errors.NewField("Signers", err)
	}
	// Deserialize `Transmitters`:
	err = decoder.Decode(&obj.Transmitters)
	if err != nil {
		return errors.NewField("Transmitters", err)
	}
	return nil
}

func (obj *Ocr3Config) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Ocr3Config: %w", err)
	}
	return nil
}

func UnmarshalOcr3Config(buf []byte) (*Ocr3Config, error) {
	obj := new(Ocr3Config)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type Ocr3ConfigInfo struct {
	ConfigDigest                   [32]uint8 `json:"configDigest"`
	F                              uint8     `json:"f"`
	N                              uint8     `json:"n"`
	IsSignatureVerificationEnabled uint8     `json:"isSignatureVerificationEnabled"`
}

func (obj Ocr3ConfigInfo) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `ConfigDigest`:
	err = encoder.Encode(obj.ConfigDigest)
	if err != nil {
		return errors.NewField("ConfigDigest", err)
	}
	// Serialize `F`:
	err = encoder.Encode(obj.F)
	if err != nil {
		return errors.NewField("F", err)
	}
	// Serialize `N`:
	err = encoder.Encode(obj.N)
	if err != nil {
		return errors.NewField("N", err)
	}
	// Serialize `IsSignatureVerificationEnabled`:
	err = encoder.Encode(obj.IsSignatureVerificationEnabled)
	if err != nil {
		return errors.NewField("IsSignatureVerificationEnabled", err)
	}
	return nil
}

func (obj Ocr3ConfigInfo) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Ocr3ConfigInfo: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Ocr3ConfigInfo) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `ConfigDigest`:
	err = decoder.Decode(&obj.ConfigDigest)
	if err != nil {
		return errors.NewField("ConfigDigest", err)
	}
	// Deserialize `F`:
	err = decoder.Decode(&obj.F)
	if err != nil {
		return errors.NewField("F", err)
	}
	// Deserialize `N`:
	err = decoder.Decode(&obj.N)
	if err != nil {
		return errors.NewField("N", err)
	}
	// Deserialize `IsSignatureVerificationEnabled`:
	err = decoder.Decode(&obj.IsSignatureVerificationEnabled)
	if err != nil {
		return errors.NewField("IsSignatureVerificationEnabled", err)
	}
	return nil
}

func (obj *Ocr3ConfigInfo) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Ocr3ConfigInfo: %w", err)
	}
	return nil
}

func UnmarshalOcr3ConfigInfo(buf []byte) (*Ocr3ConfigInfo, error) {
	obj := new(Ocr3ConfigInfo)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Input struct for instruction parameters (non-zero_copy, uses Borsh serialization)
type Ocr3ConfigInfoInput struct {
	ConfigDigest [32]uint8 `json:"configDigest"`
	F            uint8     `json:"f"`
}

func (obj Ocr3ConfigInfoInput) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `ConfigDigest`:
	err = encoder.Encode(obj.ConfigDigest)
	if err != nil {
		return errors.NewField("ConfigDigest", err)
	}
	// Serialize `F`:
	err = encoder.Encode(obj.F)
	if err != nil {
		return errors.NewField("F", err)
	}
	return nil
}

func (obj Ocr3ConfigInfoInput) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Ocr3ConfigInfoInput: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Ocr3ConfigInfoInput) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `ConfigDigest`:
	err = decoder.Decode(&obj.ConfigDigest)
	if err != nil {
		return errors.NewField("ConfigDigest", err)
	}
	// Deserialize `F`:
	err = decoder.Decode(&obj.F)
	if err != nil {
		return errors.NewField("F", err)
	}
	return nil
}

func (obj *Ocr3ConfigInfoInput) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Ocr3ConfigInfoInput: %w", err)
	}
	return nil
}

func UnmarshalOcr3ConfigInfoInput(buf []byte) (*Ocr3ConfigInfoInput, error) {
	obj := new(Ocr3ConfigInfoInput)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type Ocr3ConfigSet struct {
	OcrPluginType OcrPluginType        `json:"ocrPluginType"`
	ConfigDigest  [32]uint8            `json:"configDigest"`
	Signers       [][20]uint8          `json:"signers"`
	Transmitters  []solanago.PublicKey `json:"transmitters"`
	F             uint8                `json:"f"`
}

func (obj Ocr3ConfigSet) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `OcrPluginType`:
	err = encoder.Encode(obj.OcrPluginType)
	if err != nil {
		return errors.NewField("OcrPluginType", err)
	}
	// Serialize `ConfigDigest`:
	err = encoder.Encode(obj.ConfigDigest)
	if err != nil {
		return errors.NewField("ConfigDigest", err)
	}
	// Serialize `Signers`:
	err = encoder.Encode(obj.Signers)
	if err != nil {
		return errors.NewField("Signers", err)
	}
	// Serialize `Transmitters`:
	err = encoder.Encode(obj.Transmitters)
	if err != nil {
		return errors.NewField("Transmitters", err)
	}
	// Serialize `F`:
	err = encoder.Encode(obj.F)
	if err != nil {
		return errors.NewField("F", err)
	}
	return nil
}

func (obj Ocr3ConfigSet) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Ocr3ConfigSet: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Ocr3ConfigSet) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `OcrPluginType`:
	err = decoder.Decode(&obj.OcrPluginType)
	if err != nil {
		return errors.NewField("OcrPluginType", err)
	}
	// Deserialize `ConfigDigest`:
	err = decoder.Decode(&obj.ConfigDigest)
	if err != nil {
		return errors.NewField("ConfigDigest", err)
	}
	// Deserialize `Signers`:
	err = decoder.Decode(&obj.Signers)
	if err != nil {
		return errors.NewField("Signers", err)
	}
	// Deserialize `Transmitters`:
	err = decoder.Decode(&obj.Transmitters)
	if err != nil {
		return errors.NewField("Transmitters", err)
	}
	// Deserialize `F`:
	err = decoder.Decode(&obj.F)
	if err != nil {
		return errors.NewField("F", err)
	}
	return nil
}

func (obj *Ocr3ConfigSet) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Ocr3ConfigSet: %w", err)
	}
	return nil
}

func UnmarshalOcr3ConfigSet(buf []byte) (*Ocr3ConfigSet, error) {
	obj := new(Ocr3ConfigSet)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type OcrPluginType binary.BorshEnum

const (
	OcrPluginType_Commit OcrPluginType = iota
	OcrPluginType_Execution
)

func (value OcrPluginType) String() string {
	switch value {
	case OcrPluginType_Commit:
		return "Commit"
	case OcrPluginType_Execution:
		return "Execution"
	default:
		return ""
	}
}

type OnRampAddress struct {
	Bytes [64]uint8 `json:"bytes"`
	Len   uint32    `json:"len"`
}

func (obj OnRampAddress) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Bytes`:
	err = encoder.Encode(obj.Bytes)
	if err != nil {
		return errors.NewField("Bytes", err)
	}
	// Serialize `Len`:
	err = encoder.Encode(obj.Len)
	if err != nil {
		return errors.NewField("Len", err)
	}
	return nil
}

func (obj OnRampAddress) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding OnRampAddress: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *OnRampAddress) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Bytes`:
	err = decoder.Decode(&obj.Bytes)
	if err != nil {
		return errors.NewField("Bytes", err)
	}
	// Deserialize `Len`:
	err = decoder.Decode(&obj.Len)
	if err != nil {
		return errors.NewField("Len", err)
	}
	return nil
}

func (obj *OnRampAddress) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling OnRampAddress: %w", err)
	}
	return nil
}

func UnmarshalOnRampAddress(buf []byte) (*OnRampAddress, error) {
	obj := new(OnRampAddress)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type OwnershipTransferRequested struct {
	From solanago.PublicKey `json:"from"`
	To   solanago.PublicKey `json:"to"`
}

func (obj OwnershipTransferRequested) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `From`:
	err = encoder.Encode(obj.From)
	if err != nil {
		return errors.NewField("From", err)
	}
	// Serialize `To`:
	err = encoder.Encode(obj.To)
	if err != nil {
		return errors.NewField("To", err)
	}
	return nil
}

func (obj OwnershipTransferRequested) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding OwnershipTransferRequested: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *OwnershipTransferRequested) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `From`:
	err = decoder.Decode(&obj.From)
	if err != nil {
		return errors.NewField("From", err)
	}
	// Deserialize `To`:
	err = decoder.Decode(&obj.To)
	if err != nil {
		return errors.NewField("To", err)
	}
	return nil
}

func (obj *OwnershipTransferRequested) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling OwnershipTransferRequested: %w", err)
	}
	return nil
}

func UnmarshalOwnershipTransferRequested(buf []byte) (*OwnershipTransferRequested, error) {
	obj := new(OwnershipTransferRequested)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type OwnershipTransferred struct {
	From solanago.PublicKey `json:"from"`
	To   solanago.PublicKey `json:"to"`
}

func (obj OwnershipTransferred) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `From`:
	err = encoder.Encode(obj.From)
	if err != nil {
		return errors.NewField("From", err)
	}
	// Serialize `To`:
	err = encoder.Encode(obj.To)
	if err != nil {
		return errors.NewField("To", err)
	}
	return nil
}

func (obj OwnershipTransferred) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding OwnershipTransferred: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *OwnershipTransferred) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `From`:
	err = decoder.Decode(&obj.From)
	if err != nil {
		return errors.NewField("From", err)
	}
	// Deserialize `To`:
	err = decoder.Decode(&obj.To)
	if err != nil {
		return errors.NewField("To", err)
	}
	return nil
}

func (obj *OwnershipTransferred) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling OwnershipTransferred: %w", err)
	}
	return nil
}

func UnmarshalOwnershipTransferred(buf []byte) (*OwnershipTransferred, error) {
	obj := new(OwnershipTransferred)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type PriceUpdates struct {
	TokenPriceUpdates []TokenPriceUpdate `json:"tokenPriceUpdates"`
	GasPriceUpdates   []GasPriceUpdate   `json:"gasPriceUpdates"`
}

func (obj PriceUpdates) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `TokenPriceUpdates`:
	err = encoder.Encode(obj.TokenPriceUpdates)
	if err != nil {
		return errors.NewField("TokenPriceUpdates", err)
	}
	// Serialize `GasPriceUpdates`:
	err = encoder.Encode(obj.GasPriceUpdates)
	if err != nil {
		return errors.NewField("GasPriceUpdates", err)
	}
	return nil
}

func (obj PriceUpdates) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding PriceUpdates: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *PriceUpdates) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `TokenPriceUpdates`:
	err = decoder.Decode(&obj.TokenPriceUpdates)
	if err != nil {
		return errors.NewField("TokenPriceUpdates", err)
	}
	// Deserialize `GasPriceUpdates`:
	err = decoder.Decode(&obj.GasPriceUpdates)
	if err != nil {
		return errors.NewField("GasPriceUpdates", err)
	}
	return nil
}

func (obj *PriceUpdates) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling PriceUpdates: %w", err)
	}
	return nil
}

func UnmarshalPriceUpdates(buf []byte) (*PriceUpdates, error) {
	obj := new(PriceUpdates)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ReferenceAddresses struct {
	Version            uint8              `json:"version"`
	Router             solanago.PublicKey `json:"router"`
	FeeQuoter          solanago.PublicKey `json:"feeQuoter"`
	OfframpLookupTable solanago.PublicKey `json:"offrampLookupTable"`
	RmnRemote          solanago.PublicKey `json:"rmnRemote"`
}

func (obj ReferenceAddresses) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Version`:
	err = encoder.Encode(obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Serialize `Router`:
	err = encoder.Encode(obj.Router)
	if err != nil {
		return errors.NewField("Router", err)
	}
	// Serialize `FeeQuoter`:
	err = encoder.Encode(obj.FeeQuoter)
	if err != nil {
		return errors.NewField("FeeQuoter", err)
	}
	// Serialize `OfframpLookupTable`:
	err = encoder.Encode(obj.OfframpLookupTable)
	if err != nil {
		return errors.NewField("OfframpLookupTable", err)
	}
	// Serialize `RmnRemote`:
	err = encoder.Encode(obj.RmnRemote)
	if err != nil {
		return errors.NewField("RmnRemote", err)
	}
	return nil
}

func (obj ReferenceAddresses) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding ReferenceAddresses: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *ReferenceAddresses) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Version`:
	err = decoder.Decode(&obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Deserialize `Router`:
	err = decoder.Decode(&obj.Router)
	if err != nil {
		return errors.NewField("Router", err)
	}
	// Deserialize `FeeQuoter`:
	err = decoder.Decode(&obj.FeeQuoter)
	if err != nil {
		return errors.NewField("FeeQuoter", err)
	}
	// Deserialize `OfframpLookupTable`:
	err = decoder.Decode(&obj.OfframpLookupTable)
	if err != nil {
		return errors.NewField("OfframpLookupTable", err)
	}
	// Deserialize `RmnRemote`:
	err = decoder.Decode(&obj.RmnRemote)
	if err != nil {
		return errors.NewField("RmnRemote", err)
	}
	return nil
}

func (obj *ReferenceAddresses) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ReferenceAddresses: %w", err)
	}
	return nil
}

func UnmarshalReferenceAddresses(buf []byte) (*ReferenceAddresses, error) {
	obj := new(ReferenceAddresses)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ReferenceAddressesSet struct {
	Router             solanago.PublicKey `json:"router"`
	FeeQuoter          solanago.PublicKey `json:"feeQuoter"`
	OfframpLookupTable solanago.PublicKey `json:"offrampLookupTable"`
	RmnRemote          solanago.PublicKey `json:"rmnRemote"`
}

func (obj ReferenceAddressesSet) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Router`:
	err = encoder.Encode(obj.Router)
	if err != nil {
		return errors.NewField("Router", err)
	}
	// Serialize `FeeQuoter`:
	err = encoder.Encode(obj.FeeQuoter)
	if err != nil {
		return errors.NewField("FeeQuoter", err)
	}
	// Serialize `OfframpLookupTable`:
	err = encoder.Encode(obj.OfframpLookupTable)
	if err != nil {
		return errors.NewField("OfframpLookupTable", err)
	}
	// Serialize `RmnRemote`:
	err = encoder.Encode(obj.RmnRemote)
	if err != nil {
		return errors.NewField("RmnRemote", err)
	}
	return nil
}

func (obj ReferenceAddressesSet) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding ReferenceAddressesSet: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *ReferenceAddressesSet) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Router`:
	err = decoder.Decode(&obj.Router)
	if err != nil {
		return errors.NewField("Router", err)
	}
	// Deserialize `FeeQuoter`:
	err = decoder.Decode(&obj.FeeQuoter)
	if err != nil {
		return errors.NewField("FeeQuoter", err)
	}
	// Deserialize `OfframpLookupTable`:
	err = decoder.Decode(&obj.OfframpLookupTable)
	if err != nil {
		return errors.NewField("OfframpLookupTable", err)
	}
	// Deserialize `RmnRemote`:
	err = decoder.Decode(&obj.RmnRemote)
	if err != nil {
		return errors.NewField("RmnRemote", err)
	}
	return nil
}

func (obj *ReferenceAddressesSet) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ReferenceAddressesSet: %w", err)
	}
	return nil
}

func UnmarshalReferenceAddressesSet(buf []byte) (*ReferenceAddressesSet, error) {
	obj := new(ReferenceAddressesSet)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SkippedAlreadyExecutedMessage struct {
	SourceChainSelector uint64 `json:"sourceChainSelector"`
	SequenceNumber      uint64 `json:"sequenceNumber"`
}

func (obj SkippedAlreadyExecutedMessage) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `SourceChainSelector`:
	err = encoder.Encode(obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Serialize `SequenceNumber`:
	err = encoder.Encode(obj.SequenceNumber)
	if err != nil {
		return errors.NewField("SequenceNumber", err)
	}
	return nil
}

func (obj SkippedAlreadyExecutedMessage) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding SkippedAlreadyExecutedMessage: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *SkippedAlreadyExecutedMessage) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `SourceChainSelector`:
	err = decoder.Decode(&obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Deserialize `SequenceNumber`:
	err = decoder.Decode(&obj.SequenceNumber)
	if err != nil {
		return errors.NewField("SequenceNumber", err)
	}
	return nil
}

func (obj *SkippedAlreadyExecutedMessage) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SkippedAlreadyExecutedMessage: %w", err)
	}
	return nil
}

func UnmarshalSkippedAlreadyExecutedMessage(buf []byte) (*SkippedAlreadyExecutedMessage, error) {
	obj := new(SkippedAlreadyExecutedMessage)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SourceChain struct {
	Version       uint8             `json:"version"`
	ChainSelector uint64            `json:"chainSelector"`
	State         SourceChainState  `json:"state"`
	Config        SourceChainConfig `json:"config"`
}

func (obj SourceChain) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Version`:
	err = encoder.Encode(obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Serialize `ChainSelector`:
	err = encoder.Encode(obj.ChainSelector)
	if err != nil {
		return errors.NewField("ChainSelector", err)
	}
	// Serialize `State`:
	err = encoder.Encode(obj.State)
	if err != nil {
		return errors.NewField("State", err)
	}
	// Serialize `Config`:
	err = encoder.Encode(obj.Config)
	if err != nil {
		return errors.NewField("Config", err)
	}
	return nil
}

func (obj SourceChain) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding SourceChain: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *SourceChain) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Version`:
	err = decoder.Decode(&obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Deserialize `ChainSelector`:
	err = decoder.Decode(&obj.ChainSelector)
	if err != nil {
		return errors.NewField("ChainSelector", err)
	}
	// Deserialize `State`:
	err = decoder.Decode(&obj.State)
	if err != nil {
		return errors.NewField("State", err)
	}
	// Deserialize `Config`:
	err = decoder.Decode(&obj.Config)
	if err != nil {
		return errors.NewField("Config", err)
	}
	return nil
}

func (obj *SourceChain) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SourceChain: %w", err)
	}
	return nil
}

func UnmarshalSourceChain(buf []byte) (*SourceChain, error) {
	obj := new(SourceChain)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SourceChainAdded struct {
	SourceChainSelector uint64            `json:"sourceChainSelector"`
	SourceChainConfig   SourceChainConfig `json:"sourceChainConfig"`
}

func (obj SourceChainAdded) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `SourceChainSelector`:
	err = encoder.Encode(obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Serialize `SourceChainConfig`:
	err = encoder.Encode(obj.SourceChainConfig)
	if err != nil {
		return errors.NewField("SourceChainConfig", err)
	}
	return nil
}

func (obj SourceChainAdded) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding SourceChainAdded: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *SourceChainAdded) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `SourceChainSelector`:
	err = decoder.Decode(&obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Deserialize `SourceChainConfig`:
	err = decoder.Decode(&obj.SourceChainConfig)
	if err != nil {
		return errors.NewField("SourceChainConfig", err)
	}
	return nil
}

func (obj *SourceChainAdded) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SourceChainAdded: %w", err)
	}
	return nil
}

func UnmarshalSourceChainAdded(buf []byte) (*SourceChainAdded, error) {
	obj := new(SourceChainAdded)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SourceChainConfig struct {
	IsEnabled                 bool          `json:"isEnabled"`
	IsRmnVerificationDisabled bool          `json:"isRmnVerificationDisabled"`
	LaneCodeVersion           CodeVersion   `json:"laneCodeVersion"`
	OnRamp                    OnRampAddress `json:"onRamp"`
}

func (obj SourceChainConfig) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `IsEnabled`:
	err = encoder.Encode(obj.IsEnabled)
	if err != nil {
		return errors.NewField("IsEnabled", err)
	}
	// Serialize `IsRmnVerificationDisabled`:
	err = encoder.Encode(obj.IsRmnVerificationDisabled)
	if err != nil {
		return errors.NewField("IsRmnVerificationDisabled", err)
	}
	// Serialize `LaneCodeVersion`:
	err = encoder.Encode(obj.LaneCodeVersion)
	if err != nil {
		return errors.NewField("LaneCodeVersion", err)
	}
	// Serialize `OnRamp`:
	err = encoder.Encode(obj.OnRamp)
	if err != nil {
		return errors.NewField("OnRamp", err)
	}
	return nil
}

func (obj SourceChainConfig) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding SourceChainConfig: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *SourceChainConfig) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `IsEnabled`:
	err = decoder.Decode(&obj.IsEnabled)
	if err != nil {
		return errors.NewField("IsEnabled", err)
	}
	// Deserialize `IsRmnVerificationDisabled`:
	err = decoder.Decode(&obj.IsRmnVerificationDisabled)
	if err != nil {
		return errors.NewField("IsRmnVerificationDisabled", err)
	}
	// Deserialize `LaneCodeVersion`:
	err = decoder.Decode(&obj.LaneCodeVersion)
	if err != nil {
		return errors.NewField("LaneCodeVersion", err)
	}
	// Deserialize `OnRamp`:
	err = decoder.Decode(&obj.OnRamp)
	if err != nil {
		return errors.NewField("OnRamp", err)
	}
	return nil
}

func (obj *SourceChainConfig) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SourceChainConfig: %w", err)
	}
	return nil
}

func UnmarshalSourceChainConfig(buf []byte) (*SourceChainConfig, error) {
	obj := new(SourceChainConfig)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SourceChainConfigUpdated struct {
	SourceChainSelector uint64            `json:"sourceChainSelector"`
	SourceChainConfig   SourceChainConfig `json:"sourceChainConfig"`
}

func (obj SourceChainConfigUpdated) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `SourceChainSelector`:
	err = encoder.Encode(obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Serialize `SourceChainConfig`:
	err = encoder.Encode(obj.SourceChainConfig)
	if err != nil {
		return errors.NewField("SourceChainConfig", err)
	}
	return nil
}

func (obj SourceChainConfigUpdated) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding SourceChainConfigUpdated: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *SourceChainConfigUpdated) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `SourceChainSelector`:
	err = decoder.Decode(&obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Deserialize `SourceChainConfig`:
	err = decoder.Decode(&obj.SourceChainConfig)
	if err != nil {
		return errors.NewField("SourceChainConfig", err)
	}
	return nil
}

func (obj *SourceChainConfigUpdated) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SourceChainConfigUpdated: %w", err)
	}
	return nil
}

func UnmarshalSourceChainConfigUpdated(buf []byte) (*SourceChainConfigUpdated, error) {
	obj := new(SourceChainConfigUpdated)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SourceChainState struct {
	MinSeqNr uint64 `json:"minSeqNr"`
}

func (obj SourceChainState) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `MinSeqNr`:
	err = encoder.Encode(obj.MinSeqNr)
	if err != nil {
		return errors.NewField("MinSeqNr", err)
	}
	return nil
}

func (obj SourceChainState) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding SourceChainState: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *SourceChainState) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `MinSeqNr`:
	err = decoder.Decode(&obj.MinSeqNr)
	if err != nil {
		return errors.NewField("MinSeqNr", err)
	}
	return nil
}

func (obj *SourceChainState) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SourceChainState: %w", err)
	}
	return nil
}

func UnmarshalSourceChainState(buf []byte) (*SourceChainState, error) {
	obj := new(SourceChainState)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type TokenPriceUpdate struct {
	SourceToken solanago.PublicKey `json:"sourceToken"`
	UsdPerToken [28]uint8          `json:"usdPerToken"`
}

func (obj TokenPriceUpdate) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `SourceToken`:
	err = encoder.Encode(obj.SourceToken)
	if err != nil {
		return errors.NewField("SourceToken", err)
	}
	// Serialize `UsdPerToken`:
	err = encoder.Encode(obj.UsdPerToken)
	if err != nil {
		return errors.NewField("UsdPerToken", err)
	}
	return nil
}

func (obj TokenPriceUpdate) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding TokenPriceUpdate: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *TokenPriceUpdate) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `SourceToken`:
	err = decoder.Decode(&obj.SourceToken)
	if err != nil {
		return errors.NewField("SourceToken", err)
	}
	// Deserialize `UsdPerToken`:
	err = decoder.Decode(&obj.UsdPerToken)
	if err != nil {
		return errors.NewField("UsdPerToken", err)
	}
	return nil
}

func (obj *TokenPriceUpdate) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling TokenPriceUpdate: %w", err)
	}
	return nil
}

func UnmarshalTokenPriceUpdate(buf []byte) (*TokenPriceUpdate, error) {
	obj := new(TokenPriceUpdate)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type TokenTransferAndOffchainData struct {
	Transfer Any2SvmTokenTransfer `json:"transfer"`
	Data     []byte               `json:"data"`
}

func (obj TokenTransferAndOffchainData) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Transfer`:
	err = encoder.Encode(obj.Transfer)
	if err != nil {
		return errors.NewField("Transfer", err)
	}
	// Serialize `Data`:
	err = encoder.Encode(obj.Data)
	if err != nil {
		return errors.NewField("Data", err)
	}
	return nil
}

func (obj TokenTransferAndOffchainData) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding TokenTransferAndOffchainData: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *TokenTransferAndOffchainData) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Transfer`:
	err = decoder.Decode(&obj.Transfer)
	if err != nil {
		return errors.NewField("Transfer", err)
	}
	// Deserialize `Data`:
	err = decoder.Decode(&obj.Data)
	if err != nil {
		return errors.NewField("Data", err)
	}
	return nil
}

func (obj *TokenTransferAndOffchainData) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling TokenTransferAndOffchainData: %w", err)
	}
	return nil
}

func UnmarshalTokenTransferAndOffchainData(buf []byte) (*TokenTransferAndOffchainData, error) {
	obj := new(TokenTransferAndOffchainData)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type Transmitted struct {
	OcrPluginType  OcrPluginType `json:"ocrPluginType"`
	ConfigDigest   [32]uint8     `json:"configDigest"`
	SequenceNumber uint64        `json:"sequenceNumber"`
}

func (obj Transmitted) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `OcrPluginType`:
	err = encoder.Encode(obj.OcrPluginType)
	if err != nil {
		return errors.NewField("OcrPluginType", err)
	}
	// Serialize `ConfigDigest`:
	err = encoder.Encode(obj.ConfigDigest)
	if err != nil {
		return errors.NewField("ConfigDigest", err)
	}
	// Serialize `SequenceNumber`:
	err = encoder.Encode(obj.SequenceNumber)
	if err != nil {
		return errors.NewField("SequenceNumber", err)
	}
	return nil
}

func (obj Transmitted) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Transmitted: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Transmitted) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `OcrPluginType`:
	err = decoder.Decode(&obj.OcrPluginType)
	if err != nil {
		return errors.NewField("OcrPluginType", err)
	}
	// Deserialize `ConfigDigest`:
	err = decoder.Decode(&obj.ConfigDigest)
	if err != nil {
		return errors.NewField("ConfigDigest", err)
	}
	// Deserialize `SequenceNumber`:
	err = decoder.Decode(&obj.SequenceNumber)
	if err != nil {
		return errors.NewField("SequenceNumber", err)
	}
	return nil
}

func (obj *Transmitted) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Transmitted: %w", err)
	}
	return nil
}

func UnmarshalTransmitted(buf []byte) (*Transmitted, error) {
	obj := new(Transmitted)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}
