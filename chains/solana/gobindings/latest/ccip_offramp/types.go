// Code generated by https://github.com/Unheilbar/anchor-go. DO NOT EDIT.
// This file contains parsers for the types defined in the IDL.

package ccip_offramp

import (
	"bytes"
	"fmt"
	errors "github.com/Unheilbar/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

type Any2SvmRampExtraArgs struct {
	ComputeUnits     uint32 `json:"compute_units"`
	IsWritableBitmap uint64 `json:"is_writable_bitmap"`
}

func (obj Any2SvmRampExtraArgs) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `ComputeUnits`:
	err = encoder.Encode(obj.ComputeUnits)
	if err != nil {
		return errors.NewField("ComputeUnits", err)
	}
	// Serialize `IsWritableBitmap`:
	err = encoder.Encode(obj.IsWritableBitmap)
	if err != nil {
		return errors.NewField("IsWritableBitmap", err)
	}
	return nil
}

func (obj Any2SvmRampExtraArgs) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Any2SvmRampExtraArgs: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Any2SvmRampExtraArgs) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `ComputeUnits`:
	err = decoder.Decode(&obj.ComputeUnits)
	if err != nil {
		return errors.NewField("ComputeUnits", err)
	}
	// Deserialize `IsWritableBitmap`:
	err = decoder.Decode(&obj.IsWritableBitmap)
	if err != nil {
		return errors.NewField("IsWritableBitmap", err)
	}
	return nil
}

func (obj *Any2SvmRampExtraArgs) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Any2SvmRampExtraArgs: %w", err)
	}
	return nil
}

func UnmarshalAny2SvmRampExtraArgs(buf []byte) (*Any2SvmRampExtraArgs, error) {
	obj := new(Any2SvmRampExtraArgs)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type Any2SvmRampMessage struct {
	Header        RampMessageHeader      `json:"header"`
	Sender        []byte                 `json:"sender"`
	Data          []byte                 `json:"data"`
	TokenReceiver solanago.PublicKey     `json:"token_receiver"`
	TokenAmounts  []Any2SvmTokenTransfer `json:"token_amounts"`
	ExtraArgs     Any2SvmRampExtraArgs   `json:"extra_args"`
}

func (obj Any2SvmRampMessage) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Header`:
	err = encoder.Encode(obj.Header)
	if err != nil {
		return errors.NewField("Header", err)
	}
	// Serialize `Sender`:
	err = encoder.Encode(obj.Sender)
	if err != nil {
		return errors.NewField("Sender", err)
	}
	// Serialize `Data`:
	err = encoder.Encode(obj.Data)
	if err != nil {
		return errors.NewField("Data", err)
	}
	// Serialize `TokenReceiver`:
	err = encoder.Encode(obj.TokenReceiver)
	if err != nil {
		return errors.NewField("TokenReceiver", err)
	}
	// Serialize `TokenAmounts`:
	err = encoder.Encode(obj.TokenAmounts)
	if err != nil {
		return errors.NewField("TokenAmounts", err)
	}
	// Serialize `ExtraArgs`:
	err = encoder.Encode(obj.ExtraArgs)
	if err != nil {
		return errors.NewField("ExtraArgs", err)
	}
	return nil
}

func (obj Any2SvmRampMessage) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Any2SvmRampMessage: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Any2SvmRampMessage) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Header`:
	err = decoder.Decode(&obj.Header)
	if err != nil {
		return errors.NewField("Header", err)
	}
	// Deserialize `Sender`:
	err = decoder.Decode(&obj.Sender)
	if err != nil {
		return errors.NewField("Sender", err)
	}
	// Deserialize `Data`:
	err = decoder.Decode(&obj.Data)
	if err != nil {
		return errors.NewField("Data", err)
	}
	// Deserialize `TokenReceiver`:
	err = decoder.Decode(&obj.TokenReceiver)
	if err != nil {
		return errors.NewField("TokenReceiver", err)
	}
	// Deserialize `TokenAmounts`:
	err = decoder.Decode(&obj.TokenAmounts)
	if err != nil {
		return errors.NewField("TokenAmounts", err)
	}
	// Deserialize `ExtraArgs`:
	err = decoder.Decode(&obj.ExtraArgs)
	if err != nil {
		return errors.NewField("ExtraArgs", err)
	}
	return nil
}

func (obj *Any2SvmRampMessage) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Any2SvmRampMessage: %w", err)
	}
	return nil
}

func UnmarshalAny2SvmRampMessage(buf []byte) (*Any2SvmRampMessage, error) {
	obj := new(Any2SvmRampMessage)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type Any2SvmTokenTransfer struct {
	SourcePoolAddress []byte             `json:"source_pool_address"`
	DestTokenAddress  solanago.PublicKey `json:"dest_token_address"`
	DestGasAmount     uint32             `json:"dest_gas_amount"`
	ExtraData         []byte             `json:"extra_data"`
	Amount            CrossChainAmount   `json:"amount"`
}

func (obj Any2SvmTokenTransfer) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `SourcePoolAddress`:
	err = encoder.Encode(obj.SourcePoolAddress)
	if err != nil {
		return errors.NewField("SourcePoolAddress", err)
	}
	// Serialize `DestTokenAddress`:
	err = encoder.Encode(obj.DestTokenAddress)
	if err != nil {
		return errors.NewField("DestTokenAddress", err)
	}
	// Serialize `DestGasAmount`:
	err = encoder.Encode(obj.DestGasAmount)
	if err != nil {
		return errors.NewField("DestGasAmount", err)
	}
	// Serialize `ExtraData`:
	err = encoder.Encode(obj.ExtraData)
	if err != nil {
		return errors.NewField("ExtraData", err)
	}
	// Serialize `Amount`:
	err = encoder.Encode(obj.Amount)
	if err != nil {
		return errors.NewField("Amount", err)
	}
	return nil
}

func (obj Any2SvmTokenTransfer) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Any2SvmTokenTransfer: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Any2SvmTokenTransfer) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `SourcePoolAddress`:
	err = decoder.Decode(&obj.SourcePoolAddress)
	if err != nil {
		return errors.NewField("SourcePoolAddress", err)
	}
	// Deserialize `DestTokenAddress`:
	err = decoder.Decode(&obj.DestTokenAddress)
	if err != nil {
		return errors.NewField("DestTokenAddress", err)
	}
	// Deserialize `DestGasAmount`:
	err = decoder.Decode(&obj.DestGasAmount)
	if err != nil {
		return errors.NewField("DestGasAmount", err)
	}
	// Deserialize `ExtraData`:
	err = decoder.Decode(&obj.ExtraData)
	if err != nil {
		return errors.NewField("ExtraData", err)
	}
	// Deserialize `Amount`:
	err = decoder.Decode(&obj.Amount)
	if err != nil {
		return errors.NewField("Amount", err)
	}
	return nil
}

func (obj *Any2SvmTokenTransfer) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Any2SvmTokenTransfer: %w", err)
	}
	return nil
}

func UnmarshalAny2SvmTokenTransfer(buf []byte) (*Any2SvmTokenTransfer, error) {
	obj := new(Any2SvmTokenTransfer)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type CcipAccountMeta struct {
	Pubkey     solanago.PublicKey `json:"pubkey"`
	IsSigner   bool               `json:"is_signer"`
	IsWritable bool               `json:"is_writable"`
}

func (obj CcipAccountMeta) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Pubkey`:
	err = encoder.Encode(obj.Pubkey)
	if err != nil {
		return errors.NewField("Pubkey", err)
	}
	// Serialize `IsSigner`:
	err = encoder.Encode(obj.IsSigner)
	if err != nil {
		return errors.NewField("IsSigner", err)
	}
	// Serialize `IsWritable`:
	err = encoder.Encode(obj.IsWritable)
	if err != nil {
		return errors.NewField("IsWritable", err)
	}
	return nil
}

func (obj CcipAccountMeta) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding CcipAccountMeta: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *CcipAccountMeta) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Pubkey`:
	err = decoder.Decode(&obj.Pubkey)
	if err != nil {
		return errors.NewField("Pubkey", err)
	}
	// Deserialize `IsSigner`:
	err = decoder.Decode(&obj.IsSigner)
	if err != nil {
		return errors.NewField("IsSigner", err)
	}
	// Deserialize `IsWritable`:
	err = decoder.Decode(&obj.IsWritable)
	if err != nil {
		return errors.NewField("IsWritable", err)
	}
	return nil
}

func (obj *CcipAccountMeta) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CcipAccountMeta: %w", err)
	}
	return nil
}

func UnmarshalCcipAccountMeta(buf []byte) (*CcipAccountMeta, error) {
	obj := new(CcipAccountMeta)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type CodeVersion binary.BorshEnum

const (
	CodeVersion_Default CodeVersion = iota
	CodeVersion_V1
)

func (value CodeVersion) String() string {
	switch value {
	case CodeVersion_Default:
		return "Default"
	case CodeVersion_V1:
		return "V1"
	default:
		return ""
	}
}

// Input from an offchain node, containing the Merkle root and interval for
// the source chain, and optionally some price updates alongside it
type CommitInput struct {
	PriceUpdates  PriceUpdates `json:"price_updates"`
	MerkleRoot    *MerkleRoot  `bin:"optional" json:"merkle_root,omitempty"`
	RmnSignatures [][64]uint8  `json:"rmn_signatures"`
}

func (obj CommitInput) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `PriceUpdates`:
	err = encoder.Encode(obj.PriceUpdates)
	if err != nil {
		return errors.NewField("PriceUpdates", err)
	}
	// Serialize `MerkleRoot` (optional):
	{
		if obj.MerkleRoot == nil {
			err = encoder.WriteOption(false)
			if err != nil {
				return errors.NewOption("MerkleRoot", fmt.Errorf("error while encoding optionality: %w", err))
			}
		} else {
			err = encoder.WriteOption(true)
			if err != nil {
				return errors.NewOption("MerkleRoot", fmt.Errorf("error while encoding optionality: %w", err))
			}
			err = encoder.Encode(obj.MerkleRoot)
			if err != nil {
				return errors.NewField("MerkleRoot", err)
			}
		}
	}
	// Serialize `RmnSignatures`:
	err = encoder.Encode(obj.RmnSignatures)
	if err != nil {
		return errors.NewField("RmnSignatures", err)
	}
	return nil
}

func (obj CommitInput) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding CommitInput: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *CommitInput) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `PriceUpdates`:
	err = decoder.Decode(&obj.PriceUpdates)
	if err != nil {
		return errors.NewField("PriceUpdates", err)
	}
	// Deserialize `MerkleRoot` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return errors.NewOption("MerkleRoot", fmt.Errorf("error while reading optionality: %w", err))
		}
		if ok {
			err = decoder.Decode(&obj.MerkleRoot)
			if err != nil {
				return errors.NewField("MerkleRoot", err)
			}
		}
	}
	// Deserialize `RmnSignatures`:
	err = decoder.Decode(&obj.RmnSignatures)
	if err != nil {
		return errors.NewField("RmnSignatures", err)
	}
	return nil
}

func (obj *CommitInput) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CommitInput: %w", err)
	}
	return nil
}

func UnmarshalCommitInput(buf []byte) (*CommitInput, error) {
	obj := new(CommitInput)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type CommitReport struct {
	Version         uint8          `json:"version"`
	ChainSelector   uint64         `json:"chain_selector"`
	MerkleRoot      [32]uint8      `json:"merkle_root"`
	Timestamp       int64          `json:"timestamp"`
	MinMsgNr        uint64         `json:"min_msg_nr"`
	MaxMsgNr        uint64         `json:"max_msg_nr"`
	ExecutionStates binary.Uint128 `json:"execution_states"`
}

func (obj CommitReport) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Version`:
	err = encoder.Encode(obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Serialize `ChainSelector`:
	err = encoder.Encode(obj.ChainSelector)
	if err != nil {
		return errors.NewField("ChainSelector", err)
	}
	// Serialize `MerkleRoot`:
	err = encoder.Encode(obj.MerkleRoot)
	if err != nil {
		return errors.NewField("MerkleRoot", err)
	}
	// Serialize `Timestamp`:
	err = encoder.Encode(obj.Timestamp)
	if err != nil {
		return errors.NewField("Timestamp", err)
	}
	// Serialize `MinMsgNr`:
	err = encoder.Encode(obj.MinMsgNr)
	if err != nil {
		return errors.NewField("MinMsgNr", err)
	}
	// Serialize `MaxMsgNr`:
	err = encoder.Encode(obj.MaxMsgNr)
	if err != nil {
		return errors.NewField("MaxMsgNr", err)
	}
	// Serialize `ExecutionStates`:
	err = encoder.Encode(obj.ExecutionStates)
	if err != nil {
		return errors.NewField("ExecutionStates", err)
	}
	return nil
}

func (obj CommitReport) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding CommitReport: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *CommitReport) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Version`:
	err = decoder.Decode(&obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Deserialize `ChainSelector`:
	err = decoder.Decode(&obj.ChainSelector)
	if err != nil {
		return errors.NewField("ChainSelector", err)
	}
	// Deserialize `MerkleRoot`:
	err = decoder.Decode(&obj.MerkleRoot)
	if err != nil {
		return errors.NewField("MerkleRoot", err)
	}
	// Deserialize `Timestamp`:
	err = decoder.Decode(&obj.Timestamp)
	if err != nil {
		return errors.NewField("Timestamp", err)
	}
	// Deserialize `MinMsgNr`:
	err = decoder.Decode(&obj.MinMsgNr)
	if err != nil {
		return errors.NewField("MinMsgNr", err)
	}
	// Deserialize `MaxMsgNr`:
	err = decoder.Decode(&obj.MaxMsgNr)
	if err != nil {
		return errors.NewField("MaxMsgNr", err)
	}
	// Deserialize `ExecutionStates`:
	err = decoder.Decode(&obj.ExecutionStates)
	if err != nil {
		return errors.NewField("ExecutionStates", err)
	}
	return nil
}

func (obj *CommitReport) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CommitReport: %w", err)
	}
	return nil
}

func UnmarshalCommitReport(buf []byte) (*CommitReport, error) {
	obj := new(CommitReport)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type CommitReportAccepted struct {
	MerkleRoot   *MerkleRoot  `bin:"optional" json:"merkle_root,omitempty"`
	PriceUpdates PriceUpdates `json:"price_updates"`
}

func (obj CommitReportAccepted) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `MerkleRoot` (optional):
	{
		if obj.MerkleRoot == nil {
			err = encoder.WriteOption(false)
			if err != nil {
				return errors.NewOption("MerkleRoot", fmt.Errorf("error while encoding optionality: %w", err))
			}
		} else {
			err = encoder.WriteOption(true)
			if err != nil {
				return errors.NewOption("MerkleRoot", fmt.Errorf("error while encoding optionality: %w", err))
			}
			err = encoder.Encode(obj.MerkleRoot)
			if err != nil {
				return errors.NewField("MerkleRoot", err)
			}
		}
	}
	// Serialize `PriceUpdates`:
	err = encoder.Encode(obj.PriceUpdates)
	if err != nil {
		return errors.NewField("PriceUpdates", err)
	}
	return nil
}

func (obj CommitReportAccepted) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding CommitReportAccepted: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *CommitReportAccepted) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `MerkleRoot` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return errors.NewOption("MerkleRoot", fmt.Errorf("error while reading optionality: %w", err))
		}
		if ok {
			err = decoder.Decode(&obj.MerkleRoot)
			if err != nil {
				return errors.NewField("MerkleRoot", err)
			}
		}
	}
	// Deserialize `PriceUpdates`:
	err = decoder.Decode(&obj.PriceUpdates)
	if err != nil {
		return errors.NewField("PriceUpdates", err)
	}
	return nil
}

func (obj *CommitReportAccepted) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CommitReportAccepted: %w", err)
	}
	return nil
}

func UnmarshalCommitReportAccepted(buf []byte) (*CommitReportAccepted, error) {
	obj := new(CommitReportAccepted)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type CommitReportPdaClosed struct {
	SourceChainSelector uint64    `json:"source_chain_selector"`
	MerkleRoot          [32]uint8 `json:"merkle_root"`
}

func (obj CommitReportPdaClosed) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `SourceChainSelector`:
	err = encoder.Encode(obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Serialize `MerkleRoot`:
	err = encoder.Encode(obj.MerkleRoot)
	if err != nil {
		return errors.NewField("MerkleRoot", err)
	}
	return nil
}

func (obj CommitReportPdaClosed) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding CommitReportPdaClosed: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *CommitReportPdaClosed) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `SourceChainSelector`:
	err = decoder.Decode(&obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Deserialize `MerkleRoot`:
	err = decoder.Decode(&obj.MerkleRoot)
	if err != nil {
		return errors.NewField("MerkleRoot", err)
	}
	return nil
}

func (obj *CommitReportPdaClosed) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CommitReportPdaClosed: %w", err)
	}
	return nil
}

func UnmarshalCommitReportPdaClosed(buf []byte) (*CommitReportPdaClosed, error) {
	obj := new(CommitReportPdaClosed)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type Config struct {
	Version                    uint8              `json:"version"`
	DefaultCodeVersion         uint8              `json:"default_code_version"`
	Padding0                   [6]uint8           `json:"_padding0"`
	SvmChainSelector           uint64             `json:"svm_chain_selector"`
	EnableManualExecutionAfter int64              `json:"enable_manual_execution_after"`
	Padding1                   [8]uint8           `json:"_padding1"`
	Owner                      solanago.PublicKey `json:"owner"`
	ProposedOwner              solanago.PublicKey `json:"proposed_owner"`
	Padding2                   [8]uint8           `json:"_padding2"`
	Ocr3                       [2]Ocr3Config      `json:"ocr3"`
}

func (obj Config) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Version`:
	err = encoder.Encode(obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Serialize `DefaultCodeVersion`:
	err = encoder.Encode(obj.DefaultCodeVersion)
	if err != nil {
		return errors.NewField("DefaultCodeVersion", err)
	}
	// Serialize `Padding0`:
	err = encoder.Encode(obj.Padding0)
	if err != nil {
		return errors.NewField("Padding0", err)
	}
	// Serialize `SvmChainSelector`:
	err = encoder.Encode(obj.SvmChainSelector)
	if err != nil {
		return errors.NewField("SvmChainSelector", err)
	}
	// Serialize `EnableManualExecutionAfter`:
	err = encoder.Encode(obj.EnableManualExecutionAfter)
	if err != nil {
		return errors.NewField("EnableManualExecutionAfter", err)
	}
	// Serialize `Padding1`:
	err = encoder.Encode(obj.Padding1)
	if err != nil {
		return errors.NewField("Padding1", err)
	}
	// Serialize `Owner`:
	err = encoder.Encode(obj.Owner)
	if err != nil {
		return errors.NewField("Owner", err)
	}
	// Serialize `ProposedOwner`:
	err = encoder.Encode(obj.ProposedOwner)
	if err != nil {
		return errors.NewField("ProposedOwner", err)
	}
	// Serialize `Padding2`:
	err = encoder.Encode(obj.Padding2)
	if err != nil {
		return errors.NewField("Padding2", err)
	}
	// Serialize `Ocr3`:
	err = encoder.Encode(obj.Ocr3)
	if err != nil {
		return errors.NewField("Ocr3", err)
	}
	return nil
}

func (obj Config) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Config: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Config) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Version`:
	err = decoder.Decode(&obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Deserialize `DefaultCodeVersion`:
	err = decoder.Decode(&obj.DefaultCodeVersion)
	if err != nil {
		return errors.NewField("DefaultCodeVersion", err)
	}
	// Deserialize `Padding0`:
	err = decoder.Decode(&obj.Padding0)
	if err != nil {
		return errors.NewField("Padding0", err)
	}
	// Deserialize `SvmChainSelector`:
	err = decoder.Decode(&obj.SvmChainSelector)
	if err != nil {
		return errors.NewField("SvmChainSelector", err)
	}
	// Deserialize `EnableManualExecutionAfter`:
	err = decoder.Decode(&obj.EnableManualExecutionAfter)
	if err != nil {
		return errors.NewField("EnableManualExecutionAfter", err)
	}
	// Deserialize `Padding1`:
	err = decoder.Decode(&obj.Padding1)
	if err != nil {
		return errors.NewField("Padding1", err)
	}
	// Deserialize `Owner`:
	err = decoder.Decode(&obj.Owner)
	if err != nil {
		return errors.NewField("Owner", err)
	}
	// Deserialize `ProposedOwner`:
	err = decoder.Decode(&obj.ProposedOwner)
	if err != nil {
		return errors.NewField("ProposedOwner", err)
	}
	// Deserialize `Padding2`:
	err = decoder.Decode(&obj.Padding2)
	if err != nil {
		return errors.NewField("Padding2", err)
	}
	// Deserialize `Ocr3`:
	err = decoder.Decode(&obj.Ocr3)
	if err != nil {
		return errors.NewField("Ocr3", err)
	}
	return nil
}

func (obj *Config) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Config: %w", err)
	}
	return nil
}

func UnmarshalConfig(buf []byte) (*Config, error) {
	obj := new(Config)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// It's not possible to store enums in zero_copy accounts, so we wrap the discriminant
// in a struct to store in config.
type ConfigOcrPluginType struct {
	Discriminant uint8 `json:"discriminant"`
}

func (obj ConfigOcrPluginType) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Discriminant`:
	err = encoder.Encode(obj.Discriminant)
	if err != nil {
		return errors.NewField("Discriminant", err)
	}
	return nil
}

func (obj ConfigOcrPluginType) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding ConfigOcrPluginType: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *ConfigOcrPluginType) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Discriminant`:
	err = decoder.Decode(&obj.Discriminant)
	if err != nil {
		return errors.NewField("Discriminant", err)
	}
	return nil
}

func (obj *ConfigOcrPluginType) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ConfigOcrPluginType: %w", err)
	}
	return nil
}

func UnmarshalConfigOcrPluginType(buf []byte) (*ConfigOcrPluginType, error) {
	obj := new(ConfigOcrPluginType)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ConfigSet struct {
	SvmChainSelector           uint64 `json:"svm_chain_selector"`
	EnableManualExecutionAfter int64  `json:"enable_manual_execution_after"`
}

func (obj ConfigSet) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `SvmChainSelector`:
	err = encoder.Encode(obj.SvmChainSelector)
	if err != nil {
		return errors.NewField("SvmChainSelector", err)
	}
	// Serialize `EnableManualExecutionAfter`:
	err = encoder.Encode(obj.EnableManualExecutionAfter)
	if err != nil {
		return errors.NewField("EnableManualExecutionAfter", err)
	}
	return nil
}

func (obj ConfigSet) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding ConfigSet: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *ConfigSet) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `SvmChainSelector`:
	err = decoder.Decode(&obj.SvmChainSelector)
	if err != nil {
		return errors.NewField("SvmChainSelector", err)
	}
	// Deserialize `EnableManualExecutionAfter`:
	err = decoder.Decode(&obj.EnableManualExecutionAfter)
	if err != nil {
		return errors.NewField("EnableManualExecutionAfter", err)
	}
	return nil
}

func (obj *ConfigSet) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ConfigSet: %w", err)
	}
	return nil
}

func UnmarshalConfigSet(buf []byte) (*ConfigSet, error) {
	obj := new(ConfigSet)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type CrossChainAmount struct {
	LeBytes [32]uint8 `json:"le_bytes"`
}

func (obj CrossChainAmount) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `LeBytes`:
	err = encoder.Encode(obj.LeBytes)
	if err != nil {
		return errors.NewField("LeBytes", err)
	}
	return nil
}

func (obj CrossChainAmount) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding CrossChainAmount: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *CrossChainAmount) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `LeBytes`:
	err = decoder.Decode(&obj.LeBytes)
	if err != nil {
		return errors.NewField("LeBytes", err)
	}
	return nil
}

func (obj *CrossChainAmount) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CrossChainAmount: %w", err)
	}
	return nil
}

func UnmarshalCrossChainAmount(buf []byte) (*CrossChainAmount, error) {
	obj := new(CrossChainAmount)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type DeriveAccountsExecuteParams struct {
	ExecuteCaller       solanago.PublicKey             `json:"execute_caller"`
	TokenReceiver       solanago.PublicKey             `json:"token_receiver"`
	TokenTransfers      []TokenTransferAndOffchainData `json:"token_transfers"`
	MessageAccounts     []CcipAccountMeta              `json:"message_accounts"`
	SourceChainSelector uint64                         `json:"source_chain_selector"`
	OriginalSender      []byte                         `json:"original_sender"`
	MerkleRoot          [32]uint8                      `json:"merkle_root"`
	BufferId            []byte                         `json:"buffer_id"`
}

func (obj DeriveAccountsExecuteParams) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `ExecuteCaller`:
	err = encoder.Encode(obj.ExecuteCaller)
	if err != nil {
		return errors.NewField("ExecuteCaller", err)
	}
	// Serialize `TokenReceiver`:
	err = encoder.Encode(obj.TokenReceiver)
	if err != nil {
		return errors.NewField("TokenReceiver", err)
	}
	// Serialize `TokenTransfers`:
	err = encoder.Encode(obj.TokenTransfers)
	if err != nil {
		return errors.NewField("TokenTransfers", err)
	}
	// Serialize `MessageAccounts`:
	err = encoder.Encode(obj.MessageAccounts)
	if err != nil {
		return errors.NewField("MessageAccounts", err)
	}
	// Serialize `SourceChainSelector`:
	err = encoder.Encode(obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Serialize `OriginalSender`:
	err = encoder.Encode(obj.OriginalSender)
	if err != nil {
		return errors.NewField("OriginalSender", err)
	}
	// Serialize `MerkleRoot`:
	err = encoder.Encode(obj.MerkleRoot)
	if err != nil {
		return errors.NewField("MerkleRoot", err)
	}
	// Serialize `BufferId`:
	err = encoder.Encode(obj.BufferId)
	if err != nil {
		return errors.NewField("BufferId", err)
	}
	return nil
}

func (obj DeriveAccountsExecuteParams) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding DeriveAccountsExecuteParams: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *DeriveAccountsExecuteParams) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `ExecuteCaller`:
	err = decoder.Decode(&obj.ExecuteCaller)
	if err != nil {
		return errors.NewField("ExecuteCaller", err)
	}
	// Deserialize `TokenReceiver`:
	err = decoder.Decode(&obj.TokenReceiver)
	if err != nil {
		return errors.NewField("TokenReceiver", err)
	}
	// Deserialize `TokenTransfers`:
	err = decoder.Decode(&obj.TokenTransfers)
	if err != nil {
		return errors.NewField("TokenTransfers", err)
	}
	// Deserialize `MessageAccounts`:
	err = decoder.Decode(&obj.MessageAccounts)
	if err != nil {
		return errors.NewField("MessageAccounts", err)
	}
	// Deserialize `SourceChainSelector`:
	err = decoder.Decode(&obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Deserialize `OriginalSender`:
	err = decoder.Decode(&obj.OriginalSender)
	if err != nil {
		return errors.NewField("OriginalSender", err)
	}
	// Deserialize `MerkleRoot`:
	err = decoder.Decode(&obj.MerkleRoot)
	if err != nil {
		return errors.NewField("MerkleRoot", err)
	}
	// Deserialize `BufferId`:
	err = decoder.Decode(&obj.BufferId)
	if err != nil {
		return errors.NewField("BufferId", err)
	}
	return nil
}

func (obj *DeriveAccountsExecuteParams) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling DeriveAccountsExecuteParams: %w", err)
	}
	return nil
}

func UnmarshalDeriveAccountsExecuteParams(buf []byte) (*DeriveAccountsExecuteParams, error) {
	obj := new(DeriveAccountsExecuteParams)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type DeriveAccountsResponse struct {
	// If this vector is not empty, you must call the `derive_` method again including
	// exactly these accounts as the `remaining_accounts` field.
	AskAgainWith []CcipAccountMeta `json:"ask_again_with"`

	// You must append these accounts at the end of a separate list. When `next_stage`
	// is finally empty, this separate list will contain all the accounts to use for the
	// instruction of interest.
	AccountsToSave []CcipAccountMeta `json:"accounts_to_save"`

	// Append these look up tables at the end of a list. It will contain all LUTs
	// that the instruction of interest can use.
	LookUpTablesToSave []solanago.PublicKey `json:"look_up_tables_to_save"`

	// Identifies the derivation stage.
	CurrentStage string `json:"current_stage"`

	// Identifies the next derivation stage. If empty, the derivation is complete.
	NextStage string `json:"next_stage"`
}

func (obj DeriveAccountsResponse) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `AskAgainWith`:
	err = encoder.Encode(obj.AskAgainWith)
	if err != nil {
		return errors.NewField("AskAgainWith", err)
	}
	// Serialize `AccountsToSave`:
	err = encoder.Encode(obj.AccountsToSave)
	if err != nil {
		return errors.NewField("AccountsToSave", err)
	}
	// Serialize `LookUpTablesToSave`:
	err = encoder.Encode(obj.LookUpTablesToSave)
	if err != nil {
		return errors.NewField("LookUpTablesToSave", err)
	}
	// Serialize `CurrentStage`:
	err = encoder.Encode(obj.CurrentStage)
	if err != nil {
		return errors.NewField("CurrentStage", err)
	}
	// Serialize `NextStage`:
	err = encoder.Encode(obj.NextStage)
	if err != nil {
		return errors.NewField("NextStage", err)
	}
	return nil
}

func (obj DeriveAccountsResponse) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding DeriveAccountsResponse: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *DeriveAccountsResponse) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `AskAgainWith`:
	err = decoder.Decode(&obj.AskAgainWith)
	if err != nil {
		return errors.NewField("AskAgainWith", err)
	}
	// Deserialize `AccountsToSave`:
	err = decoder.Decode(&obj.AccountsToSave)
	if err != nil {
		return errors.NewField("AccountsToSave", err)
	}
	// Deserialize `LookUpTablesToSave`:
	err = decoder.Decode(&obj.LookUpTablesToSave)
	if err != nil {
		return errors.NewField("LookUpTablesToSave", err)
	}
	// Deserialize `CurrentStage`:
	err = decoder.Decode(&obj.CurrentStage)
	if err != nil {
		return errors.NewField("CurrentStage", err)
	}
	// Deserialize `NextStage`:
	err = decoder.Decode(&obj.NextStage)
	if err != nil {
		return errors.NewField("NextStage", err)
	}
	return nil
}

func (obj *DeriveAccountsResponse) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling DeriveAccountsResponse: %w", err)
	}
	return nil
}

func UnmarshalDeriveAccountsResponse(buf []byte) (*DeriveAccountsResponse, error) {
	obj := new(DeriveAccountsResponse)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ExecutionReportBuffer struct {
	Version     uint8  `json:"version"`
	ChunkBitmap uint64 `json:"chunk_bitmap"`
	NumChunks   uint8  `json:"num_chunks"`
	ChunkLength uint32 `json:"chunk_length"`
	Data        []byte `json:"data"`
}

func (obj ExecutionReportBuffer) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Version`:
	err = encoder.Encode(obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Serialize `ChunkBitmap`:
	err = encoder.Encode(obj.ChunkBitmap)
	if err != nil {
		return errors.NewField("ChunkBitmap", err)
	}
	// Serialize `NumChunks`:
	err = encoder.Encode(obj.NumChunks)
	if err != nil {
		return errors.NewField("NumChunks", err)
	}
	// Serialize `ChunkLength`:
	err = encoder.Encode(obj.ChunkLength)
	if err != nil {
		return errors.NewField("ChunkLength", err)
	}
	// Serialize `Data`:
	err = encoder.Encode(obj.Data)
	if err != nil {
		return errors.NewField("Data", err)
	}
	return nil
}

func (obj ExecutionReportBuffer) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding ExecutionReportBuffer: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *ExecutionReportBuffer) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Version`:
	err = decoder.Decode(&obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Deserialize `ChunkBitmap`:
	err = decoder.Decode(&obj.ChunkBitmap)
	if err != nil {
		return errors.NewField("ChunkBitmap", err)
	}
	// Deserialize `NumChunks`:
	err = decoder.Decode(&obj.NumChunks)
	if err != nil {
		return errors.NewField("NumChunks", err)
	}
	// Deserialize `ChunkLength`:
	err = decoder.Decode(&obj.ChunkLength)
	if err != nil {
		return errors.NewField("ChunkLength", err)
	}
	// Deserialize `Data`:
	err = decoder.Decode(&obj.Data)
	if err != nil {
		return errors.NewField("Data", err)
	}
	return nil
}

func (obj *ExecutionReportBuffer) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ExecutionReportBuffer: %w", err)
	}
	return nil
}

func UnmarshalExecutionReportBuffer(buf []byte) (*ExecutionReportBuffer, error) {
	obj := new(ExecutionReportBuffer)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Report that is submitted by the execution DON at the execution phase. (including chain selector data)
type ExecutionReportSingleChain struct {
	SourceChainSelector uint64             `json:"source_chain_selector"`
	Message             Any2SvmRampMessage `json:"message"`
	OffchainTokenData   [][]byte           `json:"offchain_token_data"`
	Proofs              [][32]uint8        `json:"proofs"`
}

func (obj ExecutionReportSingleChain) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `SourceChainSelector`:
	err = encoder.Encode(obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Serialize `Message`:
	err = encoder.Encode(obj.Message)
	if err != nil {
		return errors.NewField("Message", err)
	}
	// Serialize `OffchainTokenData`:
	err = encoder.Encode(obj.OffchainTokenData)
	if err != nil {
		return errors.NewField("OffchainTokenData", err)
	}
	// Serialize `Proofs`:
	err = encoder.Encode(obj.Proofs)
	if err != nil {
		return errors.NewField("Proofs", err)
	}
	return nil
}

func (obj ExecutionReportSingleChain) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding ExecutionReportSingleChain: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *ExecutionReportSingleChain) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `SourceChainSelector`:
	err = decoder.Decode(&obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Deserialize `Message`:
	err = decoder.Decode(&obj.Message)
	if err != nil {
		return errors.NewField("Message", err)
	}
	// Deserialize `OffchainTokenData`:
	err = decoder.Decode(&obj.OffchainTokenData)
	if err != nil {
		return errors.NewField("OffchainTokenData", err)
	}
	// Deserialize `Proofs`:
	err = decoder.Decode(&obj.Proofs)
	if err != nil {
		return errors.NewField("Proofs", err)
	}
	return nil
}

func (obj *ExecutionReportSingleChain) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ExecutionReportSingleChain: %w", err)
	}
	return nil
}

func UnmarshalExecutionReportSingleChain(buf []byte) (*ExecutionReportSingleChain, error) {
	obj := new(ExecutionReportSingleChain)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ExecutionStateChanged struct {
	SourceChainSelector uint64                `json:"source_chain_selector"`
	SequenceNumber      uint64                `json:"sequence_number"`
	MessageId           [32]uint8             `json:"message_id"`
	MessageHash         [32]uint8             `json:"message_hash"`
	State               MessageExecutionState `json:"state"`
}

func (obj ExecutionStateChanged) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `SourceChainSelector`:
	err = encoder.Encode(obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Serialize `SequenceNumber`:
	err = encoder.Encode(obj.SequenceNumber)
	if err != nil {
		return errors.NewField("SequenceNumber", err)
	}
	// Serialize `MessageId`:
	err = encoder.Encode(obj.MessageId)
	if err != nil {
		return errors.NewField("MessageId", err)
	}
	// Serialize `MessageHash`:
	err = encoder.Encode(obj.MessageHash)
	if err != nil {
		return errors.NewField("MessageHash", err)
	}
	// Serialize `State`:
	err = encoder.Encode(obj.State)
	if err != nil {
		return errors.NewField("State", err)
	}
	return nil
}

func (obj ExecutionStateChanged) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding ExecutionStateChanged: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *ExecutionStateChanged) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `SourceChainSelector`:
	err = decoder.Decode(&obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Deserialize `SequenceNumber`:
	err = decoder.Decode(&obj.SequenceNumber)
	if err != nil {
		return errors.NewField("SequenceNumber", err)
	}
	// Deserialize `MessageId`:
	err = decoder.Decode(&obj.MessageId)
	if err != nil {
		return errors.NewField("MessageId", err)
	}
	// Deserialize `MessageHash`:
	err = decoder.Decode(&obj.MessageHash)
	if err != nil {
		return errors.NewField("MessageHash", err)
	}
	// Deserialize `State`:
	err = decoder.Decode(&obj.State)
	if err != nil {
		return errors.NewField("State", err)
	}
	return nil
}

func (obj *ExecutionStateChanged) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ExecutionStateChanged: %w", err)
	}
	return nil
}

func UnmarshalExecutionStateChanged(buf []byte) (*ExecutionStateChanged, error) {
	obj := new(ExecutionStateChanged)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Gas price for a given chain in USD; its value may contain tightly packed fields.
type GasPriceUpdate struct {
	DestChainSelector uint64    `json:"dest_chain_selector"`
	UsdPerUnitGas     [28]uint8 `json:"usd_per_unit_gas"`
}

func (obj GasPriceUpdate) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `DestChainSelector`:
	err = encoder.Encode(obj.DestChainSelector)
	if err != nil {
		return errors.NewField("DestChainSelector", err)
	}
	// Serialize `UsdPerUnitGas`:
	err = encoder.Encode(obj.UsdPerUnitGas)
	if err != nil {
		return errors.NewField("UsdPerUnitGas", err)
	}
	return nil
}

func (obj GasPriceUpdate) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding GasPriceUpdate: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *GasPriceUpdate) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `DestChainSelector`:
	err = decoder.Decode(&obj.DestChainSelector)
	if err != nil {
		return errors.NewField("DestChainSelector", err)
	}
	// Deserialize `UsdPerUnitGas`:
	err = decoder.Decode(&obj.UsdPerUnitGas)
	if err != nil {
		return errors.NewField("UsdPerUnitGas", err)
	}
	return nil
}

func (obj *GasPriceUpdate) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling GasPriceUpdate: %w", err)
	}
	return nil
}

func UnmarshalGasPriceUpdate(buf []byte) (*GasPriceUpdate, error) {
	obj := new(GasPriceUpdate)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type GlobalState struct {
	LatestPriceSequenceNumber uint64 `json:"latest_price_sequence_number"`
}

func (obj GlobalState) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `LatestPriceSequenceNumber`:
	err = encoder.Encode(obj.LatestPriceSequenceNumber)
	if err != nil {
		return errors.NewField("LatestPriceSequenceNumber", err)
	}
	return nil
}

func (obj GlobalState) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding GlobalState: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *GlobalState) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `LatestPriceSequenceNumber`:
	err = decoder.Decode(&obj.LatestPriceSequenceNumber)
	if err != nil {
		return errors.NewField("LatestPriceSequenceNumber", err)
	}
	return nil
}

func (obj *GlobalState) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling GlobalState: %w", err)
	}
	return nil
}

func UnmarshalGlobalState(buf []byte) (*GlobalState, error) {
	obj := new(GlobalState)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Event used only during IDL build to ensure CommitInput and related types
// are exported in the IDL for Go bindings generation.
// This event is never emitted at runtime.
type IdlBuildTypeExport struct {
	CommitInput                CommitInput                `json:"commit_input"`
	TokenPriceUpdate           TokenPriceUpdate           `json:"token_price_update"`
	GasPriceUpdate             GasPriceUpdate             `json:"gas_price_update"`
	Any2SvmRampMessage         Any2SvmRampMessage         `json:"any2svm_ramp_message"`
	RampMessageHeader          RampMessageHeader          `json:"ramp_message_header"`
	Any2SvmRampExtraArgs       Any2SvmRampExtraArgs       `json:"any2svm_ramp_extra_args"`
	Any2SvmTokenTransfer       Any2SvmTokenTransfer       `json:"any2svm_token_transfer"`
	ExecutionReportSingleChain ExecutionReportSingleChain `json:"execution_report_single_chain"`
	CrossChainAmount           CrossChainAmount           `json:"cross_chain_amount"`
	SvmTokenAmount             SvmTokenAmount             `json:"svm_token_amount"`
}

func (obj IdlBuildTypeExport) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `CommitInput`:
	err = encoder.Encode(obj.CommitInput)
	if err != nil {
		return errors.NewField("CommitInput", err)
	}
	// Serialize `TokenPriceUpdate`:
	err = encoder.Encode(obj.TokenPriceUpdate)
	if err != nil {
		return errors.NewField("TokenPriceUpdate", err)
	}
	// Serialize `GasPriceUpdate`:
	err = encoder.Encode(obj.GasPriceUpdate)
	if err != nil {
		return errors.NewField("GasPriceUpdate", err)
	}
	// Serialize `Any2SvmRampMessage`:
	err = encoder.Encode(obj.Any2SvmRampMessage)
	if err != nil {
		return errors.NewField("Any2SvmRampMessage", err)
	}
	// Serialize `RampMessageHeader`:
	err = encoder.Encode(obj.RampMessageHeader)
	if err != nil {
		return errors.NewField("RampMessageHeader", err)
	}
	// Serialize `Any2SvmRampExtraArgs`:
	err = encoder.Encode(obj.Any2SvmRampExtraArgs)
	if err != nil {
		return errors.NewField("Any2SvmRampExtraArgs", err)
	}
	// Serialize `Any2SvmTokenTransfer`:
	err = encoder.Encode(obj.Any2SvmTokenTransfer)
	if err != nil {
		return errors.NewField("Any2SvmTokenTransfer", err)
	}
	// Serialize `ExecutionReportSingleChain`:
	err = encoder.Encode(obj.ExecutionReportSingleChain)
	if err != nil {
		return errors.NewField("ExecutionReportSingleChain", err)
	}
	// Serialize `CrossChainAmount`:
	err = encoder.Encode(obj.CrossChainAmount)
	if err != nil {
		return errors.NewField("CrossChainAmount", err)
	}
	// Serialize `SvmTokenAmount`:
	err = encoder.Encode(obj.SvmTokenAmount)
	if err != nil {
		return errors.NewField("SvmTokenAmount", err)
	}
	return nil
}

func (obj IdlBuildTypeExport) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding IdlBuildTypeExport: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *IdlBuildTypeExport) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `CommitInput`:
	err = decoder.Decode(&obj.CommitInput)
	if err != nil {
		return errors.NewField("CommitInput", err)
	}
	// Deserialize `TokenPriceUpdate`:
	err = decoder.Decode(&obj.TokenPriceUpdate)
	if err != nil {
		return errors.NewField("TokenPriceUpdate", err)
	}
	// Deserialize `GasPriceUpdate`:
	err = decoder.Decode(&obj.GasPriceUpdate)
	if err != nil {
		return errors.NewField("GasPriceUpdate", err)
	}
	// Deserialize `Any2SvmRampMessage`:
	err = decoder.Decode(&obj.Any2SvmRampMessage)
	if err != nil {
		return errors.NewField("Any2SvmRampMessage", err)
	}
	// Deserialize `RampMessageHeader`:
	err = decoder.Decode(&obj.RampMessageHeader)
	if err != nil {
		return errors.NewField("RampMessageHeader", err)
	}
	// Deserialize `Any2SvmRampExtraArgs`:
	err = decoder.Decode(&obj.Any2SvmRampExtraArgs)
	if err != nil {
		return errors.NewField("Any2SvmRampExtraArgs", err)
	}
	// Deserialize `Any2SvmTokenTransfer`:
	err = decoder.Decode(&obj.Any2SvmTokenTransfer)
	if err != nil {
		return errors.NewField("Any2SvmTokenTransfer", err)
	}
	// Deserialize `ExecutionReportSingleChain`:
	err = decoder.Decode(&obj.ExecutionReportSingleChain)
	if err != nil {
		return errors.NewField("ExecutionReportSingleChain", err)
	}
	// Deserialize `CrossChainAmount`:
	err = decoder.Decode(&obj.CrossChainAmount)
	if err != nil {
		return errors.NewField("CrossChainAmount", err)
	}
	// Deserialize `SvmTokenAmount`:
	err = decoder.Decode(&obj.SvmTokenAmount)
	if err != nil {
		return errors.NewField("SvmTokenAmount", err)
	}
	return nil
}

func (obj *IdlBuildTypeExport) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling IdlBuildTypeExport: %w", err)
	}
	return nil
}

func UnmarshalIdlBuildTypeExport(buf []byte) (*IdlBuildTypeExport, error) {
	obj := new(IdlBuildTypeExport)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Struct to hold a merkle root and an interval for a source chain
type MerkleRoot struct {
	SourceChainSelector uint64    `json:"source_chain_selector"`
	OnRampAddress       []byte    `json:"on_ramp_address"`
	MinSeqNr            uint64    `json:"min_seq_nr"`
	MaxSeqNr            uint64    `json:"max_seq_nr"`
	MerkleRoot          [32]uint8 `json:"merkle_root"`
}

func (obj MerkleRoot) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `SourceChainSelector`:
	err = encoder.Encode(obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Serialize `OnRampAddress`:
	err = encoder.Encode(obj.OnRampAddress)
	if err != nil {
		return errors.NewField("OnRampAddress", err)
	}
	// Serialize `MinSeqNr`:
	err = encoder.Encode(obj.MinSeqNr)
	if err != nil {
		return errors.NewField("MinSeqNr", err)
	}
	// Serialize `MaxSeqNr`:
	err = encoder.Encode(obj.MaxSeqNr)
	if err != nil {
		return errors.NewField("MaxSeqNr", err)
	}
	// Serialize `MerkleRoot`:
	err = encoder.Encode(obj.MerkleRoot)
	if err != nil {
		return errors.NewField("MerkleRoot", err)
	}
	return nil
}

func (obj MerkleRoot) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding MerkleRoot: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *MerkleRoot) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `SourceChainSelector`:
	err = decoder.Decode(&obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Deserialize `OnRampAddress`:
	err = decoder.Decode(&obj.OnRampAddress)
	if err != nil {
		return errors.NewField("OnRampAddress", err)
	}
	// Deserialize `MinSeqNr`:
	err = decoder.Decode(&obj.MinSeqNr)
	if err != nil {
		return errors.NewField("MinSeqNr", err)
	}
	// Deserialize `MaxSeqNr`:
	err = decoder.Decode(&obj.MaxSeqNr)
	if err != nil {
		return errors.NewField("MaxSeqNr", err)
	}
	// Deserialize `MerkleRoot`:
	err = decoder.Decode(&obj.MerkleRoot)
	if err != nil {
		return errors.NewField("MerkleRoot", err)
	}
	return nil
}

func (obj *MerkleRoot) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling MerkleRoot: %w", err)
	}
	return nil
}

func UnmarshalMerkleRoot(buf []byte) (*MerkleRoot, error) {
	obj := new(MerkleRoot)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type MessageExecutionState binary.BorshEnum

const (
	MessageExecutionState_Untouched MessageExecutionState = iota
	MessageExecutionState_InProgress
	MessageExecutionState_Success
	MessageExecutionState_Failure
)

func (value MessageExecutionState) String() string {
	switch value {
	case MessageExecutionState_Untouched:
		return "Untouched"
	case MessageExecutionState_InProgress:
		return "InProgress"
	case MessageExecutionState_Success:
		return "Success"
	case MessageExecutionState_Failure:
		return "Failure"
	default:
		return ""
	}
}

type Ocr3Config struct {
	PluginType   ConfigOcrPluginType `json:"plugin_type"`
	ConfigInfo   Ocr3ConfigInfo      `json:"config_info"`
	Signers      [16][20]uint8       `json:"signers"`
	Transmitters [16][32]uint8       `json:"transmitters"`
}

func (obj Ocr3Config) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `PluginType`:
	err = encoder.Encode(obj.PluginType)
	if err != nil {
		return errors.NewField("PluginType", err)
	}
	// Serialize `ConfigInfo`:
	err = encoder.Encode(obj.ConfigInfo)
	if err != nil {
		return errors.NewField("ConfigInfo", err)
	}
	// Serialize `Signers`:
	err = encoder.Encode(obj.Signers)
	if err != nil {
		return errors.NewField("Signers", err)
	}
	// Serialize `Transmitters`:
	err = encoder.Encode(obj.Transmitters)
	if err != nil {
		return errors.NewField("Transmitters", err)
	}
	return nil
}

func (obj Ocr3Config) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Ocr3Config: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Ocr3Config) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `PluginType`:
	err = decoder.Decode(&obj.PluginType)
	if err != nil {
		return errors.NewField("PluginType", err)
	}
	// Deserialize `ConfigInfo`:
	err = decoder.Decode(&obj.ConfigInfo)
	if err != nil {
		return errors.NewField("ConfigInfo", err)
	}
	// Deserialize `Signers`:
	err = decoder.Decode(&obj.Signers)
	if err != nil {
		return errors.NewField("Signers", err)
	}
	// Deserialize `Transmitters`:
	err = decoder.Decode(&obj.Transmitters)
	if err != nil {
		return errors.NewField("Transmitters", err)
	}
	return nil
}

func (obj *Ocr3Config) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Ocr3Config: %w", err)
	}
	return nil
}

func UnmarshalOcr3Config(buf []byte) (*Ocr3Config, error) {
	obj := new(Ocr3Config)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type Ocr3ConfigInfo struct {
	ConfigDigest                   [32]uint8 `json:"config_digest"`
	F                              uint8     `json:"f"`
	N                              uint8     `json:"n"`
	IsSignatureVerificationEnabled uint8     `json:"is_signature_verification_enabled"`
}

func (obj Ocr3ConfigInfo) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `ConfigDigest`:
	err = encoder.Encode(obj.ConfigDigest)
	if err != nil {
		return errors.NewField("ConfigDigest", err)
	}
	// Serialize `F`:
	err = encoder.Encode(obj.F)
	if err != nil {
		return errors.NewField("F", err)
	}
	// Serialize `N`:
	err = encoder.Encode(obj.N)
	if err != nil {
		return errors.NewField("N", err)
	}
	// Serialize `IsSignatureVerificationEnabled`:
	err = encoder.Encode(obj.IsSignatureVerificationEnabled)
	if err != nil {
		return errors.NewField("IsSignatureVerificationEnabled", err)
	}
	return nil
}

func (obj Ocr3ConfigInfo) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Ocr3ConfigInfo: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Ocr3ConfigInfo) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `ConfigDigest`:
	err = decoder.Decode(&obj.ConfigDigest)
	if err != nil {
		return errors.NewField("ConfigDigest", err)
	}
	// Deserialize `F`:
	err = decoder.Decode(&obj.F)
	if err != nil {
		return errors.NewField("F", err)
	}
	// Deserialize `N`:
	err = decoder.Decode(&obj.N)
	if err != nil {
		return errors.NewField("N", err)
	}
	// Deserialize `IsSignatureVerificationEnabled`:
	err = decoder.Decode(&obj.IsSignatureVerificationEnabled)
	if err != nil {
		return errors.NewField("IsSignatureVerificationEnabled", err)
	}
	return nil
}

func (obj *Ocr3ConfigInfo) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Ocr3ConfigInfo: %w", err)
	}
	return nil
}

func UnmarshalOcr3ConfigInfo(buf []byte) (*Ocr3ConfigInfo, error) {
	obj := new(Ocr3ConfigInfo)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Input struct for instruction parameters (non-zero_copy, uses Borsh serialization)
type Ocr3ConfigInfoInput struct {
	ConfigDigest                   [32]uint8 `json:"config_digest"`
	F                              uint8     `json:"f"`
	N                              uint8     `json:"n"`
	IsSignatureVerificationEnabled uint8     `json:"is_signature_verification_enabled"`
}

func (obj Ocr3ConfigInfoInput) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `ConfigDigest`:
	err = encoder.Encode(obj.ConfigDigest)
	if err != nil {
		return errors.NewField("ConfigDigest", err)
	}
	// Serialize `F`:
	err = encoder.Encode(obj.F)
	if err != nil {
		return errors.NewField("F", err)
	}
	// Serialize `N`:
	err = encoder.Encode(obj.N)
	if err != nil {
		return errors.NewField("N", err)
	}
	// Serialize `IsSignatureVerificationEnabled`:
	err = encoder.Encode(obj.IsSignatureVerificationEnabled)
	if err != nil {
		return errors.NewField("IsSignatureVerificationEnabled", err)
	}
	return nil
}

func (obj Ocr3ConfigInfoInput) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Ocr3ConfigInfoInput: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Ocr3ConfigInfoInput) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `ConfigDigest`:
	err = decoder.Decode(&obj.ConfigDigest)
	if err != nil {
		return errors.NewField("ConfigDigest", err)
	}
	// Deserialize `F`:
	err = decoder.Decode(&obj.F)
	if err != nil {
		return errors.NewField("F", err)
	}
	// Deserialize `N`:
	err = decoder.Decode(&obj.N)
	if err != nil {
		return errors.NewField("N", err)
	}
	// Deserialize `IsSignatureVerificationEnabled`:
	err = decoder.Decode(&obj.IsSignatureVerificationEnabled)
	if err != nil {
		return errors.NewField("IsSignatureVerificationEnabled", err)
	}
	return nil
}

func (obj *Ocr3ConfigInfoInput) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Ocr3ConfigInfoInput: %w", err)
	}
	return nil
}

func UnmarshalOcr3ConfigInfoInput(buf []byte) (*Ocr3ConfigInfoInput, error) {
	obj := new(Ocr3ConfigInfoInput)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type Ocr3ConfigSet struct {
	OcrPluginType OcrPluginType        `json:"ocr_plugin_type"`
	ConfigDigest  [32]uint8            `json:"config_digest"`
	Signers       [][20]uint8          `json:"signers"`
	Transmitters  []solanago.PublicKey `json:"transmitters"`
	F             uint8                `json:"f"`
}

func (obj Ocr3ConfigSet) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `OcrPluginType`:
	err = encoder.Encode(obj.OcrPluginType)
	if err != nil {
		return errors.NewField("OcrPluginType", err)
	}
	// Serialize `ConfigDigest`:
	err = encoder.Encode(obj.ConfigDigest)
	if err != nil {
		return errors.NewField("ConfigDigest", err)
	}
	// Serialize `Signers`:
	err = encoder.Encode(obj.Signers)
	if err != nil {
		return errors.NewField("Signers", err)
	}
	// Serialize `Transmitters`:
	err = encoder.Encode(obj.Transmitters)
	if err != nil {
		return errors.NewField("Transmitters", err)
	}
	// Serialize `F`:
	err = encoder.Encode(obj.F)
	if err != nil {
		return errors.NewField("F", err)
	}
	return nil
}

func (obj Ocr3ConfigSet) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Ocr3ConfigSet: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Ocr3ConfigSet) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `OcrPluginType`:
	err = decoder.Decode(&obj.OcrPluginType)
	if err != nil {
		return errors.NewField("OcrPluginType", err)
	}
	// Deserialize `ConfigDigest`:
	err = decoder.Decode(&obj.ConfigDigest)
	if err != nil {
		return errors.NewField("ConfigDigest", err)
	}
	// Deserialize `Signers`:
	err = decoder.Decode(&obj.Signers)
	if err != nil {
		return errors.NewField("Signers", err)
	}
	// Deserialize `Transmitters`:
	err = decoder.Decode(&obj.Transmitters)
	if err != nil {
		return errors.NewField("Transmitters", err)
	}
	// Deserialize `F`:
	err = decoder.Decode(&obj.F)
	if err != nil {
		return errors.NewField("F", err)
	}
	return nil
}

func (obj *Ocr3ConfigSet) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Ocr3ConfigSet: %w", err)
	}
	return nil
}

func UnmarshalOcr3ConfigSet(buf []byte) (*Ocr3ConfigSet, error) {
	obj := new(Ocr3ConfigSet)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type OcrPluginType binary.BorshEnum

const (
	OcrPluginType_Commit OcrPluginType = iota
	OcrPluginType_Execution
)

func (value OcrPluginType) String() string {
	switch value {
	case OcrPluginType_Commit:
		return "Commit"
	case OcrPluginType_Execution:
		return "Execution"
	default:
		return ""
	}
}

type OnRampAddress struct {
	Bytes [64]uint8 `json:"bytes"`
	Len   uint32    `json:"len"`
}

func (obj OnRampAddress) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Bytes`:
	err = encoder.Encode(obj.Bytes)
	if err != nil {
		return errors.NewField("Bytes", err)
	}
	// Serialize `Len`:
	err = encoder.Encode(obj.Len)
	if err != nil {
		return errors.NewField("Len", err)
	}
	return nil
}

func (obj OnRampAddress) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding OnRampAddress: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *OnRampAddress) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Bytes`:
	err = decoder.Decode(&obj.Bytes)
	if err != nil {
		return errors.NewField("Bytes", err)
	}
	// Deserialize `Len`:
	err = decoder.Decode(&obj.Len)
	if err != nil {
		return errors.NewField("Len", err)
	}
	return nil
}

func (obj *OnRampAddress) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling OnRampAddress: %w", err)
	}
	return nil
}

func UnmarshalOnRampAddress(buf []byte) (*OnRampAddress, error) {
	obj := new(OnRampAddress)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type OwnershipTransferRequested struct {
	From solanago.PublicKey `json:"from"`
	To   solanago.PublicKey `json:"to"`
}

func (obj OwnershipTransferRequested) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `From`:
	err = encoder.Encode(obj.From)
	if err != nil {
		return errors.NewField("From", err)
	}
	// Serialize `To`:
	err = encoder.Encode(obj.To)
	if err != nil {
		return errors.NewField("To", err)
	}
	return nil
}

func (obj OwnershipTransferRequested) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding OwnershipTransferRequested: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *OwnershipTransferRequested) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `From`:
	err = decoder.Decode(&obj.From)
	if err != nil {
		return errors.NewField("From", err)
	}
	// Deserialize `To`:
	err = decoder.Decode(&obj.To)
	if err != nil {
		return errors.NewField("To", err)
	}
	return nil
}

func (obj *OwnershipTransferRequested) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling OwnershipTransferRequested: %w", err)
	}
	return nil
}

func UnmarshalOwnershipTransferRequested(buf []byte) (*OwnershipTransferRequested, error) {
	obj := new(OwnershipTransferRequested)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type OwnershipTransferred struct {
	From solanago.PublicKey `json:"from"`
	To   solanago.PublicKey `json:"to"`
}

func (obj OwnershipTransferred) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `From`:
	err = encoder.Encode(obj.From)
	if err != nil {
		return errors.NewField("From", err)
	}
	// Serialize `To`:
	err = encoder.Encode(obj.To)
	if err != nil {
		return errors.NewField("To", err)
	}
	return nil
}

func (obj OwnershipTransferred) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding OwnershipTransferred: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *OwnershipTransferred) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `From`:
	err = decoder.Decode(&obj.From)
	if err != nil {
		return errors.NewField("From", err)
	}
	// Deserialize `To`:
	err = decoder.Decode(&obj.To)
	if err != nil {
		return errors.NewField("To", err)
	}
	return nil
}

func (obj *OwnershipTransferred) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling OwnershipTransferred: %w", err)
	}
	return nil
}

func UnmarshalOwnershipTransferred(buf []byte) (*OwnershipTransferred, error) {
	obj := new(OwnershipTransferred)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type PriceUpdates struct {
	TokenPriceUpdates []TokenPriceUpdate `json:"token_price_updates"`
	GasPriceUpdates   []GasPriceUpdate   `json:"gas_price_updates"`
}

func (obj PriceUpdates) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `TokenPriceUpdates`:
	err = encoder.Encode(obj.TokenPriceUpdates)
	if err != nil {
		return errors.NewField("TokenPriceUpdates", err)
	}
	// Serialize `GasPriceUpdates`:
	err = encoder.Encode(obj.GasPriceUpdates)
	if err != nil {
		return errors.NewField("GasPriceUpdates", err)
	}
	return nil
}

func (obj PriceUpdates) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding PriceUpdates: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *PriceUpdates) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `TokenPriceUpdates`:
	err = decoder.Decode(&obj.TokenPriceUpdates)
	if err != nil {
		return errors.NewField("TokenPriceUpdates", err)
	}
	// Deserialize `GasPriceUpdates`:
	err = decoder.Decode(&obj.GasPriceUpdates)
	if err != nil {
		return errors.NewField("GasPriceUpdates", err)
	}
	return nil
}

func (obj *PriceUpdates) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling PriceUpdates: %w", err)
	}
	return nil
}

func UnmarshalPriceUpdates(buf []byte) (*PriceUpdates, error) {
	obj := new(PriceUpdates)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type RampMessageHeader struct {
	MessageId           [32]uint8 `json:"message_id"`
	SourceChainSelector uint64    `json:"source_chain_selector"`
	DestChainSelector   uint64    `json:"dest_chain_selector"`
	SequenceNumber      uint64    `json:"sequence_number"`
	Nonce               uint64    `json:"nonce"`
}

func (obj RampMessageHeader) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `MessageId`:
	err = encoder.Encode(obj.MessageId)
	if err != nil {
		return errors.NewField("MessageId", err)
	}
	// Serialize `SourceChainSelector`:
	err = encoder.Encode(obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Serialize `DestChainSelector`:
	err = encoder.Encode(obj.DestChainSelector)
	if err != nil {
		return errors.NewField("DestChainSelector", err)
	}
	// Serialize `SequenceNumber`:
	err = encoder.Encode(obj.SequenceNumber)
	if err != nil {
		return errors.NewField("SequenceNumber", err)
	}
	// Serialize `Nonce`:
	err = encoder.Encode(obj.Nonce)
	if err != nil {
		return errors.NewField("Nonce", err)
	}
	return nil
}

func (obj RampMessageHeader) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding RampMessageHeader: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *RampMessageHeader) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `MessageId`:
	err = decoder.Decode(&obj.MessageId)
	if err != nil {
		return errors.NewField("MessageId", err)
	}
	// Deserialize `SourceChainSelector`:
	err = decoder.Decode(&obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Deserialize `DestChainSelector`:
	err = decoder.Decode(&obj.DestChainSelector)
	if err != nil {
		return errors.NewField("DestChainSelector", err)
	}
	// Deserialize `SequenceNumber`:
	err = decoder.Decode(&obj.SequenceNumber)
	if err != nil {
		return errors.NewField("SequenceNumber", err)
	}
	// Deserialize `Nonce`:
	err = decoder.Decode(&obj.Nonce)
	if err != nil {
		return errors.NewField("Nonce", err)
	}
	return nil
}

func (obj *RampMessageHeader) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling RampMessageHeader: %w", err)
	}
	return nil
}

func UnmarshalRampMessageHeader(buf []byte) (*RampMessageHeader, error) {
	obj := new(RampMessageHeader)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ReferenceAddresses struct {
	Version            uint8              `json:"version"`
	Router             solanago.PublicKey `json:"router"`
	FeeQuoter          solanago.PublicKey `json:"fee_quoter"`
	OfframpLookupTable solanago.PublicKey `json:"offramp_lookup_table"`
	RmnRemote          solanago.PublicKey `json:"rmn_remote"`
}

func (obj ReferenceAddresses) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Version`:
	err = encoder.Encode(obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Serialize `Router`:
	err = encoder.Encode(obj.Router)
	if err != nil {
		return errors.NewField("Router", err)
	}
	// Serialize `FeeQuoter`:
	err = encoder.Encode(obj.FeeQuoter)
	if err != nil {
		return errors.NewField("FeeQuoter", err)
	}
	// Serialize `OfframpLookupTable`:
	err = encoder.Encode(obj.OfframpLookupTable)
	if err != nil {
		return errors.NewField("OfframpLookupTable", err)
	}
	// Serialize `RmnRemote`:
	err = encoder.Encode(obj.RmnRemote)
	if err != nil {
		return errors.NewField("RmnRemote", err)
	}
	return nil
}

func (obj ReferenceAddresses) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding ReferenceAddresses: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *ReferenceAddresses) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Version`:
	err = decoder.Decode(&obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Deserialize `Router`:
	err = decoder.Decode(&obj.Router)
	if err != nil {
		return errors.NewField("Router", err)
	}
	// Deserialize `FeeQuoter`:
	err = decoder.Decode(&obj.FeeQuoter)
	if err != nil {
		return errors.NewField("FeeQuoter", err)
	}
	// Deserialize `OfframpLookupTable`:
	err = decoder.Decode(&obj.OfframpLookupTable)
	if err != nil {
		return errors.NewField("OfframpLookupTable", err)
	}
	// Deserialize `RmnRemote`:
	err = decoder.Decode(&obj.RmnRemote)
	if err != nil {
		return errors.NewField("RmnRemote", err)
	}
	return nil
}

func (obj *ReferenceAddresses) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ReferenceAddresses: %w", err)
	}
	return nil
}

func UnmarshalReferenceAddresses(buf []byte) (*ReferenceAddresses, error) {
	obj := new(ReferenceAddresses)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ReferenceAddressesSet struct {
	Router             solanago.PublicKey `json:"router"`
	FeeQuoter          solanago.PublicKey `json:"fee_quoter"`
	OfframpLookupTable solanago.PublicKey `json:"offramp_lookup_table"`
	RmnRemote          solanago.PublicKey `json:"rmn_remote"`
}

func (obj ReferenceAddressesSet) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Router`:
	err = encoder.Encode(obj.Router)
	if err != nil {
		return errors.NewField("Router", err)
	}
	// Serialize `FeeQuoter`:
	err = encoder.Encode(obj.FeeQuoter)
	if err != nil {
		return errors.NewField("FeeQuoter", err)
	}
	// Serialize `OfframpLookupTable`:
	err = encoder.Encode(obj.OfframpLookupTable)
	if err != nil {
		return errors.NewField("OfframpLookupTable", err)
	}
	// Serialize `RmnRemote`:
	err = encoder.Encode(obj.RmnRemote)
	if err != nil {
		return errors.NewField("RmnRemote", err)
	}
	return nil
}

func (obj ReferenceAddressesSet) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding ReferenceAddressesSet: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *ReferenceAddressesSet) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Router`:
	err = decoder.Decode(&obj.Router)
	if err != nil {
		return errors.NewField("Router", err)
	}
	// Deserialize `FeeQuoter`:
	err = decoder.Decode(&obj.FeeQuoter)
	if err != nil {
		return errors.NewField("FeeQuoter", err)
	}
	// Deserialize `OfframpLookupTable`:
	err = decoder.Decode(&obj.OfframpLookupTable)
	if err != nil {
		return errors.NewField("OfframpLookupTable", err)
	}
	// Deserialize `RmnRemote`:
	err = decoder.Decode(&obj.RmnRemote)
	if err != nil {
		return errors.NewField("RmnRemote", err)
	}
	return nil
}

func (obj *ReferenceAddressesSet) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ReferenceAddressesSet: %w", err)
	}
	return nil
}

func UnmarshalReferenceAddressesSet(buf []byte) (*ReferenceAddressesSet, error) {
	obj := new(ReferenceAddressesSet)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SvmTokenAmount struct {
	Token  solanago.PublicKey `json:"token"`
	Amount uint64             `json:"amount"`
}

func (obj SvmTokenAmount) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Token`:
	err = encoder.Encode(obj.Token)
	if err != nil {
		return errors.NewField("Token", err)
	}
	// Serialize `Amount`:
	err = encoder.Encode(obj.Amount)
	if err != nil {
		return errors.NewField("Amount", err)
	}
	return nil
}

func (obj SvmTokenAmount) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding SvmTokenAmount: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *SvmTokenAmount) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Token`:
	err = decoder.Decode(&obj.Token)
	if err != nil {
		return errors.NewField("Token", err)
	}
	// Deserialize `Amount`:
	err = decoder.Decode(&obj.Amount)
	if err != nil {
		return errors.NewField("Amount", err)
	}
	return nil
}

func (obj *SvmTokenAmount) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SvmTokenAmount: %w", err)
	}
	return nil
}

func UnmarshalSvmTokenAmount(buf []byte) (*SvmTokenAmount, error) {
	obj := new(SvmTokenAmount)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SkippedAlreadyExecutedMessage struct {
	SourceChainSelector uint64 `json:"source_chain_selector"`
	SequenceNumber      uint64 `json:"sequence_number"`
}

func (obj SkippedAlreadyExecutedMessage) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `SourceChainSelector`:
	err = encoder.Encode(obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Serialize `SequenceNumber`:
	err = encoder.Encode(obj.SequenceNumber)
	if err != nil {
		return errors.NewField("SequenceNumber", err)
	}
	return nil
}

func (obj SkippedAlreadyExecutedMessage) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding SkippedAlreadyExecutedMessage: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *SkippedAlreadyExecutedMessage) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `SourceChainSelector`:
	err = decoder.Decode(&obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Deserialize `SequenceNumber`:
	err = decoder.Decode(&obj.SequenceNumber)
	if err != nil {
		return errors.NewField("SequenceNumber", err)
	}
	return nil
}

func (obj *SkippedAlreadyExecutedMessage) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SkippedAlreadyExecutedMessage: %w", err)
	}
	return nil
}

func UnmarshalSkippedAlreadyExecutedMessage(buf []byte) (*SkippedAlreadyExecutedMessage, error) {
	obj := new(SkippedAlreadyExecutedMessage)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SourceChain struct {
	Version       uint8             `json:"version"`
	ChainSelector uint64            `json:"chain_selector"`
	State         SourceChainState  `json:"state"`
	Config        SourceChainConfig `json:"config"`
}

func (obj SourceChain) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Version`:
	err = encoder.Encode(obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Serialize `ChainSelector`:
	err = encoder.Encode(obj.ChainSelector)
	if err != nil {
		return errors.NewField("ChainSelector", err)
	}
	// Serialize `State`:
	err = encoder.Encode(obj.State)
	if err != nil {
		return errors.NewField("State", err)
	}
	// Serialize `Config`:
	err = encoder.Encode(obj.Config)
	if err != nil {
		return errors.NewField("Config", err)
	}
	return nil
}

func (obj SourceChain) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding SourceChain: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *SourceChain) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Version`:
	err = decoder.Decode(&obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	// Deserialize `ChainSelector`:
	err = decoder.Decode(&obj.ChainSelector)
	if err != nil {
		return errors.NewField("ChainSelector", err)
	}
	// Deserialize `State`:
	err = decoder.Decode(&obj.State)
	if err != nil {
		return errors.NewField("State", err)
	}
	// Deserialize `Config`:
	err = decoder.Decode(&obj.Config)
	if err != nil {
		return errors.NewField("Config", err)
	}
	return nil
}

func (obj *SourceChain) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SourceChain: %w", err)
	}
	return nil
}

func UnmarshalSourceChain(buf []byte) (*SourceChain, error) {
	obj := new(SourceChain)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SourceChainAdded struct {
	SourceChainSelector uint64            `json:"source_chain_selector"`
	SourceChainConfig   SourceChainConfig `json:"source_chain_config"`
}

func (obj SourceChainAdded) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `SourceChainSelector`:
	err = encoder.Encode(obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Serialize `SourceChainConfig`:
	err = encoder.Encode(obj.SourceChainConfig)
	if err != nil {
		return errors.NewField("SourceChainConfig", err)
	}
	return nil
}

func (obj SourceChainAdded) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding SourceChainAdded: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *SourceChainAdded) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `SourceChainSelector`:
	err = decoder.Decode(&obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Deserialize `SourceChainConfig`:
	err = decoder.Decode(&obj.SourceChainConfig)
	if err != nil {
		return errors.NewField("SourceChainConfig", err)
	}
	return nil
}

func (obj *SourceChainAdded) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SourceChainAdded: %w", err)
	}
	return nil
}

func UnmarshalSourceChainAdded(buf []byte) (*SourceChainAdded, error) {
	obj := new(SourceChainAdded)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SourceChainConfig struct {
	IsEnabled                 bool          `json:"is_enabled"`
	IsRmnVerificationDisabled bool          `json:"is_rmn_verification_disabled"`
	LaneCodeVersion           CodeVersion   `json:"lane_code_version"`
	OnRamp                    OnRampAddress `json:"on_ramp"`
}

func (obj SourceChainConfig) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `IsEnabled`:
	err = encoder.Encode(obj.IsEnabled)
	if err != nil {
		return errors.NewField("IsEnabled", err)
	}
	// Serialize `IsRmnVerificationDisabled`:
	err = encoder.Encode(obj.IsRmnVerificationDisabled)
	if err != nil {
		return errors.NewField("IsRmnVerificationDisabled", err)
	}
	// Serialize `LaneCodeVersion`:
	err = encoder.Encode(obj.LaneCodeVersion)
	if err != nil {
		return errors.NewField("LaneCodeVersion", err)
	}
	// Serialize `OnRamp`:
	err = encoder.Encode(obj.OnRamp)
	if err != nil {
		return errors.NewField("OnRamp", err)
	}
	return nil
}

func (obj SourceChainConfig) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding SourceChainConfig: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *SourceChainConfig) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `IsEnabled`:
	err = decoder.Decode(&obj.IsEnabled)
	if err != nil {
		return errors.NewField("IsEnabled", err)
	}
	// Deserialize `IsRmnVerificationDisabled`:
	err = decoder.Decode(&obj.IsRmnVerificationDisabled)
	if err != nil {
		return errors.NewField("IsRmnVerificationDisabled", err)
	}
	// Deserialize `LaneCodeVersion`:
	err = decoder.Decode(&obj.LaneCodeVersion)
	if err != nil {
		return errors.NewField("LaneCodeVersion", err)
	}
	// Deserialize `OnRamp`:
	err = decoder.Decode(&obj.OnRamp)
	if err != nil {
		return errors.NewField("OnRamp", err)
	}
	return nil
}

func (obj *SourceChainConfig) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SourceChainConfig: %w", err)
	}
	return nil
}

func UnmarshalSourceChainConfig(buf []byte) (*SourceChainConfig, error) {
	obj := new(SourceChainConfig)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SourceChainConfigUpdated struct {
	SourceChainSelector uint64            `json:"source_chain_selector"`
	SourceChainConfig   SourceChainConfig `json:"source_chain_config"`
}

func (obj SourceChainConfigUpdated) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `SourceChainSelector`:
	err = encoder.Encode(obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Serialize `SourceChainConfig`:
	err = encoder.Encode(obj.SourceChainConfig)
	if err != nil {
		return errors.NewField("SourceChainConfig", err)
	}
	return nil
}

func (obj SourceChainConfigUpdated) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding SourceChainConfigUpdated: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *SourceChainConfigUpdated) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `SourceChainSelector`:
	err = decoder.Decode(&obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Deserialize `SourceChainConfig`:
	err = decoder.Decode(&obj.SourceChainConfig)
	if err != nil {
		return errors.NewField("SourceChainConfig", err)
	}
	return nil
}

func (obj *SourceChainConfigUpdated) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SourceChainConfigUpdated: %w", err)
	}
	return nil
}

func UnmarshalSourceChainConfigUpdated(buf []byte) (*SourceChainConfigUpdated, error) {
	obj := new(SourceChainConfigUpdated)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SourceChainState struct {
	MinSeqNr uint64 `json:"min_seq_nr"`
}

func (obj SourceChainState) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `MinSeqNr`:
	err = encoder.Encode(obj.MinSeqNr)
	if err != nil {
		return errors.NewField("MinSeqNr", err)
	}
	return nil
}

func (obj SourceChainState) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding SourceChainState: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *SourceChainState) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `MinSeqNr`:
	err = decoder.Decode(&obj.MinSeqNr)
	if err != nil {
		return errors.NewField("MinSeqNr", err)
	}
	return nil
}

func (obj *SourceChainState) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SourceChainState: %w", err)
	}
	return nil
}

func UnmarshalSourceChainState(buf []byte) (*SourceChainState, error) {
	obj := new(SourceChainState)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type TokenPriceUpdate struct {
	SourceToken solanago.PublicKey `json:"source_token"`
	UsdPerToken [28]uint8          `json:"usd_per_token"`
}

func (obj TokenPriceUpdate) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `SourceToken`:
	err = encoder.Encode(obj.SourceToken)
	if err != nil {
		return errors.NewField("SourceToken", err)
	}
	// Serialize `UsdPerToken`:
	err = encoder.Encode(obj.UsdPerToken)
	if err != nil {
		return errors.NewField("UsdPerToken", err)
	}
	return nil
}

func (obj TokenPriceUpdate) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding TokenPriceUpdate: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *TokenPriceUpdate) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `SourceToken`:
	err = decoder.Decode(&obj.SourceToken)
	if err != nil {
		return errors.NewField("SourceToken", err)
	}
	// Deserialize `UsdPerToken`:
	err = decoder.Decode(&obj.UsdPerToken)
	if err != nil {
		return errors.NewField("UsdPerToken", err)
	}
	return nil
}

func (obj *TokenPriceUpdate) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling TokenPriceUpdate: %w", err)
	}
	return nil
}

func UnmarshalTokenPriceUpdate(buf []byte) (*TokenPriceUpdate, error) {
	obj := new(TokenPriceUpdate)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type TokenTransferAndOffchainData struct {
	Transfer Any2SvmTokenTransfer `json:"transfer"`
	Data     []byte               `json:"data"`
}

func (obj TokenTransferAndOffchainData) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Transfer`:
	err = encoder.Encode(obj.Transfer)
	if err != nil {
		return errors.NewField("Transfer", err)
	}
	// Serialize `Data`:
	err = encoder.Encode(obj.Data)
	if err != nil {
		return errors.NewField("Data", err)
	}
	return nil
}

func (obj TokenTransferAndOffchainData) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding TokenTransferAndOffchainData: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *TokenTransferAndOffchainData) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Transfer`:
	err = decoder.Decode(&obj.Transfer)
	if err != nil {
		return errors.NewField("Transfer", err)
	}
	// Deserialize `Data`:
	err = decoder.Decode(&obj.Data)
	if err != nil {
		return errors.NewField("Data", err)
	}
	return nil
}

func (obj *TokenTransferAndOffchainData) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling TokenTransferAndOffchainData: %w", err)
	}
	return nil
}

func UnmarshalTokenTransferAndOffchainData(buf []byte) (*TokenTransferAndOffchainData, error) {
	obj := new(TokenTransferAndOffchainData)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type Transmitted struct {
	OcrPluginType  OcrPluginType `json:"ocr_plugin_type"`
	ConfigDigest   [32]uint8     `json:"config_digest"`
	SequenceNumber uint64        `json:"sequence_number"`
}

func (obj Transmitted) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `OcrPluginType`:
	err = encoder.Encode(obj.OcrPluginType)
	if err != nil {
		return errors.NewField("OcrPluginType", err)
	}
	// Serialize `ConfigDigest`:
	err = encoder.Encode(obj.ConfigDigest)
	if err != nil {
		return errors.NewField("ConfigDigest", err)
	}
	// Serialize `SequenceNumber`:
	err = encoder.Encode(obj.SequenceNumber)
	if err != nil {
		return errors.NewField("SequenceNumber", err)
	}
	return nil
}

func (obj Transmitted) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Transmitted: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Transmitted) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `OcrPluginType`:
	err = decoder.Decode(&obj.OcrPluginType)
	if err != nil {
		return errors.NewField("OcrPluginType", err)
	}
	// Deserialize `ConfigDigest`:
	err = decoder.Decode(&obj.ConfigDigest)
	if err != nil {
		return errors.NewField("ConfigDigest", err)
	}
	// Deserialize `SequenceNumber`:
	err = decoder.Decode(&obj.SequenceNumber)
	if err != nil {
		return errors.NewField("SequenceNumber", err)
	}
	return nil
}

func (obj *Transmitted) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Transmitted: %w", err)
	}
	return nil
}

func UnmarshalTransmitted(buf []byte) (*Transmitted, error) {
	obj := new(Transmitted)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}
