// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains instructions.

package example_ccip_receiver

import (
	"bytes"
	"fmt"
	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "accept_ownership" instruction.
func NewAcceptOwnershipInstruction(
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "approve_sender" instruction.
func NewApproveSenderInstruction(
	// Params:
	chainSelectorParam uint64,
	remoteAddressParam []byte,

	// Accounts:
	stateAccount solanago.PublicKey,
	approvedSenderAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ApproveSender[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `chainSelectorParam`:
		err = enc__.Encode(chainSelectorParam)
		if err != nil {
			return nil, errors.NewField("chainSelectorParam", err)
		}
		// Serialize `remoteAddressParam`:
		err = enc__.Encode(remoteAddressParam)
		if err != nil {
			return nil, errors.NewField("remoteAddressParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "approved_sender": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(approvedSenderAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "ccip_receive" instruction.
// This function is called by the CCIP Offramp to execute the CCIP message. // The method name needs to be ccip_receive with Anchor encoding, // if not using Anchor the discriminator needs to be [0x0b, 0xf4, 0x09, 0xf9, 0x2c, 0x53, 0x2f, 0xf5] // You can send as many accounts as you need, specifying if mutable or not. // But none of them could be an init, realloc or close.
func NewCcipReceiveInstruction(
	// Params:
	messageParam Any2SvmMessage,

	// Accounts:
	authorityAccount solanago.PublicKey,
	offrampProgramAccount solanago.PublicKey,
	allowedOfframpAccount solanago.PublicKey,
	approvedSenderAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CcipReceive[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `messageParam`:
		err = enc__.Encode(messageParam)
		if err != nil {
			return nil, errors.NewField("messageParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 1 "offramp_program": Read-only, Non-signer, Required
		// CHECK offramp program: exists only to derive the allowed offramp PDA
		// and the authority PDA. Must be second.
		accounts__.Append(solanago.NewAccountMeta(offrampProgramAccount, false, false))
		// Account 2 "allowed_offramp": Read-only, Non-signer, Required
		// CHECK PDA of the router program verifying the signer is an allowed offramp.
		// If PDA does not exist, the router doesn't allow this offramp
		accounts__.Append(solanago.NewAccountMeta(allowedOfframpAccount, false, false))
		// Account 3 "approved_sender": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(approvedSenderAccount, false, false))
		// Account 4 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize" instruction.
// The initialization is responsibility of the External User, CCIP is not handling initialization of Accounts
func NewInitializeInstruction(
	// Params:
	routerParam solanago.PublicKey,

	// Accounts:
	stateAccount solanago.PublicKey,
	tokenAdminAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Initialize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `routerParam`:
		err = enc__.Encode(routerParam)
		if err != nil {
			return nil, errors.NewField("routerParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "token_admin": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenAdminAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "transfer_ownership" instruction.
func NewTransferOwnershipInstruction(
	// Params:
	proposedOwnerParam solanago.PublicKey,

	// Accounts:
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_TransferOwnership[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `proposedOwnerParam`:
		err = enc__.Encode(proposedOwnerParam)
		if err != nil {
			return nil, errors.NewField("proposedOwnerParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "unapprove_sender" instruction.
func NewUnapproveSenderInstruction(
	// Params:
	chainSelectorParam uint64,
	remoteAddressParam []byte,

	// Accounts:
	stateAccount solanago.PublicKey,
	approvedSenderAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UnapproveSender[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `chainSelectorParam`:
		err = enc__.Encode(chainSelectorParam)
		if err != nil {
			return nil, errors.NewField("chainSelectorParam", err)
		}
		// Serialize `remoteAddressParam`:
		err = enc__.Encode(remoteAddressParam)
		if err != nil {
			return nil, errors.NewField("remoteAddressParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "approved_sender": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(approvedSenderAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_router" instruction.
func NewUpdateRouterInstruction(
	// Params:
	newRouterParam solanago.PublicKey,

	// Accounts:
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateRouter[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newRouterParam`:
		err = enc__.Encode(newRouterParam)
		if err != nil {
			return nil, errors.NewField("newRouterParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "withdraw_tokens" instruction.
func NewWithdrawTokensInstruction(
	// Params:
	amountParam uint64,
	decimalsParam uint8,

	// Accounts:
	stateAccount solanago.PublicKey,
	programTokenAccountAccount solanago.PublicKey,
	toTokenAccountAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	tokenAdminAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_WithdrawTokens[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `amountParam`:
		err = enc__.Encode(amountParam)
		if err != nil {
			return nil, errors.NewField("amountParam", err)
		}
		// Serialize `decimalsParam`:
		err = enc__.Encode(decimalsParam)
		if err != nil {
			return nil, errors.NewField("decimalsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "program_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programTokenAccountAccount, true, false))
		// Account 2 "to_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(toTokenAccountAccount, true, false))
		// Account 3 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 4 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 5 "token_admin": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenAdminAccount, false, false))
		// Account 6 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}
