// Code generated by https://github.com/Unheilbar/anchor-go. DO NOT EDIT.
// This file contains instructions and instruction parsers.

package example_ccip_receiver

import (
	"bytes"
	"fmt"
	errors "github.com/Unheilbar/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "accept_ownership" instruction.
func NewAcceptOwnershipInstruction(
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AcceptOwnership[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "approve_sender" instruction.
func NewApproveSenderInstruction(
	// Params:
	chainSelectorParam uint64,
	remoteAddressParam []byte,

	// Accounts:
	stateAccount solanago.PublicKey,
	approvedSenderAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ApproveSender[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `chainSelectorParam`:
		err = enc__.Encode(chainSelectorParam)
		if err != nil {
			return nil, errors.NewField("chainSelectorParam", err)
		}
		// Serialize `remoteAddressParam`:
		err = enc__.Encode(remoteAddressParam)
		if err != nil {
			return nil, errors.NewField("remoteAddressParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "approved_sender": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(approvedSenderAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "ccip_receive" instruction.
// This function is called by the CCIP Offramp to execute the CCIP message. // The method name needs to be ccip_receive with Anchor encoding, // if not using Anchor the discriminator needs to be [0x0b, 0xf4, 0x09, 0xf9, 0x2c, 0x53, 0x2f, 0xf5] // You can send as many accounts as you need, specifying if mutable or not. // But none of them could be an init, realloc or close.
func NewCcipReceiveInstruction(
	// Params:
	messageParam Any2SvmMessage,

	// Accounts:
	authorityAccount solanago.PublicKey,
	offrampProgramAccount solanago.PublicKey,
	allowedOfframpAccount solanago.PublicKey,
	approvedSenderAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CcipReceive[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `messageParam`:
		err = enc__.Encode(messageParam)
		if err != nil {
			return nil, errors.NewField("messageParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 1 "offramp_program": Read-only, Non-signer, Required
		// CHECK offramp program: exists only to derive the allowed offramp PDA
		// and the authority PDA. Must be second.
		accounts__.Append(solanago.NewAccountMeta(offrampProgramAccount, false, false))
		// Account 2 "allowed_offramp": Read-only, Non-signer, Required
		// CHECK PDA of the router program verifying the signer is an allowed offramp.
		// If PDA does not exist, the router doesn't allow this offramp
		accounts__.Append(solanago.NewAccountMeta(allowedOfframpAccount, false, false))
		// Account 3 "approved_sender": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(approvedSenderAccount, false, false))
		// Account 4 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize" instruction.
// The initialization is responsibility of the External User, CCIP is not handling initialization of Accounts
func NewInitializeInstruction(
	// Params:
	routerParam solanago.PublicKey,

	// Accounts:
	stateAccount solanago.PublicKey,
	tokenAdminAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Initialize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `routerParam`:
		err = enc__.Encode(routerParam)
		if err != nil {
			return nil, errors.NewField("routerParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "token_admin": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenAdminAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "transfer_ownership" instruction.
func NewTransferOwnershipInstruction(
	// Params:
	proposedOwnerParam solanago.PublicKey,

	// Accounts:
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_TransferOwnership[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `proposedOwnerParam`:
		err = enc__.Encode(proposedOwnerParam)
		if err != nil {
			return nil, errors.NewField("proposedOwnerParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "unapprove_sender" instruction.
func NewUnapproveSenderInstruction(
	// Params:
	chainSelectorParam uint64,
	remoteAddressParam []byte,

	// Accounts:
	stateAccount solanago.PublicKey,
	approvedSenderAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UnapproveSender[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `chainSelectorParam`:
		err = enc__.Encode(chainSelectorParam)
		if err != nil {
			return nil, errors.NewField("chainSelectorParam", err)
		}
		// Serialize `remoteAddressParam`:
		err = enc__.Encode(remoteAddressParam)
		if err != nil {
			return nil, errors.NewField("remoteAddressParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "approved_sender": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(approvedSenderAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_router" instruction.
func NewUpdateRouterInstruction(
	// Params:
	newRouterParam solanago.PublicKey,

	// Accounts:
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateRouter[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newRouterParam`:
		err = enc__.Encode(newRouterParam)
		if err != nil {
			return nil, errors.NewField("newRouterParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "withdraw_tokens" instruction.
func NewWithdrawTokensInstruction(
	// Params:
	amountParam uint64,
	decimalsParam uint8,

	// Accounts:
	stateAccount solanago.PublicKey,
	programTokenAccountAccount solanago.PublicKey,
	toTokenAccountAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	tokenAdminAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_WithdrawTokens[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `amountParam`:
		err = enc__.Encode(amountParam)
		if err != nil {
			return nil, errors.NewField("amountParam", err)
		}
		// Serialize `decimalsParam`:
		err = enc__.Encode(decimalsParam)
		if err != nil {
			return nil, errors.NewField("decimalsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "program_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programTokenAccountAccount, true, false))
		// Account 2 "to_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(toTokenAccountAccount, true, false))
		// Account 3 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 4 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 5 "token_admin": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenAdminAccount, false, false))
		// Account 6 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

type AcceptOwnershipInstruction struct {

	// Accounts:
	State           solanago.PublicKey `json:"state"`
	StateWritable   bool               `json:"state_writable"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
}

func (obj *AcceptOwnershipInstruction) GetDiscriminator() []byte {
	return Instruction_AcceptOwnership[:]
}

// UnmarshalWithDecoder unmarshals the AcceptOwnershipInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *AcceptOwnershipInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "AcceptOwnershipInstruction", err)
	}
	if discriminator != Instruction_AcceptOwnership {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "AcceptOwnershipInstruction", Instruction_AcceptOwnership, discriminator)
	}
	return nil
}

func (obj *AcceptOwnershipInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AcceptOwnershipInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 2 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 2, len(indices))
	}
	indexOffset := 0
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AcceptOwnershipInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.State)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the AcceptOwnershipInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *AcceptOwnershipInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AcceptOwnershipInstruction: %w", err)
	}
	return nil
}

// UnmarshalAcceptOwnershipInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalAcceptOwnershipInstruction(buf []byte) (*AcceptOwnershipInstruction, error) {
	obj := new(AcceptOwnershipInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ApproveSenderInstruction struct {
	ChainSelector uint64 `json:"_chain_selector"`
	RemoteAddress []byte `json:"_remote_address"`

	// Accounts:
	State                  solanago.PublicKey `json:"state"`
	ApprovedSender         solanago.PublicKey `json:"approved_sender"`
	ApprovedSenderWritable bool               `json:"approved_sender_writable"`
	Authority              solanago.PublicKey `json:"authority"`
	AuthorityWritable      bool               `json:"authority_writable"`
	AuthoritySigner        bool               `json:"authority_signer"`
	SystemProgram          solanago.PublicKey `json:"system_program"`
}

func (obj *ApproveSenderInstruction) GetDiscriminator() []byte {
	return Instruction_ApproveSender[:]
}

// UnmarshalWithDecoder unmarshals the ApproveSenderInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *ApproveSenderInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "ApproveSenderInstruction", err)
	}
	if discriminator != Instruction_ApproveSender {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "ApproveSenderInstruction", Instruction_ApproveSender, discriminator)
	}
	// Deserialize `ChainSelector`:
	err = decoder.Decode(&obj.ChainSelector)
	if err != nil {
		return err
	}
	// Deserialize `RemoteAddress`:
	err = decoder.Decode(&obj.RemoteAddress)
	if err != nil {
		return err
	}
	return nil
}

func (obj *ApproveSenderInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from approved_sender account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "approved_sender", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *ApproveSenderInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set approved_sender account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "approved_sender", len(accountKeys)-1)
	}
	obj.ApprovedSender = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *ApproveSenderInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.State)
	keys = append(keys, obj.ApprovedSender)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the ApproveSenderInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *ApproveSenderInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ApproveSenderInstruction: %w", err)
	}
	return nil
}

// UnmarshalApproveSenderInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalApproveSenderInstruction(buf []byte) (*ApproveSenderInstruction, error) {
	obj := new(ApproveSenderInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type CcipReceiveInstruction struct {
	Message Any2SvmMessage `json:"message"`

	// Accounts:
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
	OfframpProgram  solanago.PublicKey `json:"offramp_program"`
	AllowedOfframp  solanago.PublicKey `json:"allowed_offramp"`
	ApprovedSender  solanago.PublicKey `json:"approved_sender"`
	State           solanago.PublicKey `json:"state"`
}

func (obj *CcipReceiveInstruction) GetDiscriminator() []byte {
	return Instruction_CcipReceive[:]
}

// UnmarshalWithDecoder unmarshals the CcipReceiveInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *CcipReceiveInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "CcipReceiveInstruction", err)
	}
	if discriminator != Instruction_CcipReceive {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "CcipReceiveInstruction", Instruction_CcipReceive, discriminator)
	}
	// Deserialize `Message`:
	err = decoder.Decode(&obj.Message)
	if err != nil {
		return err
	}
	return nil
}

func (obj *CcipReceiveInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from offramp_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "offramp_program", err)
	}
	indices = append(indices, index)
	// Decode from allowed_offramp account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "allowed_offramp", err)
	}
	indices = append(indices, index)
	// Decode from approved_sender account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "approved_sender", err)
	}
	indices = append(indices, index)
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *CcipReceiveInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 5 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 5, len(indices))
	}
	indexOffset := 0
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set offramp_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "offramp_program", len(accountKeys)-1)
	}
	obj.OfframpProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set allowed_offramp account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "allowed_offramp", len(accountKeys)-1)
	}
	obj.AllowedOfframp = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set approved_sender account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "approved_sender", len(accountKeys)-1)
	}
	obj.ApprovedSender = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *CcipReceiveInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.OfframpProgram)
	keys = append(keys, obj.AllowedOfframp)
	keys = append(keys, obj.ApprovedSender)
	keys = append(keys, obj.State)
	return keys
}

// Unmarshal unmarshals the CcipReceiveInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *CcipReceiveInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CcipReceiveInstruction: %w", err)
	}
	return nil
}

// UnmarshalCcipReceiveInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalCcipReceiveInstruction(buf []byte) (*CcipReceiveInstruction, error) {
	obj := new(CcipReceiveInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitializeInstruction struct {
	Router solanago.PublicKey `json:"router"`

	// Accounts:
	State              solanago.PublicKey `json:"state"`
	StateWritable      bool               `json:"state_writable"`
	TokenAdmin         solanago.PublicKey `json:"token_admin"`
	TokenAdminWritable bool               `json:"token_admin_writable"`
	Authority          solanago.PublicKey `json:"authority"`
	AuthorityWritable  bool               `json:"authority_writable"`
	AuthoritySigner    bool               `json:"authority_signer"`
	SystemProgram      solanago.PublicKey `json:"system_program"`
}

func (obj *InitializeInstruction) GetDiscriminator() []byte {
	return Instruction_Initialize[:]
}

// UnmarshalWithDecoder unmarshals the InitializeInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *InitializeInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "InitializeInstruction", err)
	}
	if discriminator != Instruction_Initialize {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "InitializeInstruction", Instruction_Initialize, discriminator)
	}
	// Deserialize `Router`:
	err = decoder.Decode(&obj.Router)
	if err != nil {
		return err
	}
	return nil
}

func (obj *InitializeInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from token_admin account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_admin", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitializeInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_admin account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_admin", len(accountKeys)-1)
	}
	obj.TokenAdmin = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitializeInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.State)
	keys = append(keys, obj.TokenAdmin)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the InitializeInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *InitializeInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitializeInstruction: %w", err)
	}
	return nil
}

// UnmarshalInitializeInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalInitializeInstruction(buf []byte) (*InitializeInstruction, error) {
	obj := new(InitializeInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type TransferOwnershipInstruction struct {
	ProposedOwner solanago.PublicKey `json:"proposed_owner"`

	// Accounts:
	State           solanago.PublicKey `json:"state"`
	StateWritable   bool               `json:"state_writable"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
}

func (obj *TransferOwnershipInstruction) GetDiscriminator() []byte {
	return Instruction_TransferOwnership[:]
}

// UnmarshalWithDecoder unmarshals the TransferOwnershipInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *TransferOwnershipInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "TransferOwnershipInstruction", err)
	}
	if discriminator != Instruction_TransferOwnership {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "TransferOwnershipInstruction", Instruction_TransferOwnership, discriminator)
	}
	// Deserialize `ProposedOwner`:
	err = decoder.Decode(&obj.ProposedOwner)
	if err != nil {
		return err
	}
	return nil
}

func (obj *TransferOwnershipInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *TransferOwnershipInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 2 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 2, len(indices))
	}
	indexOffset := 0
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *TransferOwnershipInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.State)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the TransferOwnershipInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *TransferOwnershipInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling TransferOwnershipInstruction: %w", err)
	}
	return nil
}

// UnmarshalTransferOwnershipInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalTransferOwnershipInstruction(buf []byte) (*TransferOwnershipInstruction, error) {
	obj := new(TransferOwnershipInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UnapproveSenderInstruction struct {
	ChainSelector uint64 `json:"_chain_selector"`
	RemoteAddress []byte `json:"_remote_address"`

	// Accounts:
	State                  solanago.PublicKey `json:"state"`
	StateWritable          bool               `json:"state_writable"`
	ApprovedSender         solanago.PublicKey `json:"approved_sender"`
	ApprovedSenderWritable bool               `json:"approved_sender_writable"`
	Authority              solanago.PublicKey `json:"authority"`
	AuthorityWritable      bool               `json:"authority_writable"`
	AuthoritySigner        bool               `json:"authority_signer"`
	SystemProgram          solanago.PublicKey `json:"system_program"`
}

func (obj *UnapproveSenderInstruction) GetDiscriminator() []byte {
	return Instruction_UnapproveSender[:]
}

// UnmarshalWithDecoder unmarshals the UnapproveSenderInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *UnapproveSenderInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "UnapproveSenderInstruction", err)
	}
	if discriminator != Instruction_UnapproveSender {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "UnapproveSenderInstruction", Instruction_UnapproveSender, discriminator)
	}
	// Deserialize `ChainSelector`:
	err = decoder.Decode(&obj.ChainSelector)
	if err != nil {
		return err
	}
	// Deserialize `RemoteAddress`:
	err = decoder.Decode(&obj.RemoteAddress)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UnapproveSenderInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from approved_sender account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "approved_sender", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *UnapproveSenderInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set approved_sender account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "approved_sender", len(accountKeys)-1)
	}
	obj.ApprovedSender = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *UnapproveSenderInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.State)
	keys = append(keys, obj.ApprovedSender)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the UnapproveSenderInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *UnapproveSenderInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UnapproveSenderInstruction: %w", err)
	}
	return nil
}

// UnmarshalUnapproveSenderInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalUnapproveSenderInstruction(buf []byte) (*UnapproveSenderInstruction, error) {
	obj := new(UnapproveSenderInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UpdateRouterInstruction struct {
	NewRouter solanago.PublicKey `json:"new_router"`

	// Accounts:
	State           solanago.PublicKey `json:"state"`
	StateWritable   bool               `json:"state_writable"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
}

func (obj *UpdateRouterInstruction) GetDiscriminator() []byte {
	return Instruction_UpdateRouter[:]
}

// UnmarshalWithDecoder unmarshals the UpdateRouterInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *UpdateRouterInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "UpdateRouterInstruction", err)
	}
	if discriminator != Instruction_UpdateRouter {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "UpdateRouterInstruction", Instruction_UpdateRouter, discriminator)
	}
	// Deserialize `NewRouter`:
	err = decoder.Decode(&obj.NewRouter)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UpdateRouterInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *UpdateRouterInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 2 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 2, len(indices))
	}
	indexOffset := 0
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *UpdateRouterInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.State)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the UpdateRouterInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *UpdateRouterInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdateRouterInstruction: %w", err)
	}
	return nil
}

// UnmarshalUpdateRouterInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalUpdateRouterInstruction(buf []byte) (*UpdateRouterInstruction, error) {
	obj := new(UpdateRouterInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type WithdrawTokensInstruction struct {
	Amount   uint64 `json:"amount"`
	Decimals uint8  `json:"decimals"`

	// Accounts:
	State                       solanago.PublicKey `json:"state"`
	StateWritable               bool               `json:"state_writable"`
	ProgramTokenAccount         solanago.PublicKey `json:"program_token_account"`
	ProgramTokenAccountWritable bool               `json:"program_token_account_writable"`
	ToTokenAccount              solanago.PublicKey `json:"to_token_account"`
	ToTokenAccountWritable      bool               `json:"to_token_account_writable"`
	Mint                        solanago.PublicKey `json:"mint"`
	TokenProgram                solanago.PublicKey `json:"token_program"`
	TokenAdmin                  solanago.PublicKey `json:"token_admin"`
	Authority                   solanago.PublicKey `json:"authority"`
	AuthoritySigner             bool               `json:"authority_signer"`
}

func (obj *WithdrawTokensInstruction) GetDiscriminator() []byte {
	return Instruction_WithdrawTokens[:]
}

// UnmarshalWithDecoder unmarshals the WithdrawTokensInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *WithdrawTokensInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "WithdrawTokensInstruction", err)
	}
	if discriminator != Instruction_WithdrawTokens {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "WithdrawTokensInstruction", Instruction_WithdrawTokens, discriminator)
	}
	// Deserialize `Amount`:
	err = decoder.Decode(&obj.Amount)
	if err != nil {
		return err
	}
	// Deserialize `Decimals`:
	err = decoder.Decode(&obj.Decimals)
	if err != nil {
		return err
	}
	return nil
}

func (obj *WithdrawTokensInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from program_token_account account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program_token_account", err)
	}
	indices = append(indices, index)
	// Decode from to_token_account account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "to_token_account", err)
	}
	indices = append(indices, index)
	// Decode from mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "mint", err)
	}
	indices = append(indices, index)
	// Decode from token_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_program", err)
	}
	indices = append(indices, index)
	// Decode from token_admin account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_admin", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *WithdrawTokensInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 7 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 7, len(indices))
	}
	indexOffset := 0
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program_token_account account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program_token_account", len(accountKeys)-1)
	}
	obj.ProgramTokenAccount = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set to_token_account account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "to_token_account", len(accountKeys)-1)
	}
	obj.ToTokenAccount = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "mint", len(accountKeys)-1)
	}
	obj.Mint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_program", len(accountKeys)-1)
	}
	obj.TokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_admin account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_admin", len(accountKeys)-1)
	}
	obj.TokenAdmin = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *WithdrawTokensInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.State)
	keys = append(keys, obj.ProgramTokenAccount)
	keys = append(keys, obj.ToTokenAccount)
	keys = append(keys, obj.Mint)
	keys = append(keys, obj.TokenProgram)
	keys = append(keys, obj.TokenAdmin)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the WithdrawTokensInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *WithdrawTokensInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling WithdrawTokensInstruction: %w", err)
	}
	return nil
}

// UnmarshalWithdrawTokensInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalWithdrawTokensInstruction(buf []byte) (*WithdrawTokensInstruction, error) {
	obj := new(WithdrawTokensInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Instruction interface defines common methods for all instruction types
type Instruction interface {
	GetDiscriminator() []byte

	UnmarshalWithDecoder(decoder *binary.Decoder) error

	UnmarshalAccountIndices(buf []byte) ([]uint8, error)

	PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error

	GetAccountKeys() []solanago.PublicKey
}

// ParseInstruction parses instruction data and optionally populates accounts
// If accountIndicesData is nil or empty, accounts will not be populated
func ParseInstruction(instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (Instruction, error) {
	// Validate inputs
	if len(instructionData) < 8 {
		return nil, fmt.Errorf("instruction data too short: expected at least 8 bytes, got %d", len(instructionData))
	}
	// Extract discriminator
	discriminator := [8]byte{}
	copy(discriminator[:], instructionData[0:8])
	// Parse based on discriminator
	switch discriminator {
	case Instruction_AcceptOwnership:
		instruction := new(AcceptOwnershipInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AcceptOwnershipInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_ApproveSender:
		instruction := new(ApproveSenderInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as ApproveSenderInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_CcipReceive:
		instruction := new(CcipReceiveInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as CcipReceiveInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_Initialize:
		instruction := new(InitializeInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitializeInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_TransferOwnership:
		instruction := new(TransferOwnershipInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as TransferOwnershipInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_UnapproveSender:
		instruction := new(UnapproveSenderInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as UnapproveSenderInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_UpdateRouter:
		instruction := new(UpdateRouterInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as UpdateRouterInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_WithdrawTokens:
		instruction := new(WithdrawTokensInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as WithdrawTokensInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	default:
		return nil, fmt.Errorf("unknown instruction discriminator: %s", binary.FormatDiscriminator(discriminator))
	}
}

// ParseInstructionTyped parses instruction data and returns a specific instruction type // T must implement the Instruction interface
func ParseInstructionTyped[T Instruction](instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (T, error) {
	instruction, err := ParseInstruction(instructionData, accountIndicesData, accountKeys)
	if err != nil {
		return *new(T), err
	}
	typed, ok := instruction.(T)
	if !ok {
		return *new(T), fmt.Errorf("instruction is not of expected type")
	}
	return typed, nil
}

// ParseInstructionWithoutAccounts parses instruction data without account information
func ParseInstructionWithoutAccounts(instructionData []byte) (Instruction, error) {
	return ParseInstruction(instructionData, nil, []solanago.PublicKey{})
}

// ParseInstructionWithAccounts parses instruction data with account information
func ParseInstructionWithAccounts(instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (Instruction, error) {
	return ParseInstruction(instructionData, accountIndicesData, accountKeys)
}
