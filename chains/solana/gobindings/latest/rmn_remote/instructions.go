// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains instructions.

package rmn_remote

import (
	"bytes"
	"fmt"
	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "accept_ownership" instruction.
// Accepts the ownership of the fee quoter by the proposed owner. //  // Shared func signature with other programs. //  // # Arguments //  // * `ctx` - The context containing the accounts required for accepting ownership. // The new owner must be a signer of the transaction.
func NewAcceptOwnershipInstruction(
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "curse" instruction.
// Curses an abstract subject. If the subject is CurseSubject::GLOBAL, // the entire chain will be cursed. //  // Only the CCIP Admin may perform this operation //  // # Arguments //  // * `ctx` - The context containing the accounts required for adding a new curse. // * `subject` - The subject to curse.
func NewCurseInstruction(
	// Params:
	subjectParam CurseSubject,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	cursesAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Curse[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `subjectParam`:
		err = enc__.Encode(subjectParam)
		if err != nil {
			return nil, errors.NewField("subjectParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 2 "curses": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(cursesAccount, true, false))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize" instruction.
// Initializes the Rmn Remote contract. //  // The initialization is responsibility of Admin, nothing more than calling this method should be done first. //  // # Arguments //  // * `ctx` - The context containing the accounts required for initialization.
func NewInitializeInstruction(
	configAccount solanago.PublicKey,
	cursesAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
	programDataAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "curses": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(cursesAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 4 "program": Read-only, Non-signer, Required, Address: RmnXLft1mSEwDgMKu2okYuHkiazxntFFcZFrrcXxYg7
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
		// Account 5 "program_data": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programDataAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "set_default_code_version" instruction.
// Sets the default code version to be used. This is then used by the slim routing layer to determine // which version of the versioned business logic module (`instructions`) to use. Only the admin may set this. //  // Shared func signature with other programs. //  // # Arguments //  // * `ctx` - The context containing the accounts required for updating the configuration. // * `code_version` - The new code version to be set as default.
func NewSetDefaultCodeVersionInstruction(
	// Params:
	codeVersionParam CodeVersion,

	// Accounts:
	configAccount solanago.PublicKey,
	cursesAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetDefaultCodeVersion[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `codeVersionParam`:
		err = enc__.Encode(codeVersionParam)
		if err != nil {
			return nil, errors.NewField("codeVersionParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "curses": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(cursesAccount, false, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "transfer_ownership" instruction.
// Transfers the ownership of the fee quoter to a new proposed owner. //  // Shared func signature with other programs. //  // # Arguments //  // * `ctx` - The context containing the accounts required for the transfer. // * `proposed_owner` - The public key of the new proposed owner.
func NewTransferOwnershipInstruction(
	// Params:
	newOwnerParam solanago.PublicKey,

	// Accounts:
	configAccount solanago.PublicKey,
	cursesAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_TransferOwnership[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newOwnerParam`:
		err = enc__.Encode(newOwnerParam)
		if err != nil {
			return nil, errors.NewField("newOwnerParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "curses": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(cursesAccount, false, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "type_version" instruction.
// Returns the program type (name) and version. // Used by offchain code to easily determine which program & version is being interacted with. //  // # Arguments // * `ctx` - The context
func NewTypeVersionInstruction(
	clockAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "clock": Read-only, Non-signer, Required, Address: SysvarC1ock11111111111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(clockAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "uncurse" instruction.
// Uncurses an abstract subject. If the subject is CurseSubject::GLOBAL, // the entire chain curse will be lifted. (note that any other specific // subject curses will remain active.) //  // Only the CCIP Admin may perform this operation //  // # Arguments //  // * `ctx` - The context containing the accounts required for removing a curse. // * `subject` - The subject to uncurse.
func NewUncurseInstruction(
	// Params:
	subjectParam CurseSubject,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	cursesAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Uncurse[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `subjectParam`:
		err = enc__.Encode(subjectParam)
		if err != nil {
			return nil, errors.NewField("subjectParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 2 "curses": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(cursesAccount, true, false))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "verify_not_cursed" instruction.
// Verifies that the subject is not cursed AND that this chain is not globally cursed. // In case either of those assumptions fail, the instruction reverts. //  // # Arguments //  // * `ctx` - The context containing the accounts required to inspect curses. // * `subject` - The subject to verify. Note that this instruction will revert if the chain // is globally cursed too, even if the provided subject is not explicitly cursed.
func NewVerifyNotCursedInstruction(
	// Params:
	subjectParam CurseSubject,

	// Accounts:
	cursesAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_VerifyNotCursed[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `subjectParam`:
		err = enc__.Encode(subjectParam)
		if err != nil {
			return nil, errors.NewField("subjectParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "curses": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(cursesAccount, false, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}
