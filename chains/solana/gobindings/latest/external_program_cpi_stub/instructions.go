// Code generated by https://github.com/Unheilbar/anchor-go. DO NOT EDIT.
// This file contains instructions and instruction parsers.

package external_program_cpi_stub

import (
	"bytes"
	"fmt"
	errors "github.com/Unheilbar/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "account_mut" instruction.
func NewAccountMutInstruction(
	u8ValueAccount solanago.PublicKey,
	stubCallerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AccountMut[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "u8_value": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(u8ValueAccount, true, false))
		// Account 1 "stub_caller": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(stubCallerAccount, false, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "account_read" instruction.
func NewAccountReadInstruction(
	u8ValueAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AccountRead[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "u8_value": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(u8ValueAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "big_instruction_data" instruction.
// instruction that accepts arbitrarily large instruction data.
func NewBigInstructionDataInstruction(
	dataParam []byte,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_BigInstructionData[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `dataParam`:
		err = enc__.Encode(dataParam)
		if err != nil {
			return nil, errors.NewField("dataParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "compute_heavy" instruction.
func NewComputeHeavyInstruction(
	iterationsParam uint32,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ComputeHeavy[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `iterationsParam`:
		err = enc__.Encode(iterationsParam)
		if err != nil {
			return nil, errors.NewField("iterationsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "empty" instruction.
func NewEmptyInstruction() (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Empty[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize" instruction.
func NewInitializeInstruction(
	u8ValueAccount solanago.PublicKey,
	stubCallerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Initialize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "u8_value": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(u8ValueAccount, true, false))
		// Account 1 "stub_caller": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(stubCallerAccount, true, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "no_op" instruction.
// no-op instruction that does nothing, also can be used to test maximum account references(remaining_accounts)
func NewNoOpInstruction() (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_NoOp[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "struct_instruction_data" instruction.
func NewStructInstructionDataInstruction(
	dataParam Value,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_StructInstructionData[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `dataParam`:
		err = enc__.Encode(dataParam)
		if err != nil {
			return nil, errors.NewField("dataParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "u8_instruction_data" instruction.
func NewU8InstructionDataInstruction(
	dataParam uint8,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_U8InstructionData[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `dataParam`:
		err = enc__.Encode(dataParam)
		if err != nil {
			return nil, errors.NewField("dataParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

type AccountMutInstruction struct {

	// Accounts:
	U8Value          solanago.PublicKey `json:"u8_value"`
	U8ValueWritable  bool               `json:"u8_value_writable"`
	StubCaller       solanago.PublicKey `json:"stub_caller"`
	StubCallerSigner bool               `json:"stub_caller_signer"`
	SystemProgram    solanago.PublicKey `json:"system_program"`
}

func (obj *AccountMutInstruction) GetDiscriminator() []byte {
	return Instruction_AccountMut[:]
}

// UnmarshalWithDecoder unmarshals the AccountMutInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *AccountMutInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "AccountMutInstruction", err)
	}
	if discriminator != Instruction_AccountMut {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "AccountMutInstruction", Instruction_AccountMut, discriminator)
	}
	return nil
}

func (obj *AccountMutInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from u8_value account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "u8_value", err)
	}
	indices = append(indices, index)
	// Decode from stub_caller account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "stub_caller", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AccountMutInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set u8_value account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "u8_value", len(accountKeys)-1)
	}
	obj.U8Value = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set stub_caller account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "stub_caller", len(accountKeys)-1)
	}
	obj.StubCaller = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AccountMutInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.U8Value)
	keys = append(keys, obj.StubCaller)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the AccountMutInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *AccountMutInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AccountMutInstruction: %w", err)
	}
	return nil
}

// UnmarshalAccountMutInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalAccountMutInstruction(buf []byte) (*AccountMutInstruction, error) {
	obj := new(AccountMutInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type AccountReadInstruction struct {

	// Accounts:
	U8Value solanago.PublicKey `json:"u8_value"`
}

func (obj *AccountReadInstruction) GetDiscriminator() []byte {
	return Instruction_AccountRead[:]
}

// UnmarshalWithDecoder unmarshals the AccountReadInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *AccountReadInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "AccountReadInstruction", err)
	}
	if discriminator != Instruction_AccountRead {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "AccountReadInstruction", Instruction_AccountRead, discriminator)
	}
	return nil
}

func (obj *AccountReadInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from u8_value account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "u8_value", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AccountReadInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 1 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 1, len(indices))
	}
	indexOffset := 0
	// Set u8_value account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "u8_value", len(accountKeys)-1)
	}
	obj.U8Value = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AccountReadInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.U8Value)
	return keys
}

// Unmarshal unmarshals the AccountReadInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *AccountReadInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AccountReadInstruction: %w", err)
	}
	return nil
}

// UnmarshalAccountReadInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalAccountReadInstruction(buf []byte) (*AccountReadInstruction, error) {
	obj := new(AccountReadInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type BigInstructionDataInstruction struct {
	Data []byte `json:"data"`
}

func (obj *BigInstructionDataInstruction) GetDiscriminator() []byte {
	return Instruction_BigInstructionData[:]
}

// UnmarshalWithDecoder unmarshals the BigInstructionDataInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *BigInstructionDataInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "BigInstructionDataInstruction", err)
	}
	if discriminator != Instruction_BigInstructionData {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "BigInstructionDataInstruction", Instruction_BigInstructionData, discriminator)
	}
	// Deserialize `Data`:
	err = decoder.Decode(&obj.Data)
	if err != nil {
		return err
	}
	return nil
}

func (obj *BigInstructionDataInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	return []uint8{}, nil
}

func (obj *BigInstructionDataInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	return nil
}

func (obj *BigInstructionDataInstruction) GetAccountKeys() []solanago.PublicKey {
	return []solanago.PublicKey{}
}

// Unmarshal unmarshals the BigInstructionDataInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *BigInstructionDataInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling BigInstructionDataInstruction: %w", err)
	}
	return nil
}

// UnmarshalBigInstructionDataInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalBigInstructionDataInstruction(buf []byte) (*BigInstructionDataInstruction, error) {
	obj := new(BigInstructionDataInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ComputeHeavyInstruction struct {
	Iterations uint32 `json:"iterations"`
}

func (obj *ComputeHeavyInstruction) GetDiscriminator() []byte {
	return Instruction_ComputeHeavy[:]
}

// UnmarshalWithDecoder unmarshals the ComputeHeavyInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *ComputeHeavyInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "ComputeHeavyInstruction", err)
	}
	if discriminator != Instruction_ComputeHeavy {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "ComputeHeavyInstruction", Instruction_ComputeHeavy, discriminator)
	}
	// Deserialize `Iterations`:
	err = decoder.Decode(&obj.Iterations)
	if err != nil {
		return err
	}
	return nil
}

func (obj *ComputeHeavyInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	return []uint8{}, nil
}

func (obj *ComputeHeavyInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	return nil
}

func (obj *ComputeHeavyInstruction) GetAccountKeys() []solanago.PublicKey {
	return []solanago.PublicKey{}
}

// Unmarshal unmarshals the ComputeHeavyInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *ComputeHeavyInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ComputeHeavyInstruction: %w", err)
	}
	return nil
}

// UnmarshalComputeHeavyInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalComputeHeavyInstruction(buf []byte) (*ComputeHeavyInstruction, error) {
	obj := new(ComputeHeavyInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type EmptyInstruction struct{}

func (obj *EmptyInstruction) GetDiscriminator() []byte {
	return Instruction_Empty[:]
}

// UnmarshalWithDecoder unmarshals the EmptyInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *EmptyInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "EmptyInstruction", err)
	}
	if discriminator != Instruction_Empty {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "EmptyInstruction", Instruction_Empty, discriminator)
	}
	return nil
}

func (obj *EmptyInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	return []uint8{}, nil
}

func (obj *EmptyInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	return nil
}

func (obj *EmptyInstruction) GetAccountKeys() []solanago.PublicKey {
	return []solanago.PublicKey{}
}

// Unmarshal unmarshals the EmptyInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *EmptyInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling EmptyInstruction: %w", err)
	}
	return nil
}

// UnmarshalEmptyInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalEmptyInstruction(buf []byte) (*EmptyInstruction, error) {
	obj := new(EmptyInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitializeInstruction struct {

	// Accounts:
	U8Value            solanago.PublicKey `json:"u8_value"`
	U8ValueWritable    bool               `json:"u8_value_writable"`
	StubCaller         solanago.PublicKey `json:"stub_caller"`
	StubCallerWritable bool               `json:"stub_caller_writable"`
	StubCallerSigner   bool               `json:"stub_caller_signer"`
	SystemProgram      solanago.PublicKey `json:"system_program"`
}

func (obj *InitializeInstruction) GetDiscriminator() []byte {
	return Instruction_Initialize[:]
}

// UnmarshalWithDecoder unmarshals the InitializeInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *InitializeInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "InitializeInstruction", err)
	}
	if discriminator != Instruction_Initialize {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "InitializeInstruction", Instruction_Initialize, discriminator)
	}
	return nil
}

func (obj *InitializeInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from u8_value account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "u8_value", err)
	}
	indices = append(indices, index)
	// Decode from stub_caller account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "stub_caller", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitializeInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set u8_value account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "u8_value", len(accountKeys)-1)
	}
	obj.U8Value = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set stub_caller account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "stub_caller", len(accountKeys)-1)
	}
	obj.StubCaller = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitializeInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.U8Value)
	keys = append(keys, obj.StubCaller)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the InitializeInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *InitializeInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitializeInstruction: %w", err)
	}
	return nil
}

// UnmarshalInitializeInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalInitializeInstruction(buf []byte) (*InitializeInstruction, error) {
	obj := new(InitializeInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type NoOpInstruction struct{}

func (obj *NoOpInstruction) GetDiscriminator() []byte {
	return Instruction_NoOp[:]
}

// UnmarshalWithDecoder unmarshals the NoOpInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *NoOpInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "NoOpInstruction", err)
	}
	if discriminator != Instruction_NoOp {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "NoOpInstruction", Instruction_NoOp, discriminator)
	}
	return nil
}

func (obj *NoOpInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	return []uint8{}, nil
}

func (obj *NoOpInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	return nil
}

func (obj *NoOpInstruction) GetAccountKeys() []solanago.PublicKey {
	return []solanago.PublicKey{}
}

// Unmarshal unmarshals the NoOpInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *NoOpInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling NoOpInstruction: %w", err)
	}
	return nil
}

// UnmarshalNoOpInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalNoOpInstruction(buf []byte) (*NoOpInstruction, error) {
	obj := new(NoOpInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type StructInstructionDataInstruction struct {
	Data Value `json:"data"`
}

func (obj *StructInstructionDataInstruction) GetDiscriminator() []byte {
	return Instruction_StructInstructionData[:]
}

// UnmarshalWithDecoder unmarshals the StructInstructionDataInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *StructInstructionDataInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "StructInstructionDataInstruction", err)
	}
	if discriminator != Instruction_StructInstructionData {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "StructInstructionDataInstruction", Instruction_StructInstructionData, discriminator)
	}
	// Deserialize `Data`:
	err = decoder.Decode(&obj.Data)
	if err != nil {
		return err
	}
	return nil
}

func (obj *StructInstructionDataInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	return []uint8{}, nil
}

func (obj *StructInstructionDataInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	return nil
}

func (obj *StructInstructionDataInstruction) GetAccountKeys() []solanago.PublicKey {
	return []solanago.PublicKey{}
}

// Unmarshal unmarshals the StructInstructionDataInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *StructInstructionDataInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling StructInstructionDataInstruction: %w", err)
	}
	return nil
}

// UnmarshalStructInstructionDataInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalStructInstructionDataInstruction(buf []byte) (*StructInstructionDataInstruction, error) {
	obj := new(StructInstructionDataInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type U8InstructionDataInstruction struct {
	Data uint8 `json:"data"`
}

func (obj *U8InstructionDataInstruction) GetDiscriminator() []byte {
	return Instruction_U8InstructionData[:]
}

// UnmarshalWithDecoder unmarshals the U8InstructionDataInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *U8InstructionDataInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "U8InstructionDataInstruction", err)
	}
	if discriminator != Instruction_U8InstructionData {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "U8InstructionDataInstruction", Instruction_U8InstructionData, discriminator)
	}
	// Deserialize `Data`:
	err = decoder.Decode(&obj.Data)
	if err != nil {
		return err
	}
	return nil
}

func (obj *U8InstructionDataInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	return []uint8{}, nil
}

func (obj *U8InstructionDataInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	return nil
}

func (obj *U8InstructionDataInstruction) GetAccountKeys() []solanago.PublicKey {
	return []solanago.PublicKey{}
}

// Unmarshal unmarshals the U8InstructionDataInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *U8InstructionDataInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling U8InstructionDataInstruction: %w", err)
	}
	return nil
}

// UnmarshalU8InstructionDataInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalU8InstructionDataInstruction(buf []byte) (*U8InstructionDataInstruction, error) {
	obj := new(U8InstructionDataInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Instruction interface defines common methods for all instruction types
type Instruction interface {
	GetDiscriminator() []byte

	UnmarshalWithDecoder(decoder *binary.Decoder) error

	UnmarshalAccountIndices(buf []byte) ([]uint8, error)

	PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error

	GetAccountKeys() []solanago.PublicKey
}

// ParseInstruction parses instruction data and optionally populates accounts
// If accountIndicesData is nil or empty, accounts will not be populated
func ParseInstruction(instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (Instruction, error) {
	// Validate inputs
	if len(instructionData) < 8 {
		return nil, fmt.Errorf("instruction data too short: expected at least 8 bytes, got %d", len(instructionData))
	}
	// Extract discriminator
	discriminator := [8]byte{}
	copy(discriminator[:], instructionData[0:8])
	// Parse based on discriminator
	switch discriminator {
	case Instruction_AccountMut:
		instruction := new(AccountMutInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AccountMutInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_AccountRead:
		instruction := new(AccountReadInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AccountReadInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_BigInstructionData:
		instruction := new(BigInstructionDataInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as BigInstructionDataInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_ComputeHeavy:
		instruction := new(ComputeHeavyInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as ComputeHeavyInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_Empty:
		instruction := new(EmptyInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as EmptyInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_Initialize:
		instruction := new(InitializeInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitializeInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_NoOp:
		instruction := new(NoOpInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as NoOpInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_StructInstructionData:
		instruction := new(StructInstructionDataInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as StructInstructionDataInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_U8InstructionData:
		instruction := new(U8InstructionDataInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as U8InstructionDataInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	default:
		return nil, fmt.Errorf("unknown instruction discriminator: %s", binary.FormatDiscriminator(discriminator))
	}
}

// ParseInstructionTyped parses instruction data and returns a specific instruction type // T must implement the Instruction interface
func ParseInstructionTyped[T Instruction](instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (T, error) {
	instruction, err := ParseInstruction(instructionData, accountIndicesData, accountKeys)
	if err != nil {
		return *new(T), err
	}
	typed, ok := instruction.(T)
	if !ok {
		return *new(T), fmt.Errorf("instruction is not of expected type")
	}
	return typed, nil
}

// ParseInstructionWithoutAccounts parses instruction data without account information
func ParseInstructionWithoutAccounts(instructionData []byte) (Instruction, error) {
	return ParseInstruction(instructionData, nil, []solanago.PublicKey{})
}

// ParseInstructionWithAccounts parses instruction data with account information
func ParseInstructionWithAccounts(instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (Instruction, error) {
	return ParseInstruction(instructionData, accountIndicesData, accountKeys)
}
