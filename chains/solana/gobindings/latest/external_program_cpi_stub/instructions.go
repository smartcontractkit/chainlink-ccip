// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains instructions.

package external_program_cpi_stub

import (
	"bytes"
	"fmt"
	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "account_mut" instruction.
func NewAccountMutInstruction(
	u8ValueAccount solanago.PublicKey,
	stubCallerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "u8_value": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(u8ValueAccount, true, false))
		// Account 1 "stub_caller": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(stubCallerAccount, false, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "account_read" instruction.
func NewAccountReadInstruction(
	u8ValueAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "u8_value": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(u8ValueAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "big_instruction_data" instruction.
// instruction that accepts arbitrarily large instruction data.
func NewBigInstructionDataInstruction(
	dataParam []byte,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_BigInstructionData[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `dataParam`:
		err = enc__.Encode(dataParam)
		if err != nil {
			return nil, errors.NewField("dataParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "compute_heavy" instruction.
func NewComputeHeavyInstruction(
	iterationsParam uint32,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ComputeHeavy[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `iterationsParam`:
		err = enc__.Encode(iterationsParam)
		if err != nil {
			return nil, errors.NewField("iterationsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "empty" instruction.
func NewEmptyInstruction() (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "initialize" instruction.
func NewInitializeInstruction(
	u8ValueAccount solanago.PublicKey,
	stubCallerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "u8_value": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(u8ValueAccount, true, false))
		// Account 1 "stub_caller": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(stubCallerAccount, true, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "no_op" instruction.
// no-op instruction that does nothing, also can be used to test maximum account references(remaining_accounts)
func NewNoOpInstruction() (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "struct_instruction_data" instruction.
func NewStructInstructionDataInstruction(
	dataParam Value,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_StructInstructionData[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `dataParam`:
		err = enc__.Encode(dataParam)
		if err != nil {
			return nil, errors.NewField("dataParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "u8_instruction_data" instruction.
func NewU8InstructionDataInstruction(
	dataParam uint8,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_U8InstructionData[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `dataParam`:
		err = enc__.Encode(dataParam)
		if err != nil {
			return nil, errors.NewField("dataParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}
