// Code generated by https://github.com/Unheilbar/anchor-go. DO NOT EDIT.
// This file contains instructions and instruction parsers.

package fee_quoter

import (
	"bytes"
	"fmt"
	errors "github.com/Unheilbar/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "accept_ownership" instruction.
// Accepts the ownership of the fee quoter by the proposed owner. //  // Shared func signature with other programs //  // # Arguments //  // * `ctx` - The context containing the accounts required for accepting ownership. // The new owner must be a signer of the transaction.
func NewAcceptOwnershipInstruction(
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AcceptOwnership[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "add_billing_token_config" instruction.
// Adds a billing token configuration. // Only CCIP Admin can add a billing token configuration. //  // # Arguments //  // * `ctx` - The context containing the accounts required for adding the billing token configuration. // * `config` - The billing token configuration to be added.
func NewAddBillingTokenConfigInstruction(
	// Params:
	configParam BillingTokenConfig,

	// Accounts:
	configAccount solanago.PublicKey,
	billingTokenConfigAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	feeTokenMintAccount solanago.PublicKey,
	feeTokenReceiverAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	feeBillingSignerAccount solanago.PublicKey,
	associatedTokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AddBillingTokenConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `configParam`:
		err = enc__.Encode(configParam)
		if err != nil {
			return nil, errors.NewField("configParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "billing_token_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(billingTokenConfigAccount, true, false))
		// Account 2 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 3 "fee_token_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeTokenMintAccount, false, false))
		// Account 4 "fee_token_receiver": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeTokenReceiverAccount, true, false))
		// Account 5 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 6 "fee_billing_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeBillingSignerAccount, false, false))
		// Account 7 "associated_token_program": Read-only, Non-signer, Required, Address: ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL
		accounts__.Append(solanago.NewAccountMeta(associatedTokenProgramAccount, false, false))
		// Account 8 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "add_dest_chain" instruction.
// Adds a new destination chain selector to the fee quoter. //  // The Admin needs to add any new chain supported. // When adding a new chain, the Admin needs to specify if it's enabled or not. //  // # Arguments //  // * `ctx` - The context containing the accounts required for adding the chain selector. // * `chain_selector` - The new chain selector to be added. // * `dest_chain_config` - The configuration for the chain as destination.
func NewAddDestChainInstruction(
	// Params:
	chainSelectorParam uint64,
	destChainConfigParam DestChainConfig,

	// Accounts:
	configAccount solanago.PublicKey,
	destChainAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AddDestChain[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `chainSelectorParam`:
		err = enc__.Encode(chainSelectorParam)
		if err != nil {
			return nil, errors.NewField("chainSelectorParam", err)
		}
		// Serialize `destChainConfigParam`:
		err = enc__.Encode(destChainConfigParam)
		if err != nil {
			return nil, errors.NewField("destChainConfigParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "dest_chain": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(destChainAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "add_price_updater" instruction.
// Add a price updater address to the list of allowed price updaters. // On price updates, the fee quoter will check the that caller is allowed. //  // # Arguments //  // * `ctx` - The context containing the accounts required for this operation. // * `price_updater` - The price updater address.
func NewAddPriceUpdaterInstruction(
	// Params:
	priceUpdaterParam solanago.PublicKey,

	// Accounts:
	allowedPriceUpdaterAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AddPriceUpdater[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `priceUpdaterParam`:
		err = enc__.Encode(priceUpdaterParam)
		if err != nil {
			return nil, errors.NewField("priceUpdaterParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "allowed_price_updater": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(allowedPriceUpdaterAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "disable_dest_chain" instruction.
// Disables the destination chain selector. //  // The Admin is the only one able to disable the chain selector as destination. This method is thought of as an emergency kill-switch. //  // # Arguments //  // * `ctx` - The context containing the accounts required for disabling the chain selector. // * `chain_selector` - The destination chain selector to be disabled.
func NewDisableDestChainInstruction(
	// Params:
	chainSelectorParam uint64,

	// Accounts:
	configAccount solanago.PublicKey,
	destChainAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_DisableDestChain[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `chainSelectorParam`:
		err = enc__.Encode(chainSelectorParam)
		if err != nil {
			return nil, errors.NewField("chainSelectorParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "dest_chain": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(destChainAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "get_fee" instruction.
// Calculates the fee for sending a message to the destination chain. //  // # Arguments //  // * `ctx` - The context containing the accounts required for the fee calculation. // * `dest_chain_selector` - The chain selector for the destination chain. // * `message` - The message to be sent. //  // # Additional accounts //  // In addition to the fixed amount of accounts defined in the `GetFee` context, // the following accounts must be provided: //  // * First, the billing token config accounts for each token sent with the message, sequentially. // For each token with no billing config account (i.e. tokens that cannot be possibly used as fee // tokens, which also have no BPS fees enabled) the ZERO address must be provided instead. // * Then, the per chain / per token config of every token sent with the message, sequentially // in the same order. //  // # Returns //  // GetFeeResult struct with: // - the fee token mint address, // - the fee amount of said token, // - the fee value in juels, // - additional data required when performing the cross-chain transfer of tokens in that message // - deserialized and processed extra args
func NewGetFeeInstruction(
	// Params:
	destChainSelectorParam uint64,
	messageParam Svm2AnyMessage,

	// Accounts:
	configAccount solanago.PublicKey,
	destChainAccount solanago.PublicKey,
	billingTokenConfigAccount solanago.PublicKey,
	linkTokenConfigAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_GetFee[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `destChainSelectorParam`:
		err = enc__.Encode(destChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("destChainSelectorParam", err)
		}
		// Serialize `messageParam`:
		err = enc__.Encode(messageParam)
		if err != nil {
			return nil, errors.NewField("messageParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "dest_chain": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(destChainAccount, false, false))
		// Account 2 "billing_token_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(billingTokenConfigAccount, false, false))
		// Account 3 "link_token_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(linkTokenConfigAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize" instruction.
// Initializes the Fee Quoter. //  // The initialization is responsibility of Admin, nothing more than calling this method should be done first. //  // # Arguments //  // * `ctx` - The context containing the accounts required for initialization. // * `max_fee_juels_per_msg` - The maximum fee in juels that can be charged per message. // * `onramp` - The public key of the onramp. //  // The function also uses the link_token_mint account from the context.
func NewInitializeInstruction(
	// Params:
	maxFeeJuelsPerMsgParam binary.Uint128,
	onrampParam solanago.PublicKey,

	// Accounts:
	configAccount solanago.PublicKey,
	linkTokenMintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
	programDataAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Initialize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `maxFeeJuelsPerMsgParam`:
		err = enc__.Encode(maxFeeJuelsPerMsgParam)
		if err != nil {
			return nil, errors.NewField("maxFeeJuelsPerMsgParam", err)
		}
		// Serialize `onrampParam`:
		err = enc__.Encode(onrampParam)
		if err != nil {
			return nil, errors.NewField("onrampParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "link_token_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(linkTokenMintAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 4 "program": Read-only, Non-signer, Required, Address: FeeQPGkKDeRV1MgoYfMH6L8o3KeuYjwUZrgn4LRKfjHi
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
		// Account 5 "program_data": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programDataAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "remove_price_updater" instruction.
// Remove a price updater address from the list of allowed price updaters. //  // # Arguments //  // * `ctx` - The context containing the accounts required for this operation. // * `price_updater` - The price updater address.
func NewRemovePriceUpdaterInstruction(
	// Params:
	priceUpdaterParam solanago.PublicKey,

	// Accounts:
	allowedPriceUpdaterAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RemovePriceUpdater[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `priceUpdaterParam`:
		err = enc__.Encode(priceUpdaterParam)
		if err != nil {
			return nil, errors.NewField("priceUpdaterParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "allowed_price_updater": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(allowedPriceUpdaterAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_default_code_version" instruction.
// Sets the default code version to be used. This is then used by the slim routing layer to determine // which version of the versioned business logic module (`instructions`) to use. Only the admin may set this. //  // Shared func signature with other programs //  // # Arguments //  // * `ctx` - The context containing the accounts required for updating the configuration. // * `code_version` - The new code version to be set as default.
func NewSetDefaultCodeVersionInstruction(
	// Params:
	codeVersionParam CodeVersion,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetDefaultCodeVersion[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `codeVersionParam`:
		err = enc__.Encode(codeVersionParam)
		if err != nil {
			return nil, errors.NewField("codeVersionParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_link_token_mint" instruction.
// Sets the link_token_mint and updates the link_token_local_decimals. //  // Only the admin may set this. //  // # Arguments //  // * `ctx` - The context containing the accounts required for updating the configuration.
func NewSetLinkTokenMintInstruction(
	configAccount solanago.PublicKey,
	linkTokenMintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetLinkTokenMint[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "link_token_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(linkTokenMintAccount, false, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_max_fee_juels_per_msg" instruction.
// Sets the max_fee_juels_per_msg, which is an upper bound on how much can be billed for any message. // (1 juels = 1e-18 LINK) //  // Only the admin may set this. //  // # Arguments //  // * `ctx` - The context containing the accounts required for updating the configuration. // * `max_fee_juels_per_msg` - The new value for the max_feel_juels_per_msg config.
func NewSetMaxFeeJuelsPerMsgInstruction(
	// Params:
	maxFeeJuelsPerMsgParam binary.Uint128,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetMaxFeeJuelsPerMsg[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `maxFeeJuelsPerMsgParam`:
		err = enc__.Encode(maxFeeJuelsPerMsgParam)
		if err != nil {
			return nil, errors.NewField("maxFeeJuelsPerMsgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_token_transfer_fee_config" instruction.
// Sets the token transfer fee configuration for a particular token when it's transferred to a particular dest chain. // It is an upsert, initializing the per-chain-per-token config account if it doesn't exist // and overwriting it if it does. //  // Only the Admin can perform this operation. //  // # Arguments //  // * `ctx` - The context containing the accounts required for setting the token billing configuration. // * `chain_selector` - The chain selector. // * `mint` - The public key of the token mint. // * `cfg` - The token transfer fee configuration.
func NewSetTokenTransferFeeConfigInstruction(
	// Params:
	chainSelectorParam uint64,
	mintParam solanago.PublicKey,
	cfgParam TokenTransferFeeConfig,

	// Accounts:
	configAccount solanago.PublicKey,
	perChainPerTokenConfigAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetTokenTransferFeeConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `chainSelectorParam`:
		err = enc__.Encode(chainSelectorParam)
		if err != nil {
			return nil, errors.NewField("chainSelectorParam", err)
		}
		// Serialize `mintParam`:
		err = enc__.Encode(mintParam)
		if err != nil {
			return nil, errors.NewField("mintParam", err)
		}
		// Serialize `cfgParam`:
		err = enc__.Encode(cfgParam)
		if err != nil {
			return nil, errors.NewField("cfgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "per_chain_per_token_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perChainPerTokenConfigAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "transfer_ownership" instruction.
// Transfers the ownership of the fee quoter to a new proposed owner. //  // Shared func signature with other programs //  // # Arguments //  // * `ctx` - The context containing the accounts required for the transfer. // * `proposed_owner` - The public key of the new proposed owner.
func NewTransferOwnershipInstruction(
	// Params:
	newOwnerParam solanago.PublicKey,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_TransferOwnership[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newOwnerParam`:
		err = enc__.Encode(newOwnerParam)
		if err != nil {
			return nil, errors.NewField("newOwnerParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "type_version" instruction.
// Returns the program type (name) and version. // Used by offchain code to easily determine which program & version is being interacted with. //  // # Arguments // * `ctx` - The context
func NewTypeVersionInstruction(
	clockAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_TypeVersion[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "clock": Read-only, Non-signer, Required, Address: SysvarC1ock11111111111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(clockAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_billing_token_config" instruction.
// Updates the billing token configuration. // Only CCIP Admin can update a billing token configuration. //  // # Arguments //  // * `ctx` - The context containing the accounts required for updating the billing token configuration. // * `config` - The new billing token configuration.
func NewUpdateBillingTokenConfigInstruction(
	// Params:
	configParam BillingTokenConfig,

	// Accounts:
	configAccount solanago.PublicKey,
	billingTokenConfigAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateBillingTokenConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `configParam`:
		err = enc__.Encode(configParam)
		if err != nil {
			return nil, errors.NewField("configParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "billing_token_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(billingTokenConfigAccount, true, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_dest_chain_config" instruction.
// Updates the configuration of the destination chain selector. //  // The Admin is the only one able to update the destination chain config. //  // # Arguments //  // * `ctx` - The context containing the accounts required for updating the chain selector. // * `chain_selector` - The destination chain selector to be updated. // * `dest_chain_config` - The new configuration for the destination chain.
func NewUpdateDestChainConfigInstruction(
	// Params:
	chainSelectorParam uint64,
	destChainConfigParam DestChainConfig,

	// Accounts:
	configAccount solanago.PublicKey,
	destChainAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateDestChainConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `chainSelectorParam`:
		err = enc__.Encode(chainSelectorParam)
		if err != nil {
			return nil, errors.NewField("chainSelectorParam", err)
		}
		// Serialize `destChainConfigParam`:
		err = enc__.Encode(destChainConfigParam)
		if err != nil {
			return nil, errors.NewField("destChainConfigParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "dest_chain": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(destChainAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_prices" instruction.
// Updates prices for tokens and gas. This method may only be called by an allowed price updater. //  // # Arguments //  // * `ctx` - The context containing the accounts always required for the price updates // * `token_updates` - Vector of token price updates // * `gas_updates` - Vector of gas price updates //  // # Additional accounts //  // In addition to the fixed amount of accounts defined in the `UpdatePrices` context, // the following accounts must be provided: //  // * First, the billing token config accounts for each token whose price is being updated, in the same order // as the token_updates vector. // * Then, the dest chain accounts of every chain whose gas price is being updated, in the same order as the // gas_updates vector.
func NewUpdatePricesInstruction(
	// Params:
	tokenUpdatesParam []TokenPriceUpdate,
	gasUpdatesParam []GasPriceUpdate,

	// Accounts:
	authorityAccount solanago.PublicKey,
	allowedPriceUpdaterAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePrices[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `tokenUpdatesParam`:
		err = enc__.Encode(tokenUpdatesParam)
		if err != nil {
			return nil, errors.NewField("tokenUpdatesParam", err)
		}
		// Serialize `gasUpdatesParam`:
		err = enc__.Encode(gasUpdatesParam)
		if err != nil {
			return nil, errors.NewField("gasUpdatesParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 1 "allowed_price_updater": Read-only, Non-signer, Required
		// was added by the owner as an allowed price updater. The constraints enforced guarantee that it is the right PDA
		// and that it was initialized.
		accounts__.Append(solanago.NewAccountMeta(allowedPriceUpdaterAccount, false, false))
		// Account 2 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

type AcceptOwnershipInstruction struct {

	// Accounts:
	Config          solanago.PublicKey `json:"config"`
	ConfigWritable  bool               `json:"config_writable"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
}

func (obj *AcceptOwnershipInstruction) GetDiscriminator() []byte {
	return Instruction_AcceptOwnership[:]
}

// UnmarshalWithDecoder unmarshals the AcceptOwnershipInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *AcceptOwnershipInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "AcceptOwnershipInstruction", err)
	}
	if discriminator != Instruction_AcceptOwnership {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "AcceptOwnershipInstruction", Instruction_AcceptOwnership, discriminator)
	}
	return nil
}

func (obj *AcceptOwnershipInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AcceptOwnershipInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 2 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 2, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AcceptOwnershipInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the AcceptOwnershipInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *AcceptOwnershipInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AcceptOwnershipInstruction: %w", err)
	}
	return nil
}

// UnmarshalAcceptOwnershipInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalAcceptOwnershipInstruction(buf []byte) (*AcceptOwnershipInstruction, error) {
	obj := new(AcceptOwnershipInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type AddBillingTokenConfigInstruction struct {
	Config BillingTokenConfig `json:"config"`

	// Accounts:
	ConfigAccount              solanago.PublicKey `json:"config_account"`
	BillingTokenConfig         solanago.PublicKey `json:"billing_token_config"`
	BillingTokenConfigWritable bool               `json:"billing_token_config_writable"`
	TokenProgram               solanago.PublicKey `json:"token_program"`
	FeeTokenMint               solanago.PublicKey `json:"fee_token_mint"`
	FeeTokenReceiver           solanago.PublicKey `json:"fee_token_receiver"`
	FeeTokenReceiverWritable   bool               `json:"fee_token_receiver_writable"`
	Authority                  solanago.PublicKey `json:"authority"`
	AuthorityWritable          bool               `json:"authority_writable"`
	AuthoritySigner            bool               `json:"authority_signer"`
	FeeBillingSigner           solanago.PublicKey `json:"fee_billing_signer"`
	AssociatedTokenProgram     solanago.PublicKey `json:"associated_token_program"`
	SystemProgram              solanago.PublicKey `json:"system_program"`
}

func (obj *AddBillingTokenConfigInstruction) GetDiscriminator() []byte {
	return Instruction_AddBillingTokenConfig[:]
}

// UnmarshalWithDecoder unmarshals the AddBillingTokenConfigInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *AddBillingTokenConfigInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "AddBillingTokenConfigInstruction", err)
	}
	if discriminator != Instruction_AddBillingTokenConfig {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "AddBillingTokenConfigInstruction", Instruction_AddBillingTokenConfig, discriminator)
	}
	// Deserialize `Config`:
	err = decoder.Decode(&obj.Config)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AddBillingTokenConfigInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from billing_token_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "billing_token_config", err)
	}
	indices = append(indices, index)
	// Decode from token_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_program", err)
	}
	indices = append(indices, index)
	// Decode from fee_token_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_token_mint", err)
	}
	indices = append(indices, index)
	// Decode from fee_token_receiver account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_token_receiver", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from fee_billing_signer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_billing_signer", err)
	}
	indices = append(indices, index)
	// Decode from associated_token_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "associated_token_program", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AddBillingTokenConfigInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 9 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 9, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.ConfigAccount = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set billing_token_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "billing_token_config", len(accountKeys)-1)
	}
	obj.BillingTokenConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_program", len(accountKeys)-1)
	}
	obj.TokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_token_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_token_mint", len(accountKeys)-1)
	}
	obj.FeeTokenMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_token_receiver account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_token_receiver", len(accountKeys)-1)
	}
	obj.FeeTokenReceiver = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_billing_signer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_billing_signer", len(accountKeys)-1)
	}
	obj.FeeBillingSigner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set associated_token_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "associated_token_program", len(accountKeys)-1)
	}
	obj.AssociatedTokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AddBillingTokenConfigInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.ConfigAccount)
	keys = append(keys, obj.BillingTokenConfig)
	keys = append(keys, obj.TokenProgram)
	keys = append(keys, obj.FeeTokenMint)
	keys = append(keys, obj.FeeTokenReceiver)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.FeeBillingSigner)
	keys = append(keys, obj.AssociatedTokenProgram)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the AddBillingTokenConfigInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *AddBillingTokenConfigInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AddBillingTokenConfigInstruction: %w", err)
	}
	return nil
}

// UnmarshalAddBillingTokenConfigInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalAddBillingTokenConfigInstruction(buf []byte) (*AddBillingTokenConfigInstruction, error) {
	obj := new(AddBillingTokenConfigInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type AddDestChainInstruction struct {
	ChainSelector   uint64          `json:"chain_selector"`
	DestChainConfig DestChainConfig `json:"dest_chain_config"`

	// Accounts:
	Config            solanago.PublicKey `json:"config"`
	DestChain         solanago.PublicKey `json:"dest_chain"`
	DestChainWritable bool               `json:"dest_chain_writable"`
	Authority         solanago.PublicKey `json:"authority"`
	AuthorityWritable bool               `json:"authority_writable"`
	AuthoritySigner   bool               `json:"authority_signer"`
	SystemProgram     solanago.PublicKey `json:"system_program"`
}

func (obj *AddDestChainInstruction) GetDiscriminator() []byte {
	return Instruction_AddDestChain[:]
}

// UnmarshalWithDecoder unmarshals the AddDestChainInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *AddDestChainInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "AddDestChainInstruction", err)
	}
	if discriminator != Instruction_AddDestChain {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "AddDestChainInstruction", Instruction_AddDestChain, discriminator)
	}
	// Deserialize `ChainSelector`:
	err = decoder.Decode(&obj.ChainSelector)
	if err != nil {
		return err
	}
	// Deserialize `DestChainConfig`:
	err = decoder.Decode(&obj.DestChainConfig)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AddDestChainInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from dest_chain account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "dest_chain", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AddDestChainInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set dest_chain account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "dest_chain", len(accountKeys)-1)
	}
	obj.DestChain = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AddDestChainInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.DestChain)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the AddDestChainInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *AddDestChainInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AddDestChainInstruction: %w", err)
	}
	return nil
}

// UnmarshalAddDestChainInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalAddDestChainInstruction(buf []byte) (*AddDestChainInstruction, error) {
	obj := new(AddDestChainInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type AddPriceUpdaterInstruction struct {
	PriceUpdater solanago.PublicKey `json:"price_updater"`

	// Accounts:
	AllowedPriceUpdater         solanago.PublicKey `json:"allowed_price_updater"`
	AllowedPriceUpdaterWritable bool               `json:"allowed_price_updater_writable"`
	Config                      solanago.PublicKey `json:"config"`
	Authority                   solanago.PublicKey `json:"authority"`
	AuthorityWritable           bool               `json:"authority_writable"`
	AuthoritySigner             bool               `json:"authority_signer"`
	SystemProgram               solanago.PublicKey `json:"system_program"`
}

func (obj *AddPriceUpdaterInstruction) GetDiscriminator() []byte {
	return Instruction_AddPriceUpdater[:]
}

// UnmarshalWithDecoder unmarshals the AddPriceUpdaterInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *AddPriceUpdaterInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "AddPriceUpdaterInstruction", err)
	}
	if discriminator != Instruction_AddPriceUpdater {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "AddPriceUpdaterInstruction", Instruction_AddPriceUpdater, discriminator)
	}
	// Deserialize `PriceUpdater`:
	err = decoder.Decode(&obj.PriceUpdater)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AddPriceUpdaterInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from allowed_price_updater account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "allowed_price_updater", err)
	}
	indices = append(indices, index)
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AddPriceUpdaterInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set allowed_price_updater account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "allowed_price_updater", len(accountKeys)-1)
	}
	obj.AllowedPriceUpdater = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AddPriceUpdaterInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.AllowedPriceUpdater)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the AddPriceUpdaterInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *AddPriceUpdaterInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AddPriceUpdaterInstruction: %w", err)
	}
	return nil
}

// UnmarshalAddPriceUpdaterInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalAddPriceUpdaterInstruction(buf []byte) (*AddPriceUpdaterInstruction, error) {
	obj := new(AddPriceUpdaterInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type DisableDestChainInstruction struct {
	ChainSelector uint64 `json:"chain_selector"`

	// Accounts:
	Config            solanago.PublicKey `json:"config"`
	DestChain         solanago.PublicKey `json:"dest_chain"`
	DestChainWritable bool               `json:"dest_chain_writable"`
	Authority         solanago.PublicKey `json:"authority"`
	AuthorityWritable bool               `json:"authority_writable"`
	AuthoritySigner   bool               `json:"authority_signer"`
}

func (obj *DisableDestChainInstruction) GetDiscriminator() []byte {
	return Instruction_DisableDestChain[:]
}

// UnmarshalWithDecoder unmarshals the DisableDestChainInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *DisableDestChainInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "DisableDestChainInstruction", err)
	}
	if discriminator != Instruction_DisableDestChain {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "DisableDestChainInstruction", Instruction_DisableDestChain, discriminator)
	}
	// Deserialize `ChainSelector`:
	err = decoder.Decode(&obj.ChainSelector)
	if err != nil {
		return err
	}
	return nil
}

func (obj *DisableDestChainInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from dest_chain account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "dest_chain", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *DisableDestChainInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set dest_chain account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "dest_chain", len(accountKeys)-1)
	}
	obj.DestChain = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *DisableDestChainInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.DestChain)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the DisableDestChainInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *DisableDestChainInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling DisableDestChainInstruction: %w", err)
	}
	return nil
}

// UnmarshalDisableDestChainInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalDisableDestChainInstruction(buf []byte) (*DisableDestChainInstruction, error) {
	obj := new(DisableDestChainInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type GetFeeInstruction struct {
	DestChainSelector uint64         `json:"dest_chain_selector"`
	Message           Svm2AnyMessage `json:"message"`

	// Accounts:
	Config             solanago.PublicKey `json:"config"`
	DestChain          solanago.PublicKey `json:"dest_chain"`
	BillingTokenConfig solanago.PublicKey `json:"billing_token_config"`
	LinkTokenConfig    solanago.PublicKey `json:"link_token_config"`
}

func (obj *GetFeeInstruction) GetDiscriminator() []byte {
	return Instruction_GetFee[:]
}

// UnmarshalWithDecoder unmarshals the GetFeeInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *GetFeeInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "GetFeeInstruction", err)
	}
	if discriminator != Instruction_GetFee {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "GetFeeInstruction", Instruction_GetFee, discriminator)
	}
	// Deserialize `DestChainSelector`:
	err = decoder.Decode(&obj.DestChainSelector)
	if err != nil {
		return err
	}
	// Deserialize `Message`:
	err = decoder.Decode(&obj.Message)
	if err != nil {
		return err
	}
	return nil
}

func (obj *GetFeeInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from dest_chain account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "dest_chain", err)
	}
	indices = append(indices, index)
	// Decode from billing_token_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "billing_token_config", err)
	}
	indices = append(indices, index)
	// Decode from link_token_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "link_token_config", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *GetFeeInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set dest_chain account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "dest_chain", len(accountKeys)-1)
	}
	obj.DestChain = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set billing_token_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "billing_token_config", len(accountKeys)-1)
	}
	obj.BillingTokenConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set link_token_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "link_token_config", len(accountKeys)-1)
	}
	obj.LinkTokenConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *GetFeeInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.DestChain)
	keys = append(keys, obj.BillingTokenConfig)
	keys = append(keys, obj.LinkTokenConfig)
	return keys
}

// Unmarshal unmarshals the GetFeeInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *GetFeeInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling GetFeeInstruction: %w", err)
	}
	return nil
}

// UnmarshalGetFeeInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalGetFeeInstruction(buf []byte) (*GetFeeInstruction, error) {
	obj := new(GetFeeInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitializeInstruction struct {
	MaxFeeJuelsPerMsg binary.Uint128     `json:"max_fee_juels_per_msg"`
	Onramp            solanago.PublicKey `json:"onramp"`

	// Accounts:
	Config            solanago.PublicKey `json:"config"`
	ConfigWritable    bool               `json:"config_writable"`
	LinkTokenMint     solanago.PublicKey `json:"link_token_mint"`
	Authority         solanago.PublicKey `json:"authority"`
	AuthorityWritable bool               `json:"authority_writable"`
	AuthoritySigner   bool               `json:"authority_signer"`
	SystemProgram     solanago.PublicKey `json:"system_program"`
	Program           solanago.PublicKey `json:"program"`
	ProgramData       solanago.PublicKey `json:"program_data"`
}

func (obj *InitializeInstruction) GetDiscriminator() []byte {
	return Instruction_Initialize[:]
}

// UnmarshalWithDecoder unmarshals the InitializeInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *InitializeInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "InitializeInstruction", err)
	}
	if discriminator != Instruction_Initialize {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "InitializeInstruction", Instruction_Initialize, discriminator)
	}
	// Deserialize `MaxFeeJuelsPerMsg`:
	err = decoder.Decode(&obj.MaxFeeJuelsPerMsg)
	if err != nil {
		return err
	}
	// Deserialize `Onramp`:
	err = decoder.Decode(&obj.Onramp)
	if err != nil {
		return err
	}
	return nil
}

func (obj *InitializeInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from link_token_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "link_token_mint", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	// Decode from program_data account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program_data", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitializeInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 6 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 6, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set link_token_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "link_token_mint", len(accountKeys)-1)
	}
	obj.LinkTokenMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program_data account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program_data", len(accountKeys)-1)
	}
	obj.ProgramData = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitializeInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.LinkTokenMint)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.Program)
	keys = append(keys, obj.ProgramData)
	return keys
}

// Unmarshal unmarshals the InitializeInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *InitializeInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitializeInstruction: %w", err)
	}
	return nil
}

// UnmarshalInitializeInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalInitializeInstruction(buf []byte) (*InitializeInstruction, error) {
	obj := new(InitializeInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type RemovePriceUpdaterInstruction struct {
	PriceUpdater solanago.PublicKey `json:"price_updater"`

	// Accounts:
	AllowedPriceUpdater         solanago.PublicKey `json:"allowed_price_updater"`
	AllowedPriceUpdaterWritable bool               `json:"allowed_price_updater_writable"`
	Config                      solanago.PublicKey `json:"config"`
	Authority                   solanago.PublicKey `json:"authority"`
	AuthorityWritable           bool               `json:"authority_writable"`
	AuthoritySigner             bool               `json:"authority_signer"`
	SystemProgram               solanago.PublicKey `json:"system_program"`
}

func (obj *RemovePriceUpdaterInstruction) GetDiscriminator() []byte {
	return Instruction_RemovePriceUpdater[:]
}

// UnmarshalWithDecoder unmarshals the RemovePriceUpdaterInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *RemovePriceUpdaterInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "RemovePriceUpdaterInstruction", err)
	}
	if discriminator != Instruction_RemovePriceUpdater {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "RemovePriceUpdaterInstruction", Instruction_RemovePriceUpdater, discriminator)
	}
	// Deserialize `PriceUpdater`:
	err = decoder.Decode(&obj.PriceUpdater)
	if err != nil {
		return err
	}
	return nil
}

func (obj *RemovePriceUpdaterInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from allowed_price_updater account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "allowed_price_updater", err)
	}
	indices = append(indices, index)
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *RemovePriceUpdaterInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set allowed_price_updater account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "allowed_price_updater", len(accountKeys)-1)
	}
	obj.AllowedPriceUpdater = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *RemovePriceUpdaterInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.AllowedPriceUpdater)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the RemovePriceUpdaterInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *RemovePriceUpdaterInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling RemovePriceUpdaterInstruction: %w", err)
	}
	return nil
}

// UnmarshalRemovePriceUpdaterInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalRemovePriceUpdaterInstruction(buf []byte) (*RemovePriceUpdaterInstruction, error) {
	obj := new(RemovePriceUpdaterInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SetDefaultCodeVersionInstruction struct {
	CodeVersion CodeVersion `json:"code_version"`

	// Accounts:
	Config          solanago.PublicKey `json:"config"`
	ConfigWritable  bool               `json:"config_writable"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
}

func (obj *SetDefaultCodeVersionInstruction) GetDiscriminator() []byte {
	return Instruction_SetDefaultCodeVersion[:]
}

// UnmarshalWithDecoder unmarshals the SetDefaultCodeVersionInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *SetDefaultCodeVersionInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "SetDefaultCodeVersionInstruction", err)
	}
	if discriminator != Instruction_SetDefaultCodeVersion {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "SetDefaultCodeVersionInstruction", Instruction_SetDefaultCodeVersion, discriminator)
	}
	// Deserialize `CodeVersion`:
	err = decoder.Decode(&obj.CodeVersion)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SetDefaultCodeVersionInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SetDefaultCodeVersionInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 2 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 2, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SetDefaultCodeVersionInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the SetDefaultCodeVersionInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *SetDefaultCodeVersionInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SetDefaultCodeVersionInstruction: %w", err)
	}
	return nil
}

// UnmarshalSetDefaultCodeVersionInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalSetDefaultCodeVersionInstruction(buf []byte) (*SetDefaultCodeVersionInstruction, error) {
	obj := new(SetDefaultCodeVersionInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SetLinkTokenMintInstruction struct {

	// Accounts:
	Config          solanago.PublicKey `json:"config"`
	ConfigWritable  bool               `json:"config_writable"`
	LinkTokenMint   solanago.PublicKey `json:"link_token_mint"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
}

func (obj *SetLinkTokenMintInstruction) GetDiscriminator() []byte {
	return Instruction_SetLinkTokenMint[:]
}

// UnmarshalWithDecoder unmarshals the SetLinkTokenMintInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *SetLinkTokenMintInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "SetLinkTokenMintInstruction", err)
	}
	if discriminator != Instruction_SetLinkTokenMint {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "SetLinkTokenMintInstruction", Instruction_SetLinkTokenMint, discriminator)
	}
	return nil
}

func (obj *SetLinkTokenMintInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from link_token_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "link_token_mint", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SetLinkTokenMintInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set link_token_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "link_token_mint", len(accountKeys)-1)
	}
	obj.LinkTokenMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SetLinkTokenMintInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.LinkTokenMint)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the SetLinkTokenMintInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *SetLinkTokenMintInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SetLinkTokenMintInstruction: %w", err)
	}
	return nil
}

// UnmarshalSetLinkTokenMintInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalSetLinkTokenMintInstruction(buf []byte) (*SetLinkTokenMintInstruction, error) {
	obj := new(SetLinkTokenMintInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SetMaxFeeJuelsPerMsgInstruction struct {
	MaxFeeJuelsPerMsg binary.Uint128 `json:"max_fee_juels_per_msg"`

	// Accounts:
	Config          solanago.PublicKey `json:"config"`
	ConfigWritable  bool               `json:"config_writable"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
}

func (obj *SetMaxFeeJuelsPerMsgInstruction) GetDiscriminator() []byte {
	return Instruction_SetMaxFeeJuelsPerMsg[:]
}

// UnmarshalWithDecoder unmarshals the SetMaxFeeJuelsPerMsgInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *SetMaxFeeJuelsPerMsgInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "SetMaxFeeJuelsPerMsgInstruction", err)
	}
	if discriminator != Instruction_SetMaxFeeJuelsPerMsg {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "SetMaxFeeJuelsPerMsgInstruction", Instruction_SetMaxFeeJuelsPerMsg, discriminator)
	}
	// Deserialize `MaxFeeJuelsPerMsg`:
	err = decoder.Decode(&obj.MaxFeeJuelsPerMsg)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SetMaxFeeJuelsPerMsgInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SetMaxFeeJuelsPerMsgInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 2 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 2, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SetMaxFeeJuelsPerMsgInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the SetMaxFeeJuelsPerMsgInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *SetMaxFeeJuelsPerMsgInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SetMaxFeeJuelsPerMsgInstruction: %w", err)
	}
	return nil
}

// UnmarshalSetMaxFeeJuelsPerMsgInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalSetMaxFeeJuelsPerMsgInstruction(buf []byte) (*SetMaxFeeJuelsPerMsgInstruction, error) {
	obj := new(SetMaxFeeJuelsPerMsgInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SetTokenTransferFeeConfigInstruction struct {
	ChainSelector uint64                 `json:"chain_selector"`
	Mint          solanago.PublicKey     `json:"mint"`
	Cfg           TokenTransferFeeConfig `json:"cfg"`

	// Accounts:
	Config                         solanago.PublicKey `json:"config"`
	PerChainPerTokenConfig         solanago.PublicKey `json:"per_chain_per_token_config"`
	PerChainPerTokenConfigWritable bool               `json:"per_chain_per_token_config_writable"`
	Authority                      solanago.PublicKey `json:"authority"`
	AuthorityWritable              bool               `json:"authority_writable"`
	AuthoritySigner                bool               `json:"authority_signer"`
	SystemProgram                  solanago.PublicKey `json:"system_program"`
}

func (obj *SetTokenTransferFeeConfigInstruction) GetDiscriminator() []byte {
	return Instruction_SetTokenTransferFeeConfig[:]
}

// UnmarshalWithDecoder unmarshals the SetTokenTransferFeeConfigInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *SetTokenTransferFeeConfigInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "SetTokenTransferFeeConfigInstruction", err)
	}
	if discriminator != Instruction_SetTokenTransferFeeConfig {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "SetTokenTransferFeeConfigInstruction", Instruction_SetTokenTransferFeeConfig, discriminator)
	}
	// Deserialize `ChainSelector`:
	err = decoder.Decode(&obj.ChainSelector)
	if err != nil {
		return err
	}
	// Deserialize `Mint`:
	err = decoder.Decode(&obj.Mint)
	if err != nil {
		return err
	}
	// Deserialize `Cfg`:
	err = decoder.Decode(&obj.Cfg)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SetTokenTransferFeeConfigInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from per_chain_per_token_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "per_chain_per_token_config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SetTokenTransferFeeConfigInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set per_chain_per_token_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "per_chain_per_token_config", len(accountKeys)-1)
	}
	obj.PerChainPerTokenConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SetTokenTransferFeeConfigInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.PerChainPerTokenConfig)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the SetTokenTransferFeeConfigInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *SetTokenTransferFeeConfigInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SetTokenTransferFeeConfigInstruction: %w", err)
	}
	return nil
}

// UnmarshalSetTokenTransferFeeConfigInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalSetTokenTransferFeeConfigInstruction(buf []byte) (*SetTokenTransferFeeConfigInstruction, error) {
	obj := new(SetTokenTransferFeeConfigInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type TransferOwnershipInstruction struct {
	NewOwner solanago.PublicKey `json:"new_owner"`

	// Accounts:
	Config          solanago.PublicKey `json:"config"`
	ConfigWritable  bool               `json:"config_writable"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
}

func (obj *TransferOwnershipInstruction) GetDiscriminator() []byte {
	return Instruction_TransferOwnership[:]
}

// UnmarshalWithDecoder unmarshals the TransferOwnershipInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *TransferOwnershipInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "TransferOwnershipInstruction", err)
	}
	if discriminator != Instruction_TransferOwnership {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "TransferOwnershipInstruction", Instruction_TransferOwnership, discriminator)
	}
	// Deserialize `NewOwner`:
	err = decoder.Decode(&obj.NewOwner)
	if err != nil {
		return err
	}
	return nil
}

func (obj *TransferOwnershipInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *TransferOwnershipInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 2 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 2, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *TransferOwnershipInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the TransferOwnershipInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *TransferOwnershipInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling TransferOwnershipInstruction: %w", err)
	}
	return nil
}

// UnmarshalTransferOwnershipInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalTransferOwnershipInstruction(buf []byte) (*TransferOwnershipInstruction, error) {
	obj := new(TransferOwnershipInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type TypeVersionInstruction struct {

	// Accounts:
	Clock solanago.PublicKey `json:"clock"`
}

func (obj *TypeVersionInstruction) GetDiscriminator() []byte {
	return Instruction_TypeVersion[:]
}

// UnmarshalWithDecoder unmarshals the TypeVersionInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *TypeVersionInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "TypeVersionInstruction", err)
	}
	if discriminator != Instruction_TypeVersion {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "TypeVersionInstruction", Instruction_TypeVersion, discriminator)
	}
	return nil
}

func (obj *TypeVersionInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from clock account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "clock", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *TypeVersionInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 1 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 1, len(indices))
	}
	indexOffset := 0
	// Set clock account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "clock", len(accountKeys)-1)
	}
	obj.Clock = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *TypeVersionInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Clock)
	return keys
}

// Unmarshal unmarshals the TypeVersionInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *TypeVersionInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling TypeVersionInstruction: %w", err)
	}
	return nil
}

// UnmarshalTypeVersionInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalTypeVersionInstruction(buf []byte) (*TypeVersionInstruction, error) {
	obj := new(TypeVersionInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UpdateBillingTokenConfigInstruction struct {
	Config BillingTokenConfig `json:"config"`

	// Accounts:
	ConfigAccount              solanago.PublicKey `json:"config_account"`
	BillingTokenConfig         solanago.PublicKey `json:"billing_token_config"`
	BillingTokenConfigWritable bool               `json:"billing_token_config_writable"`
	Authority                  solanago.PublicKey `json:"authority"`
	AuthoritySigner            bool               `json:"authority_signer"`
}

func (obj *UpdateBillingTokenConfigInstruction) GetDiscriminator() []byte {
	return Instruction_UpdateBillingTokenConfig[:]
}

// UnmarshalWithDecoder unmarshals the UpdateBillingTokenConfigInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *UpdateBillingTokenConfigInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "UpdateBillingTokenConfigInstruction", err)
	}
	if discriminator != Instruction_UpdateBillingTokenConfig {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "UpdateBillingTokenConfigInstruction", Instruction_UpdateBillingTokenConfig, discriminator)
	}
	// Deserialize `Config`:
	err = decoder.Decode(&obj.Config)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UpdateBillingTokenConfigInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from billing_token_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "billing_token_config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *UpdateBillingTokenConfigInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.ConfigAccount = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set billing_token_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "billing_token_config", len(accountKeys)-1)
	}
	obj.BillingTokenConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *UpdateBillingTokenConfigInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.ConfigAccount)
	keys = append(keys, obj.BillingTokenConfig)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the UpdateBillingTokenConfigInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *UpdateBillingTokenConfigInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdateBillingTokenConfigInstruction: %w", err)
	}
	return nil
}

// UnmarshalUpdateBillingTokenConfigInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalUpdateBillingTokenConfigInstruction(buf []byte) (*UpdateBillingTokenConfigInstruction, error) {
	obj := new(UpdateBillingTokenConfigInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UpdateDestChainConfigInstruction struct {
	ChainSelector   uint64          `json:"chain_selector"`
	DestChainConfig DestChainConfig `json:"dest_chain_config"`

	// Accounts:
	Config            solanago.PublicKey `json:"config"`
	DestChain         solanago.PublicKey `json:"dest_chain"`
	DestChainWritable bool               `json:"dest_chain_writable"`
	Authority         solanago.PublicKey `json:"authority"`
	AuthorityWritable bool               `json:"authority_writable"`
	AuthoritySigner   bool               `json:"authority_signer"`
}

func (obj *UpdateDestChainConfigInstruction) GetDiscriminator() []byte {
	return Instruction_UpdateDestChainConfig[:]
}

// UnmarshalWithDecoder unmarshals the UpdateDestChainConfigInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *UpdateDestChainConfigInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "UpdateDestChainConfigInstruction", err)
	}
	if discriminator != Instruction_UpdateDestChainConfig {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "UpdateDestChainConfigInstruction", Instruction_UpdateDestChainConfig, discriminator)
	}
	// Deserialize `ChainSelector`:
	err = decoder.Decode(&obj.ChainSelector)
	if err != nil {
		return err
	}
	// Deserialize `DestChainConfig`:
	err = decoder.Decode(&obj.DestChainConfig)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UpdateDestChainConfigInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from dest_chain account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "dest_chain", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *UpdateDestChainConfigInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set dest_chain account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "dest_chain", len(accountKeys)-1)
	}
	obj.DestChain = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *UpdateDestChainConfigInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.DestChain)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the UpdateDestChainConfigInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *UpdateDestChainConfigInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdateDestChainConfigInstruction: %w", err)
	}
	return nil
}

// UnmarshalUpdateDestChainConfigInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalUpdateDestChainConfigInstruction(buf []byte) (*UpdateDestChainConfigInstruction, error) {
	obj := new(UpdateDestChainConfigInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UpdatePricesInstruction struct {
	TokenUpdates []TokenPriceUpdate `json:"token_updates"`
	GasUpdates   []GasPriceUpdate   `json:"gas_updates"`

	// Accounts:
	Authority           solanago.PublicKey `json:"authority"`
	AuthoritySigner     bool               `json:"authority_signer"`
	AllowedPriceUpdater solanago.PublicKey `json:"allowed_price_updater"`
	Config              solanago.PublicKey `json:"config"`
}

func (obj *UpdatePricesInstruction) GetDiscriminator() []byte {
	return Instruction_UpdatePrices[:]
}

// UnmarshalWithDecoder unmarshals the UpdatePricesInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *UpdatePricesInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "UpdatePricesInstruction", err)
	}
	if discriminator != Instruction_UpdatePrices {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "UpdatePricesInstruction", Instruction_UpdatePrices, discriminator)
	}
	// Deserialize `TokenUpdates`:
	err = decoder.Decode(&obj.TokenUpdates)
	if err != nil {
		return err
	}
	// Deserialize `GasUpdates`:
	err = decoder.Decode(&obj.GasUpdates)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UpdatePricesInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from allowed_price_updater account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "allowed_price_updater", err)
	}
	indices = append(indices, index)
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *UpdatePricesInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set allowed_price_updater account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "allowed_price_updater", len(accountKeys)-1)
	}
	obj.AllowedPriceUpdater = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *UpdatePricesInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.AllowedPriceUpdater)
	keys = append(keys, obj.Config)
	return keys
}

// Unmarshal unmarshals the UpdatePricesInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *UpdatePricesInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdatePricesInstruction: %w", err)
	}
	return nil
}

// UnmarshalUpdatePricesInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalUpdatePricesInstruction(buf []byte) (*UpdatePricesInstruction, error) {
	obj := new(UpdatePricesInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Instruction interface defines common methods for all instruction types
type Instruction interface {
	GetDiscriminator() []byte

	UnmarshalWithDecoder(decoder *binary.Decoder) error

	UnmarshalAccountIndices(buf []byte) ([]uint8, error)

	PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error

	GetAccountKeys() []solanago.PublicKey
}

// ParseInstruction parses instruction data and optionally populates accounts
// If accountIndicesData is nil or empty, accounts will not be populated
func ParseInstruction(instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (Instruction, error) {
	// Validate inputs
	if len(instructionData) < 8 {
		return nil, fmt.Errorf("instruction data too short: expected at least 8 bytes, got %d", len(instructionData))
	}
	// Extract discriminator
	discriminator := [8]byte{}
	copy(discriminator[:], instructionData[0:8])
	// Parse based on discriminator
	switch discriminator {
	case Instruction_AcceptOwnership:
		instruction := new(AcceptOwnershipInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AcceptOwnershipInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_AddBillingTokenConfig:
		instruction := new(AddBillingTokenConfigInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AddBillingTokenConfigInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_AddDestChain:
		instruction := new(AddDestChainInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AddDestChainInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_AddPriceUpdater:
		instruction := new(AddPriceUpdaterInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AddPriceUpdaterInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_DisableDestChain:
		instruction := new(DisableDestChainInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as DisableDestChainInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_GetFee:
		instruction := new(GetFeeInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as GetFeeInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_Initialize:
		instruction := new(InitializeInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitializeInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_RemovePriceUpdater:
		instruction := new(RemovePriceUpdaterInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as RemovePriceUpdaterInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SetDefaultCodeVersion:
		instruction := new(SetDefaultCodeVersionInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SetDefaultCodeVersionInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SetLinkTokenMint:
		instruction := new(SetLinkTokenMintInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SetLinkTokenMintInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SetMaxFeeJuelsPerMsg:
		instruction := new(SetMaxFeeJuelsPerMsgInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SetMaxFeeJuelsPerMsgInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SetTokenTransferFeeConfig:
		instruction := new(SetTokenTransferFeeConfigInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SetTokenTransferFeeConfigInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_TransferOwnership:
		instruction := new(TransferOwnershipInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as TransferOwnershipInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_TypeVersion:
		instruction := new(TypeVersionInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as TypeVersionInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_UpdateBillingTokenConfig:
		instruction := new(UpdateBillingTokenConfigInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as UpdateBillingTokenConfigInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_UpdateDestChainConfig:
		instruction := new(UpdateDestChainConfigInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as UpdateDestChainConfigInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_UpdatePrices:
		instruction := new(UpdatePricesInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as UpdatePricesInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	default:
		return nil, fmt.Errorf("unknown instruction discriminator: %s", binary.FormatDiscriminator(discriminator))
	}
}

// ParseInstructionTyped parses instruction data and returns a specific instruction type // T must implement the Instruction interface
func ParseInstructionTyped[T Instruction](instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (T, error) {
	instruction, err := ParseInstruction(instructionData, accountIndicesData, accountKeys)
	if err != nil {
		return *new(T), err
	}
	typed, ok := instruction.(T)
	if !ok {
		return *new(T), fmt.Errorf("instruction is not of expected type")
	}
	return typed, nil
}

// ParseInstructionWithoutAccounts parses instruction data without account information
func ParseInstructionWithoutAccounts(instructionData []byte) (Instruction, error) {
	return ParseInstruction(instructionData, nil, []solanago.PublicKey{})
}

// ParseInstructionWithAccounts parses instruction data with account information
func ParseInstructionWithAccounts(instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (Instruction, error) {
	return ParseInstruction(instructionData, accountIndicesData, accountKeys)
}
