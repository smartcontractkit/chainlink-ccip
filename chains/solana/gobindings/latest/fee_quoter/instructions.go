// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains instructions.

package fee_quoter

import (
	"bytes"
	"fmt"
	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "accept_ownership" instruction.
// Accepts the ownership of the fee quoter by the proposed owner. //  // Shared func signature with other programs //  // # Arguments //  // * `ctx` - The context containing the accounts required for accepting ownership. // The new owner must be a signer of the transaction.
func NewAcceptOwnershipInstruction(
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "add_billing_token_config" instruction.
// Adds a billing token configuration. // Only CCIP Admin can add a billing token configuration. //  // # Arguments //  // * `ctx` - The context containing the accounts required for adding the billing token configuration. // * `config` - The billing token configuration to be added.
func NewAddBillingTokenConfigInstruction(
	// Params:
	configParam BillingTokenConfig,

	// Accounts:
	configAccount solanago.PublicKey,
	billingTokenConfigAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	feeTokenMintAccount solanago.PublicKey,
	feeTokenReceiverAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	feeBillingSignerAccount solanago.PublicKey,
	associatedTokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AddBillingTokenConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `configParam`:
		err = enc__.Encode(configParam)
		if err != nil {
			return nil, errors.NewField("configParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "billing_token_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(billingTokenConfigAccount, true, false))
		// Account 2 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 3 "fee_token_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeTokenMintAccount, false, false))
		// Account 4 "fee_token_receiver": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeTokenReceiverAccount, true, false))
		// Account 5 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 6 "fee_billing_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeBillingSignerAccount, false, false))
		// Account 7 "associated_token_program": Read-only, Non-signer, Required, Address: ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL
		accounts__.Append(solanago.NewAccountMeta(associatedTokenProgramAccount, false, false))
		// Account 8 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "add_dest_chain" instruction.
// Adds a new destination chain selector to the fee quoter. //  // The Admin needs to add any new chain supported. // When adding a new chain, the Admin needs to specify if it's enabled or not. //  // # Arguments //  // * `ctx` - The context containing the accounts required for adding the chain selector. // * `chain_selector` - The new chain selector to be added. // * `dest_chain_config` - The configuration for the chain as destination.
func NewAddDestChainInstruction(
	// Params:
	chainSelectorParam uint64,
	destChainConfigParam DestChainConfig,

	// Accounts:
	configAccount solanago.PublicKey,
	destChainAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AddDestChain[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `chainSelectorParam`:
		err = enc__.Encode(chainSelectorParam)
		if err != nil {
			return nil, errors.NewField("chainSelectorParam", err)
		}
		// Serialize `destChainConfigParam`:
		err = enc__.Encode(destChainConfigParam)
		if err != nil {
			return nil, errors.NewField("destChainConfigParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "dest_chain": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(destChainAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "add_price_updater" instruction.
// Add a price updater address to the list of allowed price updaters. // On price updates, the fee quoter will check the that caller is allowed. //  // # Arguments //  // * `ctx` - The context containing the accounts required for this operation. // * `price_updater` - The price updater address.
func NewAddPriceUpdaterInstruction(
	// Params:
	priceUpdaterParam solanago.PublicKey,

	// Accounts:
	allowedPriceUpdaterAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AddPriceUpdater[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `priceUpdaterParam`:
		err = enc__.Encode(priceUpdaterParam)
		if err != nil {
			return nil, errors.NewField("priceUpdaterParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "allowed_price_updater": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(allowedPriceUpdaterAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "disable_dest_chain" instruction.
// Disables the destination chain selector. //  // The Admin is the only one able to disable the chain selector as destination. This method is thought of as an emergency kill-switch. //  // # Arguments //  // * `ctx` - The context containing the accounts required for disabling the chain selector. // * `chain_selector` - The destination chain selector to be disabled.
func NewDisableDestChainInstruction(
	// Params:
	chainSelectorParam uint64,

	// Accounts:
	configAccount solanago.PublicKey,
	destChainAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_DisableDestChain[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `chainSelectorParam`:
		err = enc__.Encode(chainSelectorParam)
		if err != nil {
			return nil, errors.NewField("chainSelectorParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "dest_chain": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(destChainAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "get_fee" instruction.
// Calculates the fee for sending a message to the destination chain. //  // # Arguments //  // * `ctx` - The context containing the accounts required for the fee calculation. // * `dest_chain_selector` - The chain selector for the destination chain. // * `message` - The message to be sent. //  // # Additional accounts //  // In addition to the fixed amount of accounts defined in the `GetFee` context, // the following accounts must be provided: //  // * First, the billing token config accounts for each token sent with the message, sequentially. // For each token with no billing config account (i.e. tokens that cannot be possibly used as fee // tokens, which also have no BPS fees enabled) the ZERO address must be provided instead. // * Then, the per chain / per token config of every token sent with the message, sequentially // in the same order. //  // # Returns //  // GetFeeResult struct with: // - the fee token mint address, // - the fee amount of said token, // - the fee value in juels, // - additional data required when performing the cross-chain transfer of tokens in that message // - deserialized and processed extra args
func NewGetFeeInstruction(
	// Params:
	destChainSelectorParam uint64,
	messageParam Svm2AnyMessage,

	// Accounts:
	configAccount solanago.PublicKey,
	destChainAccount solanago.PublicKey,
	billingTokenConfigAccount solanago.PublicKey,
	linkTokenConfigAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_GetFee[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `destChainSelectorParam`:
		err = enc__.Encode(destChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("destChainSelectorParam", err)
		}
		// Serialize `messageParam`:
		err = enc__.Encode(messageParam)
		if err != nil {
			return nil, errors.NewField("messageParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "dest_chain": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(destChainAccount, false, false))
		// Account 2 "billing_token_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(billingTokenConfigAccount, false, false))
		// Account 3 "link_token_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(linkTokenConfigAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize" instruction.
// Initializes the Fee Quoter. //  // The initialization is responsibility of Admin, nothing more than calling this method should be done first. //  // # Arguments //  // * `ctx` - The context containing the accounts required for initialization. // * `max_fee_juels_per_msg` - The maximum fee in juels that can be charged per message. // * `onramp` - The public key of the onramp. //  // The function also uses the link_token_mint account from the context.
func NewInitializeInstruction(
	// Params:
	maxFeeJuelsPerMsgParam binary.Uint128,
	onrampParam solanago.PublicKey,

	// Accounts:
	configAccount solanago.PublicKey,
	linkTokenMintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
	programDataAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Initialize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `maxFeeJuelsPerMsgParam`:
		err = enc__.Encode(maxFeeJuelsPerMsgParam)
		if err != nil {
			return nil, errors.NewField("maxFeeJuelsPerMsgParam", err)
		}
		// Serialize `onrampParam`:
		err = enc__.Encode(onrampParam)
		if err != nil {
			return nil, errors.NewField("onrampParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "link_token_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(linkTokenMintAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 4 "program": Read-only, Non-signer, Required, Address: FeeQPGkKDeRV1MgoYfMH6L8o3KeuYjwUZrgn4LRKfjHi
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
		// Account 5 "program_data": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programDataAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "remove_price_updater" instruction.
// Remove a price updater address from the list of allowed price updaters. //  // # Arguments //  // * `ctx` - The context containing the accounts required for this operation. // * `price_updater` - The price updater address.
func NewRemovePriceUpdaterInstruction(
	// Params:
	priceUpdaterParam solanago.PublicKey,

	// Accounts:
	allowedPriceUpdaterAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RemovePriceUpdater[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `priceUpdaterParam`:
		err = enc__.Encode(priceUpdaterParam)
		if err != nil {
			return nil, errors.NewField("priceUpdaterParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "allowed_price_updater": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(allowedPriceUpdaterAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_default_code_version" instruction.
// Sets the default code version to be used. This is then used by the slim routing layer to determine // which version of the versioned business logic module (`instructions`) to use. Only the admin may set this. //  // Shared func signature with other programs //  // # Arguments //  // * `ctx` - The context containing the accounts required for updating the configuration. // * `code_version` - The new code version to be set as default.
func NewSetDefaultCodeVersionInstruction(
	// Params:
	codeVersionParam CodeVersion,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetDefaultCodeVersion[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `codeVersionParam`:
		err = enc__.Encode(codeVersionParam)
		if err != nil {
			return nil, errors.NewField("codeVersionParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_link_token_mint" instruction.
// Sets the link_token_mint and updates the link_token_local_decimals. //  // Only the admin may set this. //  // # Arguments //  // * `ctx` - The context containing the accounts required for updating the configuration.
func NewSetLinkTokenMintInstruction(
	configAccount solanago.PublicKey,
	linkTokenMintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "link_token_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(linkTokenMintAccount, false, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "set_max_fee_juels_per_msg" instruction.
// Sets the max_fee_juels_per_msg, which is an upper bound on how much can be billed for any message. // (1 juels = 1e-18 LINK) //  // Only the admin may set this. //  // # Arguments //  // * `ctx` - The context containing the accounts required for updating the configuration. // * `max_fee_juels_per_msg` - The new value for the max_feel_juels_per_msg config.
func NewSetMaxFeeJuelsPerMsgInstruction(
	// Params:
	maxFeeJuelsPerMsgParam binary.Uint128,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetMaxFeeJuelsPerMsg[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `maxFeeJuelsPerMsgParam`:
		err = enc__.Encode(maxFeeJuelsPerMsgParam)
		if err != nil {
			return nil, errors.NewField("maxFeeJuelsPerMsgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_token_transfer_fee_config" instruction.
// Sets the token transfer fee configuration for a particular token when it's transferred to a particular dest chain. // It is an upsert, initializing the per-chain-per-token config account if it doesn't exist // and overwriting it if it does. //  // Only the Admin can perform this operation. //  // # Arguments //  // * `ctx` - The context containing the accounts required for setting the token billing configuration. // * `chain_selector` - The chain selector. // * `mint` - The public key of the token mint. // * `cfg` - The token transfer fee configuration.
func NewSetTokenTransferFeeConfigInstruction(
	// Params:
	chainSelectorParam uint64,
	mintParam solanago.PublicKey,
	cfgParam TokenTransferFeeConfig,

	// Accounts:
	configAccount solanago.PublicKey,
	perChainPerTokenConfigAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetTokenTransferFeeConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `chainSelectorParam`:
		err = enc__.Encode(chainSelectorParam)
		if err != nil {
			return nil, errors.NewField("chainSelectorParam", err)
		}
		// Serialize `mintParam`:
		err = enc__.Encode(mintParam)
		if err != nil {
			return nil, errors.NewField("mintParam", err)
		}
		// Serialize `cfgParam`:
		err = enc__.Encode(cfgParam)
		if err != nil {
			return nil, errors.NewField("cfgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "per_chain_per_token_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(perChainPerTokenConfigAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "transfer_ownership" instruction.
// Transfers the ownership of the fee quoter to a new proposed owner. //  // Shared func signature with other programs //  // # Arguments //  // * `ctx` - The context containing the accounts required for the transfer. // * `proposed_owner` - The public key of the new proposed owner.
func NewTransferOwnershipInstruction(
	// Params:
	newOwnerParam solanago.PublicKey,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_TransferOwnership[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newOwnerParam`:
		err = enc__.Encode(newOwnerParam)
		if err != nil {
			return nil, errors.NewField("newOwnerParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "type_version" instruction.
// Returns the program type (name) and version. // Used by offchain code to easily determine which program & version is being interacted with. //  // # Arguments // * `ctx` - The context
func NewTypeVersionInstruction(
	clockAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "clock": Read-only, Non-signer, Required, Address: SysvarC1ock11111111111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(clockAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "update_billing_token_config" instruction.
// Updates the billing token configuration. // Only CCIP Admin can update a billing token configuration. //  // # Arguments //  // * `ctx` - The context containing the accounts required for updating the billing token configuration. // * `config` - The new billing token configuration.
func NewUpdateBillingTokenConfigInstruction(
	// Params:
	configParam BillingTokenConfig,

	// Accounts:
	configAccount solanago.PublicKey,
	billingTokenConfigAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateBillingTokenConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `configParam`:
		err = enc__.Encode(configParam)
		if err != nil {
			return nil, errors.NewField("configParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "billing_token_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(billingTokenConfigAccount, true, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_dest_chain_config" instruction.
// Updates the configuration of the destination chain selector. //  // The Admin is the only one able to update the destination chain config. //  // # Arguments //  // * `ctx` - The context containing the accounts required for updating the chain selector. // * `chain_selector` - The destination chain selector to be updated. // * `dest_chain_config` - The new configuration for the destination chain.
func NewUpdateDestChainConfigInstruction(
	// Params:
	chainSelectorParam uint64,
	destChainConfigParam DestChainConfig,

	// Accounts:
	configAccount solanago.PublicKey,
	destChainAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateDestChainConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `chainSelectorParam`:
		err = enc__.Encode(chainSelectorParam)
		if err != nil {
			return nil, errors.NewField("chainSelectorParam", err)
		}
		// Serialize `destChainConfigParam`:
		err = enc__.Encode(destChainConfigParam)
		if err != nil {
			return nil, errors.NewField("destChainConfigParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "dest_chain": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(destChainAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_prices" instruction.
// Updates prices for tokens and gas. This method may only be called by an allowed price updater. //  // # Arguments //  // * `ctx` - The context containing the accounts always required for the price updates // * `token_updates` - Vector of token price updates // * `gas_updates` - Vector of gas price updates //  // # Additional accounts //  // In addition to the fixed amount of accounts defined in the `UpdatePrices` context, // the following accounts must be provided: //  // * First, the billing token config accounts for each token whose price is being updated, in the same order // as the token_updates vector. // * Then, the dest chain accounts of every chain whose gas price is being updated, in the same order as the // gas_updates vector.
func NewUpdatePricesInstruction(
	// Params:
	tokenUpdatesParam []TokenPriceUpdate,
	gasUpdatesParam []GasPriceUpdate,

	// Accounts:
	authorityAccount solanago.PublicKey,
	allowedPriceUpdaterAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePrices[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `tokenUpdatesParam`:
		err = enc__.Encode(tokenUpdatesParam)
		if err != nil {
			return nil, errors.NewField("tokenUpdatesParam", err)
		}
		// Serialize `gasUpdatesParam`:
		err = enc__.Encode(gasUpdatesParam)
		if err != nil {
			return nil, errors.NewField("gasUpdatesParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 1 "allowed_price_updater": Read-only, Non-signer, Required
		// was added by the owner as an allowed price updater. The constraints enforced guarantee that it is the right PDA
		// and that it was initialized.
		accounts__.Append(solanago.NewAccountMeta(allowedPriceUpdaterAccount, false, false))
		// Account 2 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}
