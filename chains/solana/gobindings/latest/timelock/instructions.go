// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains instructions.

package timelock

import (
	"bytes"
	"fmt"
	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "accept_ownership" instruction.
// Accept ownership of the timelock config. //  // The proposed new owner must call this function to assume ownership. //  // # Parameters //  // - `ctx`: The context containing the configuration account. // - `_timelock_id`: The timelock identifier.
func NewAcceptOwnershipInstruction(
	// Params:
	timelockIdParam [32]uint8,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AcceptOwnership[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "append_bypasser_instruction_data" instruction.
// Append additional data to an instruction of a bypasser operation. //  // # Parameters //  // - `ctx`: The context containing the bypasser operation account. // - `_timelock_id`: The timelock identifier. // - `_id`: The operation identifier. // - `ix_index`: The index of the instruction. // - `ix_data_chunk`: The data to append.
func NewAppendBypasserInstructionDataInstruction(
	// Params:
	timelockIdParam [32]uint8,
	idParam [32]uint8,
	ixIndexParam uint32,
	ixDataChunkParam []byte,

	// Accounts:
	operationAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	roleAccessControllerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AppendBypasserInstructionData[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `idParam`:
		err = enc__.Encode(idParam)
		if err != nil {
			return nil, errors.NewField("idParam", err)
		}
		// Serialize `ixIndexParam`:
		err = enc__.Encode(ixIndexParam)
		if err != nil {
			return nil, errors.NewField("ixIndexParam", err)
		}
		// Serialize `ixDataChunkParam`:
		err = enc__.Encode(ixDataChunkParam)
		if err != nil {
			return nil, errors.NewField("ixDataChunkParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "operation": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(operationAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(roleAccessControllerAccount, false, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "append_instruction_data" instruction.
// Append additional instruction data to an instruction of an existing standard operation. //  // # Parameters //  // - `ctx`: The context containing the operation account. // - `_timelock_id`: The timelock identifier (for PDA derivation). // - `_id`: The operation identifier. // - `ix_index`: The index of the instruction to which the data will be appended. // - `ix_data_chunk`: A chunk of data to be appended.
func NewAppendInstructionDataInstruction(
	// Params:
	timelockIdParam [32]uint8,
	idParam [32]uint8,
	ixIndexParam uint32,
	ixDataChunkParam []byte,

	// Accounts:
	operationAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	roleAccessControllerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AppendInstructionData[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `idParam`:
		err = enc__.Encode(idParam)
		if err != nil {
			return nil, errors.NewField("idParam", err)
		}
		// Serialize `ixIndexParam`:
		err = enc__.Encode(ixIndexParam)
		if err != nil {
			return nil, errors.NewField("ixIndexParam", err)
		}
		// Serialize `ixDataChunkParam`:
		err = enc__.Encode(ixDataChunkParam)
		if err != nil {
			return nil, errors.NewField("ixDataChunkParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "operation": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(operationAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(roleAccessControllerAccount, false, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "batch_add_access" instruction.
// Add a new access role in batch. Only the admin is allowed to perform this operation. //  // # Parameters //  // - `ctx`: The context containing the accounts required for batch adding access. // - `timelock_id`: A unique, padded identifier for this timelock instance. // - `role`: The role to be added.
func NewBatchAddAccessInstruction(
	// Params:
	timelockIdParam [32]uint8,
	roleParam Role,

	// Accounts:
	configAccount solanago.PublicKey,
	accessControllerProgramAccount solanago.PublicKey,
	roleAccessControllerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_BatchAddAccess[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `roleParam`:
		err = enc__.Encode(roleParam)
		if err != nil {
			return nil, errors.NewField("roleParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "access_controller_program": Read-only, Non-signer, Required, Address: 6KsN58MTnRQ8FfPaXHiFPPFGDRioikj9CdPvPxZJdCjb
		accounts__.Append(solanago.NewAccountMeta(accessControllerProgramAccount, false, false))
		// Account 2 "role_access_controller": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(roleAccessControllerAccount, true, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "block_function_selector" instruction.
// Block a function selector from being called. //  // Only the admin can block function selectors. //  // # Parameters //  // - `ctx`: The context containing the configuration account. // - `_timelock_id`: The timelock identifier. // - `selector`: The 8-byte function selector(Anchor discriminator) to block.
func NewBlockFunctionSelectorInstruction(
	// Params:
	timelockIdParam [32]uint8,
	selectorParam [8]uint8,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_BlockFunctionSelector[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `selectorParam`:
		err = enc__.Encode(selectorParam)
		if err != nil {
			return nil, errors.NewField("selectorParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "bypasser_execute_batch" instruction.
// Execute operations immediately using the bypasser flow, bypassing time delays // and predecessor checks. //  // This function provides an emergency execution mechanism that: // 1. Skips the timelock waiting period required for standard operations // 2. Does not enforce predecessor dependencies // 3. Closes the operation account after execution //  // # Emergency Use Only //  // The bypasser flow is intended strictly for emergency situations where // waiting for the standard timelock delay would cause harm. Access to this // function is tightly controlled through the Bypasser role. //  // # Parameters //  // - `ctx`: Context containing operation accounts and signer information // - `timelock_id`: Identifier for the timelock instance // - `_id`: Operation ID (used for PDA derivation)
func NewBypasserExecuteBatchInstruction(
	// Params:
	timelockIdParam [32]uint8,
	idParam [32]uint8,

	// Accounts:
	operationAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	timelockSignerAccount solanago.PublicKey,
	roleAccessControllerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_BypasserExecuteBatch[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `idParam`:
		err = enc__.Encode(idParam)
		if err != nil {
			return nil, errors.NewField("idParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "operation": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(operationAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "timelock_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(timelockSignerAccount, false, false))
		// Account 3 "role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(roleAccessControllerAccount, false, false))
		// Account 4 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "cancel" instruction.
// Cancel a scheduled operation. //  // # Parameters //  // - `ctx`: The context containing the accounts for cancellation. // - `timelock_id`: The timelock identifier. // - `id`: The operation identifier (precalculated).
func NewCancelInstruction(
	// Params:
	timelockIdParam [32]uint8,
	idParam [32]uint8,

	// Accounts:
	operationAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	roleAccessControllerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Cancel[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `idParam`:
		err = enc__.Encode(idParam)
		if err != nil {
			return nil, errors.NewField("idParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "operation": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(operationAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(roleAccessControllerAccount, false, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "clear_bypasser_operation" instruction.
// Clear a finalized bypasser operation. //  // Closes the bypasser operation account. //  // # Parameters //  // - `ctx`: The context containing the bypasser operation account. // - `_timelock_id`: The timelock identifier. // - `_id`: The operation identifier.
func NewClearBypasserOperationInstruction(
	// Params:
	timelockIdParam [32]uint8,
	idParam [32]uint8,

	// Accounts:
	operationAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	roleAccessControllerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ClearBypasserOperation[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `idParam`:
		err = enc__.Encode(idParam)
		if err != nil {
			return nil, errors.NewField("idParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "operation": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(operationAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(roleAccessControllerAccount, false, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "clear_operation" instruction.
// Clear an operation that has been finalized. //  // This effectively closes the operation account so that it can be reinitialized later. //  // # Parameters //  // - `ctx`: The context containing the operation account. // - `_timelock_id`: The timelock identifier. // - `_id`: The operation identifier.
func NewClearOperationInstruction(
	// Params:
	timelockIdParam [32]uint8,
	idParam [32]uint8,

	// Accounts:
	operationAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	roleAccessControllerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ClearOperation[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `idParam`:
		err = enc__.Encode(idParam)
		if err != nil {
			return nil, errors.NewField("idParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "operation": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(operationAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(roleAccessControllerAccount, false, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "execute_batch" instruction.
// Executes a scheduled batch of operations after validating readiness and predecessor dependencies. //  // This function: // 1. Verifies the operation is ready for execution (delay period has passed) // 2. Validates that any predecessor operation has been completed // 3. Executes each instruction in the operation using the timelock signer PDA // 4. Emits events for each executed instruction //  // # Parameters //  // - `ctx`: Context containing operation accounts and signer information // - `timelock_id`: Identifier for the timelock instance // - `_id`: Operation ID (used for PDA derivation) //  // # Security Considerations //  // This instruction uses PDA signing to create a trusted execution environment. // The timelock's signer PDA will replace any account marked as a signer in the // original instructions, providing the necessary privileges while maintaining // security through program derivation.
func NewExecuteBatchInstruction(
	// Params:
	timelockIdParam [32]uint8,
	idParam [32]uint8,

	// Accounts:
	operationAccount solanago.PublicKey,
	predecessorOperationAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	timelockSignerAccount solanago.PublicKey,
	roleAccessControllerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ExecuteBatch[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `idParam`:
		err = enc__.Encode(idParam)
		if err != nil {
			return nil, errors.NewField("idParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "operation": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(operationAccount, true, false))
		// Account 1 "predecessor_operation": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(predecessorOperationAccount, false, false))
		// Account 2 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 3 "timelock_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(timelockSignerAccount, false, false))
		// Account 4 "role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(roleAccessControllerAccount, false, false))
		// Account 5 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "finalize_bypasser_operation" instruction.
// Finalize a bypasser operation. //  // Marks the bypasser operation as finalized, ready for execution. //  // # Parameters //  // - `ctx`: The context containing the bypasser operation account. // - `_timelock_id`: The timelock identifier. // - `_id`: The operation identifier.
func NewFinalizeBypasserOperationInstruction(
	// Params:
	timelockIdParam [32]uint8,
	idParam [32]uint8,

	// Accounts:
	operationAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	roleAccessControllerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_FinalizeBypasserOperation[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `idParam`:
		err = enc__.Encode(idParam)
		if err != nil {
			return nil, errors.NewField("idParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "operation": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(operationAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(roleAccessControllerAccount, false, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "finalize_operation" instruction.
// Finalize a standard operation. //  // Finalizing an operation marks it as ready for scheduling. //  // # Parameters //  // - `ctx`: The context containing the operation account. // - `_timelock_id`: The timelock identifier (for PDA derivation). // - `_id`: The operation identifier.
func NewFinalizeOperationInstruction(
	// Params:
	timelockIdParam [32]uint8,
	idParam [32]uint8,

	// Accounts:
	operationAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	roleAccessControllerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_FinalizeOperation[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `idParam`:
		err = enc__.Encode(idParam)
		if err != nil {
			return nil, errors.NewField("idParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "operation": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(operationAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(roleAccessControllerAccount, false, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize" instruction.
// Initialize the timelock configuration. //  // # Parameters //  // - `ctx`: The context containing the accounts required for initialization. // - `timelock_id`: A unique, padded identifier for this timelock instance. // - `min_delay`: The minimum delay (in seconds) required for scheduled operations.
func NewInitializeInstruction(
	// Params:
	timelockIdParam [32]uint8,
	minDelayParam uint64,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
	programDataAccount solanago.PublicKey,
	accessControllerProgramAccount solanago.PublicKey,
	proposerRoleAccessControllerAccount solanago.PublicKey,
	executorRoleAccessControllerAccount solanago.PublicKey,
	cancellerRoleAccessControllerAccount solanago.PublicKey,
	bypasserRoleAccessControllerAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Initialize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `minDelayParam`:
		err = enc__.Encode(minDelayParam)
		if err != nil {
			return nil, errors.NewField("minDelayParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 3 "program": Read-only, Non-signer, Required, Address: DoajfR5tK24xVw51fWcawUZWhAXD8yrBJVacc13neVQA
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
		// Account 4 "program_data": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programDataAccount, false, false))
		// Account 5 "access_controller_program": Read-only, Non-signer, Required, Address: 6KsN58MTnRQ8FfPaXHiFPPFGDRioikj9CdPvPxZJdCjb
		accounts__.Append(solanago.NewAccountMeta(accessControllerProgramAccount, false, false))
		// Account 6 "proposer_role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(proposerRoleAccessControllerAccount, false, false))
		// Account 7 "executor_role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(executorRoleAccessControllerAccount, false, false))
		// Account 8 "canceller_role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(cancellerRoleAccessControllerAccount, false, false))
		// Account 9 "bypasser_role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(bypasserRoleAccessControllerAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_bypasser_instruction" instruction.
// Initialize an instruction for a bypasser operation. //  // # Parameters //  // - `ctx`: The context containing the bypasser operation account. // - `_timelock_id`: The timelock identifier. // - `_id`: The operation identifier. // - `program_id`: The target program for the instruction. // - `accounts`: The list of accounts required for the instruction.
func NewInitializeBypasserInstructionInstruction(
	// Params:
	timelockIdParam [32]uint8,
	idParam [32]uint8,
	programIdParam solanago.PublicKey,
	accountsParam []InstructionAccount,

	// Accounts:
	operationAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	roleAccessControllerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeBypasserInstruction[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `idParam`:
		err = enc__.Encode(idParam)
		if err != nil {
			return nil, errors.NewField("idParam", err)
		}
		// Serialize `programIdParam`:
		err = enc__.Encode(programIdParam)
		if err != nil {
			return nil, errors.NewField("programIdParam", err)
		}
		// Serialize `accountsParam`:
		err = enc__.Encode(accountsParam)
		if err != nil {
			return nil, errors.NewField("accountsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "operation": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(operationAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(roleAccessControllerAccount, false, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_bypasser_operation" instruction.
// Initialize a bypasser operation. //  // Bypasser operations have no predecessor and can be executed without delay. //  // # Parameters //  // - `ctx`: The context containing the bypasser operation account. // - `_timelock_id`: The timelock identifier. // - `id`: The operation identifier. // - `salt`: A salt value for PDA derivation. // - `instruction_count`: The number of instructions to be added.
func NewInitializeBypasserOperationInstruction(
	// Params:
	timelockIdParam [32]uint8,
	idParam [32]uint8,
	saltParam [32]uint8,
	instructionCountParam uint32,

	// Accounts:
	operationAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	roleAccessControllerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeBypasserOperation[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `idParam`:
		err = enc__.Encode(idParam)
		if err != nil {
			return nil, errors.NewField("idParam", err)
		}
		// Serialize `saltParam`:
		err = enc__.Encode(saltParam)
		if err != nil {
			return nil, errors.NewField("saltParam", err)
		}
		// Serialize `instructionCountParam`:
		err = enc__.Encode(instructionCountParam)
		if err != nil {
			return nil, errors.NewField("instructionCountParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "operation": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(operationAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(roleAccessControllerAccount, false, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_instruction" instruction.
// Append a new instruction to an existing standard operation. //  // # Parameters //  // - `ctx`: The context containing the operation account. // - `_timelock_id`: The timelock identifier (for PDA derivation). // - `_id`: The operation identifier. // - `program_id`: The target program for the instruction. // - `accounts`: The list of accounts required for the instruction.
func NewInitializeInstructionInstruction(
	// Params:
	timelockIdParam [32]uint8,
	idParam [32]uint8,
	programIdParam solanago.PublicKey,
	accountsParam []InstructionAccount,

	// Accounts:
	operationAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	roleAccessControllerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeInstruction[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `idParam`:
		err = enc__.Encode(idParam)
		if err != nil {
			return nil, errors.NewField("idParam", err)
		}
		// Serialize `programIdParam`:
		err = enc__.Encode(programIdParam)
		if err != nil {
			return nil, errors.NewField("programIdParam", err)
		}
		// Serialize `accountsParam`:
		err = enc__.Encode(accountsParam)
		if err != nil {
			return nil, errors.NewField("accountsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "operation": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(operationAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(roleAccessControllerAccount, false, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_operation" instruction.
// Initialize a new standard timelock operation. //  // This sets up a new operation with the given ID, predecessor, salt, and expected number of instructions. //  // # Parameters //  // - `ctx`: The context containing the operation account. // - `_timelock_id`: A padded identifier for the timelock (unused here but required for PDA derivation). // - `id`: The unique identifier for the operation. // - `predecessor`: The identifier of the predecessor operation. // - `salt`: A salt value to help create unique PDAs. // - `instruction_count`: The total number of instructions that will be added to this operation.
func NewInitializeOperationInstruction(
	// Params:
	timelockIdParam [32]uint8,
	idParam [32]uint8,
	predecessorParam [32]uint8,
	saltParam [32]uint8,
	instructionCountParam uint32,

	// Accounts:
	operationAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	roleAccessControllerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeOperation[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `idParam`:
		err = enc__.Encode(idParam)
		if err != nil {
			return nil, errors.NewField("idParam", err)
		}
		// Serialize `predecessorParam`:
		err = enc__.Encode(predecessorParam)
		if err != nil {
			return nil, errors.NewField("predecessorParam", err)
		}
		// Serialize `saltParam`:
		err = enc__.Encode(saltParam)
		if err != nil {
			return nil, errors.NewField("saltParam", err)
		}
		// Serialize `instructionCountParam`:
		err = enc__.Encode(instructionCountParam)
		if err != nil {
			return nil, errors.NewField("instructionCountParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "operation": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(operationAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(roleAccessControllerAccount, false, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "schedule_batch" instruction.
// Schedule a finalized operation to be executed after a delay. //  // # Parameters //  // - `ctx`: The context containing the accounts for scheduling. // - `timelock_id`: The timelock identifier. // - `id`: The operation identifier. // - `delay`: The delay (in seconds) before the operation can be executed.
func NewScheduleBatchInstruction(
	// Params:
	timelockIdParam [32]uint8,
	idParam [32]uint8,
	delayParam uint64,

	// Accounts:
	operationAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	roleAccessControllerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ScheduleBatch[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `idParam`:
		err = enc__.Encode(idParam)
		if err != nil {
			return nil, errors.NewField("idParam", err)
		}
		// Serialize `delayParam`:
		err = enc__.Encode(delayParam)
		if err != nil {
			return nil, errors.NewField("delayParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "operation": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(operationAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(roleAccessControllerAccount, false, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "transfer_ownership" instruction.
// Propose a new owner for the timelock instance config. //  // Only the current owner (admin) can propose a new owner. //  // # Parameters //  // - `ctx`: The context containing the configuration account. // - `_timelock_id`: The timelock identifier. // - `proposed_owner`: The public key of the proposed new owner.
func NewTransferOwnershipInstruction(
	// Params:
	timelockIdParam [32]uint8,
	proposedOwnerParam solanago.PublicKey,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_TransferOwnership[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `proposedOwnerParam`:
		err = enc__.Encode(proposedOwnerParam)
		if err != nil {
			return nil, errors.NewField("proposedOwnerParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "unblock_function_selector" instruction.
// Unblock a previously blocked function selector. //  // Only the admin can unblock function selectors. //  // # Parameters //  // - `ctx`: The context containing the configuration account. // - `_timelock_id`: The timelock identifier. // - `selector`: The function selector to unblock.
func NewUnblockFunctionSelectorInstruction(
	// Params:
	timelockIdParam [32]uint8,
	selectorParam [8]uint8,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UnblockFunctionSelector[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `selectorParam`:
		err = enc__.Encode(selectorParam)
		if err != nil {
			return nil, errors.NewField("selectorParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_delay" instruction.
// Update the minimum delay required for scheduled operations. //  // Only the admin can update the delay. //  // # Parameters //  // - `ctx`: The context containing the configuration account. // - `_timelock_id`: The timelock identifier. // - `delay`: The new minimum delay value.
func NewUpdateDelayInstruction(
	// Params:
	timelockIdParam [32]uint8,
	delayParam uint64,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateDelay[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `delayParam`:
		err = enc__.Encode(delayParam)
		if err != nil {
			return nil, errors.NewField("delayParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}
