// Code generated by https://github.com/Unheilbar/anchor-go. DO NOT EDIT.
// This file contains instructions and instruction parsers.

package timelock

import (
	"bytes"
	"fmt"
	errors "github.com/Unheilbar/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "accept_ownership" instruction.
// Accept ownership of the timelock config. //  // The proposed new owner must call this function to assume ownership. //  // # Parameters //  // - `ctx`: The context containing the configuration account. // - `_timelock_id`: The timelock identifier.
func NewAcceptOwnershipInstruction(
	// Params:
	timelockIdParam [32]uint8,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AcceptOwnership[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "append_bypasser_instruction_data" instruction.
// Append additional data to an instruction of a bypasser operation. //  // # Parameters //  // - `ctx`: The context containing the bypasser operation account. // - `_timelock_id`: The timelock identifier. // - `_id`: The operation identifier. // - `ix_index`: The index of the instruction. // - `ix_data_chunk`: The data to append.
func NewAppendBypasserInstructionDataInstruction(
	// Params:
	timelockIdParam [32]uint8,
	idParam [32]uint8,
	ixIndexParam uint32,
	ixDataChunkParam []byte,

	// Accounts:
	operationAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	roleAccessControllerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AppendBypasserInstructionData[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `idParam`:
		err = enc__.Encode(idParam)
		if err != nil {
			return nil, errors.NewField("idParam", err)
		}
		// Serialize `ixIndexParam`:
		err = enc__.Encode(ixIndexParam)
		if err != nil {
			return nil, errors.NewField("ixIndexParam", err)
		}
		// Serialize `ixDataChunkParam`:
		err = enc__.Encode(ixDataChunkParam)
		if err != nil {
			return nil, errors.NewField("ixDataChunkParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "operation": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(operationAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(roleAccessControllerAccount, false, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "append_instruction_data" instruction.
// Append additional instruction data to an instruction of an existing standard operation. //  // # Parameters //  // - `ctx`: The context containing the operation account. // - `_timelock_id`: The timelock identifier (for PDA derivation). // - `_id`: The operation identifier. // - `ix_index`: The index of the instruction to which the data will be appended. // - `ix_data_chunk`: A chunk of data to be appended.
func NewAppendInstructionDataInstruction(
	// Params:
	timelockIdParam [32]uint8,
	idParam [32]uint8,
	ixIndexParam uint32,
	ixDataChunkParam []byte,

	// Accounts:
	operationAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	roleAccessControllerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AppendInstructionData[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `idParam`:
		err = enc__.Encode(idParam)
		if err != nil {
			return nil, errors.NewField("idParam", err)
		}
		// Serialize `ixIndexParam`:
		err = enc__.Encode(ixIndexParam)
		if err != nil {
			return nil, errors.NewField("ixIndexParam", err)
		}
		// Serialize `ixDataChunkParam`:
		err = enc__.Encode(ixDataChunkParam)
		if err != nil {
			return nil, errors.NewField("ixDataChunkParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "operation": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(operationAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(roleAccessControllerAccount, false, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "batch_add_access" instruction.
// Add a new access role in batch. Only the admin is allowed to perform this operation. //  // # Parameters //  // - `ctx`: The context containing the accounts required for batch adding access. // - `timelock_id`: A unique, padded identifier for this timelock instance. // - `role`: The role to be added.
func NewBatchAddAccessInstruction(
	// Params:
	timelockIdParam [32]uint8,
	roleParam Role,

	// Accounts:
	configAccount solanago.PublicKey,
	accessControllerProgramAccount solanago.PublicKey,
	roleAccessControllerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_BatchAddAccess[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `roleParam`:
		err = enc__.Encode(roleParam)
		if err != nil {
			return nil, errors.NewField("roleParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "access_controller_program": Read-only, Non-signer, Required, Address: 6KsN58MTnRQ8FfPaXHiFPPFGDRioikj9CdPvPxZJdCjb
		accounts__.Append(solanago.NewAccountMeta(accessControllerProgramAccount, false, false))
		// Account 2 "role_access_controller": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(roleAccessControllerAccount, true, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "block_function_selector" instruction.
// Block a function selector from being called. //  // Only the admin can block function selectors. //  // # Parameters //  // - `ctx`: The context containing the configuration account. // - `_timelock_id`: The timelock identifier. // - `selector`: The 8-byte function selector(Anchor discriminator) to block.
func NewBlockFunctionSelectorInstruction(
	// Params:
	timelockIdParam [32]uint8,
	selectorParam [8]uint8,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_BlockFunctionSelector[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `selectorParam`:
		err = enc__.Encode(selectorParam)
		if err != nil {
			return nil, errors.NewField("selectorParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "bypasser_execute_batch" instruction.
// Execute operations immediately using the bypasser flow, bypassing time delays // and predecessor checks. //  // This function provides an emergency execution mechanism that: // 1. Skips the timelock waiting period required for standard operations // 2. Does not enforce predecessor dependencies // 3. Closes the operation account after execution //  // # Emergency Use Only //  // The bypasser flow is intended strictly for emergency situations where // waiting for the standard timelock delay would cause harm. Access to this // function is tightly controlled through the Bypasser role. //  // # Parameters //  // - `ctx`: Context containing operation accounts and signer information // - `timelock_id`: Identifier for the timelock instance // - `_id`: Operation ID (used for PDA derivation)
func NewBypasserExecuteBatchInstruction(
	// Params:
	timelockIdParam [32]uint8,
	idParam [32]uint8,

	// Accounts:
	operationAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	timelockSignerAccount solanago.PublicKey,
	roleAccessControllerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_BypasserExecuteBatch[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `idParam`:
		err = enc__.Encode(idParam)
		if err != nil {
			return nil, errors.NewField("idParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "operation": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(operationAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "timelock_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(timelockSignerAccount, false, false))
		// Account 3 "role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(roleAccessControllerAccount, false, false))
		// Account 4 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "cancel" instruction.
// Cancel a scheduled operation. //  // # Parameters //  // - `ctx`: The context containing the accounts for cancellation. // - `timelock_id`: The timelock identifier. // - `id`: The operation identifier (precalculated).
func NewCancelInstruction(
	// Params:
	timelockIdParam [32]uint8,
	idParam [32]uint8,

	// Accounts:
	operationAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	roleAccessControllerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Cancel[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `idParam`:
		err = enc__.Encode(idParam)
		if err != nil {
			return nil, errors.NewField("idParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "operation": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(operationAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(roleAccessControllerAccount, false, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "clear_bypasser_operation" instruction.
// Clear a finalized bypasser operation. //  // Closes the bypasser operation account. //  // # Parameters //  // - `ctx`: The context containing the bypasser operation account. // - `_timelock_id`: The timelock identifier. // - `_id`: The operation identifier.
func NewClearBypasserOperationInstruction(
	// Params:
	timelockIdParam [32]uint8,
	idParam [32]uint8,

	// Accounts:
	operationAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	roleAccessControllerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ClearBypasserOperation[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `idParam`:
		err = enc__.Encode(idParam)
		if err != nil {
			return nil, errors.NewField("idParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "operation": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(operationAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(roleAccessControllerAccount, false, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "clear_operation" instruction.
// Clear an operation that has been finalized. //  // This effectively closes the operation account so that it can be reinitialized later. //  // # Parameters //  // - `ctx`: The context containing the operation account. // - `_timelock_id`: The timelock identifier. // - `_id`: The operation identifier.
func NewClearOperationInstruction(
	// Params:
	timelockIdParam [32]uint8,
	idParam [32]uint8,

	// Accounts:
	operationAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	roleAccessControllerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ClearOperation[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `idParam`:
		err = enc__.Encode(idParam)
		if err != nil {
			return nil, errors.NewField("idParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "operation": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(operationAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(roleAccessControllerAccount, false, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "execute_batch" instruction.
// Executes a scheduled batch of operations after validating readiness and predecessor dependencies. //  // This function: // 1. Verifies the operation is ready for execution (delay period has passed) // 2. Validates that any predecessor operation has been completed // 3. Executes each instruction in the operation using the timelock signer PDA // 4. Emits events for each executed instruction //  // # Parameters //  // - `ctx`: Context containing operation accounts and signer information // - `timelock_id`: Identifier for the timelock instance // - `_id`: Operation ID (used for PDA derivation) //  // # Security Considerations //  // This instruction uses PDA signing to create a trusted execution environment. // The timelock's signer PDA will replace any account marked as a signer in the // original instructions, providing the necessary privileges while maintaining // security through program derivation.
func NewExecuteBatchInstruction(
	// Params:
	timelockIdParam [32]uint8,
	idParam [32]uint8,

	// Accounts:
	operationAccount solanago.PublicKey,
	predecessorOperationAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	timelockSignerAccount solanago.PublicKey,
	roleAccessControllerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ExecuteBatch[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `idParam`:
		err = enc__.Encode(idParam)
		if err != nil {
			return nil, errors.NewField("idParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "operation": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(operationAccount, true, false))
		// Account 1 "predecessor_operation": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(predecessorOperationAccount, false, false))
		// Account 2 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 3 "timelock_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(timelockSignerAccount, false, false))
		// Account 4 "role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(roleAccessControllerAccount, false, false))
		// Account 5 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "finalize_bypasser_operation" instruction.
// Finalize a bypasser operation. //  // Marks the bypasser operation as finalized, ready for execution. //  // # Parameters //  // - `ctx`: The context containing the bypasser operation account. // - `_timelock_id`: The timelock identifier. // - `_id`: The operation identifier.
func NewFinalizeBypasserOperationInstruction(
	// Params:
	timelockIdParam [32]uint8,
	idParam [32]uint8,

	// Accounts:
	operationAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	roleAccessControllerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_FinalizeBypasserOperation[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `idParam`:
		err = enc__.Encode(idParam)
		if err != nil {
			return nil, errors.NewField("idParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "operation": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(operationAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(roleAccessControllerAccount, false, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "finalize_operation" instruction.
// Finalize a standard operation. //  // Finalizing an operation marks it as ready for scheduling. //  // # Parameters //  // - `ctx`: The context containing the operation account. // - `_timelock_id`: The timelock identifier (for PDA derivation). // - `_id`: The operation identifier.
func NewFinalizeOperationInstruction(
	// Params:
	timelockIdParam [32]uint8,
	idParam [32]uint8,

	// Accounts:
	operationAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	roleAccessControllerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_FinalizeOperation[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `idParam`:
		err = enc__.Encode(idParam)
		if err != nil {
			return nil, errors.NewField("idParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "operation": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(operationAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(roleAccessControllerAccount, false, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize" instruction.
// Initialize the timelock configuration. //  // # Parameters //  // - `ctx`: The context containing the accounts required for initialization. // - `timelock_id`: A unique, padded identifier for this timelock instance. // - `min_delay`: The minimum delay (in seconds) required for scheduled operations.
func NewInitializeInstruction(
	// Params:
	timelockIdParam [32]uint8,
	minDelayParam uint64,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
	programDataAccount solanago.PublicKey,
	accessControllerProgramAccount solanago.PublicKey,
	proposerRoleAccessControllerAccount solanago.PublicKey,
	executorRoleAccessControllerAccount solanago.PublicKey,
	cancellerRoleAccessControllerAccount solanago.PublicKey,
	bypasserRoleAccessControllerAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Initialize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `minDelayParam`:
		err = enc__.Encode(minDelayParam)
		if err != nil {
			return nil, errors.NewField("minDelayParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 3 "program": Read-only, Non-signer, Required, Address: DoajfR5tK24xVw51fWcawUZWhAXD8yrBJVacc13neVQA
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
		// Account 4 "program_data": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programDataAccount, false, false))
		// Account 5 "access_controller_program": Read-only, Non-signer, Required, Address: 6KsN58MTnRQ8FfPaXHiFPPFGDRioikj9CdPvPxZJdCjb
		accounts__.Append(solanago.NewAccountMeta(accessControllerProgramAccount, false, false))
		// Account 6 "proposer_role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(proposerRoleAccessControllerAccount, false, false))
		// Account 7 "executor_role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(executorRoleAccessControllerAccount, false, false))
		// Account 8 "canceller_role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(cancellerRoleAccessControllerAccount, false, false))
		// Account 9 "bypasser_role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(bypasserRoleAccessControllerAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_bypasser_instruction" instruction.
// Initialize an instruction for a bypasser operation. //  // # Parameters //  // - `ctx`: The context containing the bypasser operation account. // - `_timelock_id`: The timelock identifier. // - `_id`: The operation identifier. // - `program_id`: The target program for the instruction. // - `accounts`: The list of accounts required for the instruction.
func NewInitializeBypasserInstructionInstruction(
	// Params:
	timelockIdParam [32]uint8,
	idParam [32]uint8,
	programIdParam solanago.PublicKey,
	accountsParam []InstructionAccount,

	// Accounts:
	operationAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	roleAccessControllerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeBypasserInstruction[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `idParam`:
		err = enc__.Encode(idParam)
		if err != nil {
			return nil, errors.NewField("idParam", err)
		}
		// Serialize `programIdParam`:
		err = enc__.Encode(programIdParam)
		if err != nil {
			return nil, errors.NewField("programIdParam", err)
		}
		// Serialize `accountsParam`:
		err = enc__.Encode(accountsParam)
		if err != nil {
			return nil, errors.NewField("accountsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "operation": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(operationAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(roleAccessControllerAccount, false, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_bypasser_operation" instruction.
// Initialize a bypasser operation. //  // Bypasser operations have no predecessor and can be executed without delay. //  // # Parameters //  // - `ctx`: The context containing the bypasser operation account. // - `_timelock_id`: The timelock identifier. // - `id`: The operation identifier. // - `salt`: A salt value for PDA derivation. // - `instruction_count`: The number of instructions to be added.
func NewInitializeBypasserOperationInstruction(
	// Params:
	timelockIdParam [32]uint8,
	idParam [32]uint8,
	saltParam [32]uint8,
	instructionCountParam uint32,

	// Accounts:
	operationAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	roleAccessControllerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeBypasserOperation[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `idParam`:
		err = enc__.Encode(idParam)
		if err != nil {
			return nil, errors.NewField("idParam", err)
		}
		// Serialize `saltParam`:
		err = enc__.Encode(saltParam)
		if err != nil {
			return nil, errors.NewField("saltParam", err)
		}
		// Serialize `instructionCountParam`:
		err = enc__.Encode(instructionCountParam)
		if err != nil {
			return nil, errors.NewField("instructionCountParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "operation": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(operationAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(roleAccessControllerAccount, false, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_instruction" instruction.
// Append a new instruction to an existing standard operation. //  // # Parameters //  // - `ctx`: The context containing the operation account. // - `_timelock_id`: The timelock identifier (for PDA derivation). // - `_id`: The operation identifier. // - `program_id`: The target program for the instruction. // - `accounts`: The list of accounts required for the instruction.
func NewInitializeInstructionInstruction(
	// Params:
	timelockIdParam [32]uint8,
	idParam [32]uint8,
	programIdParam solanago.PublicKey,
	accountsParam []InstructionAccount,

	// Accounts:
	operationAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	roleAccessControllerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeInstruction[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `idParam`:
		err = enc__.Encode(idParam)
		if err != nil {
			return nil, errors.NewField("idParam", err)
		}
		// Serialize `programIdParam`:
		err = enc__.Encode(programIdParam)
		if err != nil {
			return nil, errors.NewField("programIdParam", err)
		}
		// Serialize `accountsParam`:
		err = enc__.Encode(accountsParam)
		if err != nil {
			return nil, errors.NewField("accountsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "operation": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(operationAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(roleAccessControllerAccount, false, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_operation" instruction.
// Initialize a new standard timelock operation. //  // This sets up a new operation with the given ID, predecessor, salt, and expected number of instructions. //  // # Parameters //  // - `ctx`: The context containing the operation account. // - `_timelock_id`: A padded identifier for the timelock (unused here but required for PDA derivation). // - `id`: The unique identifier for the operation. // - `predecessor`: The identifier of the predecessor operation. // - `salt`: A salt value to help create unique PDAs. // - `instruction_count`: The total number of instructions that will be added to this operation.
func NewInitializeOperationInstruction(
	// Params:
	timelockIdParam [32]uint8,
	idParam [32]uint8,
	predecessorParam [32]uint8,
	saltParam [32]uint8,
	instructionCountParam uint32,

	// Accounts:
	operationAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	roleAccessControllerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeOperation[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `idParam`:
		err = enc__.Encode(idParam)
		if err != nil {
			return nil, errors.NewField("idParam", err)
		}
		// Serialize `predecessorParam`:
		err = enc__.Encode(predecessorParam)
		if err != nil {
			return nil, errors.NewField("predecessorParam", err)
		}
		// Serialize `saltParam`:
		err = enc__.Encode(saltParam)
		if err != nil {
			return nil, errors.NewField("saltParam", err)
		}
		// Serialize `instructionCountParam`:
		err = enc__.Encode(instructionCountParam)
		if err != nil {
			return nil, errors.NewField("instructionCountParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "operation": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(operationAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(roleAccessControllerAccount, false, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "schedule_batch" instruction.
// Schedule a finalized operation to be executed after a delay. //  // # Parameters //  // - `ctx`: The context containing the accounts for scheduling. // - `timelock_id`: The timelock identifier. // - `id`: The operation identifier. // - `delay`: The delay (in seconds) before the operation can be executed.
func NewScheduleBatchInstruction(
	// Params:
	timelockIdParam [32]uint8,
	idParam [32]uint8,
	delayParam uint64,

	// Accounts:
	operationAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	roleAccessControllerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ScheduleBatch[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `idParam`:
		err = enc__.Encode(idParam)
		if err != nil {
			return nil, errors.NewField("idParam", err)
		}
		// Serialize `delayParam`:
		err = enc__.Encode(delayParam)
		if err != nil {
			return nil, errors.NewField("delayParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "operation": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(operationAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "role_access_controller": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(roleAccessControllerAccount, false, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "transfer_ownership" instruction.
// Propose a new owner for the timelock instance config. //  // Only the current owner (admin) can propose a new owner. //  // # Parameters //  // - `ctx`: The context containing the configuration account. // - `_timelock_id`: The timelock identifier. // - `proposed_owner`: The public key of the proposed new owner.
func NewTransferOwnershipInstruction(
	// Params:
	timelockIdParam [32]uint8,
	proposedOwnerParam solanago.PublicKey,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_TransferOwnership[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `proposedOwnerParam`:
		err = enc__.Encode(proposedOwnerParam)
		if err != nil {
			return nil, errors.NewField("proposedOwnerParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "unblock_function_selector" instruction.
// Unblock a previously blocked function selector. //  // Only the admin can unblock function selectors. //  // # Parameters //  // - `ctx`: The context containing the configuration account. // - `_timelock_id`: The timelock identifier. // - `selector`: The function selector to unblock.
func NewUnblockFunctionSelectorInstruction(
	// Params:
	timelockIdParam [32]uint8,
	selectorParam [8]uint8,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UnblockFunctionSelector[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `selectorParam`:
		err = enc__.Encode(selectorParam)
		if err != nil {
			return nil, errors.NewField("selectorParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_delay" instruction.
// Update the minimum delay required for scheduled operations. //  // Only the admin can update the delay. //  // # Parameters //  // - `ctx`: The context containing the configuration account. // - `_timelock_id`: The timelock identifier. // - `delay`: The new minimum delay value.
func NewUpdateDelayInstruction(
	// Params:
	timelockIdParam [32]uint8,
	delayParam uint64,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateDelay[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `timelockIdParam`:
		err = enc__.Encode(timelockIdParam)
		if err != nil {
			return nil, errors.NewField("timelockIdParam", err)
		}
		// Serialize `delayParam`:
		err = enc__.Encode(delayParam)
		if err != nil {
			return nil, errors.NewField("delayParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

type AcceptOwnershipInstruction struct {
	TimelockId [32]uint8 `json:"_timelock_id"`

	// Accounts:
	Config          solanago.PublicKey `json:"config"`
	ConfigWritable  bool               `json:"config_writable"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
}

func (obj *AcceptOwnershipInstruction) GetDiscriminator() []byte {
	return Instruction_AcceptOwnership[:]
}

// UnmarshalWithDecoder unmarshals the AcceptOwnershipInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *AcceptOwnershipInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "AcceptOwnershipInstruction", err)
	}
	if discriminator != Instruction_AcceptOwnership {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "AcceptOwnershipInstruction", Instruction_AcceptOwnership, discriminator)
	}
	// Deserialize `TimelockId`:
	err = decoder.Decode(&obj.TimelockId)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AcceptOwnershipInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AcceptOwnershipInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 2 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 2, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AcceptOwnershipInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the AcceptOwnershipInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *AcceptOwnershipInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AcceptOwnershipInstruction: %w", err)
	}
	return nil
}

// UnmarshalAcceptOwnershipInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalAcceptOwnershipInstruction(buf []byte) (*AcceptOwnershipInstruction, error) {
	obj := new(AcceptOwnershipInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type AppendBypasserInstructionDataInstruction struct {
	TimelockId  [32]uint8 `json:"_timelock_id"`
	Id          [32]uint8 `json:"_id"`
	IxIndex     uint32    `json:"ix_index"`
	IxDataChunk []byte    `json:"ix_data_chunk"`

	// Accounts:
	Operation            solanago.PublicKey `json:"operation"`
	OperationWritable    bool               `json:"operation_writable"`
	Config               solanago.PublicKey `json:"config"`
	RoleAccessController solanago.PublicKey `json:"role_access_controller"`
	Authority            solanago.PublicKey `json:"authority"`
	AuthorityWritable    bool               `json:"authority_writable"`
	AuthoritySigner      bool               `json:"authority_signer"`
	SystemProgram        solanago.PublicKey `json:"system_program"`
}

func (obj *AppendBypasserInstructionDataInstruction) GetDiscriminator() []byte {
	return Instruction_AppendBypasserInstructionData[:]
}

// UnmarshalWithDecoder unmarshals the AppendBypasserInstructionDataInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *AppendBypasserInstructionDataInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "AppendBypasserInstructionDataInstruction", err)
	}
	if discriminator != Instruction_AppendBypasserInstructionData {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "AppendBypasserInstructionDataInstruction", Instruction_AppendBypasserInstructionData, discriminator)
	}
	// Deserialize `TimelockId`:
	err = decoder.Decode(&obj.TimelockId)
	if err != nil {
		return err
	}
	// Deserialize `Id`:
	err = decoder.Decode(&obj.Id)
	if err != nil {
		return err
	}
	// Deserialize `IxIndex`:
	err = decoder.Decode(&obj.IxIndex)
	if err != nil {
		return err
	}
	// Deserialize `IxDataChunk`:
	err = decoder.Decode(&obj.IxDataChunk)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AppendBypasserInstructionDataInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from operation account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "operation", err)
	}
	indices = append(indices, index)
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from role_access_controller account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "role_access_controller", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AppendBypasserInstructionDataInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 5 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 5, len(indices))
	}
	indexOffset := 0
	// Set operation account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "operation", len(accountKeys)-1)
	}
	obj.Operation = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set role_access_controller account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "role_access_controller", len(accountKeys)-1)
	}
	obj.RoleAccessController = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AppendBypasserInstructionDataInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Operation)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.RoleAccessController)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the AppendBypasserInstructionDataInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *AppendBypasserInstructionDataInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AppendBypasserInstructionDataInstruction: %w", err)
	}
	return nil
}

// UnmarshalAppendBypasserInstructionDataInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalAppendBypasserInstructionDataInstruction(buf []byte) (*AppendBypasserInstructionDataInstruction, error) {
	obj := new(AppendBypasserInstructionDataInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type AppendInstructionDataInstruction struct {
	TimelockId  [32]uint8 `json:"_timelock_id"`
	Id          [32]uint8 `json:"_id"`
	IxIndex     uint32    `json:"ix_index"`
	IxDataChunk []byte    `json:"ix_data_chunk"`

	// Accounts:
	Operation            solanago.PublicKey `json:"operation"`
	OperationWritable    bool               `json:"operation_writable"`
	Config               solanago.PublicKey `json:"config"`
	RoleAccessController solanago.PublicKey `json:"role_access_controller"`
	Authority            solanago.PublicKey `json:"authority"`
	AuthorityWritable    bool               `json:"authority_writable"`
	AuthoritySigner      bool               `json:"authority_signer"`
	SystemProgram        solanago.PublicKey `json:"system_program"`
}

func (obj *AppendInstructionDataInstruction) GetDiscriminator() []byte {
	return Instruction_AppendInstructionData[:]
}

// UnmarshalWithDecoder unmarshals the AppendInstructionDataInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *AppendInstructionDataInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "AppendInstructionDataInstruction", err)
	}
	if discriminator != Instruction_AppendInstructionData {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "AppendInstructionDataInstruction", Instruction_AppendInstructionData, discriminator)
	}
	// Deserialize `TimelockId`:
	err = decoder.Decode(&obj.TimelockId)
	if err != nil {
		return err
	}
	// Deserialize `Id`:
	err = decoder.Decode(&obj.Id)
	if err != nil {
		return err
	}
	// Deserialize `IxIndex`:
	err = decoder.Decode(&obj.IxIndex)
	if err != nil {
		return err
	}
	// Deserialize `IxDataChunk`:
	err = decoder.Decode(&obj.IxDataChunk)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AppendInstructionDataInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from operation account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "operation", err)
	}
	indices = append(indices, index)
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from role_access_controller account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "role_access_controller", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AppendInstructionDataInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 5 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 5, len(indices))
	}
	indexOffset := 0
	// Set operation account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "operation", len(accountKeys)-1)
	}
	obj.Operation = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set role_access_controller account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "role_access_controller", len(accountKeys)-1)
	}
	obj.RoleAccessController = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AppendInstructionDataInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Operation)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.RoleAccessController)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the AppendInstructionDataInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *AppendInstructionDataInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AppendInstructionDataInstruction: %w", err)
	}
	return nil
}

// UnmarshalAppendInstructionDataInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalAppendInstructionDataInstruction(buf []byte) (*AppendInstructionDataInstruction, error) {
	obj := new(AppendInstructionDataInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type BatchAddAccessInstruction struct {
	TimelockId [32]uint8 `json:"timelock_id"`
	Role       Role      `json:"role"`

	// Accounts:
	Config                       solanago.PublicKey `json:"config"`
	AccessControllerProgram      solanago.PublicKey `json:"access_controller_program"`
	RoleAccessController         solanago.PublicKey `json:"role_access_controller"`
	RoleAccessControllerWritable bool               `json:"role_access_controller_writable"`
	Authority                    solanago.PublicKey `json:"authority"`
	AuthorityWritable            bool               `json:"authority_writable"`
	AuthoritySigner              bool               `json:"authority_signer"`
}

func (obj *BatchAddAccessInstruction) GetDiscriminator() []byte {
	return Instruction_BatchAddAccess[:]
}

// UnmarshalWithDecoder unmarshals the BatchAddAccessInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *BatchAddAccessInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "BatchAddAccessInstruction", err)
	}
	if discriminator != Instruction_BatchAddAccess {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "BatchAddAccessInstruction", Instruction_BatchAddAccess, discriminator)
	}
	// Deserialize `TimelockId`:
	err = decoder.Decode(&obj.TimelockId)
	if err != nil {
		return err
	}
	// Deserialize `Role`:
	err = decoder.Decode(&obj.Role)
	if err != nil {
		return err
	}
	return nil
}

func (obj *BatchAddAccessInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from access_controller_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "access_controller_program", err)
	}
	indices = append(indices, index)
	// Decode from role_access_controller account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "role_access_controller", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *BatchAddAccessInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set access_controller_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "access_controller_program", len(accountKeys)-1)
	}
	obj.AccessControllerProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set role_access_controller account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "role_access_controller", len(accountKeys)-1)
	}
	obj.RoleAccessController = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *BatchAddAccessInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.AccessControllerProgram)
	keys = append(keys, obj.RoleAccessController)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the BatchAddAccessInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *BatchAddAccessInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling BatchAddAccessInstruction: %w", err)
	}
	return nil
}

// UnmarshalBatchAddAccessInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalBatchAddAccessInstruction(buf []byte) (*BatchAddAccessInstruction, error) {
	obj := new(BatchAddAccessInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type BlockFunctionSelectorInstruction struct {
	TimelockId [32]uint8 `json:"_timelock_id"`
	Selector   [8]uint8  `json:"selector"`

	// Accounts:
	Config          solanago.PublicKey `json:"config"`
	ConfigWritable  bool               `json:"config_writable"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
}

func (obj *BlockFunctionSelectorInstruction) GetDiscriminator() []byte {
	return Instruction_BlockFunctionSelector[:]
}

// UnmarshalWithDecoder unmarshals the BlockFunctionSelectorInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *BlockFunctionSelectorInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "BlockFunctionSelectorInstruction", err)
	}
	if discriminator != Instruction_BlockFunctionSelector {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "BlockFunctionSelectorInstruction", Instruction_BlockFunctionSelector, discriminator)
	}
	// Deserialize `TimelockId`:
	err = decoder.Decode(&obj.TimelockId)
	if err != nil {
		return err
	}
	// Deserialize `Selector`:
	err = decoder.Decode(&obj.Selector)
	if err != nil {
		return err
	}
	return nil
}

func (obj *BlockFunctionSelectorInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *BlockFunctionSelectorInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 2 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 2, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *BlockFunctionSelectorInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the BlockFunctionSelectorInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *BlockFunctionSelectorInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling BlockFunctionSelectorInstruction: %w", err)
	}
	return nil
}

// UnmarshalBlockFunctionSelectorInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalBlockFunctionSelectorInstruction(buf []byte) (*BlockFunctionSelectorInstruction, error) {
	obj := new(BlockFunctionSelectorInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type BypasserExecuteBatchInstruction struct {
	TimelockId [32]uint8 `json:"timelock_id"`
	Id         [32]uint8 `json:"id"`

	// Accounts:
	Operation            solanago.PublicKey `json:"operation"`
	OperationWritable    bool               `json:"operation_writable"`
	Config               solanago.PublicKey `json:"config"`
	TimelockSigner       solanago.PublicKey `json:"timelock_signer"`
	RoleAccessController solanago.PublicKey `json:"role_access_controller"`
	Authority            solanago.PublicKey `json:"authority"`
	AuthorityWritable    bool               `json:"authority_writable"`
	AuthoritySigner      bool               `json:"authority_signer"`
}

func (obj *BypasserExecuteBatchInstruction) GetDiscriminator() []byte {
	return Instruction_BypasserExecuteBatch[:]
}

// UnmarshalWithDecoder unmarshals the BypasserExecuteBatchInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *BypasserExecuteBatchInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "BypasserExecuteBatchInstruction", err)
	}
	if discriminator != Instruction_BypasserExecuteBatch {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "BypasserExecuteBatchInstruction", Instruction_BypasserExecuteBatch, discriminator)
	}
	// Deserialize `TimelockId`:
	err = decoder.Decode(&obj.TimelockId)
	if err != nil {
		return err
	}
	// Deserialize `Id`:
	err = decoder.Decode(&obj.Id)
	if err != nil {
		return err
	}
	return nil
}

func (obj *BypasserExecuteBatchInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from operation account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "operation", err)
	}
	indices = append(indices, index)
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from timelock_signer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "timelock_signer", err)
	}
	indices = append(indices, index)
	// Decode from role_access_controller account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "role_access_controller", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *BypasserExecuteBatchInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 5 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 5, len(indices))
	}
	indexOffset := 0
	// Set operation account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "operation", len(accountKeys)-1)
	}
	obj.Operation = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set timelock_signer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "timelock_signer", len(accountKeys)-1)
	}
	obj.TimelockSigner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set role_access_controller account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "role_access_controller", len(accountKeys)-1)
	}
	obj.RoleAccessController = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *BypasserExecuteBatchInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Operation)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.TimelockSigner)
	keys = append(keys, obj.RoleAccessController)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the BypasserExecuteBatchInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *BypasserExecuteBatchInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling BypasserExecuteBatchInstruction: %w", err)
	}
	return nil
}

// UnmarshalBypasserExecuteBatchInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalBypasserExecuteBatchInstruction(buf []byte) (*BypasserExecuteBatchInstruction, error) {
	obj := new(BypasserExecuteBatchInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type CancelInstruction struct {
	TimelockId [32]uint8 `json:"timelock_id"`
	Id         [32]uint8 `json:"id"`

	// Accounts:
	Operation            solanago.PublicKey `json:"operation"`
	OperationWritable    bool               `json:"operation_writable"`
	Config               solanago.PublicKey `json:"config"`
	RoleAccessController solanago.PublicKey `json:"role_access_controller"`
	Authority            solanago.PublicKey `json:"authority"`
	AuthorityWritable    bool               `json:"authority_writable"`
	AuthoritySigner      bool               `json:"authority_signer"`
}

func (obj *CancelInstruction) GetDiscriminator() []byte {
	return Instruction_Cancel[:]
}

// UnmarshalWithDecoder unmarshals the CancelInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *CancelInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "CancelInstruction", err)
	}
	if discriminator != Instruction_Cancel {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "CancelInstruction", Instruction_Cancel, discriminator)
	}
	// Deserialize `TimelockId`:
	err = decoder.Decode(&obj.TimelockId)
	if err != nil {
		return err
	}
	// Deserialize `Id`:
	err = decoder.Decode(&obj.Id)
	if err != nil {
		return err
	}
	return nil
}

func (obj *CancelInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from operation account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "operation", err)
	}
	indices = append(indices, index)
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from role_access_controller account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "role_access_controller", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *CancelInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set operation account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "operation", len(accountKeys)-1)
	}
	obj.Operation = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set role_access_controller account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "role_access_controller", len(accountKeys)-1)
	}
	obj.RoleAccessController = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *CancelInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Operation)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.RoleAccessController)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the CancelInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *CancelInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CancelInstruction: %w", err)
	}
	return nil
}

// UnmarshalCancelInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalCancelInstruction(buf []byte) (*CancelInstruction, error) {
	obj := new(CancelInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ClearBypasserOperationInstruction struct {
	TimelockId [32]uint8 `json:"_timelock_id"`
	Id         [32]uint8 `json:"_id"`

	// Accounts:
	Operation            solanago.PublicKey `json:"operation"`
	OperationWritable    bool               `json:"operation_writable"`
	Config               solanago.PublicKey `json:"config"`
	RoleAccessController solanago.PublicKey `json:"role_access_controller"`
	Authority            solanago.PublicKey `json:"authority"`
	AuthorityWritable    bool               `json:"authority_writable"`
	AuthoritySigner      bool               `json:"authority_signer"`
}

func (obj *ClearBypasserOperationInstruction) GetDiscriminator() []byte {
	return Instruction_ClearBypasserOperation[:]
}

// UnmarshalWithDecoder unmarshals the ClearBypasserOperationInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *ClearBypasserOperationInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "ClearBypasserOperationInstruction", err)
	}
	if discriminator != Instruction_ClearBypasserOperation {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "ClearBypasserOperationInstruction", Instruction_ClearBypasserOperation, discriminator)
	}
	// Deserialize `TimelockId`:
	err = decoder.Decode(&obj.TimelockId)
	if err != nil {
		return err
	}
	// Deserialize `Id`:
	err = decoder.Decode(&obj.Id)
	if err != nil {
		return err
	}
	return nil
}

func (obj *ClearBypasserOperationInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from operation account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "operation", err)
	}
	indices = append(indices, index)
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from role_access_controller account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "role_access_controller", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *ClearBypasserOperationInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set operation account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "operation", len(accountKeys)-1)
	}
	obj.Operation = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set role_access_controller account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "role_access_controller", len(accountKeys)-1)
	}
	obj.RoleAccessController = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *ClearBypasserOperationInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Operation)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.RoleAccessController)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the ClearBypasserOperationInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *ClearBypasserOperationInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ClearBypasserOperationInstruction: %w", err)
	}
	return nil
}

// UnmarshalClearBypasserOperationInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalClearBypasserOperationInstruction(buf []byte) (*ClearBypasserOperationInstruction, error) {
	obj := new(ClearBypasserOperationInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ClearOperationInstruction struct {
	TimelockId [32]uint8 `json:"_timelock_id"`
	Id         [32]uint8 `json:"_id"`

	// Accounts:
	Operation            solanago.PublicKey `json:"operation"`
	OperationWritable    bool               `json:"operation_writable"`
	Config               solanago.PublicKey `json:"config"`
	RoleAccessController solanago.PublicKey `json:"role_access_controller"`
	Authority            solanago.PublicKey `json:"authority"`
	AuthorityWritable    bool               `json:"authority_writable"`
	AuthoritySigner      bool               `json:"authority_signer"`
}

func (obj *ClearOperationInstruction) GetDiscriminator() []byte {
	return Instruction_ClearOperation[:]
}

// UnmarshalWithDecoder unmarshals the ClearOperationInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *ClearOperationInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "ClearOperationInstruction", err)
	}
	if discriminator != Instruction_ClearOperation {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "ClearOperationInstruction", Instruction_ClearOperation, discriminator)
	}
	// Deserialize `TimelockId`:
	err = decoder.Decode(&obj.TimelockId)
	if err != nil {
		return err
	}
	// Deserialize `Id`:
	err = decoder.Decode(&obj.Id)
	if err != nil {
		return err
	}
	return nil
}

func (obj *ClearOperationInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from operation account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "operation", err)
	}
	indices = append(indices, index)
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from role_access_controller account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "role_access_controller", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *ClearOperationInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set operation account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "operation", len(accountKeys)-1)
	}
	obj.Operation = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set role_access_controller account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "role_access_controller", len(accountKeys)-1)
	}
	obj.RoleAccessController = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *ClearOperationInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Operation)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.RoleAccessController)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the ClearOperationInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *ClearOperationInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ClearOperationInstruction: %w", err)
	}
	return nil
}

// UnmarshalClearOperationInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalClearOperationInstruction(buf []byte) (*ClearOperationInstruction, error) {
	obj := new(ClearOperationInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ExecuteBatchInstruction struct {
	TimelockId [32]uint8 `json:"timelock_id"`
	Id         [32]uint8 `json:"id"`

	// Accounts:
	Operation            solanago.PublicKey `json:"operation"`
	OperationWritable    bool               `json:"operation_writable"`
	PredecessorOperation solanago.PublicKey `json:"predecessor_operation"`
	Config               solanago.PublicKey `json:"config"`
	TimelockSigner       solanago.PublicKey `json:"timelock_signer"`
	RoleAccessController solanago.PublicKey `json:"role_access_controller"`
	Authority            solanago.PublicKey `json:"authority"`
	AuthorityWritable    bool               `json:"authority_writable"`
	AuthoritySigner      bool               `json:"authority_signer"`
}

func (obj *ExecuteBatchInstruction) GetDiscriminator() []byte {
	return Instruction_ExecuteBatch[:]
}

// UnmarshalWithDecoder unmarshals the ExecuteBatchInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *ExecuteBatchInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "ExecuteBatchInstruction", err)
	}
	if discriminator != Instruction_ExecuteBatch {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "ExecuteBatchInstruction", Instruction_ExecuteBatch, discriminator)
	}
	// Deserialize `TimelockId`:
	err = decoder.Decode(&obj.TimelockId)
	if err != nil {
		return err
	}
	// Deserialize `Id`:
	err = decoder.Decode(&obj.Id)
	if err != nil {
		return err
	}
	return nil
}

func (obj *ExecuteBatchInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from operation account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "operation", err)
	}
	indices = append(indices, index)
	// Decode from predecessor_operation account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "predecessor_operation", err)
	}
	indices = append(indices, index)
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from timelock_signer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "timelock_signer", err)
	}
	indices = append(indices, index)
	// Decode from role_access_controller account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "role_access_controller", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *ExecuteBatchInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 6 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 6, len(indices))
	}
	indexOffset := 0
	// Set operation account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "operation", len(accountKeys)-1)
	}
	obj.Operation = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set predecessor_operation account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "predecessor_operation", len(accountKeys)-1)
	}
	obj.PredecessorOperation = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set timelock_signer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "timelock_signer", len(accountKeys)-1)
	}
	obj.TimelockSigner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set role_access_controller account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "role_access_controller", len(accountKeys)-1)
	}
	obj.RoleAccessController = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *ExecuteBatchInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Operation)
	keys = append(keys, obj.PredecessorOperation)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.TimelockSigner)
	keys = append(keys, obj.RoleAccessController)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the ExecuteBatchInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *ExecuteBatchInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ExecuteBatchInstruction: %w", err)
	}
	return nil
}

// UnmarshalExecuteBatchInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalExecuteBatchInstruction(buf []byte) (*ExecuteBatchInstruction, error) {
	obj := new(ExecuteBatchInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type FinalizeBypasserOperationInstruction struct {
	TimelockId [32]uint8 `json:"_timelock_id"`
	Id         [32]uint8 `json:"_id"`

	// Accounts:
	Operation            solanago.PublicKey `json:"operation"`
	OperationWritable    bool               `json:"operation_writable"`
	Config               solanago.PublicKey `json:"config"`
	RoleAccessController solanago.PublicKey `json:"role_access_controller"`
	Authority            solanago.PublicKey `json:"authority"`
	AuthorityWritable    bool               `json:"authority_writable"`
	AuthoritySigner      bool               `json:"authority_signer"`
}

func (obj *FinalizeBypasserOperationInstruction) GetDiscriminator() []byte {
	return Instruction_FinalizeBypasserOperation[:]
}

// UnmarshalWithDecoder unmarshals the FinalizeBypasserOperationInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *FinalizeBypasserOperationInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "FinalizeBypasserOperationInstruction", err)
	}
	if discriminator != Instruction_FinalizeBypasserOperation {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "FinalizeBypasserOperationInstruction", Instruction_FinalizeBypasserOperation, discriminator)
	}
	// Deserialize `TimelockId`:
	err = decoder.Decode(&obj.TimelockId)
	if err != nil {
		return err
	}
	// Deserialize `Id`:
	err = decoder.Decode(&obj.Id)
	if err != nil {
		return err
	}
	return nil
}

func (obj *FinalizeBypasserOperationInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from operation account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "operation", err)
	}
	indices = append(indices, index)
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from role_access_controller account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "role_access_controller", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *FinalizeBypasserOperationInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set operation account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "operation", len(accountKeys)-1)
	}
	obj.Operation = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set role_access_controller account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "role_access_controller", len(accountKeys)-1)
	}
	obj.RoleAccessController = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *FinalizeBypasserOperationInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Operation)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.RoleAccessController)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the FinalizeBypasserOperationInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *FinalizeBypasserOperationInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling FinalizeBypasserOperationInstruction: %w", err)
	}
	return nil
}

// UnmarshalFinalizeBypasserOperationInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalFinalizeBypasserOperationInstruction(buf []byte) (*FinalizeBypasserOperationInstruction, error) {
	obj := new(FinalizeBypasserOperationInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type FinalizeOperationInstruction struct {
	TimelockId [32]uint8 `json:"_timelock_id"`
	Id         [32]uint8 `json:"_id"`

	// Accounts:
	Operation            solanago.PublicKey `json:"operation"`
	OperationWritable    bool               `json:"operation_writable"`
	Config               solanago.PublicKey `json:"config"`
	RoleAccessController solanago.PublicKey `json:"role_access_controller"`
	Authority            solanago.PublicKey `json:"authority"`
	AuthorityWritable    bool               `json:"authority_writable"`
	AuthoritySigner      bool               `json:"authority_signer"`
}

func (obj *FinalizeOperationInstruction) GetDiscriminator() []byte {
	return Instruction_FinalizeOperation[:]
}

// UnmarshalWithDecoder unmarshals the FinalizeOperationInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *FinalizeOperationInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "FinalizeOperationInstruction", err)
	}
	if discriminator != Instruction_FinalizeOperation {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "FinalizeOperationInstruction", Instruction_FinalizeOperation, discriminator)
	}
	// Deserialize `TimelockId`:
	err = decoder.Decode(&obj.TimelockId)
	if err != nil {
		return err
	}
	// Deserialize `Id`:
	err = decoder.Decode(&obj.Id)
	if err != nil {
		return err
	}
	return nil
}

func (obj *FinalizeOperationInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from operation account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "operation", err)
	}
	indices = append(indices, index)
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from role_access_controller account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "role_access_controller", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *FinalizeOperationInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set operation account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "operation", len(accountKeys)-1)
	}
	obj.Operation = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set role_access_controller account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "role_access_controller", len(accountKeys)-1)
	}
	obj.RoleAccessController = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *FinalizeOperationInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Operation)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.RoleAccessController)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the FinalizeOperationInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *FinalizeOperationInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling FinalizeOperationInstruction: %w", err)
	}
	return nil
}

// UnmarshalFinalizeOperationInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalFinalizeOperationInstruction(buf []byte) (*FinalizeOperationInstruction, error) {
	obj := new(FinalizeOperationInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitializeInstruction struct {
	TimelockId [32]uint8 `json:"timelock_id"`
	MinDelay   uint64    `json:"min_delay"`

	// Accounts:
	Config                        solanago.PublicKey `json:"config"`
	ConfigWritable                bool               `json:"config_writable"`
	Authority                     solanago.PublicKey `json:"authority"`
	AuthorityWritable             bool               `json:"authority_writable"`
	AuthoritySigner               bool               `json:"authority_signer"`
	SystemProgram                 solanago.PublicKey `json:"system_program"`
	Program                       solanago.PublicKey `json:"program"`
	ProgramData                   solanago.PublicKey `json:"program_data"`
	AccessControllerProgram       solanago.PublicKey `json:"access_controller_program"`
	ProposerRoleAccessController  solanago.PublicKey `json:"proposer_role_access_controller"`
	ExecutorRoleAccessController  solanago.PublicKey `json:"executor_role_access_controller"`
	CancellerRoleAccessController solanago.PublicKey `json:"canceller_role_access_controller"`
	BypasserRoleAccessController  solanago.PublicKey `json:"bypasser_role_access_controller"`
}

func (obj *InitializeInstruction) GetDiscriminator() []byte {
	return Instruction_Initialize[:]
}

// UnmarshalWithDecoder unmarshals the InitializeInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *InitializeInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "InitializeInstruction", err)
	}
	if discriminator != Instruction_Initialize {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "InitializeInstruction", Instruction_Initialize, discriminator)
	}
	// Deserialize `TimelockId`:
	err = decoder.Decode(&obj.TimelockId)
	if err != nil {
		return err
	}
	// Deserialize `MinDelay`:
	err = decoder.Decode(&obj.MinDelay)
	if err != nil {
		return err
	}
	return nil
}

func (obj *InitializeInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	// Decode from program_data account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program_data", err)
	}
	indices = append(indices, index)
	// Decode from access_controller_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "access_controller_program", err)
	}
	indices = append(indices, index)
	// Decode from proposer_role_access_controller account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "proposer_role_access_controller", err)
	}
	indices = append(indices, index)
	// Decode from executor_role_access_controller account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "executor_role_access_controller", err)
	}
	indices = append(indices, index)
	// Decode from canceller_role_access_controller account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "canceller_role_access_controller", err)
	}
	indices = append(indices, index)
	// Decode from bypasser_role_access_controller account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "bypasser_role_access_controller", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitializeInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 10 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 10, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program_data account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program_data", len(accountKeys)-1)
	}
	obj.ProgramData = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set access_controller_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "access_controller_program", len(accountKeys)-1)
	}
	obj.AccessControllerProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set proposer_role_access_controller account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "proposer_role_access_controller", len(accountKeys)-1)
	}
	obj.ProposerRoleAccessController = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set executor_role_access_controller account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "executor_role_access_controller", len(accountKeys)-1)
	}
	obj.ExecutorRoleAccessController = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set canceller_role_access_controller account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "canceller_role_access_controller", len(accountKeys)-1)
	}
	obj.CancellerRoleAccessController = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set bypasser_role_access_controller account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "bypasser_role_access_controller", len(accountKeys)-1)
	}
	obj.BypasserRoleAccessController = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitializeInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.Program)
	keys = append(keys, obj.ProgramData)
	keys = append(keys, obj.AccessControllerProgram)
	keys = append(keys, obj.ProposerRoleAccessController)
	keys = append(keys, obj.ExecutorRoleAccessController)
	keys = append(keys, obj.CancellerRoleAccessController)
	keys = append(keys, obj.BypasserRoleAccessController)
	return keys
}

// Unmarshal unmarshals the InitializeInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *InitializeInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitializeInstruction: %w", err)
	}
	return nil
}

// UnmarshalInitializeInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalInitializeInstruction(buf []byte) (*InitializeInstruction, error) {
	obj := new(InitializeInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitializeBypasserInstructionInstruction struct {
	TimelockId [32]uint8            `json:"_timelock_id"`
	Id         [32]uint8            `json:"_id"`
	ProgramId  solanago.PublicKey   `json:"program_id"`
	Accounts   []InstructionAccount `json:"accounts"`

	// Accounts:
	Operation            solanago.PublicKey `json:"operation"`
	OperationWritable    bool               `json:"operation_writable"`
	Config               solanago.PublicKey `json:"config"`
	RoleAccessController solanago.PublicKey `json:"role_access_controller"`
	Authority            solanago.PublicKey `json:"authority"`
	AuthorityWritable    bool               `json:"authority_writable"`
	AuthoritySigner      bool               `json:"authority_signer"`
	SystemProgram        solanago.PublicKey `json:"system_program"`
}

func (obj *InitializeBypasserInstructionInstruction) GetDiscriminator() []byte {
	return Instruction_InitializeBypasserInstruction[:]
}

// UnmarshalWithDecoder unmarshals the InitializeBypasserInstructionInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *InitializeBypasserInstructionInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "InitializeBypasserInstructionInstruction", err)
	}
	if discriminator != Instruction_InitializeBypasserInstruction {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "InitializeBypasserInstructionInstruction", Instruction_InitializeBypasserInstruction, discriminator)
	}
	// Deserialize `TimelockId`:
	err = decoder.Decode(&obj.TimelockId)
	if err != nil {
		return err
	}
	// Deserialize `Id`:
	err = decoder.Decode(&obj.Id)
	if err != nil {
		return err
	}
	// Deserialize `ProgramId`:
	err = decoder.Decode(&obj.ProgramId)
	if err != nil {
		return err
	}
	// Deserialize `Accounts`:
	err = decoder.Decode(&obj.Accounts)
	if err != nil {
		return err
	}
	return nil
}

func (obj *InitializeBypasserInstructionInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from operation account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "operation", err)
	}
	indices = append(indices, index)
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from role_access_controller account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "role_access_controller", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitializeBypasserInstructionInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 5 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 5, len(indices))
	}
	indexOffset := 0
	// Set operation account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "operation", len(accountKeys)-1)
	}
	obj.Operation = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set role_access_controller account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "role_access_controller", len(accountKeys)-1)
	}
	obj.RoleAccessController = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitializeBypasserInstructionInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Operation)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.RoleAccessController)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the InitializeBypasserInstructionInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *InitializeBypasserInstructionInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitializeBypasserInstructionInstruction: %w", err)
	}
	return nil
}

// UnmarshalInitializeBypasserInstructionInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalInitializeBypasserInstructionInstruction(buf []byte) (*InitializeBypasserInstructionInstruction, error) {
	obj := new(InitializeBypasserInstructionInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitializeBypasserOperationInstruction struct {
	TimelockId       [32]uint8 `json:"_timelock_id"`
	Id               [32]uint8 `json:"id"`
	Salt             [32]uint8 `json:"salt"`
	InstructionCount uint32    `json:"instruction_count"`

	// Accounts:
	Operation            solanago.PublicKey `json:"operation"`
	OperationWritable    bool               `json:"operation_writable"`
	Config               solanago.PublicKey `json:"config"`
	RoleAccessController solanago.PublicKey `json:"role_access_controller"`
	Authority            solanago.PublicKey `json:"authority"`
	AuthorityWritable    bool               `json:"authority_writable"`
	AuthoritySigner      bool               `json:"authority_signer"`
	SystemProgram        solanago.PublicKey `json:"system_program"`
}

func (obj *InitializeBypasserOperationInstruction) GetDiscriminator() []byte {
	return Instruction_InitializeBypasserOperation[:]
}

// UnmarshalWithDecoder unmarshals the InitializeBypasserOperationInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *InitializeBypasserOperationInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "InitializeBypasserOperationInstruction", err)
	}
	if discriminator != Instruction_InitializeBypasserOperation {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "InitializeBypasserOperationInstruction", Instruction_InitializeBypasserOperation, discriminator)
	}
	// Deserialize `TimelockId`:
	err = decoder.Decode(&obj.TimelockId)
	if err != nil {
		return err
	}
	// Deserialize `Id`:
	err = decoder.Decode(&obj.Id)
	if err != nil {
		return err
	}
	// Deserialize `Salt`:
	err = decoder.Decode(&obj.Salt)
	if err != nil {
		return err
	}
	// Deserialize `InstructionCount`:
	err = decoder.Decode(&obj.InstructionCount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *InitializeBypasserOperationInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from operation account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "operation", err)
	}
	indices = append(indices, index)
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from role_access_controller account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "role_access_controller", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitializeBypasserOperationInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 5 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 5, len(indices))
	}
	indexOffset := 0
	// Set operation account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "operation", len(accountKeys)-1)
	}
	obj.Operation = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set role_access_controller account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "role_access_controller", len(accountKeys)-1)
	}
	obj.RoleAccessController = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitializeBypasserOperationInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Operation)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.RoleAccessController)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the InitializeBypasserOperationInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *InitializeBypasserOperationInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitializeBypasserOperationInstruction: %w", err)
	}
	return nil
}

// UnmarshalInitializeBypasserOperationInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalInitializeBypasserOperationInstruction(buf []byte) (*InitializeBypasserOperationInstruction, error) {
	obj := new(InitializeBypasserOperationInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitializeInstructionInstruction struct {
	TimelockId [32]uint8            `json:"_timelock_id"`
	Id         [32]uint8            `json:"_id"`
	ProgramId  solanago.PublicKey   `json:"program_id"`
	Accounts   []InstructionAccount `json:"accounts"`

	// Accounts:
	Operation            solanago.PublicKey `json:"operation"`
	OperationWritable    bool               `json:"operation_writable"`
	Config               solanago.PublicKey `json:"config"`
	RoleAccessController solanago.PublicKey `json:"role_access_controller"`
	Authority            solanago.PublicKey `json:"authority"`
	AuthorityWritable    bool               `json:"authority_writable"`
	AuthoritySigner      bool               `json:"authority_signer"`
	SystemProgram        solanago.PublicKey `json:"system_program"`
}

func (obj *InitializeInstructionInstruction) GetDiscriminator() []byte {
	return Instruction_InitializeInstruction[:]
}

// UnmarshalWithDecoder unmarshals the InitializeInstructionInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *InitializeInstructionInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "InitializeInstructionInstruction", err)
	}
	if discriminator != Instruction_InitializeInstruction {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "InitializeInstructionInstruction", Instruction_InitializeInstruction, discriminator)
	}
	// Deserialize `TimelockId`:
	err = decoder.Decode(&obj.TimelockId)
	if err != nil {
		return err
	}
	// Deserialize `Id`:
	err = decoder.Decode(&obj.Id)
	if err != nil {
		return err
	}
	// Deserialize `ProgramId`:
	err = decoder.Decode(&obj.ProgramId)
	if err != nil {
		return err
	}
	// Deserialize `Accounts`:
	err = decoder.Decode(&obj.Accounts)
	if err != nil {
		return err
	}
	return nil
}

func (obj *InitializeInstructionInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from operation account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "operation", err)
	}
	indices = append(indices, index)
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from role_access_controller account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "role_access_controller", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitializeInstructionInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 5 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 5, len(indices))
	}
	indexOffset := 0
	// Set operation account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "operation", len(accountKeys)-1)
	}
	obj.Operation = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set role_access_controller account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "role_access_controller", len(accountKeys)-1)
	}
	obj.RoleAccessController = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitializeInstructionInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Operation)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.RoleAccessController)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the InitializeInstructionInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *InitializeInstructionInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitializeInstructionInstruction: %w", err)
	}
	return nil
}

// UnmarshalInitializeInstructionInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalInitializeInstructionInstruction(buf []byte) (*InitializeInstructionInstruction, error) {
	obj := new(InitializeInstructionInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitializeOperationInstruction struct {
	TimelockId       [32]uint8 `json:"_timelock_id"`
	Id               [32]uint8 `json:"id"`
	Predecessor      [32]uint8 `json:"predecessor"`
	Salt             [32]uint8 `json:"salt"`
	InstructionCount uint32    `json:"instruction_count"`

	// Accounts:
	Operation            solanago.PublicKey `json:"operation"`
	OperationWritable    bool               `json:"operation_writable"`
	Config               solanago.PublicKey `json:"config"`
	RoleAccessController solanago.PublicKey `json:"role_access_controller"`
	Authority            solanago.PublicKey `json:"authority"`
	AuthorityWritable    bool               `json:"authority_writable"`
	AuthoritySigner      bool               `json:"authority_signer"`
	SystemProgram        solanago.PublicKey `json:"system_program"`
}

func (obj *InitializeOperationInstruction) GetDiscriminator() []byte {
	return Instruction_InitializeOperation[:]
}

// UnmarshalWithDecoder unmarshals the InitializeOperationInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *InitializeOperationInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "InitializeOperationInstruction", err)
	}
	if discriminator != Instruction_InitializeOperation {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "InitializeOperationInstruction", Instruction_InitializeOperation, discriminator)
	}
	// Deserialize `TimelockId`:
	err = decoder.Decode(&obj.TimelockId)
	if err != nil {
		return err
	}
	// Deserialize `Id`:
	err = decoder.Decode(&obj.Id)
	if err != nil {
		return err
	}
	// Deserialize `Predecessor`:
	err = decoder.Decode(&obj.Predecessor)
	if err != nil {
		return err
	}
	// Deserialize `Salt`:
	err = decoder.Decode(&obj.Salt)
	if err != nil {
		return err
	}
	// Deserialize `InstructionCount`:
	err = decoder.Decode(&obj.InstructionCount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *InitializeOperationInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from operation account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "operation", err)
	}
	indices = append(indices, index)
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from role_access_controller account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "role_access_controller", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitializeOperationInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 5 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 5, len(indices))
	}
	indexOffset := 0
	// Set operation account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "operation", len(accountKeys)-1)
	}
	obj.Operation = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set role_access_controller account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "role_access_controller", len(accountKeys)-1)
	}
	obj.RoleAccessController = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitializeOperationInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Operation)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.RoleAccessController)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the InitializeOperationInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *InitializeOperationInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitializeOperationInstruction: %w", err)
	}
	return nil
}

// UnmarshalInitializeOperationInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalInitializeOperationInstruction(buf []byte) (*InitializeOperationInstruction, error) {
	obj := new(InitializeOperationInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ScheduleBatchInstruction struct {
	TimelockId [32]uint8 `json:"timelock_id"`
	Id         [32]uint8 `json:"id"`
	Delay      uint64    `json:"delay"`

	// Accounts:
	Operation            solanago.PublicKey `json:"operation"`
	OperationWritable    bool               `json:"operation_writable"`
	Config               solanago.PublicKey `json:"config"`
	RoleAccessController solanago.PublicKey `json:"role_access_controller"`
	Authority            solanago.PublicKey `json:"authority"`
	AuthorityWritable    bool               `json:"authority_writable"`
	AuthoritySigner      bool               `json:"authority_signer"`
}

func (obj *ScheduleBatchInstruction) GetDiscriminator() []byte {
	return Instruction_ScheduleBatch[:]
}

// UnmarshalWithDecoder unmarshals the ScheduleBatchInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *ScheduleBatchInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "ScheduleBatchInstruction", err)
	}
	if discriminator != Instruction_ScheduleBatch {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "ScheduleBatchInstruction", Instruction_ScheduleBatch, discriminator)
	}
	// Deserialize `TimelockId`:
	err = decoder.Decode(&obj.TimelockId)
	if err != nil {
		return err
	}
	// Deserialize `Id`:
	err = decoder.Decode(&obj.Id)
	if err != nil {
		return err
	}
	// Deserialize `Delay`:
	err = decoder.Decode(&obj.Delay)
	if err != nil {
		return err
	}
	return nil
}

func (obj *ScheduleBatchInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from operation account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "operation", err)
	}
	indices = append(indices, index)
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from role_access_controller account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "role_access_controller", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *ScheduleBatchInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set operation account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "operation", len(accountKeys)-1)
	}
	obj.Operation = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set role_access_controller account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "role_access_controller", len(accountKeys)-1)
	}
	obj.RoleAccessController = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *ScheduleBatchInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Operation)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.RoleAccessController)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the ScheduleBatchInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *ScheduleBatchInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ScheduleBatchInstruction: %w", err)
	}
	return nil
}

// UnmarshalScheduleBatchInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalScheduleBatchInstruction(buf []byte) (*ScheduleBatchInstruction, error) {
	obj := new(ScheduleBatchInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type TransferOwnershipInstruction struct {
	TimelockId    [32]uint8          `json:"_timelock_id"`
	ProposedOwner solanago.PublicKey `json:"proposed_owner"`

	// Accounts:
	Config          solanago.PublicKey `json:"config"`
	ConfigWritable  bool               `json:"config_writable"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
}

func (obj *TransferOwnershipInstruction) GetDiscriminator() []byte {
	return Instruction_TransferOwnership[:]
}

// UnmarshalWithDecoder unmarshals the TransferOwnershipInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *TransferOwnershipInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "TransferOwnershipInstruction", err)
	}
	if discriminator != Instruction_TransferOwnership {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "TransferOwnershipInstruction", Instruction_TransferOwnership, discriminator)
	}
	// Deserialize `TimelockId`:
	err = decoder.Decode(&obj.TimelockId)
	if err != nil {
		return err
	}
	// Deserialize `ProposedOwner`:
	err = decoder.Decode(&obj.ProposedOwner)
	if err != nil {
		return err
	}
	return nil
}

func (obj *TransferOwnershipInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *TransferOwnershipInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 2 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 2, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *TransferOwnershipInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the TransferOwnershipInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *TransferOwnershipInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling TransferOwnershipInstruction: %w", err)
	}
	return nil
}

// UnmarshalTransferOwnershipInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalTransferOwnershipInstruction(buf []byte) (*TransferOwnershipInstruction, error) {
	obj := new(TransferOwnershipInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UnblockFunctionSelectorInstruction struct {
	TimelockId [32]uint8 `json:"_timelock_id"`
	Selector   [8]uint8  `json:"selector"`

	// Accounts:
	Config          solanago.PublicKey `json:"config"`
	ConfigWritable  bool               `json:"config_writable"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
}

func (obj *UnblockFunctionSelectorInstruction) GetDiscriminator() []byte {
	return Instruction_UnblockFunctionSelector[:]
}

// UnmarshalWithDecoder unmarshals the UnblockFunctionSelectorInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *UnblockFunctionSelectorInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "UnblockFunctionSelectorInstruction", err)
	}
	if discriminator != Instruction_UnblockFunctionSelector {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "UnblockFunctionSelectorInstruction", Instruction_UnblockFunctionSelector, discriminator)
	}
	// Deserialize `TimelockId`:
	err = decoder.Decode(&obj.TimelockId)
	if err != nil {
		return err
	}
	// Deserialize `Selector`:
	err = decoder.Decode(&obj.Selector)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UnblockFunctionSelectorInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *UnblockFunctionSelectorInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 2 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 2, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *UnblockFunctionSelectorInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the UnblockFunctionSelectorInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *UnblockFunctionSelectorInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UnblockFunctionSelectorInstruction: %w", err)
	}
	return nil
}

// UnmarshalUnblockFunctionSelectorInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalUnblockFunctionSelectorInstruction(buf []byte) (*UnblockFunctionSelectorInstruction, error) {
	obj := new(UnblockFunctionSelectorInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UpdateDelayInstruction struct {
	TimelockId [32]uint8 `json:"_timelock_id"`
	Delay      uint64    `json:"delay"`

	// Accounts:
	Config          solanago.PublicKey `json:"config"`
	ConfigWritable  bool               `json:"config_writable"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
}

func (obj *UpdateDelayInstruction) GetDiscriminator() []byte {
	return Instruction_UpdateDelay[:]
}

// UnmarshalWithDecoder unmarshals the UpdateDelayInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *UpdateDelayInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "UpdateDelayInstruction", err)
	}
	if discriminator != Instruction_UpdateDelay {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "UpdateDelayInstruction", Instruction_UpdateDelay, discriminator)
	}
	// Deserialize `TimelockId`:
	err = decoder.Decode(&obj.TimelockId)
	if err != nil {
		return err
	}
	// Deserialize `Delay`:
	err = decoder.Decode(&obj.Delay)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UpdateDelayInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *UpdateDelayInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 2 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 2, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *UpdateDelayInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the UpdateDelayInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *UpdateDelayInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdateDelayInstruction: %w", err)
	}
	return nil
}

// UnmarshalUpdateDelayInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalUpdateDelayInstruction(buf []byte) (*UpdateDelayInstruction, error) {
	obj := new(UpdateDelayInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Instruction interface defines common methods for all instruction types
type Instruction interface {
	GetDiscriminator() []byte

	UnmarshalWithDecoder(decoder *binary.Decoder) error

	UnmarshalAccountIndices(buf []byte) ([]uint8, error)

	PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error

	GetAccountKeys() []solanago.PublicKey
}

// ParseInstruction parses instruction data and optionally populates accounts
// If accountIndicesData is nil or empty, accounts will not be populated
func ParseInstruction(instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (Instruction, error) {
	// Validate inputs
	if len(instructionData) < 8 {
		return nil, fmt.Errorf("instruction data too short: expected at least 8 bytes, got %d", len(instructionData))
	}
	// Extract discriminator
	discriminator := [8]byte{}
	copy(discriminator[:], instructionData[0:8])
	// Parse based on discriminator
	switch discriminator {
	case Instruction_AcceptOwnership:
		instruction := new(AcceptOwnershipInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AcceptOwnershipInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_AppendBypasserInstructionData:
		instruction := new(AppendBypasserInstructionDataInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AppendBypasserInstructionDataInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_AppendInstructionData:
		instruction := new(AppendInstructionDataInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AppendInstructionDataInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_BatchAddAccess:
		instruction := new(BatchAddAccessInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as BatchAddAccessInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_BlockFunctionSelector:
		instruction := new(BlockFunctionSelectorInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as BlockFunctionSelectorInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_BypasserExecuteBatch:
		instruction := new(BypasserExecuteBatchInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as BypasserExecuteBatchInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_Cancel:
		instruction := new(CancelInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as CancelInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_ClearBypasserOperation:
		instruction := new(ClearBypasserOperationInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as ClearBypasserOperationInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_ClearOperation:
		instruction := new(ClearOperationInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as ClearOperationInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_ExecuteBatch:
		instruction := new(ExecuteBatchInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as ExecuteBatchInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_FinalizeBypasserOperation:
		instruction := new(FinalizeBypasserOperationInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as FinalizeBypasserOperationInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_FinalizeOperation:
		instruction := new(FinalizeOperationInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as FinalizeOperationInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_Initialize:
		instruction := new(InitializeInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitializeInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_InitializeBypasserInstruction:
		instruction := new(InitializeBypasserInstructionInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitializeBypasserInstructionInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_InitializeBypasserOperation:
		instruction := new(InitializeBypasserOperationInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitializeBypasserOperationInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_InitializeInstruction:
		instruction := new(InitializeInstructionInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitializeInstructionInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_InitializeOperation:
		instruction := new(InitializeOperationInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitializeOperationInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_ScheduleBatch:
		instruction := new(ScheduleBatchInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as ScheduleBatchInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_TransferOwnership:
		instruction := new(TransferOwnershipInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as TransferOwnershipInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_UnblockFunctionSelector:
		instruction := new(UnblockFunctionSelectorInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as UnblockFunctionSelectorInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_UpdateDelay:
		instruction := new(UpdateDelayInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as UpdateDelayInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	default:
		return nil, fmt.Errorf("unknown instruction discriminator: %s", binary.FormatDiscriminator(discriminator))
	}
}

// ParseInstructionTyped parses instruction data and returns a specific instruction type // T must implement the Instruction interface
func ParseInstructionTyped[T Instruction](instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (T, error) {
	instruction, err := ParseInstruction(instructionData, accountIndicesData, accountKeys)
	if err != nil {
		return *new(T), err
	}
	typed, ok := instruction.(T)
	if !ok {
		return *new(T), fmt.Errorf("instruction is not of expected type")
	}
	return typed, nil
}

// ParseInstructionWithoutAccounts parses instruction data without account information
func ParseInstructionWithoutAccounts(instructionData []byte) (Instruction, error) {
	return ParseInstruction(instructionData, nil, []solanago.PublicKey{})
}

// ParseInstructionWithAccounts parses instruction data with account information
func ParseInstructionWithAccounts(instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (Instruction, error) {
	return ParseInstruction(instructionData, accountIndicesData, accountKeys)
}
