// Code generated by https://github.com/Unheilbar/anchor-go. DO NOT EDIT.
// This file contains instructions and instruction parsers.

package token_messenger_minter

import (
	"bytes"
	"fmt"
	errors "github.com/Unheilbar/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "initialize" instruction.
func NewInitializeInstruction(
	// Params:
	paramsParam InitializeParams,

	// Accounts:
	payerAccount solanago.PublicKey,
	upgradeAuthorityAccount solanago.PublicKey,
	authorityPdaAccount solanago.PublicKey,
	tokenMessengerAccount solanago.PublicKey,
	tokenMinterAccount solanago.PublicKey,
	tokenMessengerMinterProgramDataAccount solanago.PublicKey,
	tokenMessengerMinterProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Initialize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 1 "upgradeAuthority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(upgradeAuthorityAccount, false, true))
		// Account 2 "authorityPda": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityPdaAccount, false, false))
		// Account 3 "tokenMessenger": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMessengerAccount, true, false))
		// Account 4 "tokenMinter": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMinterAccount, true, false))
		// Account 5 "tokenMessengerMinterProgramData": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMessengerMinterProgramDataAccount, false, false))
		// Account 6 "tokenMessengerMinterProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMessengerMinterProgramAccount, false, false))
		// Account 7 "systemProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 8 "eventAuthority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 9 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "transferOwnership" instruction.
func NewTransferOwnershipInstruction(
	// Params:
	paramsParam TransferOwnershipParams,

	// Accounts:
	ownerAccount solanago.PublicKey,
	tokenMessengerAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_TransferOwnership[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "owner": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
		// Account 1 "tokenMessenger": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMessengerAccount, true, false))
		// Account 2 "eventAuthority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 3 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "acceptOwnership" instruction.
func NewAcceptOwnershipInstruction(
	// Params:
	paramsParam AcceptOwnershipParams,

	// Accounts:
	pendingOwnerAccount solanago.PublicKey,
	tokenMessengerAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AcceptOwnership[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "pendingOwner": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(pendingOwnerAccount, false, true))
		// Account 1 "tokenMessenger": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMessengerAccount, true, false))
		// Account 2 "eventAuthority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 3 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "addRemoteTokenMessenger" instruction.
func NewAddRemoteTokenMessengerInstruction(
	// Params:
	paramsParam AddRemoteTokenMessengerParams,

	// Accounts:
	payerAccount solanago.PublicKey,
	ownerAccount solanago.PublicKey,
	tokenMessengerAccount solanago.PublicKey,
	remoteTokenMessengerAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AddRemoteTokenMessenger[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 1 "owner": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
		// Account 2 "tokenMessenger": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMessengerAccount, false, false))
		// Account 3 "remoteTokenMessenger": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(remoteTokenMessengerAccount, true, false))
		// Account 4 "systemProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 5 "eventAuthority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 6 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "removeRemoteTokenMessenger" instruction.
func NewRemoveRemoteTokenMessengerInstruction(
	// Params:
	paramsParam RemoveRemoteTokenMessengerParams,

	// Accounts:
	payeeAccount solanago.PublicKey,
	ownerAccount solanago.PublicKey,
	tokenMessengerAccount solanago.PublicKey,
	remoteTokenMessengerAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RemoveRemoteTokenMessenger[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "payee": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payeeAccount, true, true))
		// Account 1 "owner": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
		// Account 2 "tokenMessenger": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMessengerAccount, false, false))
		// Account 3 "remoteTokenMessenger": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(remoteTokenMessengerAccount, true, false))
		// Account 4 "eventAuthority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 5 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "depositForBurn" instruction.
func NewDepositForBurnInstruction(
	// Params:
	paramsParam DepositForBurnParams,

	// Accounts:
	ownerAccount solanago.PublicKey,
	eventRentPayerAccount solanago.PublicKey,
	senderAuthorityPdaAccount solanago.PublicKey,
	burnTokenAccountAccount solanago.PublicKey,
	messageTransmitterAccount solanago.PublicKey,
	tokenMessengerAccount solanago.PublicKey,
	remoteTokenMessengerAccount solanago.PublicKey,
	tokenMinterAccount solanago.PublicKey,
	localTokenAccount solanago.PublicKey,
	burnTokenMintAccount solanago.PublicKey,
	messageSentEventDataAccount solanago.PublicKey,
	messageTransmitterProgramAccount solanago.PublicKey,
	tokenMessengerMinterProgramAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_DepositForBurn[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "owner": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
		// Account 1 "eventRentPayer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventRentPayerAccount, true, true))
		// Account 2 "senderAuthorityPda": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(senderAuthorityPdaAccount, false, false))
		// Account 3 "burnTokenAccount": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(burnTokenAccountAccount, true, false))
		// Account 4 "messageTransmitter": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(messageTransmitterAccount, true, false))
		// Account 5 "tokenMessenger": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMessengerAccount, false, false))
		// Account 6 "remoteTokenMessenger": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(remoteTokenMessengerAccount, false, false))
		// Account 7 "tokenMinter": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMinterAccount, false, false))
		// Account 8 "localToken": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(localTokenAccount, true, false))
		// Account 9 "burnTokenMint": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(burnTokenMintAccount, true, false))
		// Account 10 "messageSentEventData": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(messageSentEventDataAccount, true, true))
		// Account 11 "messageTransmitterProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(messageTransmitterProgramAccount, false, false))
		// Account 12 "tokenMessengerMinterProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMessengerMinterProgramAccount, false, false))
		// Account 13 "tokenProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 14 "systemProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 15 "eventAuthority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 16 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "depositForBurnWithCaller" instruction.
func NewDepositForBurnWithCallerInstruction(
	// Params:
	paramsParam DepositForBurnWithCallerParams,

	// Accounts:
	ownerAccount solanago.PublicKey,
	eventRentPayerAccount solanago.PublicKey,
	senderAuthorityPdaAccount solanago.PublicKey,
	burnTokenAccountAccount solanago.PublicKey,
	messageTransmitterAccount solanago.PublicKey,
	tokenMessengerAccount solanago.PublicKey,
	remoteTokenMessengerAccount solanago.PublicKey,
	tokenMinterAccount solanago.PublicKey,
	localTokenAccount solanago.PublicKey,
	burnTokenMintAccount solanago.PublicKey,
	messageSentEventDataAccount solanago.PublicKey,
	messageTransmitterProgramAccount solanago.PublicKey,
	tokenMessengerMinterProgramAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_DepositForBurnWithCaller[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "owner": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
		// Account 1 "eventRentPayer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventRentPayerAccount, true, true))
		// Account 2 "senderAuthorityPda": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(senderAuthorityPdaAccount, false, false))
		// Account 3 "burnTokenAccount": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(burnTokenAccountAccount, true, false))
		// Account 4 "messageTransmitter": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(messageTransmitterAccount, true, false))
		// Account 5 "tokenMessenger": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMessengerAccount, false, false))
		// Account 6 "remoteTokenMessenger": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(remoteTokenMessengerAccount, false, false))
		// Account 7 "tokenMinter": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMinterAccount, false, false))
		// Account 8 "localToken": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(localTokenAccount, true, false))
		// Account 9 "burnTokenMint": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(burnTokenMintAccount, true, false))
		// Account 10 "messageSentEventData": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(messageSentEventDataAccount, true, true))
		// Account 11 "messageTransmitterProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(messageTransmitterProgramAccount, false, false))
		// Account 12 "tokenMessengerMinterProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMessengerMinterProgramAccount, false, false))
		// Account 13 "tokenProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 14 "systemProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 15 "eventAuthority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 16 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "replaceDepositForBurn" instruction.
func NewReplaceDepositForBurnInstruction(
	// Params:
	paramsParam ReplaceDepositForBurnParams,

	// Accounts:
	ownerAccount solanago.PublicKey,
	eventRentPayerAccount solanago.PublicKey,
	senderAuthorityPdaAccount solanago.PublicKey,
	messageTransmitterAccount solanago.PublicKey,
	tokenMessengerAccount solanago.PublicKey,
	messageSentEventDataAccount solanago.PublicKey,
	messageTransmitterProgramAccount solanago.PublicKey,
	tokenMessengerMinterProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ReplaceDepositForBurn[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "owner": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
		// Account 1 "eventRentPayer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventRentPayerAccount, true, true))
		// Account 2 "senderAuthorityPda": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(senderAuthorityPdaAccount, false, false))
		// Account 3 "messageTransmitter": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(messageTransmitterAccount, true, false))
		// Account 4 "tokenMessenger": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMessengerAccount, false, false))
		// Account 5 "messageSentEventData": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(messageSentEventDataAccount, true, true))
		// Account 6 "messageTransmitterProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(messageTransmitterProgramAccount, false, false))
		// Account 7 "tokenMessengerMinterProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMessengerMinterProgramAccount, false, false))
		// Account 8 "systemProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 9 "eventAuthority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 10 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "handleReceiveMessage" instruction.
func NewHandleReceiveMessageInstruction(
	// Params:
	paramsParam HandleReceiveMessageParams,

	// Accounts:
	authorityPdaAccount solanago.PublicKey,
	tokenMessengerAccount solanago.PublicKey,
	remoteTokenMessengerAccount solanago.PublicKey,
	tokenMinterAccount solanago.PublicKey,
	localTokenAccount solanago.PublicKey,
	tokenPairAccount solanago.PublicKey,
	recipientTokenAccountAccount solanago.PublicKey,
	custodyTokenAccountAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_HandleReceiveMessage[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "authorityPda": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityPdaAccount, false, true))
		// Account 1 "tokenMessenger": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMessengerAccount, false, false))
		// Account 2 "remoteTokenMessenger": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(remoteTokenMessengerAccount, false, false))
		// Account 3 "tokenMinter": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMinterAccount, false, false))
		// Account 4 "localToken": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(localTokenAccount, true, false))
		// Account 5 "tokenPair": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenPairAccount, false, false))
		// Account 6 "recipientTokenAccount": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(recipientTokenAccountAccount, true, false))
		// Account 7 "custodyTokenAccount": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(custodyTokenAccountAccount, true, false))
		// Account 8 "tokenProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 9 "eventAuthority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 10 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "setTokenController" instruction.
func NewSetTokenControllerInstruction(
	// Params:
	paramsParam SetTokenControllerParams,

	// Accounts:
	ownerAccount solanago.PublicKey,
	tokenMessengerAccount solanago.PublicKey,
	tokenMinterAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetTokenController[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "owner": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
		// Account 1 "tokenMessenger": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMessengerAccount, false, false))
		// Account 2 "tokenMinter": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMinterAccount, true, false))
		// Account 3 "eventAuthority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 4 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "pause" instruction.
func NewPauseInstruction(
	// Params:
	paramsParam PauseParams,

	// Accounts:
	pauserAccount solanago.PublicKey,
	tokenMinterAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Pause[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "pauser": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(pauserAccount, false, true))
		// Account 1 "tokenMinter": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMinterAccount, true, false))
		// Account 2 "eventAuthority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 3 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "unpause" instruction.
func NewUnpauseInstruction(
	// Params:
	paramsParam UnpauseParams,

	// Accounts:
	pauserAccount solanago.PublicKey,
	tokenMinterAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Unpause[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "pauser": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(pauserAccount, false, true))
		// Account 1 "tokenMinter": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMinterAccount, true, false))
		// Account 2 "eventAuthority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 3 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "updatePauser" instruction.
func NewUpdatePauserInstruction(
	// Params:
	paramsParam UpdatePauserParams,

	// Accounts:
	ownerAccount solanago.PublicKey,
	tokenMessengerAccount solanago.PublicKey,
	tokenMinterAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePauser[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "owner": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
		// Account 1 "tokenMessenger": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMessengerAccount, false, false))
		// Account 2 "tokenMinter": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMinterAccount, true, false))
		// Account 3 "eventAuthority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 4 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "setMaxBurnAmountPerMessage" instruction.
func NewSetMaxBurnAmountPerMessageInstruction(
	// Params:
	paramsParam SetMaxBurnAmountPerMessageParams,

	// Accounts:
	tokenControllerAccount solanago.PublicKey,
	tokenMinterAccount solanago.PublicKey,
	localTokenAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetMaxBurnAmountPerMessage[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "tokenController": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenControllerAccount, false, true))
		// Account 1 "tokenMinter": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMinterAccount, false, false))
		// Account 2 "localToken": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(localTokenAccount, true, false))
		// Account 3 "eventAuthority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 4 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "addLocalToken" instruction.
func NewAddLocalTokenInstruction(
	// Params:
	paramsParam AddLocalTokenParams,

	// Accounts:
	payerAccount solanago.PublicKey,
	tokenControllerAccount solanago.PublicKey,
	tokenMinterAccount solanago.PublicKey,
	localTokenAccount solanago.PublicKey,
	custodyTokenAccountAccount solanago.PublicKey,
	localTokenMintAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AddLocalToken[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 1 "tokenController": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenControllerAccount, false, true))
		// Account 2 "tokenMinter": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMinterAccount, false, false))
		// Account 3 "localToken": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(localTokenAccount, true, false))
		// Account 4 "custodyTokenAccount": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(custodyTokenAccountAccount, true, false))
		// Account 5 "localTokenMint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(localTokenMintAccount, false, false))
		// Account 6 "tokenProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 7 "systemProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 8 "eventAuthority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 9 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "removeLocalToken" instruction.
func NewRemoveLocalTokenInstruction(
	// Params:
	paramsParam RemoveLocalTokenParams,

	// Accounts:
	payeeAccount solanago.PublicKey,
	tokenControllerAccount solanago.PublicKey,
	tokenMinterAccount solanago.PublicKey,
	localTokenAccount solanago.PublicKey,
	custodyTokenAccountAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RemoveLocalToken[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "payee": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payeeAccount, true, true))
		// Account 1 "tokenController": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenControllerAccount, false, true))
		// Account 2 "tokenMinter": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMinterAccount, false, false))
		// Account 3 "localToken": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(localTokenAccount, true, false))
		// Account 4 "custodyTokenAccount": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(custodyTokenAccountAccount, true, false))
		// Account 5 "tokenProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 6 "eventAuthority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 7 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "linkTokenPair" instruction.
func NewLinkTokenPairInstruction(
	// Params:
	paramsParam LinkTokenPairParams,

	// Accounts:
	payerAccount solanago.PublicKey,
	tokenControllerAccount solanago.PublicKey,
	tokenMinterAccount solanago.PublicKey,
	tokenPairAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_LinkTokenPair[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 1 "tokenController": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenControllerAccount, false, true))
		// Account 2 "tokenMinter": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMinterAccount, false, false))
		// Account 3 "tokenPair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenPairAccount, true, false))
		// Account 4 "systemProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 5 "eventAuthority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 6 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "unlinkTokenPair" instruction.
func NewUnlinkTokenPairInstruction(
	// Params:
	paramsParam UninkTokenPairParams,

	// Accounts:
	payeeAccount solanago.PublicKey,
	tokenControllerAccount solanago.PublicKey,
	tokenMinterAccount solanago.PublicKey,
	tokenPairAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UnlinkTokenPair[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "payee": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payeeAccount, true, true))
		// Account 1 "tokenController": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenControllerAccount, false, true))
		// Account 2 "tokenMinter": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMinterAccount, false, false))
		// Account 3 "tokenPair": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenPairAccount, true, false))
		// Account 4 "eventAuthority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 5 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "burnTokenCustody" instruction.
func NewBurnTokenCustodyInstruction(
	// Params:
	paramsParam BurnTokenCustodyParams,

	// Accounts:
	payeeAccount solanago.PublicKey,
	tokenControllerAccount solanago.PublicKey,
	tokenMinterAccount solanago.PublicKey,
	localTokenAccount solanago.PublicKey,
	custodyTokenAccountAccount solanago.PublicKey,
	custodyTokenMintAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_BurnTokenCustody[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "payee": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payeeAccount, true, true))
		// Account 1 "tokenController": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenControllerAccount, false, true))
		// Account 2 "tokenMinter": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenMinterAccount, false, false))
		// Account 3 "localToken": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(localTokenAccount, false, false))
		// Account 4 "custodyTokenAccount": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(custodyTokenAccountAccount, true, false))
		// Account 5 "custodyTokenMint": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(custodyTokenMintAccount, true, false))
		// Account 6 "tokenProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 7 "eventAuthority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 8 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

type InitializeInstruction struct {
	Params InitializeParams `json:"params"`

	// Accounts:
	Payer                           solanago.PublicKey `json:"payer"`
	PayerWritable                   bool               `json:"payer_writable"`
	PayerSigner                     bool               `json:"payer_signer"`
	UpgradeAuthority                solanago.PublicKey `json:"upgradeAuthority"`
	UpgradeAuthoritySigner          bool               `json:"upgradeAuthority_signer"`
	AuthorityPda                    solanago.PublicKey `json:"authorityPda"`
	TokenMessenger                  solanago.PublicKey `json:"tokenMessenger"`
	TokenMessengerWritable          bool               `json:"tokenMessenger_writable"`
	TokenMinter                     solanago.PublicKey `json:"tokenMinter"`
	TokenMinterWritable             bool               `json:"tokenMinter_writable"`
	TokenMessengerMinterProgramData solanago.PublicKey `json:"tokenMessengerMinterProgramData"`
	TokenMessengerMinterProgram     solanago.PublicKey `json:"tokenMessengerMinterProgram"`
	SystemProgram                   solanago.PublicKey `json:"systemProgram"`
	EventAuthority                  solanago.PublicKey `json:"eventAuthority"`
	Program                         solanago.PublicKey `json:"program"`
}

func (obj *InitializeInstruction) GetDiscriminator() []byte {
	return Instruction_Initialize[:]
}

// UnmarshalWithDecoder unmarshals the InitializeInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *InitializeInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "InitializeInstruction", err)
	}
	if discriminator != Instruction_Initialize {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "InitializeInstruction", Instruction_Initialize, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *InitializeInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from payer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "payer", err)
	}
	indices = append(indices, index)
	// Decode from upgradeAuthority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "upgradeAuthority", err)
	}
	indices = append(indices, index)
	// Decode from authorityPda account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authorityPda", err)
	}
	indices = append(indices, index)
	// Decode from tokenMessenger account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenMessenger", err)
	}
	indices = append(indices, index)
	// Decode from tokenMinter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenMinter", err)
	}
	indices = append(indices, index)
	// Decode from tokenMessengerMinterProgramData account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenMessengerMinterProgramData", err)
	}
	indices = append(indices, index)
	// Decode from tokenMessengerMinterProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenMessengerMinterProgram", err)
	}
	indices = append(indices, index)
	// Decode from systemProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "systemProgram", err)
	}
	indices = append(indices, index)
	// Decode from eventAuthority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventAuthority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitializeInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 10 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 10, len(indices))
	}
	indexOffset := 0
	// Set payer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "payer", len(accountKeys)-1)
	}
	obj.Payer = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set upgradeAuthority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "upgradeAuthority", len(accountKeys)-1)
	}
	obj.UpgradeAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authorityPda account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authorityPda", len(accountKeys)-1)
	}
	obj.AuthorityPda = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenMessenger account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenMessenger", len(accountKeys)-1)
	}
	obj.TokenMessenger = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenMinter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenMinter", len(accountKeys)-1)
	}
	obj.TokenMinter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenMessengerMinterProgramData account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenMessengerMinterProgramData", len(accountKeys)-1)
	}
	obj.TokenMessengerMinterProgramData = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenMessengerMinterProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenMessengerMinterProgram", len(accountKeys)-1)
	}
	obj.TokenMessengerMinterProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set systemProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "systemProgram", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set eventAuthority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventAuthority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitializeInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Payer)
	keys = append(keys, obj.UpgradeAuthority)
	keys = append(keys, obj.AuthorityPda)
	keys = append(keys, obj.TokenMessenger)
	keys = append(keys, obj.TokenMinter)
	keys = append(keys, obj.TokenMessengerMinterProgramData)
	keys = append(keys, obj.TokenMessengerMinterProgram)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

// Unmarshal unmarshals the InitializeInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *InitializeInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitializeInstruction: %w", err)
	}
	return nil
}

// UnmarshalInitializeInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalInitializeInstruction(buf []byte) (*InitializeInstruction, error) {
	obj := new(InitializeInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type TransferOwnershipInstruction struct {
	Params TransferOwnershipParams `json:"params"`

	// Accounts:
	Owner                  solanago.PublicKey `json:"owner"`
	OwnerSigner            bool               `json:"owner_signer"`
	TokenMessenger         solanago.PublicKey `json:"tokenMessenger"`
	TokenMessengerWritable bool               `json:"tokenMessenger_writable"`
	EventAuthority         solanago.PublicKey `json:"eventAuthority"`
	Program                solanago.PublicKey `json:"program"`
}

func (obj *TransferOwnershipInstruction) GetDiscriminator() []byte {
	return Instruction_TransferOwnership[:]
}

// UnmarshalWithDecoder unmarshals the TransferOwnershipInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *TransferOwnershipInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "TransferOwnershipInstruction", err)
	}
	if discriminator != Instruction_TransferOwnership {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "TransferOwnershipInstruction", Instruction_TransferOwnership, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *TransferOwnershipInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from owner account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "owner", err)
	}
	indices = append(indices, index)
	// Decode from tokenMessenger account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenMessenger", err)
	}
	indices = append(indices, index)
	// Decode from eventAuthority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventAuthority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *TransferOwnershipInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set owner account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "owner", len(accountKeys)-1)
	}
	obj.Owner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenMessenger account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenMessenger", len(accountKeys)-1)
	}
	obj.TokenMessenger = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set eventAuthority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventAuthority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *TransferOwnershipInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Owner)
	keys = append(keys, obj.TokenMessenger)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

// Unmarshal unmarshals the TransferOwnershipInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *TransferOwnershipInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling TransferOwnershipInstruction: %w", err)
	}
	return nil
}

// UnmarshalTransferOwnershipInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalTransferOwnershipInstruction(buf []byte) (*TransferOwnershipInstruction, error) {
	obj := new(TransferOwnershipInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type AcceptOwnershipInstruction struct {
	Params AcceptOwnershipParams `json:"params"`

	// Accounts:
	PendingOwner           solanago.PublicKey `json:"pendingOwner"`
	PendingOwnerSigner     bool               `json:"pendingOwner_signer"`
	TokenMessenger         solanago.PublicKey `json:"tokenMessenger"`
	TokenMessengerWritable bool               `json:"tokenMessenger_writable"`
	EventAuthority         solanago.PublicKey `json:"eventAuthority"`
	Program                solanago.PublicKey `json:"program"`
}

func (obj *AcceptOwnershipInstruction) GetDiscriminator() []byte {
	return Instruction_AcceptOwnership[:]
}

// UnmarshalWithDecoder unmarshals the AcceptOwnershipInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *AcceptOwnershipInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "AcceptOwnershipInstruction", err)
	}
	if discriminator != Instruction_AcceptOwnership {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "AcceptOwnershipInstruction", Instruction_AcceptOwnership, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AcceptOwnershipInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from pendingOwner account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "pendingOwner", err)
	}
	indices = append(indices, index)
	// Decode from tokenMessenger account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenMessenger", err)
	}
	indices = append(indices, index)
	// Decode from eventAuthority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventAuthority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AcceptOwnershipInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set pendingOwner account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "pendingOwner", len(accountKeys)-1)
	}
	obj.PendingOwner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenMessenger account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenMessenger", len(accountKeys)-1)
	}
	obj.TokenMessenger = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set eventAuthority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventAuthority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AcceptOwnershipInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.PendingOwner)
	keys = append(keys, obj.TokenMessenger)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

// Unmarshal unmarshals the AcceptOwnershipInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *AcceptOwnershipInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AcceptOwnershipInstruction: %w", err)
	}
	return nil
}

// UnmarshalAcceptOwnershipInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalAcceptOwnershipInstruction(buf []byte) (*AcceptOwnershipInstruction, error) {
	obj := new(AcceptOwnershipInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type AddRemoteTokenMessengerInstruction struct {
	Params AddRemoteTokenMessengerParams `json:"params"`

	// Accounts:
	Payer                        solanago.PublicKey `json:"payer"`
	PayerWritable                bool               `json:"payer_writable"`
	PayerSigner                  bool               `json:"payer_signer"`
	Owner                        solanago.PublicKey `json:"owner"`
	OwnerSigner                  bool               `json:"owner_signer"`
	TokenMessenger               solanago.PublicKey `json:"tokenMessenger"`
	RemoteTokenMessenger         solanago.PublicKey `json:"remoteTokenMessenger"`
	RemoteTokenMessengerWritable bool               `json:"remoteTokenMessenger_writable"`
	SystemProgram                solanago.PublicKey `json:"systemProgram"`
	EventAuthority               solanago.PublicKey `json:"eventAuthority"`
	Program                      solanago.PublicKey `json:"program"`
}

func (obj *AddRemoteTokenMessengerInstruction) GetDiscriminator() []byte {
	return Instruction_AddRemoteTokenMessenger[:]
}

// UnmarshalWithDecoder unmarshals the AddRemoteTokenMessengerInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *AddRemoteTokenMessengerInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "AddRemoteTokenMessengerInstruction", err)
	}
	if discriminator != Instruction_AddRemoteTokenMessenger {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "AddRemoteTokenMessengerInstruction", Instruction_AddRemoteTokenMessenger, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AddRemoteTokenMessengerInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from payer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "payer", err)
	}
	indices = append(indices, index)
	// Decode from owner account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "owner", err)
	}
	indices = append(indices, index)
	// Decode from tokenMessenger account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenMessenger", err)
	}
	indices = append(indices, index)
	// Decode from remoteTokenMessenger account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "remoteTokenMessenger", err)
	}
	indices = append(indices, index)
	// Decode from systemProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "systemProgram", err)
	}
	indices = append(indices, index)
	// Decode from eventAuthority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventAuthority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AddRemoteTokenMessengerInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 7 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 7, len(indices))
	}
	indexOffset := 0
	// Set payer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "payer", len(accountKeys)-1)
	}
	obj.Payer = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set owner account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "owner", len(accountKeys)-1)
	}
	obj.Owner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenMessenger account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenMessenger", len(accountKeys)-1)
	}
	obj.TokenMessenger = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set remoteTokenMessenger account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "remoteTokenMessenger", len(accountKeys)-1)
	}
	obj.RemoteTokenMessenger = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set systemProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "systemProgram", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set eventAuthority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventAuthority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AddRemoteTokenMessengerInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Payer)
	keys = append(keys, obj.Owner)
	keys = append(keys, obj.TokenMessenger)
	keys = append(keys, obj.RemoteTokenMessenger)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

// Unmarshal unmarshals the AddRemoteTokenMessengerInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *AddRemoteTokenMessengerInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AddRemoteTokenMessengerInstruction: %w", err)
	}
	return nil
}

// UnmarshalAddRemoteTokenMessengerInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalAddRemoteTokenMessengerInstruction(buf []byte) (*AddRemoteTokenMessengerInstruction, error) {
	obj := new(AddRemoteTokenMessengerInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type RemoveRemoteTokenMessengerInstruction struct {
	Params RemoveRemoteTokenMessengerParams `json:"params"`

	// Accounts:
	Payee                        solanago.PublicKey `json:"payee"`
	PayeeWritable                bool               `json:"payee_writable"`
	PayeeSigner                  bool               `json:"payee_signer"`
	Owner                        solanago.PublicKey `json:"owner"`
	OwnerSigner                  bool               `json:"owner_signer"`
	TokenMessenger               solanago.PublicKey `json:"tokenMessenger"`
	RemoteTokenMessenger         solanago.PublicKey `json:"remoteTokenMessenger"`
	RemoteTokenMessengerWritable bool               `json:"remoteTokenMessenger_writable"`
	EventAuthority               solanago.PublicKey `json:"eventAuthority"`
	Program                      solanago.PublicKey `json:"program"`
}

func (obj *RemoveRemoteTokenMessengerInstruction) GetDiscriminator() []byte {
	return Instruction_RemoveRemoteTokenMessenger[:]
}

// UnmarshalWithDecoder unmarshals the RemoveRemoteTokenMessengerInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *RemoveRemoteTokenMessengerInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "RemoveRemoteTokenMessengerInstruction", err)
	}
	if discriminator != Instruction_RemoveRemoteTokenMessenger {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "RemoveRemoteTokenMessengerInstruction", Instruction_RemoveRemoteTokenMessenger, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *RemoveRemoteTokenMessengerInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from payee account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "payee", err)
	}
	indices = append(indices, index)
	// Decode from owner account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "owner", err)
	}
	indices = append(indices, index)
	// Decode from tokenMessenger account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenMessenger", err)
	}
	indices = append(indices, index)
	// Decode from remoteTokenMessenger account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "remoteTokenMessenger", err)
	}
	indices = append(indices, index)
	// Decode from eventAuthority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventAuthority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *RemoveRemoteTokenMessengerInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 6 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 6, len(indices))
	}
	indexOffset := 0
	// Set payee account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "payee", len(accountKeys)-1)
	}
	obj.Payee = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set owner account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "owner", len(accountKeys)-1)
	}
	obj.Owner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenMessenger account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenMessenger", len(accountKeys)-1)
	}
	obj.TokenMessenger = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set remoteTokenMessenger account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "remoteTokenMessenger", len(accountKeys)-1)
	}
	obj.RemoteTokenMessenger = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set eventAuthority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventAuthority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *RemoveRemoteTokenMessengerInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Payee)
	keys = append(keys, obj.Owner)
	keys = append(keys, obj.TokenMessenger)
	keys = append(keys, obj.RemoteTokenMessenger)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

// Unmarshal unmarshals the RemoveRemoteTokenMessengerInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *RemoveRemoteTokenMessengerInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling RemoveRemoteTokenMessengerInstruction: %w", err)
	}
	return nil
}

// UnmarshalRemoveRemoteTokenMessengerInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalRemoveRemoteTokenMessengerInstruction(buf []byte) (*RemoveRemoteTokenMessengerInstruction, error) {
	obj := new(RemoveRemoteTokenMessengerInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type DepositForBurnInstruction struct {
	Params DepositForBurnParams `json:"params"`

	// Accounts:
	Owner                        solanago.PublicKey `json:"owner"`
	OwnerSigner                  bool               `json:"owner_signer"`
	EventRentPayer               solanago.PublicKey `json:"eventRentPayer"`
	EventRentPayerWritable       bool               `json:"eventRentPayer_writable"`
	EventRentPayerSigner         bool               `json:"eventRentPayer_signer"`
	SenderAuthorityPda           solanago.PublicKey `json:"senderAuthorityPda"`
	BurnTokenAccount             solanago.PublicKey `json:"burnTokenAccount"`
	BurnTokenAccountWritable     bool               `json:"burnTokenAccount_writable"`
	MessageTransmitter           solanago.PublicKey `json:"messageTransmitter"`
	MessageTransmitterWritable   bool               `json:"messageTransmitter_writable"`
	TokenMessenger               solanago.PublicKey `json:"tokenMessenger"`
	RemoteTokenMessenger         solanago.PublicKey `json:"remoteTokenMessenger"`
	TokenMinter                  solanago.PublicKey `json:"tokenMinter"`
	LocalToken                   solanago.PublicKey `json:"localToken"`
	LocalTokenWritable           bool               `json:"localToken_writable"`
	BurnTokenMint                solanago.PublicKey `json:"burnTokenMint"`
	BurnTokenMintWritable        bool               `json:"burnTokenMint_writable"`
	MessageSentEventData         solanago.PublicKey `json:"messageSentEventData"`
	MessageSentEventDataWritable bool               `json:"messageSentEventData_writable"`
	MessageSentEventDataSigner   bool               `json:"messageSentEventData_signer"`
	MessageTransmitterProgram    solanago.PublicKey `json:"messageTransmitterProgram"`
	TokenMessengerMinterProgram  solanago.PublicKey `json:"tokenMessengerMinterProgram"`
	TokenProgram                 solanago.PublicKey `json:"tokenProgram"`
	SystemProgram                solanago.PublicKey `json:"systemProgram"`
	EventAuthority               solanago.PublicKey `json:"eventAuthority"`
	Program                      solanago.PublicKey `json:"program"`
}

func (obj *DepositForBurnInstruction) GetDiscriminator() []byte {
	return Instruction_DepositForBurn[:]
}

// UnmarshalWithDecoder unmarshals the DepositForBurnInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *DepositForBurnInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "DepositForBurnInstruction", err)
	}
	if discriminator != Instruction_DepositForBurn {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "DepositForBurnInstruction", Instruction_DepositForBurn, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *DepositForBurnInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from owner account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "owner", err)
	}
	indices = append(indices, index)
	// Decode from eventRentPayer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventRentPayer", err)
	}
	indices = append(indices, index)
	// Decode from senderAuthorityPda account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "senderAuthorityPda", err)
	}
	indices = append(indices, index)
	// Decode from burnTokenAccount account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "burnTokenAccount", err)
	}
	indices = append(indices, index)
	// Decode from messageTransmitter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "messageTransmitter", err)
	}
	indices = append(indices, index)
	// Decode from tokenMessenger account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenMessenger", err)
	}
	indices = append(indices, index)
	// Decode from remoteTokenMessenger account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "remoteTokenMessenger", err)
	}
	indices = append(indices, index)
	// Decode from tokenMinter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenMinter", err)
	}
	indices = append(indices, index)
	// Decode from localToken account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "localToken", err)
	}
	indices = append(indices, index)
	// Decode from burnTokenMint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "burnTokenMint", err)
	}
	indices = append(indices, index)
	// Decode from messageSentEventData account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "messageSentEventData", err)
	}
	indices = append(indices, index)
	// Decode from messageTransmitterProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "messageTransmitterProgram", err)
	}
	indices = append(indices, index)
	// Decode from tokenMessengerMinterProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenMessengerMinterProgram", err)
	}
	indices = append(indices, index)
	// Decode from tokenProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenProgram", err)
	}
	indices = append(indices, index)
	// Decode from systemProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "systemProgram", err)
	}
	indices = append(indices, index)
	// Decode from eventAuthority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventAuthority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *DepositForBurnInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 17 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 17, len(indices))
	}
	indexOffset := 0
	// Set owner account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "owner", len(accountKeys)-1)
	}
	obj.Owner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set eventRentPayer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventRentPayer", len(accountKeys)-1)
	}
	obj.EventRentPayer = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set senderAuthorityPda account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "senderAuthorityPda", len(accountKeys)-1)
	}
	obj.SenderAuthorityPda = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set burnTokenAccount account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "burnTokenAccount", len(accountKeys)-1)
	}
	obj.BurnTokenAccount = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set messageTransmitter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "messageTransmitter", len(accountKeys)-1)
	}
	obj.MessageTransmitter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenMessenger account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenMessenger", len(accountKeys)-1)
	}
	obj.TokenMessenger = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set remoteTokenMessenger account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "remoteTokenMessenger", len(accountKeys)-1)
	}
	obj.RemoteTokenMessenger = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenMinter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenMinter", len(accountKeys)-1)
	}
	obj.TokenMinter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set localToken account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "localToken", len(accountKeys)-1)
	}
	obj.LocalToken = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set burnTokenMint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "burnTokenMint", len(accountKeys)-1)
	}
	obj.BurnTokenMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set messageSentEventData account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "messageSentEventData", len(accountKeys)-1)
	}
	obj.MessageSentEventData = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set messageTransmitterProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "messageTransmitterProgram", len(accountKeys)-1)
	}
	obj.MessageTransmitterProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenMessengerMinterProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenMessengerMinterProgram", len(accountKeys)-1)
	}
	obj.TokenMessengerMinterProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenProgram", len(accountKeys)-1)
	}
	obj.TokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set systemProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "systemProgram", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set eventAuthority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventAuthority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *DepositForBurnInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Owner)
	keys = append(keys, obj.EventRentPayer)
	keys = append(keys, obj.SenderAuthorityPda)
	keys = append(keys, obj.BurnTokenAccount)
	keys = append(keys, obj.MessageTransmitter)
	keys = append(keys, obj.TokenMessenger)
	keys = append(keys, obj.RemoteTokenMessenger)
	keys = append(keys, obj.TokenMinter)
	keys = append(keys, obj.LocalToken)
	keys = append(keys, obj.BurnTokenMint)
	keys = append(keys, obj.MessageSentEventData)
	keys = append(keys, obj.MessageTransmitterProgram)
	keys = append(keys, obj.TokenMessengerMinterProgram)
	keys = append(keys, obj.TokenProgram)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

// Unmarshal unmarshals the DepositForBurnInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *DepositForBurnInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling DepositForBurnInstruction: %w", err)
	}
	return nil
}

// UnmarshalDepositForBurnInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalDepositForBurnInstruction(buf []byte) (*DepositForBurnInstruction, error) {
	obj := new(DepositForBurnInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type DepositForBurnWithCallerInstruction struct {
	Params DepositForBurnWithCallerParams `json:"params"`

	// Accounts:
	Owner                        solanago.PublicKey `json:"owner"`
	OwnerSigner                  bool               `json:"owner_signer"`
	EventRentPayer               solanago.PublicKey `json:"eventRentPayer"`
	EventRentPayerWritable       bool               `json:"eventRentPayer_writable"`
	EventRentPayerSigner         bool               `json:"eventRentPayer_signer"`
	SenderAuthorityPda           solanago.PublicKey `json:"senderAuthorityPda"`
	BurnTokenAccount             solanago.PublicKey `json:"burnTokenAccount"`
	BurnTokenAccountWritable     bool               `json:"burnTokenAccount_writable"`
	MessageTransmitter           solanago.PublicKey `json:"messageTransmitter"`
	MessageTransmitterWritable   bool               `json:"messageTransmitter_writable"`
	TokenMessenger               solanago.PublicKey `json:"tokenMessenger"`
	RemoteTokenMessenger         solanago.PublicKey `json:"remoteTokenMessenger"`
	TokenMinter                  solanago.PublicKey `json:"tokenMinter"`
	LocalToken                   solanago.PublicKey `json:"localToken"`
	LocalTokenWritable           bool               `json:"localToken_writable"`
	BurnTokenMint                solanago.PublicKey `json:"burnTokenMint"`
	BurnTokenMintWritable        bool               `json:"burnTokenMint_writable"`
	MessageSentEventData         solanago.PublicKey `json:"messageSentEventData"`
	MessageSentEventDataWritable bool               `json:"messageSentEventData_writable"`
	MessageSentEventDataSigner   bool               `json:"messageSentEventData_signer"`
	MessageTransmitterProgram    solanago.PublicKey `json:"messageTransmitterProgram"`
	TokenMessengerMinterProgram  solanago.PublicKey `json:"tokenMessengerMinterProgram"`
	TokenProgram                 solanago.PublicKey `json:"tokenProgram"`
	SystemProgram                solanago.PublicKey `json:"systemProgram"`
	EventAuthority               solanago.PublicKey `json:"eventAuthority"`
	Program                      solanago.PublicKey `json:"program"`
}

func (obj *DepositForBurnWithCallerInstruction) GetDiscriminator() []byte {
	return Instruction_DepositForBurnWithCaller[:]
}

// UnmarshalWithDecoder unmarshals the DepositForBurnWithCallerInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *DepositForBurnWithCallerInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "DepositForBurnWithCallerInstruction", err)
	}
	if discriminator != Instruction_DepositForBurnWithCaller {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "DepositForBurnWithCallerInstruction", Instruction_DepositForBurnWithCaller, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *DepositForBurnWithCallerInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from owner account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "owner", err)
	}
	indices = append(indices, index)
	// Decode from eventRentPayer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventRentPayer", err)
	}
	indices = append(indices, index)
	// Decode from senderAuthorityPda account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "senderAuthorityPda", err)
	}
	indices = append(indices, index)
	// Decode from burnTokenAccount account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "burnTokenAccount", err)
	}
	indices = append(indices, index)
	// Decode from messageTransmitter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "messageTransmitter", err)
	}
	indices = append(indices, index)
	// Decode from tokenMessenger account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenMessenger", err)
	}
	indices = append(indices, index)
	// Decode from remoteTokenMessenger account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "remoteTokenMessenger", err)
	}
	indices = append(indices, index)
	// Decode from tokenMinter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenMinter", err)
	}
	indices = append(indices, index)
	// Decode from localToken account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "localToken", err)
	}
	indices = append(indices, index)
	// Decode from burnTokenMint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "burnTokenMint", err)
	}
	indices = append(indices, index)
	// Decode from messageSentEventData account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "messageSentEventData", err)
	}
	indices = append(indices, index)
	// Decode from messageTransmitterProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "messageTransmitterProgram", err)
	}
	indices = append(indices, index)
	// Decode from tokenMessengerMinterProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenMessengerMinterProgram", err)
	}
	indices = append(indices, index)
	// Decode from tokenProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenProgram", err)
	}
	indices = append(indices, index)
	// Decode from systemProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "systemProgram", err)
	}
	indices = append(indices, index)
	// Decode from eventAuthority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventAuthority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *DepositForBurnWithCallerInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 17 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 17, len(indices))
	}
	indexOffset := 0
	// Set owner account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "owner", len(accountKeys)-1)
	}
	obj.Owner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set eventRentPayer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventRentPayer", len(accountKeys)-1)
	}
	obj.EventRentPayer = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set senderAuthorityPda account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "senderAuthorityPda", len(accountKeys)-1)
	}
	obj.SenderAuthorityPda = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set burnTokenAccount account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "burnTokenAccount", len(accountKeys)-1)
	}
	obj.BurnTokenAccount = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set messageTransmitter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "messageTransmitter", len(accountKeys)-1)
	}
	obj.MessageTransmitter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenMessenger account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenMessenger", len(accountKeys)-1)
	}
	obj.TokenMessenger = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set remoteTokenMessenger account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "remoteTokenMessenger", len(accountKeys)-1)
	}
	obj.RemoteTokenMessenger = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenMinter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenMinter", len(accountKeys)-1)
	}
	obj.TokenMinter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set localToken account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "localToken", len(accountKeys)-1)
	}
	obj.LocalToken = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set burnTokenMint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "burnTokenMint", len(accountKeys)-1)
	}
	obj.BurnTokenMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set messageSentEventData account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "messageSentEventData", len(accountKeys)-1)
	}
	obj.MessageSentEventData = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set messageTransmitterProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "messageTransmitterProgram", len(accountKeys)-1)
	}
	obj.MessageTransmitterProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenMessengerMinterProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenMessengerMinterProgram", len(accountKeys)-1)
	}
	obj.TokenMessengerMinterProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenProgram", len(accountKeys)-1)
	}
	obj.TokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set systemProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "systemProgram", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set eventAuthority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventAuthority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *DepositForBurnWithCallerInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Owner)
	keys = append(keys, obj.EventRentPayer)
	keys = append(keys, obj.SenderAuthorityPda)
	keys = append(keys, obj.BurnTokenAccount)
	keys = append(keys, obj.MessageTransmitter)
	keys = append(keys, obj.TokenMessenger)
	keys = append(keys, obj.RemoteTokenMessenger)
	keys = append(keys, obj.TokenMinter)
	keys = append(keys, obj.LocalToken)
	keys = append(keys, obj.BurnTokenMint)
	keys = append(keys, obj.MessageSentEventData)
	keys = append(keys, obj.MessageTransmitterProgram)
	keys = append(keys, obj.TokenMessengerMinterProgram)
	keys = append(keys, obj.TokenProgram)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

// Unmarshal unmarshals the DepositForBurnWithCallerInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *DepositForBurnWithCallerInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling DepositForBurnWithCallerInstruction: %w", err)
	}
	return nil
}

// UnmarshalDepositForBurnWithCallerInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalDepositForBurnWithCallerInstruction(buf []byte) (*DepositForBurnWithCallerInstruction, error) {
	obj := new(DepositForBurnWithCallerInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ReplaceDepositForBurnInstruction struct {
	Params ReplaceDepositForBurnParams `json:"params"`

	// Accounts:
	Owner                        solanago.PublicKey `json:"owner"`
	OwnerSigner                  bool               `json:"owner_signer"`
	EventRentPayer               solanago.PublicKey `json:"eventRentPayer"`
	EventRentPayerWritable       bool               `json:"eventRentPayer_writable"`
	EventRentPayerSigner         bool               `json:"eventRentPayer_signer"`
	SenderAuthorityPda           solanago.PublicKey `json:"senderAuthorityPda"`
	MessageTransmitter           solanago.PublicKey `json:"messageTransmitter"`
	MessageTransmitterWritable   bool               `json:"messageTransmitter_writable"`
	TokenMessenger               solanago.PublicKey `json:"tokenMessenger"`
	MessageSentEventData         solanago.PublicKey `json:"messageSentEventData"`
	MessageSentEventDataWritable bool               `json:"messageSentEventData_writable"`
	MessageSentEventDataSigner   bool               `json:"messageSentEventData_signer"`
	MessageTransmitterProgram    solanago.PublicKey `json:"messageTransmitterProgram"`
	TokenMessengerMinterProgram  solanago.PublicKey `json:"tokenMessengerMinterProgram"`
	SystemProgram                solanago.PublicKey `json:"systemProgram"`
	EventAuthority               solanago.PublicKey `json:"eventAuthority"`
	Program                      solanago.PublicKey `json:"program"`
}

func (obj *ReplaceDepositForBurnInstruction) GetDiscriminator() []byte {
	return Instruction_ReplaceDepositForBurn[:]
}

// UnmarshalWithDecoder unmarshals the ReplaceDepositForBurnInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *ReplaceDepositForBurnInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "ReplaceDepositForBurnInstruction", err)
	}
	if discriminator != Instruction_ReplaceDepositForBurn {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "ReplaceDepositForBurnInstruction", Instruction_ReplaceDepositForBurn, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *ReplaceDepositForBurnInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from owner account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "owner", err)
	}
	indices = append(indices, index)
	// Decode from eventRentPayer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventRentPayer", err)
	}
	indices = append(indices, index)
	// Decode from senderAuthorityPda account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "senderAuthorityPda", err)
	}
	indices = append(indices, index)
	// Decode from messageTransmitter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "messageTransmitter", err)
	}
	indices = append(indices, index)
	// Decode from tokenMessenger account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenMessenger", err)
	}
	indices = append(indices, index)
	// Decode from messageSentEventData account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "messageSentEventData", err)
	}
	indices = append(indices, index)
	// Decode from messageTransmitterProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "messageTransmitterProgram", err)
	}
	indices = append(indices, index)
	// Decode from tokenMessengerMinterProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenMessengerMinterProgram", err)
	}
	indices = append(indices, index)
	// Decode from systemProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "systemProgram", err)
	}
	indices = append(indices, index)
	// Decode from eventAuthority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventAuthority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *ReplaceDepositForBurnInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 11 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 11, len(indices))
	}
	indexOffset := 0
	// Set owner account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "owner", len(accountKeys)-1)
	}
	obj.Owner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set eventRentPayer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventRentPayer", len(accountKeys)-1)
	}
	obj.EventRentPayer = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set senderAuthorityPda account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "senderAuthorityPda", len(accountKeys)-1)
	}
	obj.SenderAuthorityPda = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set messageTransmitter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "messageTransmitter", len(accountKeys)-1)
	}
	obj.MessageTransmitter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenMessenger account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenMessenger", len(accountKeys)-1)
	}
	obj.TokenMessenger = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set messageSentEventData account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "messageSentEventData", len(accountKeys)-1)
	}
	obj.MessageSentEventData = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set messageTransmitterProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "messageTransmitterProgram", len(accountKeys)-1)
	}
	obj.MessageTransmitterProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenMessengerMinterProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenMessengerMinterProgram", len(accountKeys)-1)
	}
	obj.TokenMessengerMinterProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set systemProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "systemProgram", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set eventAuthority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventAuthority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *ReplaceDepositForBurnInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Owner)
	keys = append(keys, obj.EventRentPayer)
	keys = append(keys, obj.SenderAuthorityPda)
	keys = append(keys, obj.MessageTransmitter)
	keys = append(keys, obj.TokenMessenger)
	keys = append(keys, obj.MessageSentEventData)
	keys = append(keys, obj.MessageTransmitterProgram)
	keys = append(keys, obj.TokenMessengerMinterProgram)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

// Unmarshal unmarshals the ReplaceDepositForBurnInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *ReplaceDepositForBurnInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ReplaceDepositForBurnInstruction: %w", err)
	}
	return nil
}

// UnmarshalReplaceDepositForBurnInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalReplaceDepositForBurnInstruction(buf []byte) (*ReplaceDepositForBurnInstruction, error) {
	obj := new(ReplaceDepositForBurnInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type HandleReceiveMessageInstruction struct {
	Params HandleReceiveMessageParams `json:"params"`

	// Accounts:
	AuthorityPda                  solanago.PublicKey `json:"authorityPda"`
	AuthorityPdaSigner            bool               `json:"authorityPda_signer"`
	TokenMessenger                solanago.PublicKey `json:"tokenMessenger"`
	RemoteTokenMessenger          solanago.PublicKey `json:"remoteTokenMessenger"`
	TokenMinter                   solanago.PublicKey `json:"tokenMinter"`
	LocalToken                    solanago.PublicKey `json:"localToken"`
	LocalTokenWritable            bool               `json:"localToken_writable"`
	TokenPair                     solanago.PublicKey `json:"tokenPair"`
	RecipientTokenAccount         solanago.PublicKey `json:"recipientTokenAccount"`
	RecipientTokenAccountWritable bool               `json:"recipientTokenAccount_writable"`
	CustodyTokenAccount           solanago.PublicKey `json:"custodyTokenAccount"`
	CustodyTokenAccountWritable   bool               `json:"custodyTokenAccount_writable"`
	TokenProgram                  solanago.PublicKey `json:"tokenProgram"`
	EventAuthority                solanago.PublicKey `json:"eventAuthority"`
	Program                       solanago.PublicKey `json:"program"`
}

func (obj *HandleReceiveMessageInstruction) GetDiscriminator() []byte {
	return Instruction_HandleReceiveMessage[:]
}

// UnmarshalWithDecoder unmarshals the HandleReceiveMessageInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *HandleReceiveMessageInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "HandleReceiveMessageInstruction", err)
	}
	if discriminator != Instruction_HandleReceiveMessage {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "HandleReceiveMessageInstruction", Instruction_HandleReceiveMessage, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *HandleReceiveMessageInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from authorityPda account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authorityPda", err)
	}
	indices = append(indices, index)
	// Decode from tokenMessenger account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenMessenger", err)
	}
	indices = append(indices, index)
	// Decode from remoteTokenMessenger account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "remoteTokenMessenger", err)
	}
	indices = append(indices, index)
	// Decode from tokenMinter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenMinter", err)
	}
	indices = append(indices, index)
	// Decode from localToken account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "localToken", err)
	}
	indices = append(indices, index)
	// Decode from tokenPair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenPair", err)
	}
	indices = append(indices, index)
	// Decode from recipientTokenAccount account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "recipientTokenAccount", err)
	}
	indices = append(indices, index)
	// Decode from custodyTokenAccount account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "custodyTokenAccount", err)
	}
	indices = append(indices, index)
	// Decode from tokenProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenProgram", err)
	}
	indices = append(indices, index)
	// Decode from eventAuthority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventAuthority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *HandleReceiveMessageInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 11 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 11, len(indices))
	}
	indexOffset := 0
	// Set authorityPda account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authorityPda", len(accountKeys)-1)
	}
	obj.AuthorityPda = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenMessenger account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenMessenger", len(accountKeys)-1)
	}
	obj.TokenMessenger = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set remoteTokenMessenger account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "remoteTokenMessenger", len(accountKeys)-1)
	}
	obj.RemoteTokenMessenger = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenMinter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenMinter", len(accountKeys)-1)
	}
	obj.TokenMinter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set localToken account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "localToken", len(accountKeys)-1)
	}
	obj.LocalToken = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenPair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenPair", len(accountKeys)-1)
	}
	obj.TokenPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set recipientTokenAccount account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "recipientTokenAccount", len(accountKeys)-1)
	}
	obj.RecipientTokenAccount = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set custodyTokenAccount account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "custodyTokenAccount", len(accountKeys)-1)
	}
	obj.CustodyTokenAccount = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenProgram", len(accountKeys)-1)
	}
	obj.TokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set eventAuthority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventAuthority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *HandleReceiveMessageInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.AuthorityPda)
	keys = append(keys, obj.TokenMessenger)
	keys = append(keys, obj.RemoteTokenMessenger)
	keys = append(keys, obj.TokenMinter)
	keys = append(keys, obj.LocalToken)
	keys = append(keys, obj.TokenPair)
	keys = append(keys, obj.RecipientTokenAccount)
	keys = append(keys, obj.CustodyTokenAccount)
	keys = append(keys, obj.TokenProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

// Unmarshal unmarshals the HandleReceiveMessageInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *HandleReceiveMessageInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling HandleReceiveMessageInstruction: %w", err)
	}
	return nil
}

// UnmarshalHandleReceiveMessageInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalHandleReceiveMessageInstruction(buf []byte) (*HandleReceiveMessageInstruction, error) {
	obj := new(HandleReceiveMessageInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SetTokenControllerInstruction struct {
	Params SetTokenControllerParams `json:"params"`

	// Accounts:
	Owner               solanago.PublicKey `json:"owner"`
	OwnerSigner         bool               `json:"owner_signer"`
	TokenMessenger      solanago.PublicKey `json:"tokenMessenger"`
	TokenMinter         solanago.PublicKey `json:"tokenMinter"`
	TokenMinterWritable bool               `json:"tokenMinter_writable"`
	EventAuthority      solanago.PublicKey `json:"eventAuthority"`
	Program             solanago.PublicKey `json:"program"`
}

func (obj *SetTokenControllerInstruction) GetDiscriminator() []byte {
	return Instruction_SetTokenController[:]
}

// UnmarshalWithDecoder unmarshals the SetTokenControllerInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *SetTokenControllerInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "SetTokenControllerInstruction", err)
	}
	if discriminator != Instruction_SetTokenController {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "SetTokenControllerInstruction", Instruction_SetTokenController, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SetTokenControllerInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from owner account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "owner", err)
	}
	indices = append(indices, index)
	// Decode from tokenMessenger account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenMessenger", err)
	}
	indices = append(indices, index)
	// Decode from tokenMinter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenMinter", err)
	}
	indices = append(indices, index)
	// Decode from eventAuthority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventAuthority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SetTokenControllerInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 5 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 5, len(indices))
	}
	indexOffset := 0
	// Set owner account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "owner", len(accountKeys)-1)
	}
	obj.Owner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenMessenger account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenMessenger", len(accountKeys)-1)
	}
	obj.TokenMessenger = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenMinter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenMinter", len(accountKeys)-1)
	}
	obj.TokenMinter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set eventAuthority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventAuthority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SetTokenControllerInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Owner)
	keys = append(keys, obj.TokenMessenger)
	keys = append(keys, obj.TokenMinter)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

// Unmarshal unmarshals the SetTokenControllerInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *SetTokenControllerInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SetTokenControllerInstruction: %w", err)
	}
	return nil
}

// UnmarshalSetTokenControllerInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalSetTokenControllerInstruction(buf []byte) (*SetTokenControllerInstruction, error) {
	obj := new(SetTokenControllerInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type PauseInstruction struct {
	Params PauseParams `json:"params"`

	// Accounts:
	Pauser              solanago.PublicKey `json:"pauser"`
	PauserSigner        bool               `json:"pauser_signer"`
	TokenMinter         solanago.PublicKey `json:"tokenMinter"`
	TokenMinterWritable bool               `json:"tokenMinter_writable"`
	EventAuthority      solanago.PublicKey `json:"eventAuthority"`
	Program             solanago.PublicKey `json:"program"`
}

func (obj *PauseInstruction) GetDiscriminator() []byte {
	return Instruction_Pause[:]
}

// UnmarshalWithDecoder unmarshals the PauseInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *PauseInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "PauseInstruction", err)
	}
	if discriminator != Instruction_Pause {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "PauseInstruction", Instruction_Pause, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *PauseInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from pauser account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "pauser", err)
	}
	indices = append(indices, index)
	// Decode from tokenMinter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenMinter", err)
	}
	indices = append(indices, index)
	// Decode from eventAuthority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventAuthority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *PauseInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set pauser account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "pauser", len(accountKeys)-1)
	}
	obj.Pauser = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenMinter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenMinter", len(accountKeys)-1)
	}
	obj.TokenMinter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set eventAuthority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventAuthority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *PauseInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Pauser)
	keys = append(keys, obj.TokenMinter)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

// Unmarshal unmarshals the PauseInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *PauseInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling PauseInstruction: %w", err)
	}
	return nil
}

// UnmarshalPauseInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalPauseInstruction(buf []byte) (*PauseInstruction, error) {
	obj := new(PauseInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UnpauseInstruction struct {
	Params UnpauseParams `json:"params"`

	// Accounts:
	Pauser              solanago.PublicKey `json:"pauser"`
	PauserSigner        bool               `json:"pauser_signer"`
	TokenMinter         solanago.PublicKey `json:"tokenMinter"`
	TokenMinterWritable bool               `json:"tokenMinter_writable"`
	EventAuthority      solanago.PublicKey `json:"eventAuthority"`
	Program             solanago.PublicKey `json:"program"`
}

func (obj *UnpauseInstruction) GetDiscriminator() []byte {
	return Instruction_Unpause[:]
}

// UnmarshalWithDecoder unmarshals the UnpauseInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *UnpauseInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "UnpauseInstruction", err)
	}
	if discriminator != Instruction_Unpause {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "UnpauseInstruction", Instruction_Unpause, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UnpauseInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from pauser account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "pauser", err)
	}
	indices = append(indices, index)
	// Decode from tokenMinter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenMinter", err)
	}
	indices = append(indices, index)
	// Decode from eventAuthority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventAuthority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *UnpauseInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set pauser account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "pauser", len(accountKeys)-1)
	}
	obj.Pauser = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenMinter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenMinter", len(accountKeys)-1)
	}
	obj.TokenMinter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set eventAuthority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventAuthority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *UnpauseInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Pauser)
	keys = append(keys, obj.TokenMinter)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

// Unmarshal unmarshals the UnpauseInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *UnpauseInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UnpauseInstruction: %w", err)
	}
	return nil
}

// UnmarshalUnpauseInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalUnpauseInstruction(buf []byte) (*UnpauseInstruction, error) {
	obj := new(UnpauseInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UpdatePauserInstruction struct {
	Params UpdatePauserParams `json:"params"`

	// Accounts:
	Owner               solanago.PublicKey `json:"owner"`
	OwnerSigner         bool               `json:"owner_signer"`
	TokenMessenger      solanago.PublicKey `json:"tokenMessenger"`
	TokenMinter         solanago.PublicKey `json:"tokenMinter"`
	TokenMinterWritable bool               `json:"tokenMinter_writable"`
	EventAuthority      solanago.PublicKey `json:"eventAuthority"`
	Program             solanago.PublicKey `json:"program"`
}

func (obj *UpdatePauserInstruction) GetDiscriminator() []byte {
	return Instruction_UpdatePauser[:]
}

// UnmarshalWithDecoder unmarshals the UpdatePauserInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *UpdatePauserInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "UpdatePauserInstruction", err)
	}
	if discriminator != Instruction_UpdatePauser {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "UpdatePauserInstruction", Instruction_UpdatePauser, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UpdatePauserInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from owner account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "owner", err)
	}
	indices = append(indices, index)
	// Decode from tokenMessenger account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenMessenger", err)
	}
	indices = append(indices, index)
	// Decode from tokenMinter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenMinter", err)
	}
	indices = append(indices, index)
	// Decode from eventAuthority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventAuthority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *UpdatePauserInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 5 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 5, len(indices))
	}
	indexOffset := 0
	// Set owner account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "owner", len(accountKeys)-1)
	}
	obj.Owner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenMessenger account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenMessenger", len(accountKeys)-1)
	}
	obj.TokenMessenger = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenMinter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenMinter", len(accountKeys)-1)
	}
	obj.TokenMinter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set eventAuthority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventAuthority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *UpdatePauserInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Owner)
	keys = append(keys, obj.TokenMessenger)
	keys = append(keys, obj.TokenMinter)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

// Unmarshal unmarshals the UpdatePauserInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *UpdatePauserInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdatePauserInstruction: %w", err)
	}
	return nil
}

// UnmarshalUpdatePauserInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalUpdatePauserInstruction(buf []byte) (*UpdatePauserInstruction, error) {
	obj := new(UpdatePauserInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SetMaxBurnAmountPerMessageInstruction struct {
	Params SetMaxBurnAmountPerMessageParams `json:"params"`

	// Accounts:
	TokenController       solanago.PublicKey `json:"tokenController"`
	TokenControllerSigner bool               `json:"tokenController_signer"`
	TokenMinter           solanago.PublicKey `json:"tokenMinter"`
	LocalToken            solanago.PublicKey `json:"localToken"`
	LocalTokenWritable    bool               `json:"localToken_writable"`
	EventAuthority        solanago.PublicKey `json:"eventAuthority"`
	Program               solanago.PublicKey `json:"program"`
}

func (obj *SetMaxBurnAmountPerMessageInstruction) GetDiscriminator() []byte {
	return Instruction_SetMaxBurnAmountPerMessage[:]
}

// UnmarshalWithDecoder unmarshals the SetMaxBurnAmountPerMessageInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *SetMaxBurnAmountPerMessageInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "SetMaxBurnAmountPerMessageInstruction", err)
	}
	if discriminator != Instruction_SetMaxBurnAmountPerMessage {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "SetMaxBurnAmountPerMessageInstruction", Instruction_SetMaxBurnAmountPerMessage, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SetMaxBurnAmountPerMessageInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from tokenController account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenController", err)
	}
	indices = append(indices, index)
	// Decode from tokenMinter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenMinter", err)
	}
	indices = append(indices, index)
	// Decode from localToken account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "localToken", err)
	}
	indices = append(indices, index)
	// Decode from eventAuthority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventAuthority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SetMaxBurnAmountPerMessageInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 5 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 5, len(indices))
	}
	indexOffset := 0
	// Set tokenController account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenController", len(accountKeys)-1)
	}
	obj.TokenController = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenMinter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenMinter", len(accountKeys)-1)
	}
	obj.TokenMinter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set localToken account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "localToken", len(accountKeys)-1)
	}
	obj.LocalToken = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set eventAuthority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventAuthority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SetMaxBurnAmountPerMessageInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.TokenController)
	keys = append(keys, obj.TokenMinter)
	keys = append(keys, obj.LocalToken)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

// Unmarshal unmarshals the SetMaxBurnAmountPerMessageInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *SetMaxBurnAmountPerMessageInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SetMaxBurnAmountPerMessageInstruction: %w", err)
	}
	return nil
}

// UnmarshalSetMaxBurnAmountPerMessageInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalSetMaxBurnAmountPerMessageInstruction(buf []byte) (*SetMaxBurnAmountPerMessageInstruction, error) {
	obj := new(SetMaxBurnAmountPerMessageInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type AddLocalTokenInstruction struct {
	Params AddLocalTokenParams `json:"params"`

	// Accounts:
	Payer                       solanago.PublicKey `json:"payer"`
	PayerWritable               bool               `json:"payer_writable"`
	PayerSigner                 bool               `json:"payer_signer"`
	TokenController             solanago.PublicKey `json:"tokenController"`
	TokenControllerSigner       bool               `json:"tokenController_signer"`
	TokenMinter                 solanago.PublicKey `json:"tokenMinter"`
	LocalToken                  solanago.PublicKey `json:"localToken"`
	LocalTokenWritable          bool               `json:"localToken_writable"`
	CustodyTokenAccount         solanago.PublicKey `json:"custodyTokenAccount"`
	CustodyTokenAccountWritable bool               `json:"custodyTokenAccount_writable"`
	LocalTokenMint              solanago.PublicKey `json:"localTokenMint"`
	TokenProgram                solanago.PublicKey `json:"tokenProgram"`
	SystemProgram               solanago.PublicKey `json:"systemProgram"`
	EventAuthority              solanago.PublicKey `json:"eventAuthority"`
	Program                     solanago.PublicKey `json:"program"`
}

func (obj *AddLocalTokenInstruction) GetDiscriminator() []byte {
	return Instruction_AddLocalToken[:]
}

// UnmarshalWithDecoder unmarshals the AddLocalTokenInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *AddLocalTokenInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "AddLocalTokenInstruction", err)
	}
	if discriminator != Instruction_AddLocalToken {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "AddLocalTokenInstruction", Instruction_AddLocalToken, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AddLocalTokenInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from payer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "payer", err)
	}
	indices = append(indices, index)
	// Decode from tokenController account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenController", err)
	}
	indices = append(indices, index)
	// Decode from tokenMinter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenMinter", err)
	}
	indices = append(indices, index)
	// Decode from localToken account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "localToken", err)
	}
	indices = append(indices, index)
	// Decode from custodyTokenAccount account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "custodyTokenAccount", err)
	}
	indices = append(indices, index)
	// Decode from localTokenMint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "localTokenMint", err)
	}
	indices = append(indices, index)
	// Decode from tokenProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenProgram", err)
	}
	indices = append(indices, index)
	// Decode from systemProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "systemProgram", err)
	}
	indices = append(indices, index)
	// Decode from eventAuthority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventAuthority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AddLocalTokenInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 10 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 10, len(indices))
	}
	indexOffset := 0
	// Set payer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "payer", len(accountKeys)-1)
	}
	obj.Payer = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenController account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenController", len(accountKeys)-1)
	}
	obj.TokenController = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenMinter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenMinter", len(accountKeys)-1)
	}
	obj.TokenMinter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set localToken account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "localToken", len(accountKeys)-1)
	}
	obj.LocalToken = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set custodyTokenAccount account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "custodyTokenAccount", len(accountKeys)-1)
	}
	obj.CustodyTokenAccount = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set localTokenMint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "localTokenMint", len(accountKeys)-1)
	}
	obj.LocalTokenMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenProgram", len(accountKeys)-1)
	}
	obj.TokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set systemProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "systemProgram", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set eventAuthority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventAuthority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AddLocalTokenInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Payer)
	keys = append(keys, obj.TokenController)
	keys = append(keys, obj.TokenMinter)
	keys = append(keys, obj.LocalToken)
	keys = append(keys, obj.CustodyTokenAccount)
	keys = append(keys, obj.LocalTokenMint)
	keys = append(keys, obj.TokenProgram)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

// Unmarshal unmarshals the AddLocalTokenInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *AddLocalTokenInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AddLocalTokenInstruction: %w", err)
	}
	return nil
}

// UnmarshalAddLocalTokenInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalAddLocalTokenInstruction(buf []byte) (*AddLocalTokenInstruction, error) {
	obj := new(AddLocalTokenInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type RemoveLocalTokenInstruction struct {
	Params RemoveLocalTokenParams `json:"params"`

	// Accounts:
	Payee                       solanago.PublicKey `json:"payee"`
	PayeeWritable               bool               `json:"payee_writable"`
	PayeeSigner                 bool               `json:"payee_signer"`
	TokenController             solanago.PublicKey `json:"tokenController"`
	TokenControllerSigner       bool               `json:"tokenController_signer"`
	TokenMinter                 solanago.PublicKey `json:"tokenMinter"`
	LocalToken                  solanago.PublicKey `json:"localToken"`
	LocalTokenWritable          bool               `json:"localToken_writable"`
	CustodyTokenAccount         solanago.PublicKey `json:"custodyTokenAccount"`
	CustodyTokenAccountWritable bool               `json:"custodyTokenAccount_writable"`
	TokenProgram                solanago.PublicKey `json:"tokenProgram"`
	EventAuthority              solanago.PublicKey `json:"eventAuthority"`
	Program                     solanago.PublicKey `json:"program"`
}

func (obj *RemoveLocalTokenInstruction) GetDiscriminator() []byte {
	return Instruction_RemoveLocalToken[:]
}

// UnmarshalWithDecoder unmarshals the RemoveLocalTokenInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *RemoveLocalTokenInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "RemoveLocalTokenInstruction", err)
	}
	if discriminator != Instruction_RemoveLocalToken {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "RemoveLocalTokenInstruction", Instruction_RemoveLocalToken, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *RemoveLocalTokenInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from payee account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "payee", err)
	}
	indices = append(indices, index)
	// Decode from tokenController account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenController", err)
	}
	indices = append(indices, index)
	// Decode from tokenMinter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenMinter", err)
	}
	indices = append(indices, index)
	// Decode from localToken account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "localToken", err)
	}
	indices = append(indices, index)
	// Decode from custodyTokenAccount account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "custodyTokenAccount", err)
	}
	indices = append(indices, index)
	// Decode from tokenProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenProgram", err)
	}
	indices = append(indices, index)
	// Decode from eventAuthority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventAuthority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *RemoveLocalTokenInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 8 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 8, len(indices))
	}
	indexOffset := 0
	// Set payee account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "payee", len(accountKeys)-1)
	}
	obj.Payee = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenController account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenController", len(accountKeys)-1)
	}
	obj.TokenController = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenMinter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenMinter", len(accountKeys)-1)
	}
	obj.TokenMinter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set localToken account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "localToken", len(accountKeys)-1)
	}
	obj.LocalToken = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set custodyTokenAccount account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "custodyTokenAccount", len(accountKeys)-1)
	}
	obj.CustodyTokenAccount = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenProgram", len(accountKeys)-1)
	}
	obj.TokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set eventAuthority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventAuthority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *RemoveLocalTokenInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Payee)
	keys = append(keys, obj.TokenController)
	keys = append(keys, obj.TokenMinter)
	keys = append(keys, obj.LocalToken)
	keys = append(keys, obj.CustodyTokenAccount)
	keys = append(keys, obj.TokenProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

// Unmarshal unmarshals the RemoveLocalTokenInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *RemoveLocalTokenInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling RemoveLocalTokenInstruction: %w", err)
	}
	return nil
}

// UnmarshalRemoveLocalTokenInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalRemoveLocalTokenInstruction(buf []byte) (*RemoveLocalTokenInstruction, error) {
	obj := new(RemoveLocalTokenInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type LinkTokenPairInstruction struct {
	Params LinkTokenPairParams `json:"params"`

	// Accounts:
	Payer                 solanago.PublicKey `json:"payer"`
	PayerWritable         bool               `json:"payer_writable"`
	PayerSigner           bool               `json:"payer_signer"`
	TokenController       solanago.PublicKey `json:"tokenController"`
	TokenControllerSigner bool               `json:"tokenController_signer"`
	TokenMinter           solanago.PublicKey `json:"tokenMinter"`
	TokenPair             solanago.PublicKey `json:"tokenPair"`
	TokenPairWritable     bool               `json:"tokenPair_writable"`
	SystemProgram         solanago.PublicKey `json:"systemProgram"`
	EventAuthority        solanago.PublicKey `json:"eventAuthority"`
	Program               solanago.PublicKey `json:"program"`
}

func (obj *LinkTokenPairInstruction) GetDiscriminator() []byte {
	return Instruction_LinkTokenPair[:]
}

// UnmarshalWithDecoder unmarshals the LinkTokenPairInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *LinkTokenPairInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "LinkTokenPairInstruction", err)
	}
	if discriminator != Instruction_LinkTokenPair {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "LinkTokenPairInstruction", Instruction_LinkTokenPair, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *LinkTokenPairInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from payer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "payer", err)
	}
	indices = append(indices, index)
	// Decode from tokenController account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenController", err)
	}
	indices = append(indices, index)
	// Decode from tokenMinter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenMinter", err)
	}
	indices = append(indices, index)
	// Decode from tokenPair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenPair", err)
	}
	indices = append(indices, index)
	// Decode from systemProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "systemProgram", err)
	}
	indices = append(indices, index)
	// Decode from eventAuthority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventAuthority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *LinkTokenPairInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 7 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 7, len(indices))
	}
	indexOffset := 0
	// Set payer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "payer", len(accountKeys)-1)
	}
	obj.Payer = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenController account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenController", len(accountKeys)-1)
	}
	obj.TokenController = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenMinter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenMinter", len(accountKeys)-1)
	}
	obj.TokenMinter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenPair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenPair", len(accountKeys)-1)
	}
	obj.TokenPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set systemProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "systemProgram", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set eventAuthority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventAuthority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *LinkTokenPairInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Payer)
	keys = append(keys, obj.TokenController)
	keys = append(keys, obj.TokenMinter)
	keys = append(keys, obj.TokenPair)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

// Unmarshal unmarshals the LinkTokenPairInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *LinkTokenPairInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling LinkTokenPairInstruction: %w", err)
	}
	return nil
}

// UnmarshalLinkTokenPairInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalLinkTokenPairInstruction(buf []byte) (*LinkTokenPairInstruction, error) {
	obj := new(LinkTokenPairInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UnlinkTokenPairInstruction struct {
	Params UninkTokenPairParams `json:"params"`

	// Accounts:
	Payee                 solanago.PublicKey `json:"payee"`
	PayeeWritable         bool               `json:"payee_writable"`
	PayeeSigner           bool               `json:"payee_signer"`
	TokenController       solanago.PublicKey `json:"tokenController"`
	TokenControllerSigner bool               `json:"tokenController_signer"`
	TokenMinter           solanago.PublicKey `json:"tokenMinter"`
	TokenPair             solanago.PublicKey `json:"tokenPair"`
	TokenPairWritable     bool               `json:"tokenPair_writable"`
	EventAuthority        solanago.PublicKey `json:"eventAuthority"`
	Program               solanago.PublicKey `json:"program"`
}

func (obj *UnlinkTokenPairInstruction) GetDiscriminator() []byte {
	return Instruction_UnlinkTokenPair[:]
}

// UnmarshalWithDecoder unmarshals the UnlinkTokenPairInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *UnlinkTokenPairInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "UnlinkTokenPairInstruction", err)
	}
	if discriminator != Instruction_UnlinkTokenPair {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "UnlinkTokenPairInstruction", Instruction_UnlinkTokenPair, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UnlinkTokenPairInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from payee account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "payee", err)
	}
	indices = append(indices, index)
	// Decode from tokenController account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenController", err)
	}
	indices = append(indices, index)
	// Decode from tokenMinter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenMinter", err)
	}
	indices = append(indices, index)
	// Decode from tokenPair account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenPair", err)
	}
	indices = append(indices, index)
	// Decode from eventAuthority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventAuthority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *UnlinkTokenPairInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 6 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 6, len(indices))
	}
	indexOffset := 0
	// Set payee account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "payee", len(accountKeys)-1)
	}
	obj.Payee = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenController account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenController", len(accountKeys)-1)
	}
	obj.TokenController = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenMinter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenMinter", len(accountKeys)-1)
	}
	obj.TokenMinter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenPair account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenPair", len(accountKeys)-1)
	}
	obj.TokenPair = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set eventAuthority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventAuthority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *UnlinkTokenPairInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Payee)
	keys = append(keys, obj.TokenController)
	keys = append(keys, obj.TokenMinter)
	keys = append(keys, obj.TokenPair)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

// Unmarshal unmarshals the UnlinkTokenPairInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *UnlinkTokenPairInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UnlinkTokenPairInstruction: %w", err)
	}
	return nil
}

// UnmarshalUnlinkTokenPairInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalUnlinkTokenPairInstruction(buf []byte) (*UnlinkTokenPairInstruction, error) {
	obj := new(UnlinkTokenPairInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type BurnTokenCustodyInstruction struct {
	Params BurnTokenCustodyParams `json:"params"`

	// Accounts:
	Payee                       solanago.PublicKey `json:"payee"`
	PayeeWritable               bool               `json:"payee_writable"`
	PayeeSigner                 bool               `json:"payee_signer"`
	TokenController             solanago.PublicKey `json:"tokenController"`
	TokenControllerSigner       bool               `json:"tokenController_signer"`
	TokenMinter                 solanago.PublicKey `json:"tokenMinter"`
	LocalToken                  solanago.PublicKey `json:"localToken"`
	CustodyTokenAccount         solanago.PublicKey `json:"custodyTokenAccount"`
	CustodyTokenAccountWritable bool               `json:"custodyTokenAccount_writable"`
	CustodyTokenMint            solanago.PublicKey `json:"custodyTokenMint"`
	CustodyTokenMintWritable    bool               `json:"custodyTokenMint_writable"`
	TokenProgram                solanago.PublicKey `json:"tokenProgram"`
	EventAuthority              solanago.PublicKey `json:"eventAuthority"`
	Program                     solanago.PublicKey `json:"program"`
}

func (obj *BurnTokenCustodyInstruction) GetDiscriminator() []byte {
	return Instruction_BurnTokenCustody[:]
}

// UnmarshalWithDecoder unmarshals the BurnTokenCustodyInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *BurnTokenCustodyInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "BurnTokenCustodyInstruction", err)
	}
	if discriminator != Instruction_BurnTokenCustody {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "BurnTokenCustodyInstruction", Instruction_BurnTokenCustody, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *BurnTokenCustodyInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from payee account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "payee", err)
	}
	indices = append(indices, index)
	// Decode from tokenController account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenController", err)
	}
	indices = append(indices, index)
	// Decode from tokenMinter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenMinter", err)
	}
	indices = append(indices, index)
	// Decode from localToken account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "localToken", err)
	}
	indices = append(indices, index)
	// Decode from custodyTokenAccount account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "custodyTokenAccount", err)
	}
	indices = append(indices, index)
	// Decode from custodyTokenMint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "custodyTokenMint", err)
	}
	indices = append(indices, index)
	// Decode from tokenProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "tokenProgram", err)
	}
	indices = append(indices, index)
	// Decode from eventAuthority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventAuthority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *BurnTokenCustodyInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 9 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 9, len(indices))
	}
	indexOffset := 0
	// Set payee account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "payee", len(accountKeys)-1)
	}
	obj.Payee = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenController account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenController", len(accountKeys)-1)
	}
	obj.TokenController = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenMinter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenMinter", len(accountKeys)-1)
	}
	obj.TokenMinter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set localToken account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "localToken", len(accountKeys)-1)
	}
	obj.LocalToken = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set custodyTokenAccount account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "custodyTokenAccount", len(accountKeys)-1)
	}
	obj.CustodyTokenAccount = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set custodyTokenMint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "custodyTokenMint", len(accountKeys)-1)
	}
	obj.CustodyTokenMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set tokenProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "tokenProgram", len(accountKeys)-1)
	}
	obj.TokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set eventAuthority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventAuthority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *BurnTokenCustodyInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Payee)
	keys = append(keys, obj.TokenController)
	keys = append(keys, obj.TokenMinter)
	keys = append(keys, obj.LocalToken)
	keys = append(keys, obj.CustodyTokenAccount)
	keys = append(keys, obj.CustodyTokenMint)
	keys = append(keys, obj.TokenProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

// Unmarshal unmarshals the BurnTokenCustodyInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *BurnTokenCustodyInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling BurnTokenCustodyInstruction: %w", err)
	}
	return nil
}

// UnmarshalBurnTokenCustodyInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalBurnTokenCustodyInstruction(buf []byte) (*BurnTokenCustodyInstruction, error) {
	obj := new(BurnTokenCustodyInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Instruction interface defines common methods for all instruction types
type Instruction interface {
	GetDiscriminator() []byte

	UnmarshalWithDecoder(decoder *binary.Decoder) error

	UnmarshalAccountIndices(buf []byte) ([]uint8, error)

	PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error

	GetAccountKeys() []solanago.PublicKey
}

// ParseInstruction parses instruction data and optionally populates accounts
// If accountIndicesData is nil or empty, accounts will not be populated
func ParseInstruction(instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (Instruction, error) {
	// Validate inputs
	if len(instructionData) < 8 {
		return nil, fmt.Errorf("instruction data too short: expected at least 8 bytes, got %d", len(instructionData))
	}
	// Extract discriminator
	discriminator := [8]byte{}
	copy(discriminator[:], instructionData[0:8])
	// Parse based on discriminator
	switch discriminator {
	case Instruction_Initialize:
		instruction := new(InitializeInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitializeInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_TransferOwnership:
		instruction := new(TransferOwnershipInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as TransferOwnershipInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_AcceptOwnership:
		instruction := new(AcceptOwnershipInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AcceptOwnershipInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_AddRemoteTokenMessenger:
		instruction := new(AddRemoteTokenMessengerInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AddRemoteTokenMessengerInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_RemoveRemoteTokenMessenger:
		instruction := new(RemoveRemoteTokenMessengerInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as RemoveRemoteTokenMessengerInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_DepositForBurn:
		instruction := new(DepositForBurnInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as DepositForBurnInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_DepositForBurnWithCaller:
		instruction := new(DepositForBurnWithCallerInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as DepositForBurnWithCallerInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_ReplaceDepositForBurn:
		instruction := new(ReplaceDepositForBurnInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as ReplaceDepositForBurnInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_HandleReceiveMessage:
		instruction := new(HandleReceiveMessageInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as HandleReceiveMessageInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SetTokenController:
		instruction := new(SetTokenControllerInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SetTokenControllerInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_Pause:
		instruction := new(PauseInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as PauseInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_Unpause:
		instruction := new(UnpauseInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as UnpauseInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_UpdatePauser:
		instruction := new(UpdatePauserInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as UpdatePauserInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SetMaxBurnAmountPerMessage:
		instruction := new(SetMaxBurnAmountPerMessageInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SetMaxBurnAmountPerMessageInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_AddLocalToken:
		instruction := new(AddLocalTokenInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AddLocalTokenInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_RemoveLocalToken:
		instruction := new(RemoveLocalTokenInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as RemoveLocalTokenInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_LinkTokenPair:
		instruction := new(LinkTokenPairInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as LinkTokenPairInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_UnlinkTokenPair:
		instruction := new(UnlinkTokenPairInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as UnlinkTokenPairInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_BurnTokenCustody:
		instruction := new(BurnTokenCustodyInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as BurnTokenCustodyInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	default:
		return nil, fmt.Errorf("unknown instruction discriminator: %s", binary.FormatDiscriminator(discriminator))
	}
}

// ParseInstructionTyped parses instruction data and returns a specific instruction type // T must implement the Instruction interface
func ParseInstructionTyped[T Instruction](instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (T, error) {
	instruction, err := ParseInstruction(instructionData, accountIndicesData, accountKeys)
	if err != nil {
		return *new(T), err
	}
	typed, ok := instruction.(T)
	if !ok {
		return *new(T), fmt.Errorf("instruction is not of expected type")
	}
	return typed, nil
}

// ParseInstructionWithoutAccounts parses instruction data without account information
func ParseInstructionWithoutAccounts(instructionData []byte) (Instruction, error) {
	return ParseInstruction(instructionData, nil, []solanago.PublicKey{})
}

// ParseInstructionWithAccounts parses instruction data with account information
func ParseInstructionWithAccounts(instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (Instruction, error) {
	return ParseInstruction(instructionData, accountIndicesData, accountKeys)
}
