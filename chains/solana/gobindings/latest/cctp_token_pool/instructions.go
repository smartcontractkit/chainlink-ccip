// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains instructions.

package cctp_token_pool

import (
	"bytes"
	"fmt"
	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "accept_ownership" instruction.
func NewAcceptOwnershipInstruction(
	stateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "append_remote_pool_addresses" instruction.
func NewAppendRemotePoolAddressesInstruction(
	// Params:
	remoteChainSelectorParam uint64,
	mintParam solanago.PublicKey,
	addressesParam []RemoteAddress,

	// Accounts:
	stateAccount solanago.PublicKey,
	chainConfigAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AppendRemotePoolAddresses[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `remoteChainSelectorParam`:
		err = enc__.Encode(remoteChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("remoteChainSelectorParam", err)
		}
		// Serialize `mintParam`:
		err = enc__.Encode(mintParam)
		if err != nil {
			return nil, errors.NewField("mintParam", err)
		}
		// Serialize `addressesParam`:
		err = enc__.Encode(addressesParam)
		if err != nil {
			return nil, errors.NewField("addressesParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "chain_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(chainConfigAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "configure_allow_list" instruction.
func NewConfigureAllowListInstruction(
	// Params:
	addParam []solanago.PublicKey,
	enabledParam bool,

	// Accounts:
	stateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ConfigureAllowList[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `addParam`:
		err = enc__.Encode(addParam)
		if err != nil {
			return nil, errors.NewField("addParam", err)
		}
		// Serialize `enabledParam`:
		err = enc__.Encode(enabledParam)
		if err != nil {
			return nil, errors.NewField("enabledParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "delete_chain_config" instruction.
func NewDeleteChainConfigInstruction(
	// Params:
	remoteChainSelectorParam uint64,
	mintParam solanago.PublicKey,

	// Accounts:
	stateAccount solanago.PublicKey,
	chainConfigAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_DeleteChainConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `remoteChainSelectorParam`:
		err = enc__.Encode(remoteChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("remoteChainSelectorParam", err)
		}
		// Serialize `mintParam`:
		err = enc__.Encode(mintParam)
		if err != nil {
			return nil, errors.NewField("mintParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "chain_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(chainConfigAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "derive_accounts_lock_or_burn_tokens" instruction.
func NewDeriveAccountsLockOrBurnTokensInstruction(
	stageParam string,
	lockOrBurnParam LockOrBurnInV1,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_DeriveAccountsLockOrBurnTokens[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `stageParam`:
		err = enc__.Encode(stageParam)
		if err != nil {
			return nil, errors.NewField("stageParam", err)
		}
		// Serialize `lockOrBurnParam`:
		err = enc__.Encode(lockOrBurnParam)
		if err != nil {
			return nil, errors.NewField("lockOrBurnParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "derive_accounts_release_or_mint_tokens" instruction.
func NewDeriveAccountsReleaseOrMintTokensInstruction(
	stageParam string,
	releaseOrMintParam ReleaseOrMintInV1,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_DeriveAccountsReleaseOrMintTokens[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `stageParam`:
		err = enc__.Encode(stageParam)
		if err != nil {
			return nil, errors.NewField("stageParam", err)
		}
		// Serialize `releaseOrMintParam`:
		err = enc__.Encode(releaseOrMintParam)
		if err != nil {
			return nil, errors.NewField("releaseOrMintParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "edit_chain_remote_config" instruction.
func NewEditChainRemoteConfigInstruction(
	// Params:
	remoteChainSelectorParam uint64,
	mintParam solanago.PublicKey,
	cfgParam RemoteConfig,

	// Accounts:
	stateAccount solanago.PublicKey,
	chainConfigAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_EditChainRemoteConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `remoteChainSelectorParam`:
		err = enc__.Encode(remoteChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("remoteChainSelectorParam", err)
		}
		// Serialize `mintParam`:
		err = enc__.Encode(mintParam)
		if err != nil {
			return nil, errors.NewField("mintParam", err)
		}
		// Serialize `cfgParam`:
		err = enc__.Encode(cfgParam)
		if err != nil {
			return nil, errors.NewField("cfgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "chain_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(chainConfigAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "edit_chain_remote_config_cctp" instruction.
func NewEditChainRemoteConfigCctpInstruction(
	// Params:
	remoteChainSelectorParam uint64,
	mintParam solanago.PublicKey,
	cfgParam CctpChain,

	// Accounts:
	stateAccount solanago.PublicKey,
	chainConfigAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_EditChainRemoteConfigCctp[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `remoteChainSelectorParam`:
		err = enc__.Encode(remoteChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("remoteChainSelectorParam", err)
		}
		// Serialize `mintParam`:
		err = enc__.Encode(mintParam)
		if err != nil {
			return nil, errors.NewField("mintParam", err)
		}
		// Serialize `cfgParam`:
		err = enc__.Encode(cfgParam)
		if err != nil {
			return nil, errors.NewField("cfgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "chain_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(chainConfigAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "init_chain_remote_config" instruction.
func NewInitChainRemoteConfigInstruction(
	// Params:
	remoteChainSelectorParam uint64,
	mintParam solanago.PublicKey,
	cfgParam RemoteConfig,

	// Accounts:
	stateAccount solanago.PublicKey,
	chainConfigAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitChainRemoteConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `remoteChainSelectorParam`:
		err = enc__.Encode(remoteChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("remoteChainSelectorParam", err)
		}
		// Serialize `mintParam`:
		err = enc__.Encode(mintParam)
		if err != nil {
			return nil, errors.NewField("mintParam", err)
		}
		// Serialize `cfgParam`:
		err = enc__.Encode(cfgParam)
		if err != nil {
			return nil, errors.NewField("cfgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "chain_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(chainConfigAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "init_global_config" instruction.
func NewInitGlobalConfigInstruction(
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
	programDataAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 3 "program": Read-only, Non-signer, Required, Address: CCiTPESGEevd7TBU8EGBKrcxuRq7jx3YtW6tPidnscaZ
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
		// Account 4 "program_data": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programDataAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "initialize" instruction.
func NewInitializeInstruction(
	// Params:
	routerParam solanago.PublicKey,
	rmnRemoteParam solanago.PublicKey,

	// Accounts:
	stateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
	programDataAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Initialize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `routerParam`:
		err = enc__.Encode(routerParam)
		if err != nil {
			return nil, errors.NewField("routerParam", err)
		}
		// Serialize `rmnRemoteParam`:
		err = enc__.Encode(rmnRemoteParam)
		if err != nil {
			return nil, errors.NewField("rmnRemoteParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 4 "program": Read-only, Non-signer, Required, Address: CCiTPESGEevd7TBU8EGBKrcxuRq7jx3YtW6tPidnscaZ
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
		// Account 5 "program_data": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programDataAccount, false, false))
		// Account 6 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "lock_or_burn_tokens" instruction.
func NewLockOrBurnTokensInstruction(
	// Params:
	lockOrBurnParam LockOrBurnInV1,

	// Accounts:
	authorityAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	poolSignerAccount solanago.PublicKey,
	poolTokenAccountAccount solanago.PublicKey,
	rmnRemoteAccount solanago.PublicKey,
	rmnRemoteCursesAccount solanago.PublicKey,
	rmnRemoteConfigAccount solanago.PublicKey,
	chainConfigAccount solanago.PublicKey,
	cctpMessageTransmitterAccountAccount solanago.PublicKey,
	cctpTokenMessengerMinterAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	cctpMessageTransmitterAccount solanago.PublicKey,
	cctpTokenMessengerAccountAccount solanago.PublicKey,
	cctpTokenMinterAccountAccount solanago.PublicKey,
	cctpLocalTokenAccount solanago.PublicKey,
	cctpEventAuthorityAccount solanago.PublicKey,
	cctpAuthorityPdaAccount solanago.PublicKey,
	cctpRemoteTokenMessengerKeyAccount solanago.PublicKey,
	cctpMessageSentEventAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_LockOrBurnTokens[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `lockOrBurnParam`:
		err = enc__.Encode(lockOrBurnParam)
		if err != nil {
			return nil, errors.NewField("lockOrBurnParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 3 "mint": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, false))
		// Account 4 "pool_signer": Writable, Non-signer, Required
		// hold a balance to pay for the rent of initializing the CCTP MessageSentEvent account
		accounts__.Append(solanago.NewAccountMeta(poolSignerAccount, true, false))
		// Account 5 "pool_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolTokenAccountAccount, true, false))
		// Account 6 "rmn_remote": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteAccount, false, false))
		// Account 7 "rmn_remote_curses": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteCursesAccount, false, false))
		// Account 8 "rmn_remote_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteConfigAccount, false, false))
		// Account 9 "chain_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(chainConfigAccount, false, false))
		// Account 10 "cctp_message_transmitter_account": Writable, Non-signer, Required
		// CHECK this is not read by the pool, just forwarded to CCTP
		accounts__.Append(solanago.NewAccountMeta(cctpMessageTransmitterAccountAccount, true, false))
		// Account 11 "cctp_token_messenger_minter": Read-only, Non-signer, Required, Address: CCTPiPYPc6AsJuwueEnWgSgucamXDZwBd53dQ11YiKX3
		// CHECK this is CCTP's TokenMessengerMinter program, which
		// is invoked by this program.
		accounts__.Append(solanago.NewAccountMeta(cctpTokenMessengerMinterAccount, false, false))
		// Account 12 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 13 "cctp_message_transmitter": Read-only, Non-signer, Required, Address: CCTPmbSD7gX1bxKPAmg77w8oFzNFpaQiQUWD43TKaecd
		// CHECK this is CCTP's MessageTransmitter program, which
		// is invoked transitively by CCTP's TokenMessengerMinter,
		// which in turn is invoked explicitly by this program.
		accounts__.Append(solanago.NewAccountMeta(cctpMessageTransmitterAccount, false, false))
		// Account 14 "cctp_token_messenger_account": Read-only, Non-signer, Required
		// CHECK this is not read by the pool, just forwarded to CCTP
		accounts__.Append(solanago.NewAccountMeta(cctpTokenMessengerAccountAccount, false, false))
		// Account 15 "cctp_token_minter_account": Read-only, Non-signer, Required
		// CHECK this is not read by the pool, just forwarded to CCTP
		accounts__.Append(solanago.NewAccountMeta(cctpTokenMinterAccountAccount, false, false))
		// Account 16 "cctp_local_token": Writable, Non-signer, Required
		// CHECK this is not read by the pool, just forwarded to CCTP
		accounts__.Append(solanago.NewAccountMeta(cctpLocalTokenAccount, true, false))
		// Account 17 "cctp_event_authority": Read-only, Non-signer, Required
		// CHECK this is not read by the pool, just forwarded to CCTP
		accounts__.Append(solanago.NewAccountMeta(cctpEventAuthorityAccount, false, false))
		// Account 18 "cctp_authority_pda": Read-only, Non-signer, Required
		// CHECK this is not read by the pool, just forwarded to CCTP
		accounts__.Append(solanago.NewAccountMeta(cctpAuthorityPdaAccount, false, false))
		// Account 19 "cctp_remote_token_messenger_key": Read-only, Non-signer, Required
		// CHECK this is not read by the pool, just forwarded to CCTP
		accounts__.Append(solanago.NewAccountMeta(cctpRemoteTokenMessengerKeyAccount, false, false))
		// Account 20 "cctp_message_sent_event": Writable, Non-signer, Required
		// CHECK this is the account in which CCTP will store the event. It is not a PDA of CCTP,
		// but CCTP will initialize it and become the owner for it.
		accounts__.Append(solanago.NewAccountMeta(cctpMessageSentEventAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "reclaim_event_account" instruction.
func NewReclaimEventAccountInstruction(
	// Params:
	mintParam solanago.PublicKey,
	originalSenderParam solanago.PublicKey,
	remoteChainSelectorParam uint64,
	msgNonceParam uint64,
	attestationParam []byte,

	// Accounts:
	stateAccount solanago.PublicKey,
	poolSignerAccount solanago.PublicKey,
	messageSentEventAccountAccount solanago.PublicKey,
	messageTransmitterAccount solanago.PublicKey,
	cctpMessageTransmitterAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ReclaimEventAccount[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `mintParam`:
		err = enc__.Encode(mintParam)
		if err != nil {
			return nil, errors.NewField("mintParam", err)
		}
		// Serialize `originalSenderParam`:
		err = enc__.Encode(originalSenderParam)
		if err != nil {
			return nil, errors.NewField("originalSenderParam", err)
		}
		// Serialize `remoteChainSelectorParam`:
		err = enc__.Encode(remoteChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("remoteChainSelectorParam", err)
		}
		// Serialize `msgNonceParam`:
		err = enc__.Encode(msgNonceParam)
		if err != nil {
			return nil, errors.NewField("msgNonceParam", err)
		}
		// Serialize `attestationParam`:
		err = enc__.Encode(attestationParam)
		if err != nil {
			return nil, errors.NewField("attestationParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "pool_signer": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolSignerAccount, true, false))
		// Account 2 "message_sent_event_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(messageSentEventAccountAccount, true, false))
		// Account 3 "message_transmitter": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(messageTransmitterAccount, true, false))
		// Account 4 "cctp_message_transmitter": Read-only, Non-signer, Required, Address: CCTPmbSD7gX1bxKPAmg77w8oFzNFpaQiQUWD43TKaecd
		accounts__.Append(solanago.NewAccountMeta(cctpMessageTransmitterAccount, false, false))
		// Account 5 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 6 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "reclaim_funds" instruction.
// Returns an amount of SOL from the pool signer account to the designated // fund reclaimer. There are three entities involved: //  // * `owner`: can configure the reclaimer and fund manager. // * `fund_manager`: can execute this instruction. // * `fund_reclaim_destination`: receives the funds. //  // The resulting funds on the PDA cannot drop below `minimum_signer_funds`.
func NewReclaimFundsInstruction(
	// Params:
	amountParam uint64,

	// Accounts:
	stateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	poolSignerAccount solanago.PublicKey,
	fundReclaimDestinationAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ReclaimFunds[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `amountParam`:
		err = enc__.Encode(amountParam)
		if err != nil {
			return nil, errors.NewField("amountParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 2 "pool_signer": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolSignerAccount, true, false))
		// Account 3 "fund_reclaim_destination": Writable, Non-signer, Required
		// to be a particular fund reclaimer
		accounts__.Append(solanago.NewAccountMeta(fundReclaimDestinationAccount, true, false))
		// Account 4 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 5 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "release_or_mint_tokens" instruction.
func NewReleaseOrMintTokensInstruction(
	// Params:
	releaseOrMintParam ReleaseOrMintInV1,

	// Accounts:
	authorityAccount solanago.PublicKey,
	offrampProgramAccount solanago.PublicKey,
	allowedOfframpAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	poolSignerAccount solanago.PublicKey,
	poolTokenAccountAccount solanago.PublicKey,
	chainConfigAccount solanago.PublicKey,
	rmnRemoteAccount solanago.PublicKey,
	rmnRemoteCursesAccount solanago.PublicKey,
	rmnRemoteConfigAccount solanago.PublicKey,
	receiverTokenAccountAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ReleaseOrMintTokens[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `releaseOrMintParam`:
		err = enc__.Encode(releaseOrMintParam)
		if err != nil {
			return nil, errors.NewField("releaseOrMintParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 1 "offramp_program": Read-only, Non-signer, Required
		// CHECK offramp program: exists only to derive the allowed offramp PDA
		// and the authority PDA.
		accounts__.Append(solanago.NewAccountMeta(offrampProgramAccount, false, false))
		// Account 2 "allowed_offramp": Read-only, Non-signer, Required
		// CHECK PDA of the router program verifying the signer is an allowed offramp.
		// If PDA does not exist, the router doesn't allow this offramp
		accounts__.Append(solanago.NewAccountMeta(allowedOfframpAccount, false, false))
		// Account 3 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 4 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 5 "mint": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, false))
		// Account 6 "pool_signer": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolSignerAccount, true, false))
		// Account 7 "pool_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolTokenAccountAccount, true, false))
		// Account 8 "chain_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(chainConfigAccount, false, false))
		// Account 9 "rmn_remote": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteAccount, false, false))
		// Account 10 "rmn_remote_curses": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteCursesAccount, false, false))
		// Account 11 "rmn_remote_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteConfigAccount, false, false))
		// Account 12 "receiver_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(receiverTokenAccountAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "remove_from_allow_list" instruction.
func NewRemoveFromAllowListInstruction(
	// Params:
	removeParam []solanago.PublicKey,

	// Accounts:
	stateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RemoveFromAllowList[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `removeParam`:
		err = enc__.Encode(removeParam)
		if err != nil {
			return nil, errors.NewField("removeParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_chain_rate_limit" instruction.
func NewSetChainRateLimitInstruction(
	// Params:
	remoteChainSelectorParam uint64,
	mintParam solanago.PublicKey,
	inboundParam RateLimitConfig,
	outboundParam RateLimitConfig,

	// Accounts:
	stateAccount solanago.PublicKey,
	chainConfigAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetChainRateLimit[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `remoteChainSelectorParam`:
		err = enc__.Encode(remoteChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("remoteChainSelectorParam", err)
		}
		// Serialize `mintParam`:
		err = enc__.Encode(mintParam)
		if err != nil {
			return nil, errors.NewField("mintParam", err)
		}
		// Serialize `inboundParam`:
		err = enc__.Encode(inboundParam)
		if err != nil {
			return nil, errors.NewField("inboundParam", err)
		}
		// Serialize `outboundParam`:
		err = enc__.Encode(outboundParam)
		if err != nil {
			return nil, errors.NewField("outboundParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "chain_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(chainConfigAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_fund_manager" instruction.
func NewSetFundManagerInstruction(
	// Params:
	fundManagerParam solanago.PublicKey,

	// Accounts:
	stateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetFundManager[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `fundManagerParam`:
		err = enc__.Encode(fundManagerParam)
		if err != nil {
			return nil, errors.NewField("fundManagerParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_fund_reclaim_destination" instruction.
func NewSetFundReclaimDestinationInstruction(
	// Params:
	fundReclaimDestinationParam solanago.PublicKey,

	// Accounts:
	stateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetFundReclaimDestination[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `fundReclaimDestinationParam`:
		err = enc__.Encode(fundReclaimDestinationParam)
		if err != nil {
			return nil, errors.NewField("fundReclaimDestinationParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_minimum_signer_funds" instruction.
func NewSetMinimumSignerFundsInstruction(
	// Params:
	amountParam uint64,

	// Accounts:
	stateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetMinimumSignerFunds[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `amountParam`:
		err = enc__.Encode(amountParam)
		if err != nil {
			return nil, errors.NewField("amountParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_rate_limit_admin" instruction.
func NewSetRateLimitAdminInstruction(
	// Params:
	mintParam solanago.PublicKey,
	newRateLimitAdminParam solanago.PublicKey,

	// Accounts:
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetRateLimitAdmin[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `mintParam`:
		err = enc__.Encode(mintParam)
		if err != nil {
			return nil, errors.NewField("mintParam", err)
		}
		// Serialize `newRateLimitAdminParam`:
		err = enc__.Encode(newRateLimitAdminParam)
		if err != nil {
			return nil, errors.NewField("newRateLimitAdminParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_rmn" instruction.
func NewSetRmnInstruction(
	// Params:
	rmnAddressParam solanago.PublicKey,

	// Accounts:
	stateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
	programDataAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetRmn[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `rmnAddressParam`:
		err = enc__.Encode(rmnAddressParam)
		if err != nil {
			return nil, errors.NewField("rmnAddressParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "program": Read-only, Non-signer, Required, Address: CCiTPESGEevd7TBU8EGBKrcxuRq7jx3YtW6tPidnscaZ
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
		// Account 4 "program_data": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programDataAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_router" instruction.
func NewSetRouterInstruction(
	// Params:
	newRouterParam solanago.PublicKey,

	// Accounts:
	stateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
	programDataAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetRouter[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newRouterParam`:
		err = enc__.Encode(newRouterParam)
		if err != nil {
			return nil, errors.NewField("newRouterParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "program": Read-only, Non-signer, Required, Address: CCiTPESGEevd7TBU8EGBKrcxuRq7jx3YtW6tPidnscaZ
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
		// Account 4 "program_data": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programDataAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "transfer_ownership" instruction.
func NewTransferOwnershipInstruction(
	// Params:
	proposedOwnerParam solanago.PublicKey,

	// Accounts:
	stateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_TransferOwnership[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `proposedOwnerParam`:
		err = enc__.Encode(proposedOwnerParam)
		if err != nil {
			return nil, errors.NewField("proposedOwnerParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "type_version" instruction.
// Returns the program type (name) and version. // Used by offchain code to easily determine which program & version is being interacted with. //  // # Arguments // * `ctx` - The context
func NewTypeVersionInstruction() (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}
