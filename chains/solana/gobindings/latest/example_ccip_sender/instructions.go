// Code generated by https://github.com/Unheilbar/anchor-go. DO NOT EDIT.
// This file contains instructions and instruction parsers.

package example_ccip_sender

import (
	"bytes"
	"fmt"
	errors "github.com/Unheilbar/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "accept_ownership" instruction.
func NewAcceptOwnershipInstruction(
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AcceptOwnership[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "ccip_send" instruction.
func NewCcipSendInstruction(
	// Params:
	destChainSelectorParam uint64,
	tokenAmountsParam []SvmTokenAmount,
	dataParam []byte,
	feeTokenParam solanago.PublicKey,
	tokenIndexesParam []byte,

	// Accounts:
	stateAccount solanago.PublicKey,
	chainConfigAccount solanago.PublicKey,
	ccipSenderAccount solanago.PublicKey,
	authorityFeeTokenAtaAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	ccipRouterAccount solanago.PublicKey,
	ccipConfigAccount solanago.PublicKey,
	ccipDestChainStateAccount solanago.PublicKey,
	ccipSenderNonceAccount solanago.PublicKey,
	ccipFeeTokenProgramAccount solanago.PublicKey,
	ccipFeeTokenMintAccount solanago.PublicKey,
	ccipFeeTokenUserAtaAccount solanago.PublicKey,
	ccipFeeTokenReceiverAccount solanago.PublicKey,
	ccipFeeBillingSignerAccount solanago.PublicKey,
	ccipFeeQuoterAccount solanago.PublicKey,
	ccipFeeQuoterConfigAccount solanago.PublicKey,
	ccipFeeQuoterDestChainAccount solanago.PublicKey,
	ccipFeeQuoterBillingTokenConfigAccount solanago.PublicKey,
	ccipFeeQuoterLinkTokenConfigAccount solanago.PublicKey,
	ccipRmnRemoteAccount solanago.PublicKey,
	ccipRmnRemoteCursesAccount solanago.PublicKey,
	ccipRmnRemoteConfigAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CcipSend[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `destChainSelectorParam`:
		err = enc__.Encode(destChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("destChainSelectorParam", err)
		}
		// Serialize `tokenAmountsParam`:
		err = enc__.Encode(tokenAmountsParam)
		if err != nil {
			return nil, errors.NewField("tokenAmountsParam", err)
		}
		// Serialize `dataParam`:
		err = enc__.Encode(dataParam)
		if err != nil {
			return nil, errors.NewField("dataParam", err)
		}
		// Serialize `feeTokenParam`:
		err = enc__.Encode(feeTokenParam)
		if err != nil {
			return nil, errors.NewField("feeTokenParam", err)
		}
		// Serialize `tokenIndexesParam`:
		err = enc__.Encode(tokenIndexesParam)
		if err != nil {
			return nil, errors.NewField("tokenIndexesParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "chain_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(chainConfigAccount, false, false))
		// Account 2 "ccip_sender": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ccipSenderAccount, true, false))
		// Account 3 "authority_fee_token_ata": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityFeeTokenAtaAccount, true, false))
		// Account 4 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 5 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 6 "ccip_router": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ccipRouterAccount, false, false))
		// Account 7 "ccip_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ccipConfigAccount, false, false))
		// Account 8 "ccip_dest_chain_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ccipDestChainStateAccount, true, false))
		// Account 9 "ccip_sender_nonce": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ccipSenderNonceAccount, true, false))
		// Account 10 "ccip_fee_token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ccipFeeTokenProgramAccount, false, false))
		// Account 11 "ccip_fee_token_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ccipFeeTokenMintAccount, false, false))
		// Account 12 "ccip_fee_token_user_ata": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ccipFeeTokenUserAtaAccount, true, false))
		// Account 13 "ccip_fee_token_receiver": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ccipFeeTokenReceiverAccount, true, false))
		// Account 14 "ccip_fee_billing_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ccipFeeBillingSignerAccount, false, false))
		// Account 15 "ccip_fee_quoter": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ccipFeeQuoterAccount, false, false))
		// Account 16 "ccip_fee_quoter_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ccipFeeQuoterConfigAccount, false, false))
		// Account 17 "ccip_fee_quoter_dest_chain": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ccipFeeQuoterDestChainAccount, false, false))
		// Account 18 "ccip_fee_quoter_billing_token_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ccipFeeQuoterBillingTokenConfigAccount, false, false))
		// Account 19 "ccip_fee_quoter_link_token_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ccipFeeQuoterLinkTokenConfigAccount, false, false))
		// Account 20 "ccip_rmn_remote": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ccipRmnRemoteAccount, false, false))
		// Account 21 "ccip_rmn_remote_curses": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ccipRmnRemoteCursesAccount, false, false))
		// Account 22 "ccip_rmn_remote_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ccipRmnRemoteConfigAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "init_chain_config" instruction.
func NewInitChainConfigInstruction(
	// Params:
	chainSelectorParam uint64,
	recipientParam []byte,
	extraArgsBytesParam []byte,

	// Accounts:
	stateAccount solanago.PublicKey,
	chainConfigAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitChainConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `chainSelectorParam`:
		err = enc__.Encode(chainSelectorParam)
		if err != nil {
			return nil, errors.NewField("chainSelectorParam", err)
		}
		// Serialize `recipientParam`:
		err = enc__.Encode(recipientParam)
		if err != nil {
			return nil, errors.NewField("recipientParam", err)
		}
		// Serialize `extraArgsBytesParam`:
		err = enc__.Encode(extraArgsBytesParam)
		if err != nil {
			return nil, errors.NewField("extraArgsBytesParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "chain_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(chainConfigAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize" instruction.
func NewInitializeInstruction(
	// Params:
	routerParam solanago.PublicKey,

	// Accounts:
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Initialize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `routerParam`:
		err = enc__.Encode(routerParam)
		if err != nil {
			return nil, errors.NewField("routerParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "remove_chain_config" instruction.
func NewRemoveChainConfigInstruction(
	// Params:
	chainSelectorParam uint64,

	// Accounts:
	stateAccount solanago.PublicKey,
	chainConfigAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RemoveChainConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `chainSelectorParam`:
		err = enc__.Encode(chainSelectorParam)
		if err != nil {
			return nil, errors.NewField("chainSelectorParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "chain_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(chainConfigAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "transfer_ownership" instruction.
func NewTransferOwnershipInstruction(
	// Params:
	proposedOwnerParam solanago.PublicKey,

	// Accounts:
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_TransferOwnership[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `proposedOwnerParam`:
		err = enc__.Encode(proposedOwnerParam)
		if err != nil {
			return nil, errors.NewField("proposedOwnerParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_chain_config" instruction.
func NewUpdateChainConfigInstruction(
	// Params:
	chainSelectorParam uint64,
	recipientParam []byte,
	extraArgsBytesParam []byte,

	// Accounts:
	stateAccount solanago.PublicKey,
	chainConfigAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateChainConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `chainSelectorParam`:
		err = enc__.Encode(chainSelectorParam)
		if err != nil {
			return nil, errors.NewField("chainSelectorParam", err)
		}
		// Serialize `recipientParam`:
		err = enc__.Encode(recipientParam)
		if err != nil {
			return nil, errors.NewField("recipientParam", err)
		}
		// Serialize `extraArgsBytesParam`:
		err = enc__.Encode(extraArgsBytesParam)
		if err != nil {
			return nil, errors.NewField("extraArgsBytesParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "chain_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(chainConfigAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_router" instruction.
func NewUpdateRouterInstruction(
	// Params:
	newRouterParam solanago.PublicKey,

	// Accounts:
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateRouter[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newRouterParam`:
		err = enc__.Encode(newRouterParam)
		if err != nil {
			return nil, errors.NewField("newRouterParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "withdraw_tokens" instruction.
func NewWithdrawTokensInstruction(
	// Params:
	amountParam uint64,
	decimalsParam uint8,

	// Accounts:
	stateAccount solanago.PublicKey,
	programTokenAccountAccount solanago.PublicKey,
	toTokenAccountAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	ccipSenderAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_WithdrawTokens[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `amountParam`:
		err = enc__.Encode(amountParam)
		if err != nil {
			return nil, errors.NewField("amountParam", err)
		}
		// Serialize `decimalsParam`:
		err = enc__.Encode(decimalsParam)
		if err != nil {
			return nil, errors.NewField("decimalsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "program_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programTokenAccountAccount, true, false))
		// Account 2 "to_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(toTokenAccountAccount, true, false))
		// Account 3 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 4 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 5 "ccip_sender": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ccipSenderAccount, false, false))
		// Account 6 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

type AcceptOwnershipInstruction struct {

	// Accounts:
	State           solanago.PublicKey `json:"state"`
	StateWritable   bool               `json:"state_writable"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
}

func (obj *AcceptOwnershipInstruction) GetDiscriminator() []byte {
	return Instruction_AcceptOwnership[:]
}

// UnmarshalWithDecoder unmarshals the AcceptOwnershipInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *AcceptOwnershipInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "AcceptOwnershipInstruction", err)
	}
	if discriminator != Instruction_AcceptOwnership {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "AcceptOwnershipInstruction", Instruction_AcceptOwnership, discriminator)
	}
	return nil
}

func (obj *AcceptOwnershipInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AcceptOwnershipInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 2 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 2, len(indices))
	}
	indexOffset := 0
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AcceptOwnershipInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.State)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the AcceptOwnershipInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *AcceptOwnershipInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AcceptOwnershipInstruction: %w", err)
	}
	return nil
}

// UnmarshalAcceptOwnershipInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalAcceptOwnershipInstruction(buf []byte) (*AcceptOwnershipInstruction, error) {
	obj := new(AcceptOwnershipInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type CcipSendInstruction struct {
	DestChainSelector uint64             `json:"dest_chain_selector"`
	TokenAmounts      []SvmTokenAmount   `json:"token_amounts"`
	Data              []byte             `json:"data"`
	FeeToken          solanago.PublicKey `json:"fee_token"`
	TokenIndexes      []byte             `json:"token_indexes"`

	// Accounts:
	State                           solanago.PublicKey `json:"state"`
	ChainConfig                     solanago.PublicKey `json:"chain_config"`
	CcipSender                      solanago.PublicKey `json:"ccip_sender"`
	CcipSenderWritable              bool               `json:"ccip_sender_writable"`
	AuthorityFeeTokenAta            solanago.PublicKey `json:"authority_fee_token_ata"`
	AuthorityFeeTokenAtaWritable    bool               `json:"authority_fee_token_ata_writable"`
	Authority                       solanago.PublicKey `json:"authority"`
	AuthoritySigner                 bool               `json:"authority_signer"`
	SystemProgram                   solanago.PublicKey `json:"system_program"`
	CcipRouter                      solanago.PublicKey `json:"ccip_router"`
	CcipConfig                      solanago.PublicKey `json:"ccip_config"`
	CcipDestChainState              solanago.PublicKey `json:"ccip_dest_chain_state"`
	CcipDestChainStateWritable      bool               `json:"ccip_dest_chain_state_writable"`
	CcipSenderNonce                 solanago.PublicKey `json:"ccip_sender_nonce"`
	CcipSenderNonceWritable         bool               `json:"ccip_sender_nonce_writable"`
	CcipFeeTokenProgram             solanago.PublicKey `json:"ccip_fee_token_program"`
	CcipFeeTokenMint                solanago.PublicKey `json:"ccip_fee_token_mint"`
	CcipFeeTokenUserAta             solanago.PublicKey `json:"ccip_fee_token_user_ata"`
	CcipFeeTokenUserAtaWritable     bool               `json:"ccip_fee_token_user_ata_writable"`
	CcipFeeTokenReceiver            solanago.PublicKey `json:"ccip_fee_token_receiver"`
	CcipFeeTokenReceiverWritable    bool               `json:"ccip_fee_token_receiver_writable"`
	CcipFeeBillingSigner            solanago.PublicKey `json:"ccip_fee_billing_signer"`
	CcipFeeQuoter                   solanago.PublicKey `json:"ccip_fee_quoter"`
	CcipFeeQuoterConfig             solanago.PublicKey `json:"ccip_fee_quoter_config"`
	CcipFeeQuoterDestChain          solanago.PublicKey `json:"ccip_fee_quoter_dest_chain"`
	CcipFeeQuoterBillingTokenConfig solanago.PublicKey `json:"ccip_fee_quoter_billing_token_config"`
	CcipFeeQuoterLinkTokenConfig    solanago.PublicKey `json:"ccip_fee_quoter_link_token_config"`
	CcipRmnRemote                   solanago.PublicKey `json:"ccip_rmn_remote"`
	CcipRmnRemoteCurses             solanago.PublicKey `json:"ccip_rmn_remote_curses"`
	CcipRmnRemoteConfig             solanago.PublicKey `json:"ccip_rmn_remote_config"`
}

func (obj *CcipSendInstruction) GetDiscriminator() []byte {
	return Instruction_CcipSend[:]
}

// UnmarshalWithDecoder unmarshals the CcipSendInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *CcipSendInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "CcipSendInstruction", err)
	}
	if discriminator != Instruction_CcipSend {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "CcipSendInstruction", Instruction_CcipSend, discriminator)
	}
	// Deserialize `DestChainSelector`:
	err = decoder.Decode(&obj.DestChainSelector)
	if err != nil {
		return err
	}
	// Deserialize `TokenAmounts`:
	err = decoder.Decode(&obj.TokenAmounts)
	if err != nil {
		return err
	}
	// Deserialize `Data`:
	err = decoder.Decode(&obj.Data)
	if err != nil {
		return err
	}
	// Deserialize `FeeToken`:
	err = decoder.Decode(&obj.FeeToken)
	if err != nil {
		return err
	}
	// Deserialize `TokenIndexes`:
	err = decoder.Decode(&obj.TokenIndexes)
	if err != nil {
		return err
	}
	return nil
}

func (obj *CcipSendInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from chain_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "chain_config", err)
	}
	indices = append(indices, index)
	// Decode from ccip_sender account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ccip_sender", err)
	}
	indices = append(indices, index)
	// Decode from authority_fee_token_ata account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority_fee_token_ata", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	// Decode from ccip_router account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ccip_router", err)
	}
	indices = append(indices, index)
	// Decode from ccip_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ccip_config", err)
	}
	indices = append(indices, index)
	// Decode from ccip_dest_chain_state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ccip_dest_chain_state", err)
	}
	indices = append(indices, index)
	// Decode from ccip_sender_nonce account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ccip_sender_nonce", err)
	}
	indices = append(indices, index)
	// Decode from ccip_fee_token_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ccip_fee_token_program", err)
	}
	indices = append(indices, index)
	// Decode from ccip_fee_token_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ccip_fee_token_mint", err)
	}
	indices = append(indices, index)
	// Decode from ccip_fee_token_user_ata account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ccip_fee_token_user_ata", err)
	}
	indices = append(indices, index)
	// Decode from ccip_fee_token_receiver account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ccip_fee_token_receiver", err)
	}
	indices = append(indices, index)
	// Decode from ccip_fee_billing_signer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ccip_fee_billing_signer", err)
	}
	indices = append(indices, index)
	// Decode from ccip_fee_quoter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ccip_fee_quoter", err)
	}
	indices = append(indices, index)
	// Decode from ccip_fee_quoter_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ccip_fee_quoter_config", err)
	}
	indices = append(indices, index)
	// Decode from ccip_fee_quoter_dest_chain account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ccip_fee_quoter_dest_chain", err)
	}
	indices = append(indices, index)
	// Decode from ccip_fee_quoter_billing_token_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ccip_fee_quoter_billing_token_config", err)
	}
	indices = append(indices, index)
	// Decode from ccip_fee_quoter_link_token_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ccip_fee_quoter_link_token_config", err)
	}
	indices = append(indices, index)
	// Decode from ccip_rmn_remote account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ccip_rmn_remote", err)
	}
	indices = append(indices, index)
	// Decode from ccip_rmn_remote_curses account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ccip_rmn_remote_curses", err)
	}
	indices = append(indices, index)
	// Decode from ccip_rmn_remote_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ccip_rmn_remote_config", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *CcipSendInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 23 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 23, len(indices))
	}
	indexOffset := 0
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set chain_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "chain_config", len(accountKeys)-1)
	}
	obj.ChainConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ccip_sender account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ccip_sender", len(accountKeys)-1)
	}
	obj.CcipSender = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority_fee_token_ata account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority_fee_token_ata", len(accountKeys)-1)
	}
	obj.AuthorityFeeTokenAta = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ccip_router account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ccip_router", len(accountKeys)-1)
	}
	obj.CcipRouter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ccip_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ccip_config", len(accountKeys)-1)
	}
	obj.CcipConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ccip_dest_chain_state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ccip_dest_chain_state", len(accountKeys)-1)
	}
	obj.CcipDestChainState = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ccip_sender_nonce account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ccip_sender_nonce", len(accountKeys)-1)
	}
	obj.CcipSenderNonce = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ccip_fee_token_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ccip_fee_token_program", len(accountKeys)-1)
	}
	obj.CcipFeeTokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ccip_fee_token_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ccip_fee_token_mint", len(accountKeys)-1)
	}
	obj.CcipFeeTokenMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ccip_fee_token_user_ata account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ccip_fee_token_user_ata", len(accountKeys)-1)
	}
	obj.CcipFeeTokenUserAta = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ccip_fee_token_receiver account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ccip_fee_token_receiver", len(accountKeys)-1)
	}
	obj.CcipFeeTokenReceiver = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ccip_fee_billing_signer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ccip_fee_billing_signer", len(accountKeys)-1)
	}
	obj.CcipFeeBillingSigner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ccip_fee_quoter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ccip_fee_quoter", len(accountKeys)-1)
	}
	obj.CcipFeeQuoter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ccip_fee_quoter_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ccip_fee_quoter_config", len(accountKeys)-1)
	}
	obj.CcipFeeQuoterConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ccip_fee_quoter_dest_chain account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ccip_fee_quoter_dest_chain", len(accountKeys)-1)
	}
	obj.CcipFeeQuoterDestChain = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ccip_fee_quoter_billing_token_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ccip_fee_quoter_billing_token_config", len(accountKeys)-1)
	}
	obj.CcipFeeQuoterBillingTokenConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ccip_fee_quoter_link_token_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ccip_fee_quoter_link_token_config", len(accountKeys)-1)
	}
	obj.CcipFeeQuoterLinkTokenConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ccip_rmn_remote account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ccip_rmn_remote", len(accountKeys)-1)
	}
	obj.CcipRmnRemote = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ccip_rmn_remote_curses account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ccip_rmn_remote_curses", len(accountKeys)-1)
	}
	obj.CcipRmnRemoteCurses = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ccip_rmn_remote_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ccip_rmn_remote_config", len(accountKeys)-1)
	}
	obj.CcipRmnRemoteConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *CcipSendInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.State)
	keys = append(keys, obj.ChainConfig)
	keys = append(keys, obj.CcipSender)
	keys = append(keys, obj.AuthorityFeeTokenAta)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.CcipRouter)
	keys = append(keys, obj.CcipConfig)
	keys = append(keys, obj.CcipDestChainState)
	keys = append(keys, obj.CcipSenderNonce)
	keys = append(keys, obj.CcipFeeTokenProgram)
	keys = append(keys, obj.CcipFeeTokenMint)
	keys = append(keys, obj.CcipFeeTokenUserAta)
	keys = append(keys, obj.CcipFeeTokenReceiver)
	keys = append(keys, obj.CcipFeeBillingSigner)
	keys = append(keys, obj.CcipFeeQuoter)
	keys = append(keys, obj.CcipFeeQuoterConfig)
	keys = append(keys, obj.CcipFeeQuoterDestChain)
	keys = append(keys, obj.CcipFeeQuoterBillingTokenConfig)
	keys = append(keys, obj.CcipFeeQuoterLinkTokenConfig)
	keys = append(keys, obj.CcipRmnRemote)
	keys = append(keys, obj.CcipRmnRemoteCurses)
	keys = append(keys, obj.CcipRmnRemoteConfig)
	return keys
}

// Unmarshal unmarshals the CcipSendInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *CcipSendInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CcipSendInstruction: %w", err)
	}
	return nil
}

// UnmarshalCcipSendInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalCcipSendInstruction(buf []byte) (*CcipSendInstruction, error) {
	obj := new(CcipSendInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitChainConfigInstruction struct {
	ChainSelector  uint64 `json:"_chain_selector"`
	Recipient      []byte `json:"recipient"`
	ExtraArgsBytes []byte `json:"extra_args_bytes"`

	// Accounts:
	State               solanago.PublicKey `json:"state"`
	StateWritable       bool               `json:"state_writable"`
	ChainConfig         solanago.PublicKey `json:"chain_config"`
	ChainConfigWritable bool               `json:"chain_config_writable"`
	Authority           solanago.PublicKey `json:"authority"`
	AuthorityWritable   bool               `json:"authority_writable"`
	AuthoritySigner     bool               `json:"authority_signer"`
	SystemProgram       solanago.PublicKey `json:"system_program"`
}

func (obj *InitChainConfigInstruction) GetDiscriminator() []byte {
	return Instruction_InitChainConfig[:]
}

// UnmarshalWithDecoder unmarshals the InitChainConfigInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *InitChainConfigInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "InitChainConfigInstruction", err)
	}
	if discriminator != Instruction_InitChainConfig {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "InitChainConfigInstruction", Instruction_InitChainConfig, discriminator)
	}
	// Deserialize `ChainSelector`:
	err = decoder.Decode(&obj.ChainSelector)
	if err != nil {
		return err
	}
	// Deserialize `Recipient`:
	err = decoder.Decode(&obj.Recipient)
	if err != nil {
		return err
	}
	// Deserialize `ExtraArgsBytes`:
	err = decoder.Decode(&obj.ExtraArgsBytes)
	if err != nil {
		return err
	}
	return nil
}

func (obj *InitChainConfigInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from chain_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "chain_config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitChainConfigInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set chain_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "chain_config", len(accountKeys)-1)
	}
	obj.ChainConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitChainConfigInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.State)
	keys = append(keys, obj.ChainConfig)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the InitChainConfigInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *InitChainConfigInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitChainConfigInstruction: %w", err)
	}
	return nil
}

// UnmarshalInitChainConfigInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalInitChainConfigInstruction(buf []byte) (*InitChainConfigInstruction, error) {
	obj := new(InitChainConfigInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitializeInstruction struct {
	Router solanago.PublicKey `json:"router"`

	// Accounts:
	State             solanago.PublicKey `json:"state"`
	StateWritable     bool               `json:"state_writable"`
	Authority         solanago.PublicKey `json:"authority"`
	AuthorityWritable bool               `json:"authority_writable"`
	AuthoritySigner   bool               `json:"authority_signer"`
	SystemProgram     solanago.PublicKey `json:"system_program"`
}

func (obj *InitializeInstruction) GetDiscriminator() []byte {
	return Instruction_Initialize[:]
}

// UnmarshalWithDecoder unmarshals the InitializeInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *InitializeInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "InitializeInstruction", err)
	}
	if discriminator != Instruction_Initialize {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "InitializeInstruction", Instruction_Initialize, discriminator)
	}
	// Deserialize `Router`:
	err = decoder.Decode(&obj.Router)
	if err != nil {
		return err
	}
	return nil
}

func (obj *InitializeInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitializeInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitializeInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.State)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the InitializeInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *InitializeInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitializeInstruction: %w", err)
	}
	return nil
}

// UnmarshalInitializeInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalInitializeInstruction(buf []byte) (*InitializeInstruction, error) {
	obj := new(InitializeInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type RemoveChainConfigInstruction struct {
	ChainSelector uint64 `json:"_chain_selector"`

	// Accounts:
	State               solanago.PublicKey `json:"state"`
	StateWritable       bool               `json:"state_writable"`
	ChainConfig         solanago.PublicKey `json:"chain_config"`
	ChainConfigWritable bool               `json:"chain_config_writable"`
	Authority           solanago.PublicKey `json:"authority"`
	AuthorityWritable   bool               `json:"authority_writable"`
	AuthoritySigner     bool               `json:"authority_signer"`
	SystemProgram       solanago.PublicKey `json:"system_program"`
}

func (obj *RemoveChainConfigInstruction) GetDiscriminator() []byte {
	return Instruction_RemoveChainConfig[:]
}

// UnmarshalWithDecoder unmarshals the RemoveChainConfigInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *RemoveChainConfigInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "RemoveChainConfigInstruction", err)
	}
	if discriminator != Instruction_RemoveChainConfig {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "RemoveChainConfigInstruction", Instruction_RemoveChainConfig, discriminator)
	}
	// Deserialize `ChainSelector`:
	err = decoder.Decode(&obj.ChainSelector)
	if err != nil {
		return err
	}
	return nil
}

func (obj *RemoveChainConfigInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from chain_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "chain_config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *RemoveChainConfigInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set chain_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "chain_config", len(accountKeys)-1)
	}
	obj.ChainConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *RemoveChainConfigInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.State)
	keys = append(keys, obj.ChainConfig)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the RemoveChainConfigInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *RemoveChainConfigInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling RemoveChainConfigInstruction: %w", err)
	}
	return nil
}

// UnmarshalRemoveChainConfigInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalRemoveChainConfigInstruction(buf []byte) (*RemoveChainConfigInstruction, error) {
	obj := new(RemoveChainConfigInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type TransferOwnershipInstruction struct {
	ProposedOwner solanago.PublicKey `json:"proposed_owner"`

	// Accounts:
	State           solanago.PublicKey `json:"state"`
	StateWritable   bool               `json:"state_writable"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
}

func (obj *TransferOwnershipInstruction) GetDiscriminator() []byte {
	return Instruction_TransferOwnership[:]
}

// UnmarshalWithDecoder unmarshals the TransferOwnershipInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *TransferOwnershipInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "TransferOwnershipInstruction", err)
	}
	if discriminator != Instruction_TransferOwnership {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "TransferOwnershipInstruction", Instruction_TransferOwnership, discriminator)
	}
	// Deserialize `ProposedOwner`:
	err = decoder.Decode(&obj.ProposedOwner)
	if err != nil {
		return err
	}
	return nil
}

func (obj *TransferOwnershipInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *TransferOwnershipInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 2 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 2, len(indices))
	}
	indexOffset := 0
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *TransferOwnershipInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.State)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the TransferOwnershipInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *TransferOwnershipInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling TransferOwnershipInstruction: %w", err)
	}
	return nil
}

// UnmarshalTransferOwnershipInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalTransferOwnershipInstruction(buf []byte) (*TransferOwnershipInstruction, error) {
	obj := new(TransferOwnershipInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UpdateChainConfigInstruction struct {
	ChainSelector  uint64 `json:"_chain_selector"`
	Recipient      []byte `json:"recipient"`
	ExtraArgsBytes []byte `json:"extra_args_bytes"`

	// Accounts:
	State               solanago.PublicKey `json:"state"`
	StateWritable       bool               `json:"state_writable"`
	ChainConfig         solanago.PublicKey `json:"chain_config"`
	ChainConfigWritable bool               `json:"chain_config_writable"`
	Authority           solanago.PublicKey `json:"authority"`
	AuthorityWritable   bool               `json:"authority_writable"`
	AuthoritySigner     bool               `json:"authority_signer"`
	SystemProgram       solanago.PublicKey `json:"system_program"`
}

func (obj *UpdateChainConfigInstruction) GetDiscriminator() []byte {
	return Instruction_UpdateChainConfig[:]
}

// UnmarshalWithDecoder unmarshals the UpdateChainConfigInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *UpdateChainConfigInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "UpdateChainConfigInstruction", err)
	}
	if discriminator != Instruction_UpdateChainConfig {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "UpdateChainConfigInstruction", Instruction_UpdateChainConfig, discriminator)
	}
	// Deserialize `ChainSelector`:
	err = decoder.Decode(&obj.ChainSelector)
	if err != nil {
		return err
	}
	// Deserialize `Recipient`:
	err = decoder.Decode(&obj.Recipient)
	if err != nil {
		return err
	}
	// Deserialize `ExtraArgsBytes`:
	err = decoder.Decode(&obj.ExtraArgsBytes)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UpdateChainConfigInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from chain_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "chain_config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *UpdateChainConfigInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set chain_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "chain_config", len(accountKeys)-1)
	}
	obj.ChainConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *UpdateChainConfigInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.State)
	keys = append(keys, obj.ChainConfig)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the UpdateChainConfigInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *UpdateChainConfigInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdateChainConfigInstruction: %w", err)
	}
	return nil
}

// UnmarshalUpdateChainConfigInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalUpdateChainConfigInstruction(buf []byte) (*UpdateChainConfigInstruction, error) {
	obj := new(UpdateChainConfigInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UpdateRouterInstruction struct {
	NewRouter solanago.PublicKey `json:"new_router"`

	// Accounts:
	State           solanago.PublicKey `json:"state"`
	StateWritable   bool               `json:"state_writable"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
}

func (obj *UpdateRouterInstruction) GetDiscriminator() []byte {
	return Instruction_UpdateRouter[:]
}

// UnmarshalWithDecoder unmarshals the UpdateRouterInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *UpdateRouterInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "UpdateRouterInstruction", err)
	}
	if discriminator != Instruction_UpdateRouter {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "UpdateRouterInstruction", Instruction_UpdateRouter, discriminator)
	}
	// Deserialize `NewRouter`:
	err = decoder.Decode(&obj.NewRouter)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UpdateRouterInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *UpdateRouterInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 2 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 2, len(indices))
	}
	indexOffset := 0
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *UpdateRouterInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.State)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the UpdateRouterInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *UpdateRouterInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdateRouterInstruction: %w", err)
	}
	return nil
}

// UnmarshalUpdateRouterInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalUpdateRouterInstruction(buf []byte) (*UpdateRouterInstruction, error) {
	obj := new(UpdateRouterInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type WithdrawTokensInstruction struct {
	Amount   uint64 `json:"amount"`
	Decimals uint8  `json:"decimals"`

	// Accounts:
	State                       solanago.PublicKey `json:"state"`
	StateWritable               bool               `json:"state_writable"`
	ProgramTokenAccount         solanago.PublicKey `json:"program_token_account"`
	ProgramTokenAccountWritable bool               `json:"program_token_account_writable"`
	ToTokenAccount              solanago.PublicKey `json:"to_token_account"`
	ToTokenAccountWritable      bool               `json:"to_token_account_writable"`
	Mint                        solanago.PublicKey `json:"mint"`
	TokenProgram                solanago.PublicKey `json:"token_program"`
	CcipSender                  solanago.PublicKey `json:"ccip_sender"`
	Authority                   solanago.PublicKey `json:"authority"`
	AuthoritySigner             bool               `json:"authority_signer"`
}

func (obj *WithdrawTokensInstruction) GetDiscriminator() []byte {
	return Instruction_WithdrawTokens[:]
}

// UnmarshalWithDecoder unmarshals the WithdrawTokensInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *WithdrawTokensInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "WithdrawTokensInstruction", err)
	}
	if discriminator != Instruction_WithdrawTokens {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "WithdrawTokensInstruction", Instruction_WithdrawTokens, discriminator)
	}
	// Deserialize `Amount`:
	err = decoder.Decode(&obj.Amount)
	if err != nil {
		return err
	}
	// Deserialize `Decimals`:
	err = decoder.Decode(&obj.Decimals)
	if err != nil {
		return err
	}
	return nil
}

func (obj *WithdrawTokensInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from program_token_account account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program_token_account", err)
	}
	indices = append(indices, index)
	// Decode from to_token_account account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "to_token_account", err)
	}
	indices = append(indices, index)
	// Decode from mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "mint", err)
	}
	indices = append(indices, index)
	// Decode from token_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_program", err)
	}
	indices = append(indices, index)
	// Decode from ccip_sender account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ccip_sender", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *WithdrawTokensInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 7 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 7, len(indices))
	}
	indexOffset := 0
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program_token_account account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program_token_account", len(accountKeys)-1)
	}
	obj.ProgramTokenAccount = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set to_token_account account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "to_token_account", len(accountKeys)-1)
	}
	obj.ToTokenAccount = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "mint", len(accountKeys)-1)
	}
	obj.Mint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_program", len(accountKeys)-1)
	}
	obj.TokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ccip_sender account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ccip_sender", len(accountKeys)-1)
	}
	obj.CcipSender = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *WithdrawTokensInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.State)
	keys = append(keys, obj.ProgramTokenAccount)
	keys = append(keys, obj.ToTokenAccount)
	keys = append(keys, obj.Mint)
	keys = append(keys, obj.TokenProgram)
	keys = append(keys, obj.CcipSender)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the WithdrawTokensInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *WithdrawTokensInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling WithdrawTokensInstruction: %w", err)
	}
	return nil
}

// UnmarshalWithdrawTokensInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalWithdrawTokensInstruction(buf []byte) (*WithdrawTokensInstruction, error) {
	obj := new(WithdrawTokensInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Instruction interface defines common methods for all instruction types
type Instruction interface {
	GetDiscriminator() []byte

	UnmarshalWithDecoder(decoder *binary.Decoder) error

	UnmarshalAccountIndices(buf []byte) ([]uint8, error)

	PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error

	GetAccountKeys() []solanago.PublicKey
}

// ParseInstruction parses instruction data and optionally populates accounts
// If accountIndicesData is nil or empty, accounts will not be populated
func ParseInstruction(instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (Instruction, error) {
	// Validate inputs
	if len(instructionData) < 8 {
		return nil, fmt.Errorf("instruction data too short: expected at least 8 bytes, got %d", len(instructionData))
	}
	// Extract discriminator
	discriminator := [8]byte{}
	copy(discriminator[:], instructionData[0:8])
	// Parse based on discriminator
	switch discriminator {
	case Instruction_AcceptOwnership:
		instruction := new(AcceptOwnershipInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AcceptOwnershipInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_CcipSend:
		instruction := new(CcipSendInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as CcipSendInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_InitChainConfig:
		instruction := new(InitChainConfigInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitChainConfigInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_Initialize:
		instruction := new(InitializeInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitializeInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_RemoveChainConfig:
		instruction := new(RemoveChainConfigInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as RemoveChainConfigInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_TransferOwnership:
		instruction := new(TransferOwnershipInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as TransferOwnershipInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_UpdateChainConfig:
		instruction := new(UpdateChainConfigInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as UpdateChainConfigInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_UpdateRouter:
		instruction := new(UpdateRouterInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as UpdateRouterInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_WithdrawTokens:
		instruction := new(WithdrawTokensInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as WithdrawTokensInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	default:
		return nil, fmt.Errorf("unknown instruction discriminator: %s", binary.FormatDiscriminator(discriminator))
	}
}

// ParseInstructionTyped parses instruction data and returns a specific instruction type // T must implement the Instruction interface
func ParseInstructionTyped[T Instruction](instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (T, error) {
	instruction, err := ParseInstruction(instructionData, accountIndicesData, accountKeys)
	if err != nil {
		return *new(T), err
	}
	typed, ok := instruction.(T)
	if !ok {
		return *new(T), fmt.Errorf("instruction is not of expected type")
	}
	return typed, nil
}

// ParseInstructionWithoutAccounts parses instruction data without account information
func ParseInstructionWithoutAccounts(instructionData []byte) (Instruction, error) {
	return ParseInstruction(instructionData, nil, []solanago.PublicKey{})
}

// ParseInstructionWithAccounts parses instruction data with account information
func ParseInstructionWithAccounts(instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (Instruction, error) {
	return ParseInstruction(instructionData, accountIndicesData, accountKeys)
}
