// Code generated by https://github.com/Unheilbar/anchor-go. DO NOT EDIT.
// This file contains parsers for the types defined in the IDL.

package ping_pong_demo

import (
	"bytes"
	"fmt"
	errors "github.com/Unheilbar/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

type Any2SvmMessage struct {
	MessageId           [32]uint8        `json:"message_id"`
	SourceChainSelector uint64           `json:"source_chain_selector"`
	Sender              []byte           `json:"sender"`
	Data                []byte           `json:"data"`
	TokenAmounts        []SvmTokenAmount `json:"token_amounts"`
}

func (obj Any2SvmMessage) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `MessageId`:
	err = encoder.Encode(obj.MessageId)
	if err != nil {
		return errors.NewField("MessageId", err)
	}
	// Serialize `SourceChainSelector`:
	err = encoder.Encode(obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Serialize `Sender`:
	err = encoder.Encode(obj.Sender)
	if err != nil {
		return errors.NewField("Sender", err)
	}
	// Serialize `Data`:
	err = encoder.Encode(obj.Data)
	if err != nil {
		return errors.NewField("Data", err)
	}
	// Serialize `TokenAmounts`:
	err = encoder.Encode(obj.TokenAmounts)
	if err != nil {
		return errors.NewField("TokenAmounts", err)
	}
	return nil
}

func (obj Any2SvmMessage) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Any2SvmMessage: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Any2SvmMessage) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `MessageId`:
	err = decoder.Decode(&obj.MessageId)
	if err != nil {
		return errors.NewField("MessageId", err)
	}
	// Deserialize `SourceChainSelector`:
	err = decoder.Decode(&obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Deserialize `Sender`:
	err = decoder.Decode(&obj.Sender)
	if err != nil {
		return errors.NewField("Sender", err)
	}
	// Deserialize `Data`:
	err = decoder.Decode(&obj.Data)
	if err != nil {
		return errors.NewField("Data", err)
	}
	// Deserialize `TokenAmounts`:
	err = decoder.Decode(&obj.TokenAmounts)
	if err != nil {
		return errors.NewField("TokenAmounts", err)
	}
	return nil
}

func (obj *Any2SvmMessage) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Any2SvmMessage: %w", err)
	}
	return nil
}

func UnmarshalAny2SvmMessage(buf []byte) (*Any2SvmMessage, error) {
	obj := new(Any2SvmMessage)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type Config struct {
	Owner                    solanago.PublicKey `json:"owner"`
	Router                   solanago.PublicKey `json:"router"`
	CounterpartChainSelector uint64             `json:"counterpart_chain_selector"`
	CounterpartAddress       CounterpartAddress `json:"counterpart_address"`
	IsPaused                 bool               `json:"is_paused"`
	FeeTokenMint             solanago.PublicKey `json:"fee_token_mint"`
	ExtraArgs                []byte             `json:"extra_args"`
}

func (obj Config) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Owner`:
	err = encoder.Encode(obj.Owner)
	if err != nil {
		return errors.NewField("Owner", err)
	}
	// Serialize `Router`:
	err = encoder.Encode(obj.Router)
	if err != nil {
		return errors.NewField("Router", err)
	}
	// Serialize `CounterpartChainSelector`:
	err = encoder.Encode(obj.CounterpartChainSelector)
	if err != nil {
		return errors.NewField("CounterpartChainSelector", err)
	}
	// Serialize `CounterpartAddress`:
	err = encoder.Encode(obj.CounterpartAddress)
	if err != nil {
		return errors.NewField("CounterpartAddress", err)
	}
	// Serialize `IsPaused`:
	err = encoder.Encode(obj.IsPaused)
	if err != nil {
		return errors.NewField("IsPaused", err)
	}
	// Serialize `FeeTokenMint`:
	err = encoder.Encode(obj.FeeTokenMint)
	if err != nil {
		return errors.NewField("FeeTokenMint", err)
	}
	// Serialize `ExtraArgs`:
	err = encoder.Encode(obj.ExtraArgs)
	if err != nil {
		return errors.NewField("ExtraArgs", err)
	}
	return nil
}

func (obj Config) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Config: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Config) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Owner`:
	err = decoder.Decode(&obj.Owner)
	if err != nil {
		return errors.NewField("Owner", err)
	}
	// Deserialize `Router`:
	err = decoder.Decode(&obj.Router)
	if err != nil {
		return errors.NewField("Router", err)
	}
	// Deserialize `CounterpartChainSelector`:
	err = decoder.Decode(&obj.CounterpartChainSelector)
	if err != nil {
		return errors.NewField("CounterpartChainSelector", err)
	}
	// Deserialize `CounterpartAddress`:
	err = decoder.Decode(&obj.CounterpartAddress)
	if err != nil {
		return errors.NewField("CounterpartAddress", err)
	}
	// Deserialize `IsPaused`:
	err = decoder.Decode(&obj.IsPaused)
	if err != nil {
		return errors.NewField("IsPaused", err)
	}
	// Deserialize `FeeTokenMint`:
	err = decoder.Decode(&obj.FeeTokenMint)
	if err != nil {
		return errors.NewField("FeeTokenMint", err)
	}
	// Deserialize `ExtraArgs`:
	err = decoder.Decode(&obj.ExtraArgs)
	if err != nil {
		return errors.NewField("ExtraArgs", err)
	}
	return nil
}

func (obj *Config) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Config: %w", err)
	}
	return nil
}

func UnmarshalConfig(buf []byte) (*Config, error) {
	obj := new(Config)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type CounterpartAddress struct {
	Bytes [64]uint8 `json:"bytes"`
	Len   uint8     `json:"len"`
}

func (obj CounterpartAddress) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Bytes`:
	err = encoder.Encode(obj.Bytes)
	if err != nil {
		return errors.NewField("Bytes", err)
	}
	// Serialize `Len`:
	err = encoder.Encode(obj.Len)
	if err != nil {
		return errors.NewField("Len", err)
	}
	return nil
}

func (obj CounterpartAddress) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding CounterpartAddress: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *CounterpartAddress) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Bytes`:
	err = decoder.Decode(&obj.Bytes)
	if err != nil {
		return errors.NewField("Bytes", err)
	}
	// Deserialize `Len`:
	err = decoder.Decode(&obj.Len)
	if err != nil {
		return errors.NewField("Len", err)
	}
	return nil
}

func (obj *CounterpartAddress) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CounterpartAddress: %w", err)
	}
	return nil
}

func UnmarshalCounterpartAddress(buf []byte) (*CounterpartAddress, error) {
	obj := new(CounterpartAddress)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type NameVersion struct {
	Name    string `json:"name"`
	Version string `json:"version"`
}

func (obj NameVersion) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Name`:
	err = encoder.Encode(obj.Name)
	if err != nil {
		return errors.NewField("Name", err)
	}
	// Serialize `Version`:
	err = encoder.Encode(obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	return nil
}

func (obj NameVersion) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding NameVersion: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *NameVersion) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Name`:
	err = decoder.Decode(&obj.Name)
	if err != nil {
		return errors.NewField("Name", err)
	}
	// Deserialize `Version`:
	err = decoder.Decode(&obj.Version)
	if err != nil {
		return errors.NewField("Version", err)
	}
	return nil
}

func (obj *NameVersion) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling NameVersion: %w", err)
	}
	return nil
}

func UnmarshalNameVersion(buf []byte) (*NameVersion, error) {
	obj := new(NameVersion)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SvmTokenAmount struct {
	Token  solanago.PublicKey `json:"token"`
	Amount uint64             `json:"amount"`
}

func (obj SvmTokenAmount) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Token`:
	err = encoder.Encode(obj.Token)
	if err != nil {
		return errors.NewField("Token", err)
	}
	// Serialize `Amount`:
	err = encoder.Encode(obj.Amount)
	if err != nil {
		return errors.NewField("Amount", err)
	}
	return nil
}

func (obj SvmTokenAmount) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding SvmTokenAmount: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *SvmTokenAmount) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Token`:
	err = decoder.Decode(&obj.Token)
	if err != nil {
		return errors.NewField("Token", err)
	}
	// Deserialize `Amount`:
	err = decoder.Decode(&obj.Amount)
	if err != nil {
		return errors.NewField("Amount", err)
	}
	return nil
}

func (obj *SvmTokenAmount) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SvmTokenAmount: %w", err)
	}
	return nil
}

func UnmarshalSvmTokenAmount(buf []byte) (*SvmTokenAmount, error) {
	obj := new(SvmTokenAmount)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}
