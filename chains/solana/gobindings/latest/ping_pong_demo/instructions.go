// Code generated by https://github.com/Unheilbar/anchor-go. DO NOT EDIT.
// This file contains instructions and instruction parsers.

package ping_pong_demo

import (
	"bytes"
	"fmt"
	errors "github.com/Unheilbar/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "ccip_receive" instruction.
func NewCcipReceiveInstruction(
	// Params:
	messageParam Any2SvmMessage,

	// Accounts:
	authorityAccount solanago.PublicKey,
	offrampProgramAccount solanago.PublicKey,
	allowedOfframpAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	ccipSendSignerAccount solanago.PublicKey,
	feeTokenProgramAccount solanago.PublicKey,
	feeTokenMintAccount solanago.PublicKey,
	feeTokenAtaAccount solanago.PublicKey,
	ccipRouterProgramAccount solanago.PublicKey,
	ccipRouterConfigAccount solanago.PublicKey,
	ccipRouterDestChainStateAccount solanago.PublicKey,
	ccipRouterNonceAccount solanago.PublicKey,
	ccipRouterFeeReceiverAccount solanago.PublicKey,
	ccipRouterFeeBillingSignerAccount solanago.PublicKey,
	feeQuoterAccount solanago.PublicKey,
	feeQuoterConfigAccount solanago.PublicKey,
	feeQuoterDestChainAccount solanago.PublicKey,
	feeQuoterBillingTokenConfigAccount solanago.PublicKey,
	feeQuoterLinkTokenConfigAccount solanago.PublicKey,
	rmnRemoteAccount solanago.PublicKey,
	rmnRemoteCursesAccount solanago.PublicKey,
	rmnRemoteConfigAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CcipReceive[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `messageParam`:
		err = enc__.Encode(messageParam)
		if err != nil {
			return nil, errors.NewField("messageParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 1 "offramp_program": Read-only, Non-signer, Required
		// CHECK offramp program: exists only to derive the allowed offramp PDA
		// and the authority PDA. Must be second.
		accounts__.Append(solanago.NewAccountMeta(offrampProgramAccount, false, false))
		// Account 2 "allowed_offramp": Read-only, Non-signer, Required
		// CHECK PDA of the router program verifying the signer is an allowed offramp.
		// If PDA does not exist, the router doesn't allow this offramp
		accounts__.Append(solanago.NewAccountMeta(allowedOfframpAccount, false, false))
		// Account 3 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 4 "ccip_send_signer": Writable, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(ccipSendSignerAccount, true, false))
		// Account 5 "fee_token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeTokenProgramAccount, false, false))
		// Account 6 "fee_token_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeTokenMintAccount, false, false))
		// Account 7 "fee_token_ata": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeTokenAtaAccount, true, false))
		// Account 8 "ccip_router_program": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(ccipRouterProgramAccount, false, false))
		// Account 9 "ccip_router_config": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(ccipRouterConfigAccount, false, false))
		// Account 10 "ccip_router_dest_chain_state": Writable, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(ccipRouterDestChainStateAccount, true, false))
		// Account 11 "ccip_router_nonce": Writable, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(ccipRouterNonceAccount, true, false))
		// Account 12 "ccip_router_fee_receiver": Writable, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(ccipRouterFeeReceiverAccount, true, false))
		// Account 13 "ccip_router_fee_billing_signer": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(ccipRouterFeeBillingSignerAccount, false, false))
		// Account 14 "fee_quoter": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(feeQuoterAccount, false, false))
		// Account 15 "fee_quoter_config": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(feeQuoterConfigAccount, false, false))
		// Account 16 "fee_quoter_dest_chain": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(feeQuoterDestChainAccount, false, false))
		// Account 17 "fee_quoter_billing_token_config": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(feeQuoterBillingTokenConfigAccount, false, false))
		// Account 18 "fee_quoter_link_token_config": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(feeQuoterLinkTokenConfigAccount, false, false))
		// Account 19 "rmn_remote": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteAccount, false, false))
		// Account 20 "rmn_remote_curses": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteCursesAccount, false, false))
		// Account 21 "rmn_remote_config": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteConfigAccount, false, false))
		// Account 22 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize" instruction.
func NewInitializeInstruction(
	configAccount solanago.PublicKey,
	nameVersionAccount solanago.PublicKey,
	routerFeeBillingSignerAccount solanago.PublicKey,
	feeTokenProgramAccount solanago.PublicKey,
	feeTokenMintAccount solanago.PublicKey,
	feeTokenAtaAccount solanago.PublicKey,
	ccipSendSignerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	associatedTokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Initialize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "name_version": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(nameVersionAccount, true, false))
		// Account 2 "router_fee_billing_signer": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(routerFeeBillingSignerAccount, false, false))
		// Account 3 "fee_token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeTokenProgramAccount, false, false))
		// Account 4 "fee_token_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeTokenMintAccount, false, false))
		// Account 5 "fee_token_ata": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeTokenAtaAccount, true, false))
		// Account 6 "ccip_send_signer": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(ccipSendSignerAccount, false, false))
		// Account 7 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 8 "associated_token_program": Read-only, Non-signer, Required, Address: ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL
		accounts__.Append(solanago.NewAccountMeta(associatedTokenProgramAccount, false, false))
		// Account 9 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_config" instruction.
func NewInitializeConfigInstruction(
	// Params:
	routerParam solanago.PublicKey,
	counterpartChainSelectorParam uint64,
	counterpartAddressParam []byte,
	isPausedParam bool,
	extraArgsParam []byte,

	// Accounts:
	configAccount solanago.PublicKey,
	feeTokenMintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
	programDataAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `routerParam`:
		err = enc__.Encode(routerParam)
		if err != nil {
			return nil, errors.NewField("routerParam", err)
		}
		// Serialize `counterpartChainSelectorParam`:
		err = enc__.Encode(counterpartChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("counterpartChainSelectorParam", err)
		}
		// Serialize `counterpartAddressParam`:
		err = enc__.Encode(counterpartAddressParam)
		if err != nil {
			return nil, errors.NewField("counterpartAddressParam", err)
		}
		// Serialize `isPausedParam`:
		err = enc__.Encode(isPausedParam)
		if err != nil {
			return nil, errors.NewField("isPausedParam", err)
		}
		// Serialize `extraArgsParam`:
		err = enc__.Encode(extraArgsParam)
		if err != nil {
			return nil, errors.NewField("extraArgsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "fee_token_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeTokenMintAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 4 "program": Read-only, Non-signer, Required, Address: PPbZmYFf5SPAM9Jhm9mNmYoCwT7icPYVKAfJoMCQovU
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
		// Account 5 "program_data": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programDataAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_counterpart" instruction.
func NewSetCounterpartInstruction(
	// Params:
	counterpartChainSelectorParam uint64,
	counterpartAddressParam []byte,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetCounterpart[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `counterpartChainSelectorParam`:
		err = enc__.Encode(counterpartChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("counterpartChainSelectorParam", err)
		}
		// Serialize `counterpartAddressParam`:
		err = enc__.Encode(counterpartAddressParam)
		if err != nil {
			return nil, errors.NewField("counterpartAddressParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_extra_args" instruction.
func NewSetExtraArgsInstruction(
	// Params:
	extraArgsParam []byte,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetExtraArgs[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `extraArgsParam`:
		err = enc__.Encode(extraArgsParam)
		if err != nil {
			return nil, errors.NewField("extraArgsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_paused" instruction.
func NewSetPausedInstruction(
	// Params:
	pauseParam bool,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetPaused[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `pauseParam`:
		err = enc__.Encode(pauseParam)
		if err != nil {
			return nil, errors.NewField("pauseParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "start_ping_pong" instruction.
func NewStartPingPongInstruction(
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	ccipSendSignerAccount solanago.PublicKey,
	feeTokenProgramAccount solanago.PublicKey,
	feeTokenMintAccount solanago.PublicKey,
	feeTokenAtaAccount solanago.PublicKey,
	ccipRouterProgramAccount solanago.PublicKey,
	ccipRouterConfigAccount solanago.PublicKey,
	ccipRouterDestChainStateAccount solanago.PublicKey,
	ccipRouterNonceAccount solanago.PublicKey,
	ccipRouterFeeReceiverAccount solanago.PublicKey,
	ccipRouterFeeBillingSignerAccount solanago.PublicKey,
	feeQuoterAccount solanago.PublicKey,
	feeQuoterConfigAccount solanago.PublicKey,
	feeQuoterDestChainAccount solanago.PublicKey,
	feeQuoterBillingTokenConfigAccount solanago.PublicKey,
	feeQuoterLinkTokenConfigAccount solanago.PublicKey,
	rmnRemoteAccount solanago.PublicKey,
	rmnRemoteCursesAccount solanago.PublicKey,
	rmnRemoteConfigAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_StartPingPong[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 2 "ccip_send_signer": Writable, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(ccipSendSignerAccount, true, false))
		// Account 3 "fee_token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeTokenProgramAccount, false, false))
		// Account 4 "fee_token_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeTokenMintAccount, false, false))
		// Account 5 "fee_token_ata": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeTokenAtaAccount, true, false))
		// Account 6 "ccip_router_program": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(ccipRouterProgramAccount, false, false))
		// Account 7 "ccip_router_config": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(ccipRouterConfigAccount, false, false))
		// Account 8 "ccip_router_dest_chain_state": Writable, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(ccipRouterDestChainStateAccount, true, false))
		// Account 9 "ccip_router_nonce": Writable, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(ccipRouterNonceAccount, true, false))
		// Account 10 "ccip_router_fee_receiver": Writable, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(ccipRouterFeeReceiverAccount, true, false))
		// Account 11 "ccip_router_fee_billing_signer": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(ccipRouterFeeBillingSignerAccount, false, false))
		// Account 12 "fee_quoter": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(feeQuoterAccount, false, false))
		// Account 13 "fee_quoter_config": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(feeQuoterConfigAccount, false, false))
		// Account 14 "fee_quoter_dest_chain": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(feeQuoterDestChainAccount, false, false))
		// Account 15 "fee_quoter_billing_token_config": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(feeQuoterBillingTokenConfigAccount, false, false))
		// Account 16 "fee_quoter_link_token_config": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(feeQuoterLinkTokenConfigAccount, false, false))
		// Account 17 "rmn_remote": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteAccount, false, false))
		// Account 18 "rmn_remote_curses": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteCursesAccount, false, false))
		// Account 19 "rmn_remote_config": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteConfigAccount, false, false))
		// Account 20 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "type_version" instruction.
// Returns the program type (name) and version. // Used by offchain code to easily determine which program & version is being interacted with. //  // # Arguments // * `ctx` - The context
func NewTypeVersionInstruction(
	clockAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_TypeVersion[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "clock": Read-only, Non-signer, Required, Address: SysvarC1ock11111111111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(clockAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

type CcipReceiveInstruction struct {
	Message Any2SvmMessage `json:"message"`

	// Accounts:
	Authority                        solanago.PublicKey `json:"authority"`
	AuthoritySigner                  bool               `json:"authority_signer"`
	OfframpProgram                   solanago.PublicKey `json:"offramp_program"`
	AllowedOfframp                   solanago.PublicKey `json:"allowed_offramp"`
	Config                           solanago.PublicKey `json:"config"`
	CcipSendSigner                   solanago.PublicKey `json:"ccip_send_signer"`
	CcipSendSignerWritable           bool               `json:"ccip_send_signer_writable"`
	FeeTokenProgram                  solanago.PublicKey `json:"fee_token_program"`
	FeeTokenMint                     solanago.PublicKey `json:"fee_token_mint"`
	FeeTokenAta                      solanago.PublicKey `json:"fee_token_ata"`
	FeeTokenAtaWritable              bool               `json:"fee_token_ata_writable"`
	CcipRouterProgram                solanago.PublicKey `json:"ccip_router_program"`
	CcipRouterConfig                 solanago.PublicKey `json:"ccip_router_config"`
	CcipRouterDestChainState         solanago.PublicKey `json:"ccip_router_dest_chain_state"`
	CcipRouterDestChainStateWritable bool               `json:"ccip_router_dest_chain_state_writable"`
	CcipRouterNonce                  solanago.PublicKey `json:"ccip_router_nonce"`
	CcipRouterNonceWritable          bool               `json:"ccip_router_nonce_writable"`
	CcipRouterFeeReceiver            solanago.PublicKey `json:"ccip_router_fee_receiver"`
	CcipRouterFeeReceiverWritable    bool               `json:"ccip_router_fee_receiver_writable"`
	CcipRouterFeeBillingSigner       solanago.PublicKey `json:"ccip_router_fee_billing_signer"`
	FeeQuoter                        solanago.PublicKey `json:"fee_quoter"`
	FeeQuoterConfig                  solanago.PublicKey `json:"fee_quoter_config"`
	FeeQuoterDestChain               solanago.PublicKey `json:"fee_quoter_dest_chain"`
	FeeQuoterBillingTokenConfig      solanago.PublicKey `json:"fee_quoter_billing_token_config"`
	FeeQuoterLinkTokenConfig         solanago.PublicKey `json:"fee_quoter_link_token_config"`
	RmnRemote                        solanago.PublicKey `json:"rmn_remote"`
	RmnRemoteCurses                  solanago.PublicKey `json:"rmn_remote_curses"`
	RmnRemoteConfig                  solanago.PublicKey `json:"rmn_remote_config"`
	SystemProgram                    solanago.PublicKey `json:"system_program"`
}

func (obj *CcipReceiveInstruction) GetDiscriminator() []byte {
	return Instruction_CcipReceive[:]
}

// UnmarshalWithDecoder unmarshals the CcipReceiveInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *CcipReceiveInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "CcipReceiveInstruction", err)
	}
	if discriminator != Instruction_CcipReceive {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "CcipReceiveInstruction", Instruction_CcipReceive, discriminator)
	}
	// Deserialize `Message`:
	err = decoder.Decode(&obj.Message)
	if err != nil {
		return err
	}
	return nil
}

func (obj *CcipReceiveInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from offramp_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "offramp_program", err)
	}
	indices = append(indices, index)
	// Decode from allowed_offramp account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "allowed_offramp", err)
	}
	indices = append(indices, index)
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from ccip_send_signer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ccip_send_signer", err)
	}
	indices = append(indices, index)
	// Decode from fee_token_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_token_program", err)
	}
	indices = append(indices, index)
	// Decode from fee_token_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_token_mint", err)
	}
	indices = append(indices, index)
	// Decode from fee_token_ata account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_token_ata", err)
	}
	indices = append(indices, index)
	// Decode from ccip_router_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ccip_router_program", err)
	}
	indices = append(indices, index)
	// Decode from ccip_router_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ccip_router_config", err)
	}
	indices = append(indices, index)
	// Decode from ccip_router_dest_chain_state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ccip_router_dest_chain_state", err)
	}
	indices = append(indices, index)
	// Decode from ccip_router_nonce account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ccip_router_nonce", err)
	}
	indices = append(indices, index)
	// Decode from ccip_router_fee_receiver account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ccip_router_fee_receiver", err)
	}
	indices = append(indices, index)
	// Decode from ccip_router_fee_billing_signer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ccip_router_fee_billing_signer", err)
	}
	indices = append(indices, index)
	// Decode from fee_quoter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_quoter", err)
	}
	indices = append(indices, index)
	// Decode from fee_quoter_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_quoter_config", err)
	}
	indices = append(indices, index)
	// Decode from fee_quoter_dest_chain account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_quoter_dest_chain", err)
	}
	indices = append(indices, index)
	// Decode from fee_quoter_billing_token_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_quoter_billing_token_config", err)
	}
	indices = append(indices, index)
	// Decode from fee_quoter_link_token_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_quoter_link_token_config", err)
	}
	indices = append(indices, index)
	// Decode from rmn_remote account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rmn_remote", err)
	}
	indices = append(indices, index)
	// Decode from rmn_remote_curses account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rmn_remote_curses", err)
	}
	indices = append(indices, index)
	// Decode from rmn_remote_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rmn_remote_config", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *CcipReceiveInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 23 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 23, len(indices))
	}
	indexOffset := 0
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set offramp_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "offramp_program", len(accountKeys)-1)
	}
	obj.OfframpProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set allowed_offramp account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "allowed_offramp", len(accountKeys)-1)
	}
	obj.AllowedOfframp = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ccip_send_signer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ccip_send_signer", len(accountKeys)-1)
	}
	obj.CcipSendSigner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_token_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_token_program", len(accountKeys)-1)
	}
	obj.FeeTokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_token_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_token_mint", len(accountKeys)-1)
	}
	obj.FeeTokenMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_token_ata account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_token_ata", len(accountKeys)-1)
	}
	obj.FeeTokenAta = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ccip_router_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ccip_router_program", len(accountKeys)-1)
	}
	obj.CcipRouterProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ccip_router_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ccip_router_config", len(accountKeys)-1)
	}
	obj.CcipRouterConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ccip_router_dest_chain_state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ccip_router_dest_chain_state", len(accountKeys)-1)
	}
	obj.CcipRouterDestChainState = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ccip_router_nonce account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ccip_router_nonce", len(accountKeys)-1)
	}
	obj.CcipRouterNonce = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ccip_router_fee_receiver account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ccip_router_fee_receiver", len(accountKeys)-1)
	}
	obj.CcipRouterFeeReceiver = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ccip_router_fee_billing_signer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ccip_router_fee_billing_signer", len(accountKeys)-1)
	}
	obj.CcipRouterFeeBillingSigner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_quoter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_quoter", len(accountKeys)-1)
	}
	obj.FeeQuoter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_quoter_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_quoter_config", len(accountKeys)-1)
	}
	obj.FeeQuoterConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_quoter_dest_chain account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_quoter_dest_chain", len(accountKeys)-1)
	}
	obj.FeeQuoterDestChain = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_quoter_billing_token_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_quoter_billing_token_config", len(accountKeys)-1)
	}
	obj.FeeQuoterBillingTokenConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_quoter_link_token_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_quoter_link_token_config", len(accountKeys)-1)
	}
	obj.FeeQuoterLinkTokenConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rmn_remote account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rmn_remote", len(accountKeys)-1)
	}
	obj.RmnRemote = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rmn_remote_curses account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rmn_remote_curses", len(accountKeys)-1)
	}
	obj.RmnRemoteCurses = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rmn_remote_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rmn_remote_config", len(accountKeys)-1)
	}
	obj.RmnRemoteConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *CcipReceiveInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.OfframpProgram)
	keys = append(keys, obj.AllowedOfframp)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.CcipSendSigner)
	keys = append(keys, obj.FeeTokenProgram)
	keys = append(keys, obj.FeeTokenMint)
	keys = append(keys, obj.FeeTokenAta)
	keys = append(keys, obj.CcipRouterProgram)
	keys = append(keys, obj.CcipRouterConfig)
	keys = append(keys, obj.CcipRouterDestChainState)
	keys = append(keys, obj.CcipRouterNonce)
	keys = append(keys, obj.CcipRouterFeeReceiver)
	keys = append(keys, obj.CcipRouterFeeBillingSigner)
	keys = append(keys, obj.FeeQuoter)
	keys = append(keys, obj.FeeQuoterConfig)
	keys = append(keys, obj.FeeQuoterDestChain)
	keys = append(keys, obj.FeeQuoterBillingTokenConfig)
	keys = append(keys, obj.FeeQuoterLinkTokenConfig)
	keys = append(keys, obj.RmnRemote)
	keys = append(keys, obj.RmnRemoteCurses)
	keys = append(keys, obj.RmnRemoteConfig)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the CcipReceiveInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *CcipReceiveInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CcipReceiveInstruction: %w", err)
	}
	return nil
}

// UnmarshalCcipReceiveInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalCcipReceiveInstruction(buf []byte) (*CcipReceiveInstruction, error) {
	obj := new(CcipReceiveInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitializeInstruction struct {

	// Accounts:
	Config                 solanago.PublicKey `json:"config"`
	NameVersion            solanago.PublicKey `json:"name_version"`
	NameVersionWritable    bool               `json:"name_version_writable"`
	RouterFeeBillingSigner solanago.PublicKey `json:"router_fee_billing_signer"`
	FeeTokenProgram        solanago.PublicKey `json:"fee_token_program"`
	FeeTokenMint           solanago.PublicKey `json:"fee_token_mint"`
	FeeTokenAta            solanago.PublicKey `json:"fee_token_ata"`
	FeeTokenAtaWritable    bool               `json:"fee_token_ata_writable"`
	CcipSendSigner         solanago.PublicKey `json:"ccip_send_signer"`
	Authority              solanago.PublicKey `json:"authority"`
	AuthorityWritable      bool               `json:"authority_writable"`
	AuthoritySigner        bool               `json:"authority_signer"`
	AssociatedTokenProgram solanago.PublicKey `json:"associated_token_program"`
	SystemProgram          solanago.PublicKey `json:"system_program"`
}

func (obj *InitializeInstruction) GetDiscriminator() []byte {
	return Instruction_Initialize[:]
}

// UnmarshalWithDecoder unmarshals the InitializeInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *InitializeInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "InitializeInstruction", err)
	}
	if discriminator != Instruction_Initialize {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "InitializeInstruction", Instruction_Initialize, discriminator)
	}
	return nil
}

func (obj *InitializeInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from name_version account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "name_version", err)
	}
	indices = append(indices, index)
	// Decode from router_fee_billing_signer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "router_fee_billing_signer", err)
	}
	indices = append(indices, index)
	// Decode from fee_token_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_token_program", err)
	}
	indices = append(indices, index)
	// Decode from fee_token_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_token_mint", err)
	}
	indices = append(indices, index)
	// Decode from fee_token_ata account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_token_ata", err)
	}
	indices = append(indices, index)
	// Decode from ccip_send_signer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ccip_send_signer", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from associated_token_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "associated_token_program", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitializeInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 10 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 10, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set name_version account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "name_version", len(accountKeys)-1)
	}
	obj.NameVersion = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set router_fee_billing_signer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "router_fee_billing_signer", len(accountKeys)-1)
	}
	obj.RouterFeeBillingSigner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_token_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_token_program", len(accountKeys)-1)
	}
	obj.FeeTokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_token_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_token_mint", len(accountKeys)-1)
	}
	obj.FeeTokenMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_token_ata account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_token_ata", len(accountKeys)-1)
	}
	obj.FeeTokenAta = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ccip_send_signer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ccip_send_signer", len(accountKeys)-1)
	}
	obj.CcipSendSigner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set associated_token_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "associated_token_program", len(accountKeys)-1)
	}
	obj.AssociatedTokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitializeInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.NameVersion)
	keys = append(keys, obj.RouterFeeBillingSigner)
	keys = append(keys, obj.FeeTokenProgram)
	keys = append(keys, obj.FeeTokenMint)
	keys = append(keys, obj.FeeTokenAta)
	keys = append(keys, obj.CcipSendSigner)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.AssociatedTokenProgram)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the InitializeInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *InitializeInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitializeInstruction: %w", err)
	}
	return nil
}

// UnmarshalInitializeInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalInitializeInstruction(buf []byte) (*InitializeInstruction, error) {
	obj := new(InitializeInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitializeConfigInstruction struct {
	Router                   solanago.PublicKey `json:"router"`
	CounterpartChainSelector uint64             `json:"counterpart_chain_selector"`
	CounterpartAddress       []byte             `json:"counterpart_address"`
	IsPaused                 bool               `json:"is_paused"`
	ExtraArgs                []byte             `json:"extra_args"`

	// Accounts:
	Config            solanago.PublicKey `json:"config"`
	ConfigWritable    bool               `json:"config_writable"`
	FeeTokenMint      solanago.PublicKey `json:"fee_token_mint"`
	Authority         solanago.PublicKey `json:"authority"`
	AuthorityWritable bool               `json:"authority_writable"`
	AuthoritySigner   bool               `json:"authority_signer"`
	SystemProgram     solanago.PublicKey `json:"system_program"`
	Program           solanago.PublicKey `json:"program"`
	ProgramData       solanago.PublicKey `json:"program_data"`
}

func (obj *InitializeConfigInstruction) GetDiscriminator() []byte {
	return Instruction_InitializeConfig[:]
}

// UnmarshalWithDecoder unmarshals the InitializeConfigInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *InitializeConfigInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "InitializeConfigInstruction", err)
	}
	if discriminator != Instruction_InitializeConfig {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "InitializeConfigInstruction", Instruction_InitializeConfig, discriminator)
	}
	// Deserialize `Router`:
	err = decoder.Decode(&obj.Router)
	if err != nil {
		return err
	}
	// Deserialize `CounterpartChainSelector`:
	err = decoder.Decode(&obj.CounterpartChainSelector)
	if err != nil {
		return err
	}
	// Deserialize `CounterpartAddress`:
	err = decoder.Decode(&obj.CounterpartAddress)
	if err != nil {
		return err
	}
	// Deserialize `IsPaused`:
	err = decoder.Decode(&obj.IsPaused)
	if err != nil {
		return err
	}
	// Deserialize `ExtraArgs`:
	err = decoder.Decode(&obj.ExtraArgs)
	if err != nil {
		return err
	}
	return nil
}

func (obj *InitializeConfigInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from fee_token_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_token_mint", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	// Decode from program_data account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program_data", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitializeConfigInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 6 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 6, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_token_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_token_mint", len(accountKeys)-1)
	}
	obj.FeeTokenMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program_data account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program_data", len(accountKeys)-1)
	}
	obj.ProgramData = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitializeConfigInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.FeeTokenMint)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.Program)
	keys = append(keys, obj.ProgramData)
	return keys
}

// Unmarshal unmarshals the InitializeConfigInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *InitializeConfigInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitializeConfigInstruction: %w", err)
	}
	return nil
}

// UnmarshalInitializeConfigInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalInitializeConfigInstruction(buf []byte) (*InitializeConfigInstruction, error) {
	obj := new(InitializeConfigInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SetCounterpartInstruction struct {
	CounterpartChainSelector uint64 `json:"counterpart_chain_selector"`
	CounterpartAddress       []byte `json:"counterpart_address"`

	// Accounts:
	Config            solanago.PublicKey `json:"config"`
	ConfigWritable    bool               `json:"config_writable"`
	Authority         solanago.PublicKey `json:"authority"`
	AuthorityWritable bool               `json:"authority_writable"`
	AuthoritySigner   bool               `json:"authority_signer"`
}

func (obj *SetCounterpartInstruction) GetDiscriminator() []byte {
	return Instruction_SetCounterpart[:]
}

// UnmarshalWithDecoder unmarshals the SetCounterpartInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *SetCounterpartInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "SetCounterpartInstruction", err)
	}
	if discriminator != Instruction_SetCounterpart {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "SetCounterpartInstruction", Instruction_SetCounterpart, discriminator)
	}
	// Deserialize `CounterpartChainSelector`:
	err = decoder.Decode(&obj.CounterpartChainSelector)
	if err != nil {
		return err
	}
	// Deserialize `CounterpartAddress`:
	err = decoder.Decode(&obj.CounterpartAddress)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SetCounterpartInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SetCounterpartInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 2 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 2, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SetCounterpartInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the SetCounterpartInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *SetCounterpartInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SetCounterpartInstruction: %w", err)
	}
	return nil
}

// UnmarshalSetCounterpartInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalSetCounterpartInstruction(buf []byte) (*SetCounterpartInstruction, error) {
	obj := new(SetCounterpartInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SetExtraArgsInstruction struct {
	ExtraArgs []byte `json:"extra_args"`

	// Accounts:
	Config            solanago.PublicKey `json:"config"`
	ConfigWritable    bool               `json:"config_writable"`
	Authority         solanago.PublicKey `json:"authority"`
	AuthorityWritable bool               `json:"authority_writable"`
	AuthoritySigner   bool               `json:"authority_signer"`
	SystemProgram     solanago.PublicKey `json:"system_program"`
}

func (obj *SetExtraArgsInstruction) GetDiscriminator() []byte {
	return Instruction_SetExtraArgs[:]
}

// UnmarshalWithDecoder unmarshals the SetExtraArgsInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *SetExtraArgsInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "SetExtraArgsInstruction", err)
	}
	if discriminator != Instruction_SetExtraArgs {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "SetExtraArgsInstruction", Instruction_SetExtraArgs, discriminator)
	}
	// Deserialize `ExtraArgs`:
	err = decoder.Decode(&obj.ExtraArgs)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SetExtraArgsInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SetExtraArgsInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SetExtraArgsInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the SetExtraArgsInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *SetExtraArgsInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SetExtraArgsInstruction: %w", err)
	}
	return nil
}

// UnmarshalSetExtraArgsInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalSetExtraArgsInstruction(buf []byte) (*SetExtraArgsInstruction, error) {
	obj := new(SetExtraArgsInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SetPausedInstruction struct {
	Pause bool `json:"pause"`

	// Accounts:
	Config            solanago.PublicKey `json:"config"`
	ConfigWritable    bool               `json:"config_writable"`
	Authority         solanago.PublicKey `json:"authority"`
	AuthorityWritable bool               `json:"authority_writable"`
	AuthoritySigner   bool               `json:"authority_signer"`
}

func (obj *SetPausedInstruction) GetDiscriminator() []byte {
	return Instruction_SetPaused[:]
}

// UnmarshalWithDecoder unmarshals the SetPausedInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *SetPausedInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "SetPausedInstruction", err)
	}
	if discriminator != Instruction_SetPaused {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "SetPausedInstruction", Instruction_SetPaused, discriminator)
	}
	// Deserialize `Pause`:
	err = decoder.Decode(&obj.Pause)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SetPausedInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SetPausedInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 2 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 2, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SetPausedInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the SetPausedInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *SetPausedInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SetPausedInstruction: %w", err)
	}
	return nil
}

// UnmarshalSetPausedInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalSetPausedInstruction(buf []byte) (*SetPausedInstruction, error) {
	obj := new(SetPausedInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type StartPingPongInstruction struct {

	// Accounts:
	Config                           solanago.PublicKey `json:"config"`
	ConfigWritable                   bool               `json:"config_writable"`
	Authority                        solanago.PublicKey `json:"authority"`
	AuthorityWritable                bool               `json:"authority_writable"`
	AuthoritySigner                  bool               `json:"authority_signer"`
	CcipSendSigner                   solanago.PublicKey `json:"ccip_send_signer"`
	CcipSendSignerWritable           bool               `json:"ccip_send_signer_writable"`
	FeeTokenProgram                  solanago.PublicKey `json:"fee_token_program"`
	FeeTokenMint                     solanago.PublicKey `json:"fee_token_mint"`
	FeeTokenAta                      solanago.PublicKey `json:"fee_token_ata"`
	FeeTokenAtaWritable              bool               `json:"fee_token_ata_writable"`
	CcipRouterProgram                solanago.PublicKey `json:"ccip_router_program"`
	CcipRouterConfig                 solanago.PublicKey `json:"ccip_router_config"`
	CcipRouterDestChainState         solanago.PublicKey `json:"ccip_router_dest_chain_state"`
	CcipRouterDestChainStateWritable bool               `json:"ccip_router_dest_chain_state_writable"`
	CcipRouterNonce                  solanago.PublicKey `json:"ccip_router_nonce"`
	CcipRouterNonceWritable          bool               `json:"ccip_router_nonce_writable"`
	CcipRouterFeeReceiver            solanago.PublicKey `json:"ccip_router_fee_receiver"`
	CcipRouterFeeReceiverWritable    bool               `json:"ccip_router_fee_receiver_writable"`
	CcipRouterFeeBillingSigner       solanago.PublicKey `json:"ccip_router_fee_billing_signer"`
	FeeQuoter                        solanago.PublicKey `json:"fee_quoter"`
	FeeQuoterConfig                  solanago.PublicKey `json:"fee_quoter_config"`
	FeeQuoterDestChain               solanago.PublicKey `json:"fee_quoter_dest_chain"`
	FeeQuoterBillingTokenConfig      solanago.PublicKey `json:"fee_quoter_billing_token_config"`
	FeeQuoterLinkTokenConfig         solanago.PublicKey `json:"fee_quoter_link_token_config"`
	RmnRemote                        solanago.PublicKey `json:"rmn_remote"`
	RmnRemoteCurses                  solanago.PublicKey `json:"rmn_remote_curses"`
	RmnRemoteConfig                  solanago.PublicKey `json:"rmn_remote_config"`
	SystemProgram                    solanago.PublicKey `json:"system_program"`
}

func (obj *StartPingPongInstruction) GetDiscriminator() []byte {
	return Instruction_StartPingPong[:]
}

// UnmarshalWithDecoder unmarshals the StartPingPongInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *StartPingPongInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "StartPingPongInstruction", err)
	}
	if discriminator != Instruction_StartPingPong {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "StartPingPongInstruction", Instruction_StartPingPong, discriminator)
	}
	return nil
}

func (obj *StartPingPongInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from ccip_send_signer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ccip_send_signer", err)
	}
	indices = append(indices, index)
	// Decode from fee_token_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_token_program", err)
	}
	indices = append(indices, index)
	// Decode from fee_token_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_token_mint", err)
	}
	indices = append(indices, index)
	// Decode from fee_token_ata account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_token_ata", err)
	}
	indices = append(indices, index)
	// Decode from ccip_router_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ccip_router_program", err)
	}
	indices = append(indices, index)
	// Decode from ccip_router_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ccip_router_config", err)
	}
	indices = append(indices, index)
	// Decode from ccip_router_dest_chain_state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ccip_router_dest_chain_state", err)
	}
	indices = append(indices, index)
	// Decode from ccip_router_nonce account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ccip_router_nonce", err)
	}
	indices = append(indices, index)
	// Decode from ccip_router_fee_receiver account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ccip_router_fee_receiver", err)
	}
	indices = append(indices, index)
	// Decode from ccip_router_fee_billing_signer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "ccip_router_fee_billing_signer", err)
	}
	indices = append(indices, index)
	// Decode from fee_quoter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_quoter", err)
	}
	indices = append(indices, index)
	// Decode from fee_quoter_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_quoter_config", err)
	}
	indices = append(indices, index)
	// Decode from fee_quoter_dest_chain account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_quoter_dest_chain", err)
	}
	indices = append(indices, index)
	// Decode from fee_quoter_billing_token_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_quoter_billing_token_config", err)
	}
	indices = append(indices, index)
	// Decode from fee_quoter_link_token_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_quoter_link_token_config", err)
	}
	indices = append(indices, index)
	// Decode from rmn_remote account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rmn_remote", err)
	}
	indices = append(indices, index)
	// Decode from rmn_remote_curses account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rmn_remote_curses", err)
	}
	indices = append(indices, index)
	// Decode from rmn_remote_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rmn_remote_config", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *StartPingPongInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 21 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 21, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ccip_send_signer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ccip_send_signer", len(accountKeys)-1)
	}
	obj.CcipSendSigner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_token_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_token_program", len(accountKeys)-1)
	}
	obj.FeeTokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_token_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_token_mint", len(accountKeys)-1)
	}
	obj.FeeTokenMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_token_ata account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_token_ata", len(accountKeys)-1)
	}
	obj.FeeTokenAta = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ccip_router_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ccip_router_program", len(accountKeys)-1)
	}
	obj.CcipRouterProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ccip_router_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ccip_router_config", len(accountKeys)-1)
	}
	obj.CcipRouterConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ccip_router_dest_chain_state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ccip_router_dest_chain_state", len(accountKeys)-1)
	}
	obj.CcipRouterDestChainState = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ccip_router_nonce account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ccip_router_nonce", len(accountKeys)-1)
	}
	obj.CcipRouterNonce = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ccip_router_fee_receiver account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ccip_router_fee_receiver", len(accountKeys)-1)
	}
	obj.CcipRouterFeeReceiver = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set ccip_router_fee_billing_signer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "ccip_router_fee_billing_signer", len(accountKeys)-1)
	}
	obj.CcipRouterFeeBillingSigner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_quoter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_quoter", len(accountKeys)-1)
	}
	obj.FeeQuoter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_quoter_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_quoter_config", len(accountKeys)-1)
	}
	obj.FeeQuoterConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_quoter_dest_chain account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_quoter_dest_chain", len(accountKeys)-1)
	}
	obj.FeeQuoterDestChain = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_quoter_billing_token_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_quoter_billing_token_config", len(accountKeys)-1)
	}
	obj.FeeQuoterBillingTokenConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_quoter_link_token_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_quoter_link_token_config", len(accountKeys)-1)
	}
	obj.FeeQuoterLinkTokenConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rmn_remote account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rmn_remote", len(accountKeys)-1)
	}
	obj.RmnRemote = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rmn_remote_curses account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rmn_remote_curses", len(accountKeys)-1)
	}
	obj.RmnRemoteCurses = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rmn_remote_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rmn_remote_config", len(accountKeys)-1)
	}
	obj.RmnRemoteConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *StartPingPongInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.CcipSendSigner)
	keys = append(keys, obj.FeeTokenProgram)
	keys = append(keys, obj.FeeTokenMint)
	keys = append(keys, obj.FeeTokenAta)
	keys = append(keys, obj.CcipRouterProgram)
	keys = append(keys, obj.CcipRouterConfig)
	keys = append(keys, obj.CcipRouterDestChainState)
	keys = append(keys, obj.CcipRouterNonce)
	keys = append(keys, obj.CcipRouterFeeReceiver)
	keys = append(keys, obj.CcipRouterFeeBillingSigner)
	keys = append(keys, obj.FeeQuoter)
	keys = append(keys, obj.FeeQuoterConfig)
	keys = append(keys, obj.FeeQuoterDestChain)
	keys = append(keys, obj.FeeQuoterBillingTokenConfig)
	keys = append(keys, obj.FeeQuoterLinkTokenConfig)
	keys = append(keys, obj.RmnRemote)
	keys = append(keys, obj.RmnRemoteCurses)
	keys = append(keys, obj.RmnRemoteConfig)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the StartPingPongInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *StartPingPongInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling StartPingPongInstruction: %w", err)
	}
	return nil
}

// UnmarshalStartPingPongInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalStartPingPongInstruction(buf []byte) (*StartPingPongInstruction, error) {
	obj := new(StartPingPongInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type TypeVersionInstruction struct {

	// Accounts:
	Clock solanago.PublicKey `json:"clock"`
}

func (obj *TypeVersionInstruction) GetDiscriminator() []byte {
	return Instruction_TypeVersion[:]
}

// UnmarshalWithDecoder unmarshals the TypeVersionInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *TypeVersionInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "TypeVersionInstruction", err)
	}
	if discriminator != Instruction_TypeVersion {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "TypeVersionInstruction", Instruction_TypeVersion, discriminator)
	}
	return nil
}

func (obj *TypeVersionInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from clock account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "clock", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *TypeVersionInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 1 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 1, len(indices))
	}
	indexOffset := 0
	// Set clock account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "clock", len(accountKeys)-1)
	}
	obj.Clock = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *TypeVersionInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Clock)
	return keys
}

// Unmarshal unmarshals the TypeVersionInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *TypeVersionInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling TypeVersionInstruction: %w", err)
	}
	return nil
}

// UnmarshalTypeVersionInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalTypeVersionInstruction(buf []byte) (*TypeVersionInstruction, error) {
	obj := new(TypeVersionInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Instruction interface defines common methods for all instruction types
type Instruction interface {
	GetDiscriminator() []byte

	UnmarshalWithDecoder(decoder *binary.Decoder) error

	UnmarshalAccountIndices(buf []byte) ([]uint8, error)

	PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error

	GetAccountKeys() []solanago.PublicKey
}

// ParseInstruction parses instruction data and optionally populates accounts
// If accountIndicesData is nil or empty, accounts will not be populated
func ParseInstruction(instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (Instruction, error) {
	// Validate inputs
	if len(instructionData) < 8 {
		return nil, fmt.Errorf("instruction data too short: expected at least 8 bytes, got %d", len(instructionData))
	}
	// Extract discriminator
	discriminator := [8]byte{}
	copy(discriminator[:], instructionData[0:8])
	// Parse based on discriminator
	switch discriminator {
	case Instruction_CcipReceive:
		instruction := new(CcipReceiveInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as CcipReceiveInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_Initialize:
		instruction := new(InitializeInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitializeInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_InitializeConfig:
		instruction := new(InitializeConfigInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitializeConfigInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SetCounterpart:
		instruction := new(SetCounterpartInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SetCounterpartInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SetExtraArgs:
		instruction := new(SetExtraArgsInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SetExtraArgsInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SetPaused:
		instruction := new(SetPausedInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SetPausedInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_StartPingPong:
		instruction := new(StartPingPongInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as StartPingPongInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_TypeVersion:
		instruction := new(TypeVersionInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as TypeVersionInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	default:
		return nil, fmt.Errorf("unknown instruction discriminator: %s", binary.FormatDiscriminator(discriminator))
	}
}

// ParseInstructionTyped parses instruction data and returns a specific instruction type // T must implement the Instruction interface
func ParseInstructionTyped[T Instruction](instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (T, error) {
	instruction, err := ParseInstruction(instructionData, accountIndicesData, accountKeys)
	if err != nil {
		return *new(T), err
	}
	typed, ok := instruction.(T)
	if !ok {
		return *new(T), fmt.Errorf("instruction is not of expected type")
	}
	return typed, nil
}

// ParseInstructionWithoutAccounts parses instruction data without account information
func ParseInstructionWithoutAccounts(instructionData []byte) (Instruction, error) {
	return ParseInstruction(instructionData, nil, []solanago.PublicKey{})
}

// ParseInstructionWithAccounts parses instruction data with account information
func ParseInstructionWithAccounts(instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (Instruction, error) {
	return ParseInstruction(instructionData, accountIndicesData, accountKeys)
}
