// Code generated by https://github.com/Unheilbar/anchor-go. DO NOT EDIT.
// This file contains instructions and instruction parsers.

package mcm

import (
	"bytes"
	"fmt"
	errors "github.com/Unheilbar/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "accept_ownership" instruction.
// Accept ownership of the multisig config. //  // The proposed new owner must call this function to assume ownership. //  // # Parameters //  // - `ctx`: The context containing the configuration account. // - `_multisig_id`: The multisig identifier.
func NewAcceptOwnershipInstruction(
	// Params:
	multisigIdParam [32]uint8,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AcceptOwnership[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `multisigIdParam`:
		err = enc__.Encode(multisigIdParam)
		if err != nil {
			return nil, errors.NewField("multisigIdParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "append_signatures" instruction.
// Append a batch of ECDSA signatures to the temporary storage. //  // Allows adding multiple signatures in batches to overcome transaction size limits. //  // # Parameters //  // - `ctx`: The context containing required accounts. // - `multisig_id`: The multisig instance identifier. // - `root`: The Merkle root being approved. // - `valid_until`: Timestamp until which the root will remain valid. // - `signatures_batch`: A batch of ECDSA signatures to be verified.
func NewAppendSignaturesInstruction(
	// Params:
	multisigIdParam [32]uint8,
	rootParam [32]uint8,
	validUntilParam uint32,
	signaturesBatchParam []Signature,

	// Accounts:
	signaturesAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AppendSignatures[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `multisigIdParam`:
		err = enc__.Encode(multisigIdParam)
		if err != nil {
			return nil, errors.NewField("multisigIdParam", err)
		}
		// Serialize `rootParam`:
		err = enc__.Encode(rootParam)
		if err != nil {
			return nil, errors.NewField("rootParam", err)
		}
		// Serialize `validUntilParam`:
		err = enc__.Encode(validUntilParam)
		if err != nil {
			return nil, errors.NewField("validUntilParam", err)
		}
		// Serialize `signaturesBatchParam`:
		err = enc__.Encode(signaturesBatchParam)
		if err != nil {
			return nil, errors.NewField("signaturesBatchParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "signatures": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(signaturesAccount, true, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "append_signers" instruction.
// Append a batch of signer addresses to the temporary storage. //  // Allows adding multiple signer addresses in batches to overcome transaction size limits. //  // # Parameters //  // - `ctx`: The context containing required accounts. // - `multisig_id`: The multisig instance identifier. // - `signers_batch`: A batch of Ethereum addresses (20 bytes each) to be added as signers.
func NewAppendSignersInstruction(
	// Params:
	multisigIdParam [32]uint8,
	signersBatchParam [][20]uint8,

	// Accounts:
	multisigConfigAccount solanago.PublicKey,
	configSignersAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AppendSigners[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `multisigIdParam`:
		err = enc__.Encode(multisigIdParam)
		if err != nil {
			return nil, errors.NewField("multisigIdParam", err)
		}
		// Serialize `signersBatchParam`:
		err = enc__.Encode(signersBatchParam)
		if err != nil {
			return nil, errors.NewField("signersBatchParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "multisig_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(multisigConfigAccount, false, false))
		// Account 1 "config_signers": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configSignersAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "clear_signatures" instruction.
// Clear the temporary signature storage. //  // Closes the account storing signatures, allowing it to be reinitialized if needed. //  // # Parameters //  // - `ctx`: The context containing required accounts. // - `multisig_id`: The multisig instance identifier. // - `root`: The Merkle root associated with the signatures. // - `valid_until`: Timestamp until which the root would remain valid.
func NewClearSignaturesInstruction(
	// Params:
	multisigIdParam [32]uint8,
	rootParam [32]uint8,
	validUntilParam uint32,

	// Accounts:
	signaturesAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ClearSignatures[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `multisigIdParam`:
		err = enc__.Encode(multisigIdParam)
		if err != nil {
			return nil, errors.NewField("multisigIdParam", err)
		}
		// Serialize `rootParam`:
		err = enc__.Encode(rootParam)
		if err != nil {
			return nil, errors.NewField("rootParam", err)
		}
		// Serialize `validUntilParam`:
		err = enc__.Encode(validUntilParam)
		if err != nil {
			return nil, errors.NewField("validUntilParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "signatures": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(signaturesAccount, true, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "clear_signers" instruction.
// Clear the temporary signer storage. //  // Closes the account storing signer addresses, allowing it to be reinitialized if needed. //  // # Parameters //  // - `ctx`: The context containing required accounts. // - `multisig_id`: The multisig instance identifier.
func NewClearSignersInstruction(
	// Params:
	multisigIdParam [32]uint8,

	// Accounts:
	multisigConfigAccount solanago.PublicKey,
	configSignersAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ClearSigners[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `multisigIdParam`:
		err = enc__.Encode(multisigIdParam)
		if err != nil {
			return nil, errors.NewField("multisigIdParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "multisig_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(multisigConfigAccount, false, false))
		// Account 1 "config_signers": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configSignersAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "execute" instruction.
// Executes an operation after verifying it's authorized in the current Merkle root. //  // This function: // 1. Performs extensive validation checks on the operation // - Ensures the operation is within the allowed count range // - Verifies chain ID matches the configured chain // - Checks the root has not expired // - Validates the operation's nonce against current state // 2. Verifies the operation's inclusion in the Merkle tree // 3. Executes the cross-program invocation with the multisig signer PDA //  // # Parameters //  // - `ctx`: Context containing operation accounts and signer information // - `multisig_id`: Identifier for the multisig instance // - `chain_id`: Network identifier that must match configuration // - `nonce`: Operation counter that must match current state // - `data`: Instruction data to be executed // - `proof`: Merkle proof for operation verification //  // # Security Considerations //  // This instruction implements secure privilege delegation through PDA signing. // The multisig's signer PDA becomes the authoritative signer for the operation, // allowing controlled execution of privileged actions while maintaining the // security guarantees of the Merkle root validation.
func NewExecuteInstruction(
	// Params:
	multisigIdParam [32]uint8,
	chainIdParam uint64,
	nonceParam uint64,
	dataParam []byte,
	proofParam [][32]uint8,

	// Accounts:
	multisigConfigAccount solanago.PublicKey,
	rootMetadataAccount solanago.PublicKey,
	expiringRootAndOpCountAccount solanago.PublicKey,
	toAccount solanago.PublicKey,
	multisigSignerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Execute[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `multisigIdParam`:
		err = enc__.Encode(multisigIdParam)
		if err != nil {
			return nil, errors.NewField("multisigIdParam", err)
		}
		// Serialize `chainIdParam`:
		err = enc__.Encode(chainIdParam)
		if err != nil {
			return nil, errors.NewField("chainIdParam", err)
		}
		// Serialize `nonceParam`:
		err = enc__.Encode(nonceParam)
		if err != nil {
			return nil, errors.NewField("nonceParam", err)
		}
		// Serialize `dataParam`:
		err = enc__.Encode(dataParam)
		if err != nil {
			return nil, errors.NewField("dataParam", err)
		}
		// Serialize `proofParam`:
		err = enc__.Encode(proofParam)
		if err != nil {
			return nil, errors.NewField("proofParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "multisig_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(multisigConfigAccount, true, false))
		// Account 1 "root_metadata": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rootMetadataAccount, false, false))
		// Account 2 "expiring_root_and_op_count": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(expiringRootAndOpCountAccount, true, false))
		// Account 3 "to": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(toAccount, false, false))
		// Account 4 "multisig_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(multisigSignerAccount, false, false))
		// Account 5 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "finalize_signatures" instruction.
// Finalize the signature configuration. //  // Marks the signature list as finalized and ready for verification when setting a new root. //  // # Parameters //  // - `ctx`: The context containing required accounts. // - `multisig_id`: The multisig instance identifier. // - `root`: The Merkle root associated with the signatures. // - `valid_until`: Timestamp until which the root will remain valid.
func NewFinalizeSignaturesInstruction(
	// Params:
	multisigIdParam [32]uint8,
	rootParam [32]uint8,
	validUntilParam uint32,

	// Accounts:
	signaturesAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_FinalizeSignatures[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `multisigIdParam`:
		err = enc__.Encode(multisigIdParam)
		if err != nil {
			return nil, errors.NewField("multisigIdParam", err)
		}
		// Serialize `rootParam`:
		err = enc__.Encode(rootParam)
		if err != nil {
			return nil, errors.NewField("rootParam", err)
		}
		// Serialize `validUntilParam`:
		err = enc__.Encode(validUntilParam)
		if err != nil {
			return nil, errors.NewField("validUntilParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "signatures": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(signaturesAccount, true, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "finalize_signers" instruction.
// Finalize the signer configuration. //  // Marks the signer list as complete and ready for incorporation into the multisig configuration. //  // # Parameters //  // - `ctx`: The context containing required accounts. // - `multisig_id`: The multisig instance identifier.
func NewFinalizeSignersInstruction(
	// Params:
	multisigIdParam [32]uint8,

	// Accounts:
	multisigConfigAccount solanago.PublicKey,
	configSignersAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_FinalizeSigners[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `multisigIdParam`:
		err = enc__.Encode(multisigIdParam)
		if err != nil {
			return nil, errors.NewField("multisigIdParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "multisig_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(multisigConfigAccount, false, false))
		// Account 1 "config_signers": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configSignersAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "init_signatures" instruction.
// Initialize storage for ECDSA signatures. //  // Creates a temporary account to hold signatures that will validate a new Merkle root. //  // # Parameters //  // - `ctx`: The context containing required accounts. // - `multisig_id`: The multisig instance identifier. // - `root`: The new Merkle root these signatures will approve. // - `valid_until`: Timestamp until which the root will remain valid. // - `total_signatures`: The total number of signatures to be added.
func NewInitSignaturesInstruction(
	// Params:
	multisigIdParam [32]uint8,
	rootParam [32]uint8,
	validUntilParam uint32,
	totalSignaturesParam uint8,

	// Accounts:
	signaturesAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitSignatures[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `multisigIdParam`:
		err = enc__.Encode(multisigIdParam)
		if err != nil {
			return nil, errors.NewField("multisigIdParam", err)
		}
		// Serialize `rootParam`:
		err = enc__.Encode(rootParam)
		if err != nil {
			return nil, errors.NewField("rootParam", err)
		}
		// Serialize `validUntilParam`:
		err = enc__.Encode(validUntilParam)
		if err != nil {
			return nil, errors.NewField("validUntilParam", err)
		}
		// Serialize `totalSignaturesParam`:
		err = enc__.Encode(totalSignaturesParam)
		if err != nil {
			return nil, errors.NewField("totalSignaturesParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "signatures": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(signaturesAccount, true, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "init_signers" instruction.
// Initialize the storage for signer addresses. //  // Creates a temporary account to hold signer addresses during the multisig configuration process. //  // # Parameters //  // - `ctx`: The context containing required accounts. // - `multisig_id`: The multisig instance identifier. // - `total_signers`: The total number of signers to be added.
func NewInitSignersInstruction(
	// Params:
	multisigIdParam [32]uint8,
	totalSignersParam uint8,

	// Accounts:
	multisigConfigAccount solanago.PublicKey,
	configSignersAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitSigners[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `multisigIdParam`:
		err = enc__.Encode(multisigIdParam)
		if err != nil {
			return nil, errors.NewField("multisigIdParam", err)
		}
		// Serialize `totalSignersParam`:
		err = enc__.Encode(totalSignersParam)
		if err != nil {
			return nil, errors.NewField("totalSignersParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "multisig_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(multisigConfigAccount, false, false))
		// Account 1 "config_signers": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configSignersAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize" instruction.
// Initialize a new multisig configuration. //  // Creates the foundation for a new multisig instance by initializing the core configuration // PDAs and registering the multisig_id and chain_id. This is the first step in setting up // a new multisig configuration. //  // # Parameters //  // - `ctx`: The context containing the accounts required for initialization: // - `multisig_config`: PDA that will store the core configuration // - `root_metadata`: PDA that will store the current root's metadata // - `expiring_root_and_op_count`: PDA that tracks the current root and operation count // - `authority`: The deployer who becomes the initial owner // - `program_data`: Used to validate that the caller is the program's upgrade authority // - `chain_id`: Network identifier for the chain this configuration is targeting // - `multisig_id`: A unique, 32-byte identifier (left-padded) for this multisig instance //  // # Access Control //  // This instruction can only be called by the program's upgrade authority (typically the deployer). //  // # Note //  // After initialization, the owner can transfer ownership through the two-step // transfer_ownership/accept_ownership process.
func NewInitializeInstruction(
	// Params:
	chainIdParam uint64,
	multisigIdParam [32]uint8,

	// Accounts:
	multisigConfigAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
	programDataAccount solanago.PublicKey,
	rootMetadataAccount solanago.PublicKey,
	expiringRootAndOpCountAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Initialize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `chainIdParam`:
		err = enc__.Encode(chainIdParam)
		if err != nil {
			return nil, errors.NewField("chainIdParam", err)
		}
		// Serialize `multisigIdParam`:
		err = enc__.Encode(multisigIdParam)
		if err != nil {
			return nil, errors.NewField("multisigIdParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "multisig_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(multisigConfigAccount, true, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 3 "program": Read-only, Non-signer, Required, Address: 5vNJx78mz7KVMjhuipyr9jKBKcMrKYGdjGkgE4LUmjKk
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
		// Account 4 "program_data": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programDataAccount, false, false))
		// Account 5 "root_metadata": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rootMetadataAccount, true, false))
		// Account 6 "expiring_root_and_op_count": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(expiringRootAndOpCountAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_config" instruction.
// Set up the configuration for the multisig instance. //  // Validates and establishes the signer hierarchy, group structure, and quorum requirements. // If `clear_root` is true, it also invalidates the current Merkle root. //  // # Parameters //  // - `ctx`: The context containing the multisig configuration account. // - `multisig_id`: The unique identifier for this multisig instance. // - `signer_groups`: Vector assigning each signer to a specific group (must match signers length). // - `group_quorums`: Array defining the required signatures for each group. A group with quorum=0 is disabled. // - `group_parents`: Array defining the hierarchical relationship between groups, forming a tree structure. // - `clear_root`: If true, invalidates the current root to prevent further operations from being executed. //  // # Example //  // A group structure like this: //  // ```text // ┌──────┐ // ┌─►│2-of-3│◄───────┐ // │  └──────┘        │ // │        ▲         │ // │        │         │ // ┌──┴───┐ ┌──┴───┐ ┌───┴────┐ // ┌──►│1-of-2│ │2-of-2│ │signer A│ // │   └──────┘ └──────┘ └────────┘ // │       ▲      ▲  ▲ // │       │      │  │ // ┌───────┴┐ ┌────┴───┐ ┌┴───────┐ // │signer B│ │signer C│ │signer D│ // └────────┘ └────────┘ └────────┘ // ``` //  // Would be configured with: // - group_quorums = [2, 1, 2, ...] (root: 2-of-3, group1: 1-of-2, group2: 2-of-2) // - group_parents = [0, 0, 0, ...] (all groups under root)
func NewSetConfigInstruction(
	// Params:
	multisigIdParam [32]uint8,
	signerGroupsParam []byte,
	groupQuorumsParam [32]uint8,
	groupParentsParam [32]uint8,
	clearRootParam bool,

	// Accounts:
	multisigConfigAccount solanago.PublicKey,
	configSignersAccount solanago.PublicKey,
	rootMetadataAccount solanago.PublicKey,
	expiringRootAndOpCountAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `multisigIdParam`:
		err = enc__.Encode(multisigIdParam)
		if err != nil {
			return nil, errors.NewField("multisigIdParam", err)
		}
		// Serialize `signerGroupsParam`:
		err = enc__.Encode(signerGroupsParam)
		if err != nil {
			return nil, errors.NewField("signerGroupsParam", err)
		}
		// Serialize `groupQuorumsParam`:
		err = enc__.Encode(groupQuorumsParam)
		if err != nil {
			return nil, errors.NewField("groupQuorumsParam", err)
		}
		// Serialize `groupParentsParam`:
		err = enc__.Encode(groupParentsParam)
		if err != nil {
			return nil, errors.NewField("groupParentsParam", err)
		}
		// Serialize `clearRootParam`:
		err = enc__.Encode(clearRootParam)
		if err != nil {
			return nil, errors.NewField("clearRootParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "multisig_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(multisigConfigAccount, true, false))
		// Account 1 "config_signers": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configSignersAccount, true, false))
		// Account 2 "root_metadata": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rootMetadataAccount, true, false))
		// Account 3 "expiring_root_and_op_count": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(expiringRootAndOpCountAccount, true, false))
		// Account 4 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 5 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_root" instruction.
// Set a new Merkle root that defines approved operations. //  // This function updates the active Merkle root after verifying ECDSA signatures and validating // the provided metadata against a Merkle proof. //  // # Parameters //  // - `ctx`: The context containing required accounts. // - `multisig_id`: The multisig instance identifier. // - `root`: The new Merkle root to set. // - `valid_until`: timestamp until which the root remains valid. // - `metadata`: Structured input containing chain_id, multisig, and operation counters. // - `metadata_proof`: Merkle proof validating the metadata.
func NewSetRootInstruction(
	// Params:
	multisigIdParam [32]uint8,
	rootParam [32]uint8,
	validUntilParam uint32,
	metadataParam RootMetadataInput,
	metadataProofParam [][32]uint8,

	// Accounts:
	rootSignaturesAccount solanago.PublicKey,
	rootMetadataAccount solanago.PublicKey,
	seenSignedHashesAccount solanago.PublicKey,
	expiringRootAndOpCountAccount solanago.PublicKey,
	multisigConfigAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetRoot[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `multisigIdParam`:
		err = enc__.Encode(multisigIdParam)
		if err != nil {
			return nil, errors.NewField("multisigIdParam", err)
		}
		// Serialize `rootParam`:
		err = enc__.Encode(rootParam)
		if err != nil {
			return nil, errors.NewField("rootParam", err)
		}
		// Serialize `validUntilParam`:
		err = enc__.Encode(validUntilParam)
		if err != nil {
			return nil, errors.NewField("validUntilParam", err)
		}
		// Serialize `metadataParam`:
		err = enc__.Encode(metadataParam)
		if err != nil {
			return nil, errors.NewField("metadataParam", err)
		}
		// Serialize `metadataProofParam`:
		err = enc__.Encode(metadataProofParam)
		if err != nil {
			return nil, errors.NewField("metadataProofParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "root_signatures": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rootSignaturesAccount, true, false))
		// Account 1 "root_metadata": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rootMetadataAccount, true, false))
		// Account 2 "seen_signed_hashes": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(seenSignedHashesAccount, true, false))
		// Account 3 "expiring_root_and_op_count": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(expiringRootAndOpCountAccount, true, false))
		// Account 4 "multisig_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(multisigConfigAccount, false, false))
		// Account 5 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 6 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "transfer_ownership" instruction.
// Propose a new owner for the multisig instance config. //  // Only the current owner (admin) can propose a new owner. //  // # Parameters //  // - `ctx`: The context containing the configuration account. // - `_multisig_id`: The multisig identifier. // - `proposed_owner`: The public key of the proposed new owner.
func NewTransferOwnershipInstruction(
	// Params:
	multisigIdParam [32]uint8,
	proposedOwnerParam solanago.PublicKey,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_TransferOwnership[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `multisigIdParam`:
		err = enc__.Encode(multisigIdParam)
		if err != nil {
			return nil, errors.NewField("multisigIdParam", err)
		}
		// Serialize `proposedOwnerParam`:
		err = enc__.Encode(proposedOwnerParam)
		if err != nil {
			return nil, errors.NewField("proposedOwnerParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

type AcceptOwnershipInstruction struct {
	MultisigId [32]uint8 `json:"_multisig_id"`

	// Accounts:
	Config          solanago.PublicKey `json:"config"`
	ConfigWritable  bool               `json:"config_writable"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
}

func (obj *AcceptOwnershipInstruction) GetDiscriminator() []byte {
	return Instruction_AcceptOwnership[:]
}

// UnmarshalWithDecoder unmarshals the AcceptOwnershipInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *AcceptOwnershipInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "AcceptOwnershipInstruction", err)
	}
	if discriminator != Instruction_AcceptOwnership {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "AcceptOwnershipInstruction", Instruction_AcceptOwnership, discriminator)
	}
	// Deserialize `MultisigId`:
	err = decoder.Decode(&obj.MultisigId)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AcceptOwnershipInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AcceptOwnershipInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 2 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 2, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AcceptOwnershipInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the AcceptOwnershipInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *AcceptOwnershipInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AcceptOwnershipInstruction: %w", err)
	}
	return nil
}

// UnmarshalAcceptOwnershipInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalAcceptOwnershipInstruction(buf []byte) (*AcceptOwnershipInstruction, error) {
	obj := new(AcceptOwnershipInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type AppendSignaturesInstruction struct {
	MultisigId      [32]uint8   `json:"multisig_id"`
	Root            [32]uint8   `json:"root"`
	ValidUntil      uint32      `json:"valid_until"`
	SignaturesBatch []Signature `json:"signatures_batch"`

	// Accounts:
	Signatures         solanago.PublicKey `json:"signatures"`
	SignaturesWritable bool               `json:"signatures_writable"`
	Authority          solanago.PublicKey `json:"authority"`
	AuthorityWritable  bool               `json:"authority_writable"`
	AuthoritySigner    bool               `json:"authority_signer"`
}

func (obj *AppendSignaturesInstruction) GetDiscriminator() []byte {
	return Instruction_AppendSignatures[:]
}

// UnmarshalWithDecoder unmarshals the AppendSignaturesInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *AppendSignaturesInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "AppendSignaturesInstruction", err)
	}
	if discriminator != Instruction_AppendSignatures {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "AppendSignaturesInstruction", Instruction_AppendSignatures, discriminator)
	}
	// Deserialize `MultisigId`:
	err = decoder.Decode(&obj.MultisigId)
	if err != nil {
		return err
	}
	// Deserialize `Root`:
	err = decoder.Decode(&obj.Root)
	if err != nil {
		return err
	}
	// Deserialize `ValidUntil`:
	err = decoder.Decode(&obj.ValidUntil)
	if err != nil {
		return err
	}
	// Deserialize `SignaturesBatch`:
	err = decoder.Decode(&obj.SignaturesBatch)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AppendSignaturesInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from signatures account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "signatures", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AppendSignaturesInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 2 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 2, len(indices))
	}
	indexOffset := 0
	// Set signatures account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "signatures", len(accountKeys)-1)
	}
	obj.Signatures = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AppendSignaturesInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Signatures)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the AppendSignaturesInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *AppendSignaturesInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AppendSignaturesInstruction: %w", err)
	}
	return nil
}

// UnmarshalAppendSignaturesInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalAppendSignaturesInstruction(buf []byte) (*AppendSignaturesInstruction, error) {
	obj := new(AppendSignaturesInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type AppendSignersInstruction struct {
	MultisigId   [32]uint8   `json:"multisig_id"`
	SignersBatch [][20]uint8 `json:"signers_batch"`

	// Accounts:
	MultisigConfig        solanago.PublicKey `json:"multisig_config"`
	ConfigSigners         solanago.PublicKey `json:"config_signers"`
	ConfigSignersWritable bool               `json:"config_signers_writable"`
	Authority             solanago.PublicKey `json:"authority"`
	AuthorityWritable     bool               `json:"authority_writable"`
	AuthoritySigner       bool               `json:"authority_signer"`
}

func (obj *AppendSignersInstruction) GetDiscriminator() []byte {
	return Instruction_AppendSigners[:]
}

// UnmarshalWithDecoder unmarshals the AppendSignersInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *AppendSignersInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "AppendSignersInstruction", err)
	}
	if discriminator != Instruction_AppendSigners {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "AppendSignersInstruction", Instruction_AppendSigners, discriminator)
	}
	// Deserialize `MultisigId`:
	err = decoder.Decode(&obj.MultisigId)
	if err != nil {
		return err
	}
	// Deserialize `SignersBatch`:
	err = decoder.Decode(&obj.SignersBatch)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AppendSignersInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from multisig_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "multisig_config", err)
	}
	indices = append(indices, index)
	// Decode from config_signers account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config_signers", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AppendSignersInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set multisig_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "multisig_config", len(accountKeys)-1)
	}
	obj.MultisigConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config_signers account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config_signers", len(accountKeys)-1)
	}
	obj.ConfigSigners = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AppendSignersInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.MultisigConfig)
	keys = append(keys, obj.ConfigSigners)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the AppendSignersInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *AppendSignersInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AppendSignersInstruction: %w", err)
	}
	return nil
}

// UnmarshalAppendSignersInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalAppendSignersInstruction(buf []byte) (*AppendSignersInstruction, error) {
	obj := new(AppendSignersInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ClearSignaturesInstruction struct {
	MultisigId [32]uint8 `json:"multisig_id"`
	Root       [32]uint8 `json:"root"`
	ValidUntil uint32    `json:"valid_until"`

	// Accounts:
	Signatures         solanago.PublicKey `json:"signatures"`
	SignaturesWritable bool               `json:"signatures_writable"`
	Authority          solanago.PublicKey `json:"authority"`
	AuthorityWritable  bool               `json:"authority_writable"`
	AuthoritySigner    bool               `json:"authority_signer"`
}

func (obj *ClearSignaturesInstruction) GetDiscriminator() []byte {
	return Instruction_ClearSignatures[:]
}

// UnmarshalWithDecoder unmarshals the ClearSignaturesInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *ClearSignaturesInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "ClearSignaturesInstruction", err)
	}
	if discriminator != Instruction_ClearSignatures {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "ClearSignaturesInstruction", Instruction_ClearSignatures, discriminator)
	}
	// Deserialize `MultisigId`:
	err = decoder.Decode(&obj.MultisigId)
	if err != nil {
		return err
	}
	// Deserialize `Root`:
	err = decoder.Decode(&obj.Root)
	if err != nil {
		return err
	}
	// Deserialize `ValidUntil`:
	err = decoder.Decode(&obj.ValidUntil)
	if err != nil {
		return err
	}
	return nil
}

func (obj *ClearSignaturesInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from signatures account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "signatures", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *ClearSignaturesInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 2 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 2, len(indices))
	}
	indexOffset := 0
	// Set signatures account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "signatures", len(accountKeys)-1)
	}
	obj.Signatures = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *ClearSignaturesInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Signatures)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the ClearSignaturesInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *ClearSignaturesInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ClearSignaturesInstruction: %w", err)
	}
	return nil
}

// UnmarshalClearSignaturesInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalClearSignaturesInstruction(buf []byte) (*ClearSignaturesInstruction, error) {
	obj := new(ClearSignaturesInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ClearSignersInstruction struct {
	MultisigId [32]uint8 `json:"multisig_id"`

	// Accounts:
	MultisigConfig        solanago.PublicKey `json:"multisig_config"`
	ConfigSigners         solanago.PublicKey `json:"config_signers"`
	ConfigSignersWritable bool               `json:"config_signers_writable"`
	Authority             solanago.PublicKey `json:"authority"`
	AuthorityWritable     bool               `json:"authority_writable"`
	AuthoritySigner       bool               `json:"authority_signer"`
}

func (obj *ClearSignersInstruction) GetDiscriminator() []byte {
	return Instruction_ClearSigners[:]
}

// UnmarshalWithDecoder unmarshals the ClearSignersInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *ClearSignersInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "ClearSignersInstruction", err)
	}
	if discriminator != Instruction_ClearSigners {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "ClearSignersInstruction", Instruction_ClearSigners, discriminator)
	}
	// Deserialize `MultisigId`:
	err = decoder.Decode(&obj.MultisigId)
	if err != nil {
		return err
	}
	return nil
}

func (obj *ClearSignersInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from multisig_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "multisig_config", err)
	}
	indices = append(indices, index)
	// Decode from config_signers account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config_signers", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *ClearSignersInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set multisig_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "multisig_config", len(accountKeys)-1)
	}
	obj.MultisigConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config_signers account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config_signers", len(accountKeys)-1)
	}
	obj.ConfigSigners = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *ClearSignersInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.MultisigConfig)
	keys = append(keys, obj.ConfigSigners)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the ClearSignersInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *ClearSignersInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ClearSignersInstruction: %w", err)
	}
	return nil
}

// UnmarshalClearSignersInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalClearSignersInstruction(buf []byte) (*ClearSignersInstruction, error) {
	obj := new(ClearSignersInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ExecuteInstruction struct {
	MultisigId [32]uint8   `json:"multisig_id"`
	ChainId    uint64      `json:"chain_id"`
	Nonce      uint64      `json:"nonce"`
	Data       []byte      `json:"data"`
	Proof      [][32]uint8 `json:"proof"`

	// Accounts:
	MultisigConfig                 solanago.PublicKey `json:"multisig_config"`
	MultisigConfigWritable         bool               `json:"multisig_config_writable"`
	RootMetadata                   solanago.PublicKey `json:"root_metadata"`
	ExpiringRootAndOpCount         solanago.PublicKey `json:"expiring_root_and_op_count"`
	ExpiringRootAndOpCountWritable bool               `json:"expiring_root_and_op_count_writable"`
	To                             solanago.PublicKey `json:"to"`
	MultisigSigner                 solanago.PublicKey `json:"multisig_signer"`
	Authority                      solanago.PublicKey `json:"authority"`
	AuthorityWritable              bool               `json:"authority_writable"`
	AuthoritySigner                bool               `json:"authority_signer"`
}

func (obj *ExecuteInstruction) GetDiscriminator() []byte {
	return Instruction_Execute[:]
}

// UnmarshalWithDecoder unmarshals the ExecuteInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *ExecuteInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "ExecuteInstruction", err)
	}
	if discriminator != Instruction_Execute {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "ExecuteInstruction", Instruction_Execute, discriminator)
	}
	// Deserialize `MultisigId`:
	err = decoder.Decode(&obj.MultisigId)
	if err != nil {
		return err
	}
	// Deserialize `ChainId`:
	err = decoder.Decode(&obj.ChainId)
	if err != nil {
		return err
	}
	// Deserialize `Nonce`:
	err = decoder.Decode(&obj.Nonce)
	if err != nil {
		return err
	}
	// Deserialize `Data`:
	err = decoder.Decode(&obj.Data)
	if err != nil {
		return err
	}
	// Deserialize `Proof`:
	err = decoder.Decode(&obj.Proof)
	if err != nil {
		return err
	}
	return nil
}

func (obj *ExecuteInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from multisig_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "multisig_config", err)
	}
	indices = append(indices, index)
	// Decode from root_metadata account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "root_metadata", err)
	}
	indices = append(indices, index)
	// Decode from expiring_root_and_op_count account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "expiring_root_and_op_count", err)
	}
	indices = append(indices, index)
	// Decode from to account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "to", err)
	}
	indices = append(indices, index)
	// Decode from multisig_signer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "multisig_signer", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *ExecuteInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 6 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 6, len(indices))
	}
	indexOffset := 0
	// Set multisig_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "multisig_config", len(accountKeys)-1)
	}
	obj.MultisigConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set root_metadata account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "root_metadata", len(accountKeys)-1)
	}
	obj.RootMetadata = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set expiring_root_and_op_count account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "expiring_root_and_op_count", len(accountKeys)-1)
	}
	obj.ExpiringRootAndOpCount = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set to account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "to", len(accountKeys)-1)
	}
	obj.To = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set multisig_signer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "multisig_signer", len(accountKeys)-1)
	}
	obj.MultisigSigner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *ExecuteInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.MultisigConfig)
	keys = append(keys, obj.RootMetadata)
	keys = append(keys, obj.ExpiringRootAndOpCount)
	keys = append(keys, obj.To)
	keys = append(keys, obj.MultisigSigner)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the ExecuteInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *ExecuteInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ExecuteInstruction: %w", err)
	}
	return nil
}

// UnmarshalExecuteInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalExecuteInstruction(buf []byte) (*ExecuteInstruction, error) {
	obj := new(ExecuteInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type FinalizeSignaturesInstruction struct {
	MultisigId [32]uint8 `json:"multisig_id"`
	Root       [32]uint8 `json:"root"`
	ValidUntil uint32    `json:"valid_until"`

	// Accounts:
	Signatures         solanago.PublicKey `json:"signatures"`
	SignaturesWritable bool               `json:"signatures_writable"`
	Authority          solanago.PublicKey `json:"authority"`
	AuthorityWritable  bool               `json:"authority_writable"`
	AuthoritySigner    bool               `json:"authority_signer"`
}

func (obj *FinalizeSignaturesInstruction) GetDiscriminator() []byte {
	return Instruction_FinalizeSignatures[:]
}

// UnmarshalWithDecoder unmarshals the FinalizeSignaturesInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *FinalizeSignaturesInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "FinalizeSignaturesInstruction", err)
	}
	if discriminator != Instruction_FinalizeSignatures {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "FinalizeSignaturesInstruction", Instruction_FinalizeSignatures, discriminator)
	}
	// Deserialize `MultisigId`:
	err = decoder.Decode(&obj.MultisigId)
	if err != nil {
		return err
	}
	// Deserialize `Root`:
	err = decoder.Decode(&obj.Root)
	if err != nil {
		return err
	}
	// Deserialize `ValidUntil`:
	err = decoder.Decode(&obj.ValidUntil)
	if err != nil {
		return err
	}
	return nil
}

func (obj *FinalizeSignaturesInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from signatures account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "signatures", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *FinalizeSignaturesInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 2 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 2, len(indices))
	}
	indexOffset := 0
	// Set signatures account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "signatures", len(accountKeys)-1)
	}
	obj.Signatures = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *FinalizeSignaturesInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Signatures)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the FinalizeSignaturesInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *FinalizeSignaturesInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling FinalizeSignaturesInstruction: %w", err)
	}
	return nil
}

// UnmarshalFinalizeSignaturesInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalFinalizeSignaturesInstruction(buf []byte) (*FinalizeSignaturesInstruction, error) {
	obj := new(FinalizeSignaturesInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type FinalizeSignersInstruction struct {
	MultisigId [32]uint8 `json:"multisig_id"`

	// Accounts:
	MultisigConfig        solanago.PublicKey `json:"multisig_config"`
	ConfigSigners         solanago.PublicKey `json:"config_signers"`
	ConfigSignersWritable bool               `json:"config_signers_writable"`
	Authority             solanago.PublicKey `json:"authority"`
	AuthorityWritable     bool               `json:"authority_writable"`
	AuthoritySigner       bool               `json:"authority_signer"`
}

func (obj *FinalizeSignersInstruction) GetDiscriminator() []byte {
	return Instruction_FinalizeSigners[:]
}

// UnmarshalWithDecoder unmarshals the FinalizeSignersInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *FinalizeSignersInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "FinalizeSignersInstruction", err)
	}
	if discriminator != Instruction_FinalizeSigners {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "FinalizeSignersInstruction", Instruction_FinalizeSigners, discriminator)
	}
	// Deserialize `MultisigId`:
	err = decoder.Decode(&obj.MultisigId)
	if err != nil {
		return err
	}
	return nil
}

func (obj *FinalizeSignersInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from multisig_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "multisig_config", err)
	}
	indices = append(indices, index)
	// Decode from config_signers account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config_signers", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *FinalizeSignersInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set multisig_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "multisig_config", len(accountKeys)-1)
	}
	obj.MultisigConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config_signers account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config_signers", len(accountKeys)-1)
	}
	obj.ConfigSigners = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *FinalizeSignersInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.MultisigConfig)
	keys = append(keys, obj.ConfigSigners)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the FinalizeSignersInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *FinalizeSignersInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling FinalizeSignersInstruction: %w", err)
	}
	return nil
}

// UnmarshalFinalizeSignersInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalFinalizeSignersInstruction(buf []byte) (*FinalizeSignersInstruction, error) {
	obj := new(FinalizeSignersInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitSignaturesInstruction struct {
	MultisigId      [32]uint8 `json:"multisig_id"`
	Root            [32]uint8 `json:"root"`
	ValidUntil      uint32    `json:"valid_until"`
	TotalSignatures uint8     `json:"total_signatures"`

	// Accounts:
	Signatures         solanago.PublicKey `json:"signatures"`
	SignaturesWritable bool               `json:"signatures_writable"`
	Authority          solanago.PublicKey `json:"authority"`
	AuthorityWritable  bool               `json:"authority_writable"`
	AuthoritySigner    bool               `json:"authority_signer"`
	SystemProgram      solanago.PublicKey `json:"system_program"`
}

func (obj *InitSignaturesInstruction) GetDiscriminator() []byte {
	return Instruction_InitSignatures[:]
}

// UnmarshalWithDecoder unmarshals the InitSignaturesInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *InitSignaturesInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "InitSignaturesInstruction", err)
	}
	if discriminator != Instruction_InitSignatures {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "InitSignaturesInstruction", Instruction_InitSignatures, discriminator)
	}
	// Deserialize `MultisigId`:
	err = decoder.Decode(&obj.MultisigId)
	if err != nil {
		return err
	}
	// Deserialize `Root`:
	err = decoder.Decode(&obj.Root)
	if err != nil {
		return err
	}
	// Deserialize `ValidUntil`:
	err = decoder.Decode(&obj.ValidUntil)
	if err != nil {
		return err
	}
	// Deserialize `TotalSignatures`:
	err = decoder.Decode(&obj.TotalSignatures)
	if err != nil {
		return err
	}
	return nil
}

func (obj *InitSignaturesInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from signatures account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "signatures", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitSignaturesInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set signatures account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "signatures", len(accountKeys)-1)
	}
	obj.Signatures = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitSignaturesInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Signatures)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the InitSignaturesInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *InitSignaturesInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitSignaturesInstruction: %w", err)
	}
	return nil
}

// UnmarshalInitSignaturesInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalInitSignaturesInstruction(buf []byte) (*InitSignaturesInstruction, error) {
	obj := new(InitSignaturesInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitSignersInstruction struct {
	MultisigId   [32]uint8 `json:"multisig_id"`
	TotalSigners uint8     `json:"total_signers"`

	// Accounts:
	MultisigConfig        solanago.PublicKey `json:"multisig_config"`
	ConfigSigners         solanago.PublicKey `json:"config_signers"`
	ConfigSignersWritable bool               `json:"config_signers_writable"`
	Authority             solanago.PublicKey `json:"authority"`
	AuthorityWritable     bool               `json:"authority_writable"`
	AuthoritySigner       bool               `json:"authority_signer"`
	SystemProgram         solanago.PublicKey `json:"system_program"`
}

func (obj *InitSignersInstruction) GetDiscriminator() []byte {
	return Instruction_InitSigners[:]
}

// UnmarshalWithDecoder unmarshals the InitSignersInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *InitSignersInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "InitSignersInstruction", err)
	}
	if discriminator != Instruction_InitSigners {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "InitSignersInstruction", Instruction_InitSigners, discriminator)
	}
	// Deserialize `MultisigId`:
	err = decoder.Decode(&obj.MultisigId)
	if err != nil {
		return err
	}
	// Deserialize `TotalSigners`:
	err = decoder.Decode(&obj.TotalSigners)
	if err != nil {
		return err
	}
	return nil
}

func (obj *InitSignersInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from multisig_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "multisig_config", err)
	}
	indices = append(indices, index)
	// Decode from config_signers account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config_signers", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitSignersInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set multisig_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "multisig_config", len(accountKeys)-1)
	}
	obj.MultisigConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config_signers account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config_signers", len(accountKeys)-1)
	}
	obj.ConfigSigners = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitSignersInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.MultisigConfig)
	keys = append(keys, obj.ConfigSigners)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the InitSignersInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *InitSignersInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitSignersInstruction: %w", err)
	}
	return nil
}

// UnmarshalInitSignersInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalInitSignersInstruction(buf []byte) (*InitSignersInstruction, error) {
	obj := new(InitSignersInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitializeInstruction struct {
	ChainId    uint64    `json:"chain_id"`
	MultisigId [32]uint8 `json:"multisig_id"`

	// Accounts:
	MultisigConfig                 solanago.PublicKey `json:"multisig_config"`
	MultisigConfigWritable         bool               `json:"multisig_config_writable"`
	Authority                      solanago.PublicKey `json:"authority"`
	AuthorityWritable              bool               `json:"authority_writable"`
	AuthoritySigner                bool               `json:"authority_signer"`
	SystemProgram                  solanago.PublicKey `json:"system_program"`
	Program                        solanago.PublicKey `json:"program"`
	ProgramData                    solanago.PublicKey `json:"program_data"`
	RootMetadata                   solanago.PublicKey `json:"root_metadata"`
	RootMetadataWritable           bool               `json:"root_metadata_writable"`
	ExpiringRootAndOpCount         solanago.PublicKey `json:"expiring_root_and_op_count"`
	ExpiringRootAndOpCountWritable bool               `json:"expiring_root_and_op_count_writable"`
}

func (obj *InitializeInstruction) GetDiscriminator() []byte {
	return Instruction_Initialize[:]
}

// UnmarshalWithDecoder unmarshals the InitializeInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *InitializeInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "InitializeInstruction", err)
	}
	if discriminator != Instruction_Initialize {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "InitializeInstruction", Instruction_Initialize, discriminator)
	}
	// Deserialize `ChainId`:
	err = decoder.Decode(&obj.ChainId)
	if err != nil {
		return err
	}
	// Deserialize `MultisigId`:
	err = decoder.Decode(&obj.MultisigId)
	if err != nil {
		return err
	}
	return nil
}

func (obj *InitializeInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from multisig_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "multisig_config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	// Decode from program_data account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program_data", err)
	}
	indices = append(indices, index)
	// Decode from root_metadata account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "root_metadata", err)
	}
	indices = append(indices, index)
	// Decode from expiring_root_and_op_count account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "expiring_root_and_op_count", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitializeInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 7 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 7, len(indices))
	}
	indexOffset := 0
	// Set multisig_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "multisig_config", len(accountKeys)-1)
	}
	obj.MultisigConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program_data account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program_data", len(accountKeys)-1)
	}
	obj.ProgramData = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set root_metadata account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "root_metadata", len(accountKeys)-1)
	}
	obj.RootMetadata = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set expiring_root_and_op_count account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "expiring_root_and_op_count", len(accountKeys)-1)
	}
	obj.ExpiringRootAndOpCount = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitializeInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.MultisigConfig)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.Program)
	keys = append(keys, obj.ProgramData)
	keys = append(keys, obj.RootMetadata)
	keys = append(keys, obj.ExpiringRootAndOpCount)
	return keys
}

// Unmarshal unmarshals the InitializeInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *InitializeInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitializeInstruction: %w", err)
	}
	return nil
}

// UnmarshalInitializeInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalInitializeInstruction(buf []byte) (*InitializeInstruction, error) {
	obj := new(InitializeInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SetConfigInstruction struct {
	MultisigId   [32]uint8 `json:"multisig_id"`
	SignerGroups []byte    `json:"signer_groups"`
	GroupQuorums [32]uint8 `json:"group_quorums"`
	GroupParents [32]uint8 `json:"group_parents"`
	ClearRoot    bool      `json:"clear_root"`

	// Accounts:
	MultisigConfig                 solanago.PublicKey `json:"multisig_config"`
	MultisigConfigWritable         bool               `json:"multisig_config_writable"`
	ConfigSigners                  solanago.PublicKey `json:"config_signers"`
	ConfigSignersWritable          bool               `json:"config_signers_writable"`
	RootMetadata                   solanago.PublicKey `json:"root_metadata"`
	RootMetadataWritable           bool               `json:"root_metadata_writable"`
	ExpiringRootAndOpCount         solanago.PublicKey `json:"expiring_root_and_op_count"`
	ExpiringRootAndOpCountWritable bool               `json:"expiring_root_and_op_count_writable"`
	Authority                      solanago.PublicKey `json:"authority"`
	AuthorityWritable              bool               `json:"authority_writable"`
	AuthoritySigner                bool               `json:"authority_signer"`
	SystemProgram                  solanago.PublicKey `json:"system_program"`
}

func (obj *SetConfigInstruction) GetDiscriminator() []byte {
	return Instruction_SetConfig[:]
}

// UnmarshalWithDecoder unmarshals the SetConfigInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *SetConfigInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "SetConfigInstruction", err)
	}
	if discriminator != Instruction_SetConfig {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "SetConfigInstruction", Instruction_SetConfig, discriminator)
	}
	// Deserialize `MultisigId`:
	err = decoder.Decode(&obj.MultisigId)
	if err != nil {
		return err
	}
	// Deserialize `SignerGroups`:
	err = decoder.Decode(&obj.SignerGroups)
	if err != nil {
		return err
	}
	// Deserialize `GroupQuorums`:
	err = decoder.Decode(&obj.GroupQuorums)
	if err != nil {
		return err
	}
	// Deserialize `GroupParents`:
	err = decoder.Decode(&obj.GroupParents)
	if err != nil {
		return err
	}
	// Deserialize `ClearRoot`:
	err = decoder.Decode(&obj.ClearRoot)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SetConfigInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from multisig_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "multisig_config", err)
	}
	indices = append(indices, index)
	// Decode from config_signers account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config_signers", err)
	}
	indices = append(indices, index)
	// Decode from root_metadata account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "root_metadata", err)
	}
	indices = append(indices, index)
	// Decode from expiring_root_and_op_count account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "expiring_root_and_op_count", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SetConfigInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 6 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 6, len(indices))
	}
	indexOffset := 0
	// Set multisig_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "multisig_config", len(accountKeys)-1)
	}
	obj.MultisigConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config_signers account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config_signers", len(accountKeys)-1)
	}
	obj.ConfigSigners = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set root_metadata account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "root_metadata", len(accountKeys)-1)
	}
	obj.RootMetadata = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set expiring_root_and_op_count account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "expiring_root_and_op_count", len(accountKeys)-1)
	}
	obj.ExpiringRootAndOpCount = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SetConfigInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.MultisigConfig)
	keys = append(keys, obj.ConfigSigners)
	keys = append(keys, obj.RootMetadata)
	keys = append(keys, obj.ExpiringRootAndOpCount)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the SetConfigInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *SetConfigInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SetConfigInstruction: %w", err)
	}
	return nil
}

// UnmarshalSetConfigInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalSetConfigInstruction(buf []byte) (*SetConfigInstruction, error) {
	obj := new(SetConfigInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SetRootInstruction struct {
	MultisigId    [32]uint8         `json:"multisig_id"`
	Root          [32]uint8         `json:"root"`
	ValidUntil    uint32            `json:"valid_until"`
	Metadata      RootMetadataInput `json:"metadata"`
	MetadataProof [][32]uint8       `json:"metadata_proof"`

	// Accounts:
	RootSignatures                 solanago.PublicKey `json:"root_signatures"`
	RootSignaturesWritable         bool               `json:"root_signatures_writable"`
	RootMetadata                   solanago.PublicKey `json:"root_metadata"`
	RootMetadataWritable           bool               `json:"root_metadata_writable"`
	SeenSignedHashes               solanago.PublicKey `json:"seen_signed_hashes"`
	SeenSignedHashesWritable       bool               `json:"seen_signed_hashes_writable"`
	ExpiringRootAndOpCount         solanago.PublicKey `json:"expiring_root_and_op_count"`
	ExpiringRootAndOpCountWritable bool               `json:"expiring_root_and_op_count_writable"`
	MultisigConfig                 solanago.PublicKey `json:"multisig_config"`
	Authority                      solanago.PublicKey `json:"authority"`
	AuthorityWritable              bool               `json:"authority_writable"`
	AuthoritySigner                bool               `json:"authority_signer"`
	SystemProgram                  solanago.PublicKey `json:"system_program"`
}

func (obj *SetRootInstruction) GetDiscriminator() []byte {
	return Instruction_SetRoot[:]
}

// UnmarshalWithDecoder unmarshals the SetRootInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *SetRootInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "SetRootInstruction", err)
	}
	if discriminator != Instruction_SetRoot {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "SetRootInstruction", Instruction_SetRoot, discriminator)
	}
	// Deserialize `MultisigId`:
	err = decoder.Decode(&obj.MultisigId)
	if err != nil {
		return err
	}
	// Deserialize `Root`:
	err = decoder.Decode(&obj.Root)
	if err != nil {
		return err
	}
	// Deserialize `ValidUntil`:
	err = decoder.Decode(&obj.ValidUntil)
	if err != nil {
		return err
	}
	// Deserialize `Metadata`:
	err = decoder.Decode(&obj.Metadata)
	if err != nil {
		return err
	}
	// Deserialize `MetadataProof`:
	err = decoder.Decode(&obj.MetadataProof)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SetRootInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from root_signatures account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "root_signatures", err)
	}
	indices = append(indices, index)
	// Decode from root_metadata account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "root_metadata", err)
	}
	indices = append(indices, index)
	// Decode from seen_signed_hashes account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "seen_signed_hashes", err)
	}
	indices = append(indices, index)
	// Decode from expiring_root_and_op_count account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "expiring_root_and_op_count", err)
	}
	indices = append(indices, index)
	// Decode from multisig_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "multisig_config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SetRootInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 7 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 7, len(indices))
	}
	indexOffset := 0
	// Set root_signatures account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "root_signatures", len(accountKeys)-1)
	}
	obj.RootSignatures = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set root_metadata account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "root_metadata", len(accountKeys)-1)
	}
	obj.RootMetadata = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set seen_signed_hashes account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "seen_signed_hashes", len(accountKeys)-1)
	}
	obj.SeenSignedHashes = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set expiring_root_and_op_count account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "expiring_root_and_op_count", len(accountKeys)-1)
	}
	obj.ExpiringRootAndOpCount = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set multisig_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "multisig_config", len(accountKeys)-1)
	}
	obj.MultisigConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SetRootInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.RootSignatures)
	keys = append(keys, obj.RootMetadata)
	keys = append(keys, obj.SeenSignedHashes)
	keys = append(keys, obj.ExpiringRootAndOpCount)
	keys = append(keys, obj.MultisigConfig)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the SetRootInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *SetRootInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SetRootInstruction: %w", err)
	}
	return nil
}

// UnmarshalSetRootInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalSetRootInstruction(buf []byte) (*SetRootInstruction, error) {
	obj := new(SetRootInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type TransferOwnershipInstruction struct {
	MultisigId    [32]uint8          `json:"_multisig_id"`
	ProposedOwner solanago.PublicKey `json:"proposed_owner"`

	// Accounts:
	Config          solanago.PublicKey `json:"config"`
	ConfigWritable  bool               `json:"config_writable"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
}

func (obj *TransferOwnershipInstruction) GetDiscriminator() []byte {
	return Instruction_TransferOwnership[:]
}

// UnmarshalWithDecoder unmarshals the TransferOwnershipInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *TransferOwnershipInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "TransferOwnershipInstruction", err)
	}
	if discriminator != Instruction_TransferOwnership {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "TransferOwnershipInstruction", Instruction_TransferOwnership, discriminator)
	}
	// Deserialize `MultisigId`:
	err = decoder.Decode(&obj.MultisigId)
	if err != nil {
		return err
	}
	// Deserialize `ProposedOwner`:
	err = decoder.Decode(&obj.ProposedOwner)
	if err != nil {
		return err
	}
	return nil
}

func (obj *TransferOwnershipInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *TransferOwnershipInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 2 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 2, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *TransferOwnershipInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the TransferOwnershipInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *TransferOwnershipInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling TransferOwnershipInstruction: %w", err)
	}
	return nil
}

// UnmarshalTransferOwnershipInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalTransferOwnershipInstruction(buf []byte) (*TransferOwnershipInstruction, error) {
	obj := new(TransferOwnershipInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Instruction interface defines common methods for all instruction types
type Instruction interface {
	GetDiscriminator() []byte

	UnmarshalWithDecoder(decoder *binary.Decoder) error

	UnmarshalAccountIndices(buf []byte) ([]uint8, error)

	PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error

	GetAccountKeys() []solanago.PublicKey
}

// ParseInstruction parses instruction data and optionally populates accounts
// If accountIndicesData is nil or empty, accounts will not be populated
func ParseInstruction(instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (Instruction, error) {
	// Validate inputs
	if len(instructionData) < 8 {
		return nil, fmt.Errorf("instruction data too short: expected at least 8 bytes, got %d", len(instructionData))
	}
	// Extract discriminator
	discriminator := [8]byte{}
	copy(discriminator[:], instructionData[0:8])
	// Parse based on discriminator
	switch discriminator {
	case Instruction_AcceptOwnership:
		instruction := new(AcceptOwnershipInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AcceptOwnershipInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_AppendSignatures:
		instruction := new(AppendSignaturesInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AppendSignaturesInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_AppendSigners:
		instruction := new(AppendSignersInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AppendSignersInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_ClearSignatures:
		instruction := new(ClearSignaturesInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as ClearSignaturesInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_ClearSigners:
		instruction := new(ClearSignersInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as ClearSignersInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_Execute:
		instruction := new(ExecuteInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as ExecuteInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_FinalizeSignatures:
		instruction := new(FinalizeSignaturesInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as FinalizeSignaturesInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_FinalizeSigners:
		instruction := new(FinalizeSignersInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as FinalizeSignersInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_InitSignatures:
		instruction := new(InitSignaturesInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitSignaturesInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_InitSigners:
		instruction := new(InitSignersInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitSignersInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_Initialize:
		instruction := new(InitializeInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitializeInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SetConfig:
		instruction := new(SetConfigInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SetConfigInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SetRoot:
		instruction := new(SetRootInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SetRootInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_TransferOwnership:
		instruction := new(TransferOwnershipInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as TransferOwnershipInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	default:
		return nil, fmt.Errorf("unknown instruction discriminator: %s", binary.FormatDiscriminator(discriminator))
	}
}

// ParseInstructionTyped parses instruction data and returns a specific instruction type // T must implement the Instruction interface
func ParseInstructionTyped[T Instruction](instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (T, error) {
	instruction, err := ParseInstruction(instructionData, accountIndicesData, accountKeys)
	if err != nil {
		return *new(T), err
	}
	typed, ok := instruction.(T)
	if !ok {
		return *new(T), fmt.Errorf("instruction is not of expected type")
	}
	return typed, nil
}

// ParseInstructionWithoutAccounts parses instruction data without account information
func ParseInstructionWithoutAccounts(instructionData []byte) (Instruction, error) {
	return ParseInstruction(instructionData, nil, []solanago.PublicKey{})
}

// ParseInstructionWithAccounts parses instruction data with account information
func ParseInstructionWithAccounts(instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (Instruction, error) {
	return ParseInstruction(instructionData, accountIndicesData, accountKeys)
}
