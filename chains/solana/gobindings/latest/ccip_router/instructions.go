// Code generated by https://github.com/Unheilbar/anchor-go. DO NOT EDIT.
// This file contains instructions and instruction parsers.

package ccip_router

import (
	"bytes"
	"fmt"
	errors "github.com/Unheilbar/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "accept_admin_role_token_admin_registry" instruction.
// Accepts the admin role of the token admin registry. //  // The Pending Admin must call this function to accept the admin role of the Token Admin Registry. //  // # Arguments //  // * `ctx` - The context containing the accounts required for accepting the admin role. // * `mint` - The public key of the token mint.
func NewAcceptAdminRoleTokenAdminRegistryInstruction(
	configAccount solanago.PublicKey,
	tokenAdminRegistryAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AcceptAdminRoleTokenAdminRegistry[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "token_admin_registry": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenAdminRegistryAccount, true, false))
		// Account 2 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "accept_ownership" instruction.
// Accepts the ownership of the router by the proposed owner. //  // Shared func signature with other programs //  // # Arguments //  // * `ctx` - The context containing the accounts required for accepting ownership. // The new owner must be a signer of the transaction.
func NewAcceptOwnershipInstruction(
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AcceptOwnership[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "add_chain_selector" instruction.
// Adds a new chain selector to the router. //  // The Admin needs to add any new chain supported (this means both OnRamp and OffRamp). // When adding a new chain, the Admin needs to specify if it's enabled or not. // They may enable only source, or only destination, or neither, or both. //  // # Arguments //  // * `ctx` - The context containing the accounts required for adding the chain selector. // * `new_chain_selector` - The new chain selector to be added. // * `source_chain_config` - The configuration for the chain as source. // * `dest_chain_config` - The configuration for the chain as destination.
func NewAddChainSelectorInstruction(
	// Params:
	newChainSelectorParam uint64,
	destChainConfigParam DestChainConfig,

	// Accounts:
	destChainStateAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AddChainSelector[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newChainSelectorParam`:
		err = enc__.Encode(newChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("newChainSelectorParam", err)
		}
		// Serialize `destChainConfigParam`:
		err = enc__.Encode(destChainConfigParam)
		if err != nil {
			return nil, errors.NewField("destChainConfigParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "dest_chain_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(destChainStateAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "add_offramp" instruction.
// Add an offramp address to the list of offramps allowed by the router, for a // particular source chain. External users will check this list before accepting // a `ccip_receive` CPI. //  // # Arguments //  // * `ctx` - The context containing the accounts required for this operation. // * `source_chain_selector` - The source chain for the offramp's lane. // * `offramp` - The offramp's address.
func NewAddOfframpInstruction(
	// Params:
	sourceChainSelectorParam uint64,
	offrampParam solanago.PublicKey,

	// Accounts:
	allowedOfframpAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AddOfframp[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `sourceChainSelectorParam`:
		err = enc__.Encode(sourceChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("sourceChainSelectorParam", err)
		}
		// Serialize `offrampParam`:
		err = enc__.Encode(offrampParam)
		if err != nil {
			return nil, errors.NewField("offrampParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "allowed_offramp": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(allowedOfframpAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "bump_ccip_version_for_dest_chain" instruction.
// Bumps the CCIP version for a destination chain. // This effectively just resets the sequence number of the destination chain state. // If there had been a previous rollback, on re-upgrade the sequence number will resume from where it was // prior to the rollback. //  // # Arguments // * `ctx` - The context containing the accounts required for the bump. // * `dest_chain_selector` - The destination chain selector to bump version for.
func NewBumpCcipVersionForDestChainInstruction(
	// Params:
	destChainSelectorParam uint64,

	// Accounts:
	destChainStateAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_BumpCcipVersionForDestChain[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `destChainSelectorParam`:
		err = enc__.Encode(destChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("destChainSelectorParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "dest_chain_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(destChainStateAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "ccip_admin_override_pending_administrator" instruction.
// Overrides the pending admin of the Token Admin Registry //  // # Arguments //  // * `ctx` - The context containing the accounts required for registration. // * `token_admin_registry_admin` - The public key of the token admin registry admin to propose.
func NewCcipAdminOverridePendingAdministratorInstruction(
	// Params:
	tokenAdminRegistryAdminParam solanago.PublicKey,

	// Accounts:
	configAccount solanago.PublicKey,
	tokenAdminRegistryAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CcipAdminOverridePendingAdministrator[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `tokenAdminRegistryAdminParam`:
		err = enc__.Encode(tokenAdminRegistryAdminParam)
		if err != nil {
			return nil, errors.NewField("tokenAdminRegistryAdminParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "token_admin_registry": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenAdminRegistryAccount, true, false))
		// Account 2 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "ccip_admin_propose_administrator" instruction.
// Token Admin Registry // // Registers the Token Admin Registry via the CCIP Admin //  // # Arguments //  // * `ctx` - The context containing the accounts required for registration. // * `token_admin_registry_admin` - The public key of the token admin registry admin to propose.
func NewCcipAdminProposeAdministratorInstruction(
	// Params:
	tokenAdminRegistryAdminParam solanago.PublicKey,

	// Accounts:
	configAccount solanago.PublicKey,
	tokenAdminRegistryAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CcipAdminProposeAdministrator[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `tokenAdminRegistryAdminParam`:
		err = enc__.Encode(tokenAdminRegistryAdminParam)
		if err != nil {
			return nil, errors.NewField("tokenAdminRegistryAdminParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "token_admin_registry": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenAdminRegistryAccount, true, false))
		// Account 2 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "ccip_send" instruction.
// On Ramp Flow // // Sends a message to the destination chain. //  // Request a message to be sent to the destination chain. // The method name needs to be ccip_send with Anchor encoding. // This function is called by the CCIP Sender Contract (or final user) to send a message to the CCIP Router. // The message will be sent to the receiver on the destination chain selector. // This message emits the event CCIPMessageSent with all the necessary data to be retrieved by the OffChain Code //  // # Arguments //  // * `ctx` - The context containing the accounts required for sending the message. // * `dest_chain_selector` - The chain selector for the destination chain. // * `message` - The message to be sent. The size limit of data is 256 bytes. // * `token_indexes` - Indices into the remaining accounts vector where the subslice for a token begins.
func NewCcipSendInstruction(
	// Params:
	destChainSelectorParam uint64,
	messageParam Svm2AnyMessage,
	tokenIndexesParam []byte,

	// Accounts:
	configAccount solanago.PublicKey,
	destChainStateAccount solanago.PublicKey,
	nonceAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	feeTokenProgramAccount solanago.PublicKey,
	feeTokenMintAccount solanago.PublicKey,
	feeTokenUserAssociatedAccountAccount solanago.PublicKey,
	feeTokenReceiverAccount solanago.PublicKey,
	feeBillingSignerAccount solanago.PublicKey,
	feeQuoterAccount solanago.PublicKey,
	feeQuoterConfigAccount solanago.PublicKey,
	feeQuoterDestChainAccount solanago.PublicKey,
	feeQuoterBillingTokenConfigAccount solanago.PublicKey,
	feeQuoterLinkTokenConfigAccount solanago.PublicKey,
	rmnRemoteAccount solanago.PublicKey,
	rmnRemoteCursesAccount solanago.PublicKey,
	rmnRemoteConfigAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CcipSend[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `destChainSelectorParam`:
		err = enc__.Encode(destChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("destChainSelectorParam", err)
		}
		// Serialize `messageParam`:
		err = enc__.Encode(messageParam)
		if err != nil {
			return nil, errors.NewField("messageParam", err)
		}
		// Serialize `tokenIndexesParam`:
		err = enc__.Encode(tokenIndexesParam)
		if err != nil {
			return nil, errors.NewField("tokenIndexesParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "dest_chain_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(destChainStateAccount, true, false))
		// Account 2 "nonce": Writable, Non-signer, Required
		// CHECK this represents the PDA where the message counters are stored. As it may be initialized or not,
		// and it may be in it's v1 or v2 form, it is an UncheckedAccount and the code handles all cases manually.
		accounts__.Append(solanago.NewAccountMeta(nonceAccount, true, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 5 "fee_token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeTokenProgramAccount, false, false))
		// Account 6 "fee_token_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeTokenMintAccount, false, false))
		// Account 7 "fee_token_user_associated_account": Read-only, Non-signer, Required
		// If paying with native SOL, this must be the zero address.
		accounts__.Append(solanago.NewAccountMeta(feeTokenUserAssociatedAccountAccount, false, false))
		// Account 8 "fee_token_receiver": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeTokenReceiverAccount, true, false))
		// Account 9 "fee_billing_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeBillingSignerAccount, false, false))
		// Account 10 "fee_quoter": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeQuoterAccount, false, false))
		// Account 11 "fee_quoter_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeQuoterConfigAccount, false, false))
		// Account 12 "fee_quoter_dest_chain": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeQuoterDestChainAccount, false, false))
		// Account 13 "fee_quoter_billing_token_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeQuoterBillingTokenConfigAccount, false, false))
		// Account 14 "fee_quoter_link_token_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeQuoterLinkTokenConfigAccount, false, false))
		// Account 15 "rmn_remote": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteAccount, false, false))
		// Account 16 "rmn_remote_curses": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteCursesAccount, false, false))
		// Account 17 "rmn_remote_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteConfigAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "derive_accounts_ccip_send" instruction.
// Automatically derives all accounts required to call `ccip_send`. //  // This method receives the bare minimum amount of information needed to construct // the entire account list to send a transaction, and builds it iteratively // over the course of multiple calls. //  // The return type contains: //  // * `accounts_to_save`: The caller must append these accounts to a list they maintain. // When complete, this list will contain all accounts needed to call `ccip_send`. // * `ask_again_with`: When `next_stage` is not empty, the caller must call `derive_accounts_ccip_send` // again, including exactly these accounts as the `remaining_accounts`. // * `lookup_tables_to_save`: The caller must save those LUTs. They can be used for `ccip_send`. // * `current_stage`: A string describing the current stage of the derivation process. When the stage // is "TokenTransferStaticAccounts/<N>/0", it means the `accounts_to_save` block in this response contains // all accounts relating to the Nth token being transferred. Use this information to construct // the `token_indexes` vector that `ccip_send` requires. // * `next_stage`: If nonempty, this means the instruction must get called again with this value // as the `stage` argument. //  // Therefore, and starting with an empty `remaining_accounts` list, the caller must repeatedly // call `derive_accounts_ccip_send` until `next_stage` is returned empty. //  // # Arguments //  // * `ctx`: Context containing only the config. // * `stage`: Requested derivation stage. Pass "Start" the first time, then for each subsequent // call, pass the value returned in `response.next_stage` until empty. // * `params`: // * `ccip_send_caller`: Public key of the account that will sign the call to `ccip_send`. // * `dest_chain_selector`: CCIP chain selector for the dest chain. // * `fee_token_mint`: The mint address for the token used for fees. Pubkey::default() if native SOL. // * `mints_of_transferred_token`: List of all token mints for tokens being transferred.
func NewDeriveAccountsCcipSendInstruction(
	// Params:
	paramsParam DeriveAccountsCcipSendParams,
	stageParam string,

	// Accounts:
	configAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_DeriveAccountsCcipSend[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
		// Serialize `stageParam`:
		err = enc__.Encode(stageParam)
		if err != nil {
			return nil, errors.NewField("stageParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "get_fee" instruction.
// Queries the onramp for the fee required to send a message. //  // This call is permissionless. Note it does not verify whether there's a curse active // in order to avoid the RMN CPI overhead. //  // # Arguments //  // * `ctx` - The context containing the accounts required for obtaining the message fee. // * `dest_chain_selector` - The chain selector for the destination chain. // * `message` - The message to be sent. The size limit of data is 256 bytes.
func NewGetFeeInstruction(
	// Params:
	destChainSelectorParam uint64,
	messageParam Svm2AnyMessage,

	// Accounts:
	configAccount solanago.PublicKey,
	destChainStateAccount solanago.PublicKey,
	feeQuoterAccount solanago.PublicKey,
	feeQuoterConfigAccount solanago.PublicKey,
	feeQuoterDestChainAccount solanago.PublicKey,
	feeQuoterBillingTokenConfigAccount solanago.PublicKey,
	feeQuoterLinkTokenConfigAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_GetFee[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `destChainSelectorParam`:
		err = enc__.Encode(destChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("destChainSelectorParam", err)
		}
		// Serialize `messageParam`:
		err = enc__.Encode(messageParam)
		if err != nil {
			return nil, errors.NewField("messageParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "dest_chain_state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(destChainStateAccount, false, false))
		// Account 2 "fee_quoter": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeQuoterAccount, false, false))
		// Account 3 "fee_quoter_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeQuoterConfigAccount, false, false))
		// Account 4 "fee_quoter_dest_chain": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeQuoterDestChainAccount, false, false))
		// Account 5 "fee_quoter_billing_token_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeQuoterBillingTokenConfigAccount, false, false))
		// Account 6 "fee_quoter_link_token_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeQuoterLinkTokenConfigAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize" instruction.
// Initialization Flow // // Initializes the CCIP Router. //  // The initialization of the Router is responsibility of Admin, nothing more than calling this method should be done first. //  // # Arguments //  // * `ctx` - The context containing the accounts required for initialization. // * `svm_chain_selector` - The chain selector for SVM. // * `fee_aggregator` - The public key of the fee aggregator. // * `fee_quoter` - The public key of the fee quoter. // * `link_token_mint` - The public key of the LINK token mint. // * `rmn_remote` - The public key of the RMN remote.
func NewInitializeInstruction(
	// Params:
	svmChainSelectorParam uint64,
	feeAggregatorParam solanago.PublicKey,
	feeQuoterParam solanago.PublicKey,
	linkTokenMintParam solanago.PublicKey,
	rmnRemoteParam solanago.PublicKey,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
	programDataAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Initialize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `svmChainSelectorParam`:
		err = enc__.Encode(svmChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("svmChainSelectorParam", err)
		}
		// Serialize `feeAggregatorParam`:
		err = enc__.Encode(feeAggregatorParam)
		if err != nil {
			return nil, errors.NewField("feeAggregatorParam", err)
		}
		// Serialize `feeQuoterParam`:
		err = enc__.Encode(feeQuoterParam)
		if err != nil {
			return nil, errors.NewField("feeQuoterParam", err)
		}
		// Serialize `linkTokenMintParam`:
		err = enc__.Encode(linkTokenMintParam)
		if err != nil {
			return nil, errors.NewField("linkTokenMintParam", err)
		}
		// Serialize `rmnRemoteParam`:
		err = enc__.Encode(rmnRemoteParam)
		if err != nil {
			return nil, errors.NewField("rmnRemoteParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 3 "program": Read-only, Non-signer, Required, Address: Ccip842gzYHhvdDkSyi2YVCoAWPbYJoApMFzSxQroE9C
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
		// Account 4 "program_data": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programDataAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "owner_override_pending_administrator" instruction.
// Overrides the pending admin of the Token Admin Registry by the token owner //  // # Arguments //  // * `ctx` - The context containing the accounts required for registration. // * `token_admin_registry_admin` - The public key of the token admin registry admin to propose.
func NewOwnerOverridePendingAdministratorInstruction(
	// Params:
	tokenAdminRegistryAdminParam solanago.PublicKey,

	// Accounts:
	configAccount solanago.PublicKey,
	tokenAdminRegistryAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_OwnerOverridePendingAdministrator[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `tokenAdminRegistryAdminParam`:
		err = enc__.Encode(tokenAdminRegistryAdminParam)
		if err != nil {
			return nil, errors.NewField("tokenAdminRegistryAdminParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "token_admin_registry": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenAdminRegistryAccount, true, false))
		// Account 2 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "owner_propose_administrator" instruction.
// Registers the Token Admin Registry by the token owner. //  // The Authority of the Mint Token can claim the registry of the token. //  // # Arguments //  // * `ctx` - The context containing the accounts required for registration. // * `token_admin_registry_admin` - The public key of the token admin registry admin to propose.
func NewOwnerProposeAdministratorInstruction(
	// Params:
	tokenAdminRegistryAdminParam solanago.PublicKey,

	// Accounts:
	configAccount solanago.PublicKey,
	tokenAdminRegistryAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_OwnerProposeAdministrator[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `tokenAdminRegistryAdminParam`:
		err = enc__.Encode(tokenAdminRegistryAdminParam)
		if err != nil {
			return nil, errors.NewField("tokenAdminRegistryAdminParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "token_admin_registry": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenAdminRegistryAccount, true, false))
		// Account 2 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "remove_offramp" instruction.
// Remove an offramp address from the list of offramps allowed by the router, for a // particular source chain. External users will check this list before accepting // a `ccip_receive` CPI. //  // # Arguments //  // * `ctx` - The context containing the accounts required for this operation. // * `source_chain_selector` - The source chain for the offramp's lane. // * `offramp` - The offramp's address.
func NewRemoveOfframpInstruction(
	// Params:
	sourceChainSelectorParam uint64,
	offrampParam solanago.PublicKey,

	// Accounts:
	allowedOfframpAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RemoveOfframp[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `sourceChainSelectorParam`:
		err = enc__.Encode(sourceChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("sourceChainSelectorParam", err)
		}
		// Serialize `offrampParam`:
		err = enc__.Encode(offrampParam)
		if err != nil {
			return nil, errors.NewField("offrampParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "allowed_offramp": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(allowedOfframpAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "rollback_ccip_version_for_dest_chain" instruction.
// Rolls back the CCIP version for a destination chain. // This effectively just restores the old version's sequence number of the destination chain state. // We only support 1 consecutive rollback. If a rollback has occurred for that lane, the version can't // be rolled back again without bumping the version first. //  // # Arguments // * `ctx` - The context containing the accounts required for the rollback. // * `dest_chain_selector` - The destination chain selector to rollback the version for.
func NewRollbackCcipVersionForDestChainInstruction(
	// Params:
	destChainSelectorParam uint64,

	// Accounts:
	destChainStateAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RollbackCcipVersionForDestChain[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `destChainSelectorParam`:
		err = enc__.Encode(destChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("destChainSelectorParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "dest_chain_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(destChainStateAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_default_code_version" instruction.
// Config // // Sets the default code version to be used. This is then used by the slim routing layer to determine // which version of the versioned business logic module (`instructions`) to use. Only the admin may set this. //  // Shared func signature with other programs //  // # Arguments //  // * `ctx` - The context containing the accounts required for updating the configuration. // * `code_version` - The new code version to be set as default.
func NewSetDefaultCodeVersionInstruction(
	// Params:
	codeVersionParam CodeVersion,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetDefaultCodeVersion[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `codeVersionParam`:
		err = enc__.Encode(codeVersionParam)
		if err != nil {
			return nil, errors.NewField("codeVersionParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_link_token_mint" instruction.
// Sets the address of the LINK token mint. // The Admin is the only one able to set it. //  // # Arguments //  // * `ctx` - The context containing the accounts required for updating the configuration. // * `link_token_mint` - The new address of the LINK token mint.
func NewSetLinkTokenMintInstruction(
	// Params:
	linkTokenMintParam solanago.PublicKey,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetLinkTokenMint[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `linkTokenMintParam`:
		err = enc__.Encode(linkTokenMintParam)
		if err != nil {
			return nil, errors.NewField("linkTokenMintParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_pool" instruction.
// Sets the pool lookup table for a given token mint. //  // The administrator of the token admin registry can set the pool lookup table for a given token mint. //  // # Arguments //  // * `ctx` - The context containing the accounts required for setting the pool. // * `writable_indexes` - a bit map of the indexes of the accounts in lookup table that are writable
func NewSetPoolInstruction(
	// Params:
	writableIndexesParam []byte,

	// Accounts:
	configAccount solanago.PublicKey,
	tokenAdminRegistryAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	poolLookuptableAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetPool[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `writableIndexesParam`:
		err = enc__.Encode(writableIndexesParam)
		if err != nil {
			return nil, errors.NewField("writableIndexesParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "token_admin_registry": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenAdminRegistryAccount, true, false))
		// Account 2 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 3 "pool_lookuptable": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolLookuptableAccount, false, false))
		// Account 4 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_pool_supports_auto_derivation" instruction.
// Edits the pool config flags for a given token mint. //  // The administrator of the token admin registry is the only one allowed to invoke this. //  // # Arguments //  // * `ctx` - The context containing the accounts required for setting the pool. // * `mint` - The mint of the pool to be edited. // * `supports_auto_derivation` - A boolean flag indicating whether the pool supports auto-derivation of accounts.
func NewSetPoolSupportsAutoDerivationInstruction(
	// Params:
	mintParam solanago.PublicKey,
	supportsAutoDerivationParam bool,

	// Accounts:
	configAccount solanago.PublicKey,
	tokenAdminRegistryAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetPoolSupportsAutoDerivation[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `mintParam`:
		err = enc__.Encode(mintParam)
		if err != nil {
			return nil, errors.NewField("mintParam", err)
		}
		// Serialize `supportsAutoDerivationParam`:
		err = enc__.Encode(supportsAutoDerivationParam)
		if err != nil {
			return nil, errors.NewField("supportsAutoDerivationParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "token_admin_registry": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenAdminRegistryAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "transfer_admin_role_token_admin_registry" instruction.
// Transfers the admin role of the token admin registry to a new admin. //  // Only the Admin can transfer the Admin Role of the Token Admin Registry, this setups the Pending Admin and then it's their responsibility to accept the role. //  // # Arguments //  // * `ctx` - The context containing the accounts required for the transfer. // * `mint` - The public key of the token mint. // * `new_admin` - The public key of the new admin.
func NewTransferAdminRoleTokenAdminRegistryInstruction(
	// Params:
	newAdminParam solanago.PublicKey,

	// Accounts:
	configAccount solanago.PublicKey,
	tokenAdminRegistryAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_TransferAdminRoleTokenAdminRegistry[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newAdminParam`:
		err = enc__.Encode(newAdminParam)
		if err != nil {
			return nil, errors.NewField("newAdminParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "token_admin_registry": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenAdminRegistryAccount, true, false))
		// Account 2 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "transfer_ownership" instruction.
// Transfers the ownership of the router to a new proposed owner. //  // Shared func signature with other programs //  // # Arguments //  // * `ctx` - The context containing the accounts required for the transfer. // * `proposed_owner` - The public key of the new proposed owner.
func NewTransferOwnershipInstruction(
	// Params:
	proposedOwnerParam solanago.PublicKey,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_TransferOwnership[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `proposedOwnerParam`:
		err = enc__.Encode(proposedOwnerParam)
		if err != nil {
			return nil, errors.NewField("proposedOwnerParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "type_version" instruction.
// Returns the program type (name) and version. // Used by offchain code to easily determine which program & version is being interacted with. //  // # Arguments // * `ctx` - The context
func NewTypeVersionInstruction(
	clockAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_TypeVersion[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "clock": Read-only, Non-signer, Required, Address: SysvarC1ock11111111111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(clockAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_dest_chain_config" instruction.
// Updates the configuration of the destination chain selector. //  // The Admin is the only one able to update the destination chain config. //  // # Arguments //  // * `ctx` - The context containing the accounts required for updating the chain selector. // * `dest_chain_selector` - The destination chain selector to be updated. // * `dest_chain_config` - The new configuration for the destination chain.
func NewUpdateDestChainConfigInstruction(
	// Params:
	destChainSelectorParam uint64,
	destChainConfigParam DestChainConfig,

	// Accounts:
	destChainStateAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateDestChainConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `destChainSelectorParam`:
		err = enc__.Encode(destChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("destChainSelectorParam", err)
		}
		// Serialize `destChainConfigParam`:
		err = enc__.Encode(destChainConfigParam)
		if err != nil {
			return nil, errors.NewField("destChainConfigParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "dest_chain_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(destChainStateAccount, true, false))
		// Account 1 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_fee_aggregator" instruction.
// Updates the fee aggregator in the router configuration. // The Admin is the only one able to update the fee aggregator. //  // # Arguments //  // * `ctx` - The context containing the accounts required for updating the configuration. // * `fee_aggregator` - The new fee aggregator address (ATAs will be derived for it for each token).
func NewUpdateFeeAggregatorInstruction(
	// Params:
	feeAggregatorParam solanago.PublicKey,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateFeeAggregator[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `feeAggregatorParam`:
		err = enc__.Encode(feeAggregatorParam)
		if err != nil {
			return nil, errors.NewField("feeAggregatorParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_rmn_remote" instruction.
// Updates the RMN remote program in the router configuration. // The Admin is the only one able to update the RMN remote program. //  // # Arguments //  // * `ctx` - The context containing the accounts required for updating the configuration. // * `rmn_remote,` - The new RMN remote address.
func NewUpdateRmnRemoteInstruction(
	// Params:
	rmnRemoteParam solanago.PublicKey,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateRmnRemote[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `rmnRemoteParam`:
		err = enc__.Encode(rmnRemoteParam)
		if err != nil {
			return nil, errors.NewField("rmnRemoteParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_svm_chain_selector" instruction.
// Updates the SVM chain selector in the router configuration. //  // This method should only be used if there was an error with the initial configuration or if the solana chain selector changes. //  // # Arguments //  // * `ctx` - The context containing the accounts required for updating the configuration. // * `new_chain_selector` - The new chain selector for SVM.
func NewUpdateSvmChainSelectorInstruction(
	// Params:
	newChainSelectorParam uint64,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateSvmChainSelector[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newChainSelectorParam`:
		err = enc__.Encode(newChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("newChainSelectorParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "upgrade_token_admin_registry_from_v1" instruction.
// Upgrades the Token Admin Registry from version 1 to the current version. //  // Anyone may invoke this method, as the upgrade has safe defaults for any new value, // and those can then be changed by the Token Admin Registry Admin via separate instructions. //  // # Arguments //  // * `ctx` - The context containing the accounts required for the upgrade.
func NewUpgradeTokenAdminRegistryFromV1Instruction(
	configAccount solanago.PublicKey,
	tokenAdminRegistryAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpgradeTokenAdminRegistryFromV1[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 1 "token_admin_registry": Writable, Non-signer, Required
		// types Anchor would attempt to deserialize the data _before_ realloc'ing it, which would fail.
		// The code will load it and realloc it to the new size manually, and migrate its data.
		accounts__.Append(solanago.NewAccountMeta(tokenAdminRegistryAccount, true, false))
		// Account 2 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 3 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "withdraw_billed_funds" instruction.
// Billing // // Transfers the accumulated billed fees in a particular token to an arbitrary token account. // Only the CCIP Admin can withdraw billed funds. //  // # Arguments //  // * `ctx` - The context containing the accounts required for the transfer of billed fees. // * `transfer_all` - A flag indicating whether to transfer all the accumulated fees in that token or not. // * `desired_amount` - The amount to transfer. If `transfer_all` is true, this value must be 0.
func NewWithdrawBilledFundsInstruction(
	// Params:
	transferAllParam bool,
	desiredAmountParam uint64,

	// Accounts:
	feeTokenMintAccount solanago.PublicKey,
	feeTokenAccumAccount solanago.PublicKey,
	recipientAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	feeBillingSignerAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_WithdrawBilledFunds[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `transferAllParam`:
		err = enc__.Encode(transferAllParam)
		if err != nil {
			return nil, errors.NewField("transferAllParam", err)
		}
		// Serialize `desiredAmountParam`:
		err = enc__.Encode(desiredAmountParam)
		if err != nil {
			return nil, errors.NewField("desiredAmountParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "fee_token_mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeTokenMintAccount, false, false))
		// Account 1 "fee_token_accum": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeTokenAccumAccount, true, false))
		// Account 2 "recipient": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(recipientAccount, true, false))
		// Account 3 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 4 "fee_billing_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeBillingSignerAccount, false, false))
		// Account 5 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
		// Account 6 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

type AcceptAdminRoleTokenAdminRegistryInstruction struct {

	// Accounts:
	Config                     solanago.PublicKey `json:"config"`
	TokenAdminRegistry         solanago.PublicKey `json:"token_admin_registry"`
	TokenAdminRegistryWritable bool               `json:"token_admin_registry_writable"`
	Mint                       solanago.PublicKey `json:"mint"`
	Authority                  solanago.PublicKey `json:"authority"`
	AuthorityWritable          bool               `json:"authority_writable"`
	AuthoritySigner            bool               `json:"authority_signer"`
}

func (obj *AcceptAdminRoleTokenAdminRegistryInstruction) GetDiscriminator() []byte {
	return Instruction_AcceptAdminRoleTokenAdminRegistry[:]
}

// UnmarshalWithDecoder unmarshals the AcceptAdminRoleTokenAdminRegistryInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *AcceptAdminRoleTokenAdminRegistryInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "AcceptAdminRoleTokenAdminRegistryInstruction", err)
	}
	if discriminator != Instruction_AcceptAdminRoleTokenAdminRegistry {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "AcceptAdminRoleTokenAdminRegistryInstruction", Instruction_AcceptAdminRoleTokenAdminRegistry, discriminator)
	}
	return nil
}

func (obj *AcceptAdminRoleTokenAdminRegistryInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from token_admin_registry account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_admin_registry", err)
	}
	indices = append(indices, index)
	// Decode from mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "mint", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AcceptAdminRoleTokenAdminRegistryInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_admin_registry account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_admin_registry", len(accountKeys)-1)
	}
	obj.TokenAdminRegistry = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "mint", len(accountKeys)-1)
	}
	obj.Mint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AcceptAdminRoleTokenAdminRegistryInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.TokenAdminRegistry)
	keys = append(keys, obj.Mint)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the AcceptAdminRoleTokenAdminRegistryInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *AcceptAdminRoleTokenAdminRegistryInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AcceptAdminRoleTokenAdminRegistryInstruction: %w", err)
	}
	return nil
}

// UnmarshalAcceptAdminRoleTokenAdminRegistryInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalAcceptAdminRoleTokenAdminRegistryInstruction(buf []byte) (*AcceptAdminRoleTokenAdminRegistryInstruction, error) {
	obj := new(AcceptAdminRoleTokenAdminRegistryInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type AcceptOwnershipInstruction struct {

	// Accounts:
	Config          solanago.PublicKey `json:"config"`
	ConfigWritable  bool               `json:"config_writable"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
}

func (obj *AcceptOwnershipInstruction) GetDiscriminator() []byte {
	return Instruction_AcceptOwnership[:]
}

// UnmarshalWithDecoder unmarshals the AcceptOwnershipInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *AcceptOwnershipInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "AcceptOwnershipInstruction", err)
	}
	if discriminator != Instruction_AcceptOwnership {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "AcceptOwnershipInstruction", Instruction_AcceptOwnership, discriminator)
	}
	return nil
}

func (obj *AcceptOwnershipInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AcceptOwnershipInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 2 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 2, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AcceptOwnershipInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the AcceptOwnershipInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *AcceptOwnershipInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AcceptOwnershipInstruction: %w", err)
	}
	return nil
}

// UnmarshalAcceptOwnershipInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalAcceptOwnershipInstruction(buf []byte) (*AcceptOwnershipInstruction, error) {
	obj := new(AcceptOwnershipInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type AddChainSelectorInstruction struct {
	NewChainSelector uint64          `json:"new_chain_selector"`
	DestChainConfig  DestChainConfig `json:"dest_chain_config"`

	// Accounts:
	DestChainState         solanago.PublicKey `json:"dest_chain_state"`
	DestChainStateWritable bool               `json:"dest_chain_state_writable"`
	Config                 solanago.PublicKey `json:"config"`
	Authority              solanago.PublicKey `json:"authority"`
	AuthorityWritable      bool               `json:"authority_writable"`
	AuthoritySigner        bool               `json:"authority_signer"`
	SystemProgram          solanago.PublicKey `json:"system_program"`
}

func (obj *AddChainSelectorInstruction) GetDiscriminator() []byte {
	return Instruction_AddChainSelector[:]
}

// UnmarshalWithDecoder unmarshals the AddChainSelectorInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *AddChainSelectorInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "AddChainSelectorInstruction", err)
	}
	if discriminator != Instruction_AddChainSelector {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "AddChainSelectorInstruction", Instruction_AddChainSelector, discriminator)
	}
	// Deserialize `NewChainSelector`:
	err = decoder.Decode(&obj.NewChainSelector)
	if err != nil {
		return err
	}
	// Deserialize `DestChainConfig`:
	err = decoder.Decode(&obj.DestChainConfig)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AddChainSelectorInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from dest_chain_state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "dest_chain_state", err)
	}
	indices = append(indices, index)
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AddChainSelectorInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set dest_chain_state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "dest_chain_state", len(accountKeys)-1)
	}
	obj.DestChainState = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AddChainSelectorInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.DestChainState)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the AddChainSelectorInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *AddChainSelectorInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AddChainSelectorInstruction: %w", err)
	}
	return nil
}

// UnmarshalAddChainSelectorInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalAddChainSelectorInstruction(buf []byte) (*AddChainSelectorInstruction, error) {
	obj := new(AddChainSelectorInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type AddOfframpInstruction struct {
	SourceChainSelector uint64             `json:"source_chain_selector"`
	Offramp             solanago.PublicKey `json:"offramp"`

	// Accounts:
	AllowedOfframp         solanago.PublicKey `json:"allowed_offramp"`
	AllowedOfframpWritable bool               `json:"allowed_offramp_writable"`
	Config                 solanago.PublicKey `json:"config"`
	Authority              solanago.PublicKey `json:"authority"`
	AuthorityWritable      bool               `json:"authority_writable"`
	AuthoritySigner        bool               `json:"authority_signer"`
	SystemProgram          solanago.PublicKey `json:"system_program"`
}

func (obj *AddOfframpInstruction) GetDiscriminator() []byte {
	return Instruction_AddOfframp[:]
}

// UnmarshalWithDecoder unmarshals the AddOfframpInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *AddOfframpInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "AddOfframpInstruction", err)
	}
	if discriminator != Instruction_AddOfframp {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "AddOfframpInstruction", Instruction_AddOfframp, discriminator)
	}
	// Deserialize `SourceChainSelector`:
	err = decoder.Decode(&obj.SourceChainSelector)
	if err != nil {
		return err
	}
	// Deserialize `Offramp`:
	err = decoder.Decode(&obj.Offramp)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AddOfframpInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from allowed_offramp account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "allowed_offramp", err)
	}
	indices = append(indices, index)
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AddOfframpInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set allowed_offramp account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "allowed_offramp", len(accountKeys)-1)
	}
	obj.AllowedOfframp = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AddOfframpInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.AllowedOfframp)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the AddOfframpInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *AddOfframpInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AddOfframpInstruction: %w", err)
	}
	return nil
}

// UnmarshalAddOfframpInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalAddOfframpInstruction(buf []byte) (*AddOfframpInstruction, error) {
	obj := new(AddOfframpInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type BumpCcipVersionForDestChainInstruction struct {
	DestChainSelector uint64 `json:"dest_chain_selector"`

	// Accounts:
	DestChainState         solanago.PublicKey `json:"dest_chain_state"`
	DestChainStateWritable bool               `json:"dest_chain_state_writable"`
	Config                 solanago.PublicKey `json:"config"`
	Authority              solanago.PublicKey `json:"authority"`
	AuthorityWritable      bool               `json:"authority_writable"`
	AuthoritySigner        bool               `json:"authority_signer"`
}

func (obj *BumpCcipVersionForDestChainInstruction) GetDiscriminator() []byte {
	return Instruction_BumpCcipVersionForDestChain[:]
}

// UnmarshalWithDecoder unmarshals the BumpCcipVersionForDestChainInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *BumpCcipVersionForDestChainInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "BumpCcipVersionForDestChainInstruction", err)
	}
	if discriminator != Instruction_BumpCcipVersionForDestChain {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "BumpCcipVersionForDestChainInstruction", Instruction_BumpCcipVersionForDestChain, discriminator)
	}
	// Deserialize `DestChainSelector`:
	err = decoder.Decode(&obj.DestChainSelector)
	if err != nil {
		return err
	}
	return nil
}

func (obj *BumpCcipVersionForDestChainInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from dest_chain_state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "dest_chain_state", err)
	}
	indices = append(indices, index)
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *BumpCcipVersionForDestChainInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set dest_chain_state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "dest_chain_state", len(accountKeys)-1)
	}
	obj.DestChainState = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *BumpCcipVersionForDestChainInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.DestChainState)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the BumpCcipVersionForDestChainInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *BumpCcipVersionForDestChainInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling BumpCcipVersionForDestChainInstruction: %w", err)
	}
	return nil
}

// UnmarshalBumpCcipVersionForDestChainInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalBumpCcipVersionForDestChainInstruction(buf []byte) (*BumpCcipVersionForDestChainInstruction, error) {
	obj := new(BumpCcipVersionForDestChainInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type CcipAdminOverridePendingAdministratorInstruction struct {
	TokenAdminRegistryAdmin solanago.PublicKey `json:"token_admin_registry_admin"`

	// Accounts:
	Config                     solanago.PublicKey `json:"config"`
	TokenAdminRegistry         solanago.PublicKey `json:"token_admin_registry"`
	TokenAdminRegistryWritable bool               `json:"token_admin_registry_writable"`
	Mint                       solanago.PublicKey `json:"mint"`
	Authority                  solanago.PublicKey `json:"authority"`
	AuthorityWritable          bool               `json:"authority_writable"`
	AuthoritySigner            bool               `json:"authority_signer"`
	SystemProgram              solanago.PublicKey `json:"system_program"`
}

func (obj *CcipAdminOverridePendingAdministratorInstruction) GetDiscriminator() []byte {
	return Instruction_CcipAdminOverridePendingAdministrator[:]
}

// UnmarshalWithDecoder unmarshals the CcipAdminOverridePendingAdministratorInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *CcipAdminOverridePendingAdministratorInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "CcipAdminOverridePendingAdministratorInstruction", err)
	}
	if discriminator != Instruction_CcipAdminOverridePendingAdministrator {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "CcipAdminOverridePendingAdministratorInstruction", Instruction_CcipAdminOverridePendingAdministrator, discriminator)
	}
	// Deserialize `TokenAdminRegistryAdmin`:
	err = decoder.Decode(&obj.TokenAdminRegistryAdmin)
	if err != nil {
		return err
	}
	return nil
}

func (obj *CcipAdminOverridePendingAdministratorInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from token_admin_registry account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_admin_registry", err)
	}
	indices = append(indices, index)
	// Decode from mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "mint", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *CcipAdminOverridePendingAdministratorInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 5 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 5, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_admin_registry account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_admin_registry", len(accountKeys)-1)
	}
	obj.TokenAdminRegistry = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "mint", len(accountKeys)-1)
	}
	obj.Mint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *CcipAdminOverridePendingAdministratorInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.TokenAdminRegistry)
	keys = append(keys, obj.Mint)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the CcipAdminOverridePendingAdministratorInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *CcipAdminOverridePendingAdministratorInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CcipAdminOverridePendingAdministratorInstruction: %w", err)
	}
	return nil
}

// UnmarshalCcipAdminOverridePendingAdministratorInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalCcipAdminOverridePendingAdministratorInstruction(buf []byte) (*CcipAdminOverridePendingAdministratorInstruction, error) {
	obj := new(CcipAdminOverridePendingAdministratorInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type CcipAdminProposeAdministratorInstruction struct {
	TokenAdminRegistryAdmin solanago.PublicKey `json:"token_admin_registry_admin"`

	// Accounts:
	Config                     solanago.PublicKey `json:"config"`
	TokenAdminRegistry         solanago.PublicKey `json:"token_admin_registry"`
	TokenAdminRegistryWritable bool               `json:"token_admin_registry_writable"`
	Mint                       solanago.PublicKey `json:"mint"`
	Authority                  solanago.PublicKey `json:"authority"`
	AuthorityWritable          bool               `json:"authority_writable"`
	AuthoritySigner            bool               `json:"authority_signer"`
	SystemProgram              solanago.PublicKey `json:"system_program"`
}

func (obj *CcipAdminProposeAdministratorInstruction) GetDiscriminator() []byte {
	return Instruction_CcipAdminProposeAdministrator[:]
}

// UnmarshalWithDecoder unmarshals the CcipAdminProposeAdministratorInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *CcipAdminProposeAdministratorInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "CcipAdminProposeAdministratorInstruction", err)
	}
	if discriminator != Instruction_CcipAdminProposeAdministrator {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "CcipAdminProposeAdministratorInstruction", Instruction_CcipAdminProposeAdministrator, discriminator)
	}
	// Deserialize `TokenAdminRegistryAdmin`:
	err = decoder.Decode(&obj.TokenAdminRegistryAdmin)
	if err != nil {
		return err
	}
	return nil
}

func (obj *CcipAdminProposeAdministratorInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from token_admin_registry account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_admin_registry", err)
	}
	indices = append(indices, index)
	// Decode from mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "mint", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *CcipAdminProposeAdministratorInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 5 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 5, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_admin_registry account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_admin_registry", len(accountKeys)-1)
	}
	obj.TokenAdminRegistry = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "mint", len(accountKeys)-1)
	}
	obj.Mint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *CcipAdminProposeAdministratorInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.TokenAdminRegistry)
	keys = append(keys, obj.Mint)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the CcipAdminProposeAdministratorInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *CcipAdminProposeAdministratorInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CcipAdminProposeAdministratorInstruction: %w", err)
	}
	return nil
}

// UnmarshalCcipAdminProposeAdministratorInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalCcipAdminProposeAdministratorInstruction(buf []byte) (*CcipAdminProposeAdministratorInstruction, error) {
	obj := new(CcipAdminProposeAdministratorInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type CcipSendInstruction struct {
	DestChainSelector uint64         `json:"dest_chain_selector"`
	Message           Svm2AnyMessage `json:"message"`
	TokenIndexes      []byte         `json:"token_indexes"`

	// Accounts:
	Config                        solanago.PublicKey `json:"config"`
	DestChainState                solanago.PublicKey `json:"dest_chain_state"`
	DestChainStateWritable        bool               `json:"dest_chain_state_writable"`
	Nonce                         solanago.PublicKey `json:"nonce"`
	NonceWritable                 bool               `json:"nonce_writable"`
	Authority                     solanago.PublicKey `json:"authority"`
	AuthorityWritable             bool               `json:"authority_writable"`
	AuthoritySigner               bool               `json:"authority_signer"`
	SystemProgram                 solanago.PublicKey `json:"system_program"`
	FeeTokenProgram               solanago.PublicKey `json:"fee_token_program"`
	FeeTokenMint                  solanago.PublicKey `json:"fee_token_mint"`
	FeeTokenUserAssociatedAccount solanago.PublicKey `json:"fee_token_user_associated_account"`
	FeeTokenReceiver              solanago.PublicKey `json:"fee_token_receiver"`
	FeeTokenReceiverWritable      bool               `json:"fee_token_receiver_writable"`
	FeeBillingSigner              solanago.PublicKey `json:"fee_billing_signer"`
	FeeQuoter                     solanago.PublicKey `json:"fee_quoter"`
	FeeQuoterConfig               solanago.PublicKey `json:"fee_quoter_config"`
	FeeQuoterDestChain            solanago.PublicKey `json:"fee_quoter_dest_chain"`
	FeeQuoterBillingTokenConfig   solanago.PublicKey `json:"fee_quoter_billing_token_config"`
	FeeQuoterLinkTokenConfig      solanago.PublicKey `json:"fee_quoter_link_token_config"`
	RmnRemote                     solanago.PublicKey `json:"rmn_remote"`
	RmnRemoteCurses               solanago.PublicKey `json:"rmn_remote_curses"`
	RmnRemoteConfig               solanago.PublicKey `json:"rmn_remote_config"`
}

func (obj *CcipSendInstruction) GetDiscriminator() []byte {
	return Instruction_CcipSend[:]
}

// UnmarshalWithDecoder unmarshals the CcipSendInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *CcipSendInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "CcipSendInstruction", err)
	}
	if discriminator != Instruction_CcipSend {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "CcipSendInstruction", Instruction_CcipSend, discriminator)
	}
	// Deserialize `DestChainSelector`:
	err = decoder.Decode(&obj.DestChainSelector)
	if err != nil {
		return err
	}
	// Deserialize `Message`:
	err = decoder.Decode(&obj.Message)
	if err != nil {
		return err
	}
	// Deserialize `TokenIndexes`:
	err = decoder.Decode(&obj.TokenIndexes)
	if err != nil {
		return err
	}
	return nil
}

func (obj *CcipSendInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from dest_chain_state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "dest_chain_state", err)
	}
	indices = append(indices, index)
	// Decode from nonce account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "nonce", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	// Decode from fee_token_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_token_program", err)
	}
	indices = append(indices, index)
	// Decode from fee_token_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_token_mint", err)
	}
	indices = append(indices, index)
	// Decode from fee_token_user_associated_account account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_token_user_associated_account", err)
	}
	indices = append(indices, index)
	// Decode from fee_token_receiver account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_token_receiver", err)
	}
	indices = append(indices, index)
	// Decode from fee_billing_signer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_billing_signer", err)
	}
	indices = append(indices, index)
	// Decode from fee_quoter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_quoter", err)
	}
	indices = append(indices, index)
	// Decode from fee_quoter_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_quoter_config", err)
	}
	indices = append(indices, index)
	// Decode from fee_quoter_dest_chain account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_quoter_dest_chain", err)
	}
	indices = append(indices, index)
	// Decode from fee_quoter_billing_token_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_quoter_billing_token_config", err)
	}
	indices = append(indices, index)
	// Decode from fee_quoter_link_token_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_quoter_link_token_config", err)
	}
	indices = append(indices, index)
	// Decode from rmn_remote account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rmn_remote", err)
	}
	indices = append(indices, index)
	// Decode from rmn_remote_curses account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rmn_remote_curses", err)
	}
	indices = append(indices, index)
	// Decode from rmn_remote_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rmn_remote_config", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *CcipSendInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 18 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 18, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set dest_chain_state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "dest_chain_state", len(accountKeys)-1)
	}
	obj.DestChainState = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set nonce account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "nonce", len(accountKeys)-1)
	}
	obj.Nonce = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_token_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_token_program", len(accountKeys)-1)
	}
	obj.FeeTokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_token_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_token_mint", len(accountKeys)-1)
	}
	obj.FeeTokenMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_token_user_associated_account account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_token_user_associated_account", len(accountKeys)-1)
	}
	obj.FeeTokenUserAssociatedAccount = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_token_receiver account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_token_receiver", len(accountKeys)-1)
	}
	obj.FeeTokenReceiver = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_billing_signer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_billing_signer", len(accountKeys)-1)
	}
	obj.FeeBillingSigner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_quoter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_quoter", len(accountKeys)-1)
	}
	obj.FeeQuoter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_quoter_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_quoter_config", len(accountKeys)-1)
	}
	obj.FeeQuoterConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_quoter_dest_chain account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_quoter_dest_chain", len(accountKeys)-1)
	}
	obj.FeeQuoterDestChain = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_quoter_billing_token_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_quoter_billing_token_config", len(accountKeys)-1)
	}
	obj.FeeQuoterBillingTokenConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_quoter_link_token_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_quoter_link_token_config", len(accountKeys)-1)
	}
	obj.FeeQuoterLinkTokenConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rmn_remote account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rmn_remote", len(accountKeys)-1)
	}
	obj.RmnRemote = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rmn_remote_curses account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rmn_remote_curses", len(accountKeys)-1)
	}
	obj.RmnRemoteCurses = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rmn_remote_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rmn_remote_config", len(accountKeys)-1)
	}
	obj.RmnRemoteConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *CcipSendInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.DestChainState)
	keys = append(keys, obj.Nonce)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.FeeTokenProgram)
	keys = append(keys, obj.FeeTokenMint)
	keys = append(keys, obj.FeeTokenUserAssociatedAccount)
	keys = append(keys, obj.FeeTokenReceiver)
	keys = append(keys, obj.FeeBillingSigner)
	keys = append(keys, obj.FeeQuoter)
	keys = append(keys, obj.FeeQuoterConfig)
	keys = append(keys, obj.FeeQuoterDestChain)
	keys = append(keys, obj.FeeQuoterBillingTokenConfig)
	keys = append(keys, obj.FeeQuoterLinkTokenConfig)
	keys = append(keys, obj.RmnRemote)
	keys = append(keys, obj.RmnRemoteCurses)
	keys = append(keys, obj.RmnRemoteConfig)
	return keys
}

// Unmarshal unmarshals the CcipSendInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *CcipSendInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CcipSendInstruction: %w", err)
	}
	return nil
}

// UnmarshalCcipSendInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalCcipSendInstruction(buf []byte) (*CcipSendInstruction, error) {
	obj := new(CcipSendInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type DeriveAccountsCcipSendInstruction struct {
	Params DeriveAccountsCcipSendParams `json:"params"`
	Stage  string                       `json:"stage"`

	// Accounts:
	Config solanago.PublicKey `json:"config"`
}

func (obj *DeriveAccountsCcipSendInstruction) GetDiscriminator() []byte {
	return Instruction_DeriveAccountsCcipSend[:]
}

// UnmarshalWithDecoder unmarshals the DeriveAccountsCcipSendInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *DeriveAccountsCcipSendInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "DeriveAccountsCcipSendInstruction", err)
	}
	if discriminator != Instruction_DeriveAccountsCcipSend {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "DeriveAccountsCcipSendInstruction", Instruction_DeriveAccountsCcipSend, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	// Deserialize `Stage`:
	err = decoder.Decode(&obj.Stage)
	if err != nil {
		return err
	}
	return nil
}

func (obj *DeriveAccountsCcipSendInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *DeriveAccountsCcipSendInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 1 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 1, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *DeriveAccountsCcipSendInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	return keys
}

// Unmarshal unmarshals the DeriveAccountsCcipSendInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *DeriveAccountsCcipSendInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling DeriveAccountsCcipSendInstruction: %w", err)
	}
	return nil
}

// UnmarshalDeriveAccountsCcipSendInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalDeriveAccountsCcipSendInstruction(buf []byte) (*DeriveAccountsCcipSendInstruction, error) {
	obj := new(DeriveAccountsCcipSendInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type GetFeeInstruction struct {
	DestChainSelector uint64         `json:"dest_chain_selector"`
	Message           Svm2AnyMessage `json:"message"`

	// Accounts:
	Config                      solanago.PublicKey `json:"config"`
	DestChainState              solanago.PublicKey `json:"dest_chain_state"`
	FeeQuoter                   solanago.PublicKey `json:"fee_quoter"`
	FeeQuoterConfig             solanago.PublicKey `json:"fee_quoter_config"`
	FeeQuoterDestChain          solanago.PublicKey `json:"fee_quoter_dest_chain"`
	FeeQuoterBillingTokenConfig solanago.PublicKey `json:"fee_quoter_billing_token_config"`
	FeeQuoterLinkTokenConfig    solanago.PublicKey `json:"fee_quoter_link_token_config"`
}

func (obj *GetFeeInstruction) GetDiscriminator() []byte {
	return Instruction_GetFee[:]
}

// UnmarshalWithDecoder unmarshals the GetFeeInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *GetFeeInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "GetFeeInstruction", err)
	}
	if discriminator != Instruction_GetFee {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "GetFeeInstruction", Instruction_GetFee, discriminator)
	}
	// Deserialize `DestChainSelector`:
	err = decoder.Decode(&obj.DestChainSelector)
	if err != nil {
		return err
	}
	// Deserialize `Message`:
	err = decoder.Decode(&obj.Message)
	if err != nil {
		return err
	}
	return nil
}

func (obj *GetFeeInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from dest_chain_state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "dest_chain_state", err)
	}
	indices = append(indices, index)
	// Decode from fee_quoter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_quoter", err)
	}
	indices = append(indices, index)
	// Decode from fee_quoter_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_quoter_config", err)
	}
	indices = append(indices, index)
	// Decode from fee_quoter_dest_chain account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_quoter_dest_chain", err)
	}
	indices = append(indices, index)
	// Decode from fee_quoter_billing_token_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_quoter_billing_token_config", err)
	}
	indices = append(indices, index)
	// Decode from fee_quoter_link_token_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_quoter_link_token_config", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *GetFeeInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 7 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 7, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set dest_chain_state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "dest_chain_state", len(accountKeys)-1)
	}
	obj.DestChainState = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_quoter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_quoter", len(accountKeys)-1)
	}
	obj.FeeQuoter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_quoter_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_quoter_config", len(accountKeys)-1)
	}
	obj.FeeQuoterConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_quoter_dest_chain account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_quoter_dest_chain", len(accountKeys)-1)
	}
	obj.FeeQuoterDestChain = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_quoter_billing_token_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_quoter_billing_token_config", len(accountKeys)-1)
	}
	obj.FeeQuoterBillingTokenConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_quoter_link_token_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_quoter_link_token_config", len(accountKeys)-1)
	}
	obj.FeeQuoterLinkTokenConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *GetFeeInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.DestChainState)
	keys = append(keys, obj.FeeQuoter)
	keys = append(keys, obj.FeeQuoterConfig)
	keys = append(keys, obj.FeeQuoterDestChain)
	keys = append(keys, obj.FeeQuoterBillingTokenConfig)
	keys = append(keys, obj.FeeQuoterLinkTokenConfig)
	return keys
}

// Unmarshal unmarshals the GetFeeInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *GetFeeInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling GetFeeInstruction: %w", err)
	}
	return nil
}

// UnmarshalGetFeeInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalGetFeeInstruction(buf []byte) (*GetFeeInstruction, error) {
	obj := new(GetFeeInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitializeInstruction struct {
	SvmChainSelector uint64             `json:"svm_chain_selector"`
	FeeAggregator    solanago.PublicKey `json:"fee_aggregator"`
	FeeQuoter        solanago.PublicKey `json:"fee_quoter"`
	LinkTokenMint    solanago.PublicKey `json:"link_token_mint"`
	RmnRemote        solanago.PublicKey `json:"rmn_remote"`

	// Accounts:
	Config            solanago.PublicKey `json:"config"`
	ConfigWritable    bool               `json:"config_writable"`
	Authority         solanago.PublicKey `json:"authority"`
	AuthorityWritable bool               `json:"authority_writable"`
	AuthoritySigner   bool               `json:"authority_signer"`
	SystemProgram     solanago.PublicKey `json:"system_program"`
	Program           solanago.PublicKey `json:"program"`
	ProgramData       solanago.PublicKey `json:"program_data"`
}

func (obj *InitializeInstruction) GetDiscriminator() []byte {
	return Instruction_Initialize[:]
}

// UnmarshalWithDecoder unmarshals the InitializeInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *InitializeInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "InitializeInstruction", err)
	}
	if discriminator != Instruction_Initialize {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "InitializeInstruction", Instruction_Initialize, discriminator)
	}
	// Deserialize `SvmChainSelector`:
	err = decoder.Decode(&obj.SvmChainSelector)
	if err != nil {
		return err
	}
	// Deserialize `FeeAggregator`:
	err = decoder.Decode(&obj.FeeAggregator)
	if err != nil {
		return err
	}
	// Deserialize `FeeQuoter`:
	err = decoder.Decode(&obj.FeeQuoter)
	if err != nil {
		return err
	}
	// Deserialize `LinkTokenMint`:
	err = decoder.Decode(&obj.LinkTokenMint)
	if err != nil {
		return err
	}
	// Deserialize `RmnRemote`:
	err = decoder.Decode(&obj.RmnRemote)
	if err != nil {
		return err
	}
	return nil
}

func (obj *InitializeInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	// Decode from program_data account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program_data", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitializeInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 5 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 5, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program_data account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program_data", len(accountKeys)-1)
	}
	obj.ProgramData = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitializeInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.Program)
	keys = append(keys, obj.ProgramData)
	return keys
}

// Unmarshal unmarshals the InitializeInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *InitializeInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitializeInstruction: %w", err)
	}
	return nil
}

// UnmarshalInitializeInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalInitializeInstruction(buf []byte) (*InitializeInstruction, error) {
	obj := new(InitializeInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type OwnerOverridePendingAdministratorInstruction struct {
	TokenAdminRegistryAdmin solanago.PublicKey `json:"token_admin_registry_admin"`

	// Accounts:
	Config                     solanago.PublicKey `json:"config"`
	TokenAdminRegistry         solanago.PublicKey `json:"token_admin_registry"`
	TokenAdminRegistryWritable bool               `json:"token_admin_registry_writable"`
	Mint                       solanago.PublicKey `json:"mint"`
	Authority                  solanago.PublicKey `json:"authority"`
	AuthorityWritable          bool               `json:"authority_writable"`
	AuthoritySigner            bool               `json:"authority_signer"`
	SystemProgram              solanago.PublicKey `json:"system_program"`
}

func (obj *OwnerOverridePendingAdministratorInstruction) GetDiscriminator() []byte {
	return Instruction_OwnerOverridePendingAdministrator[:]
}

// UnmarshalWithDecoder unmarshals the OwnerOverridePendingAdministratorInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *OwnerOverridePendingAdministratorInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "OwnerOverridePendingAdministratorInstruction", err)
	}
	if discriminator != Instruction_OwnerOverridePendingAdministrator {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "OwnerOverridePendingAdministratorInstruction", Instruction_OwnerOverridePendingAdministrator, discriminator)
	}
	// Deserialize `TokenAdminRegistryAdmin`:
	err = decoder.Decode(&obj.TokenAdminRegistryAdmin)
	if err != nil {
		return err
	}
	return nil
}

func (obj *OwnerOverridePendingAdministratorInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from token_admin_registry account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_admin_registry", err)
	}
	indices = append(indices, index)
	// Decode from mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "mint", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *OwnerOverridePendingAdministratorInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 5 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 5, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_admin_registry account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_admin_registry", len(accountKeys)-1)
	}
	obj.TokenAdminRegistry = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "mint", len(accountKeys)-1)
	}
	obj.Mint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *OwnerOverridePendingAdministratorInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.TokenAdminRegistry)
	keys = append(keys, obj.Mint)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the OwnerOverridePendingAdministratorInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *OwnerOverridePendingAdministratorInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling OwnerOverridePendingAdministratorInstruction: %w", err)
	}
	return nil
}

// UnmarshalOwnerOverridePendingAdministratorInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalOwnerOverridePendingAdministratorInstruction(buf []byte) (*OwnerOverridePendingAdministratorInstruction, error) {
	obj := new(OwnerOverridePendingAdministratorInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type OwnerProposeAdministratorInstruction struct {
	TokenAdminRegistryAdmin solanago.PublicKey `json:"token_admin_registry_admin"`

	// Accounts:
	Config                     solanago.PublicKey `json:"config"`
	TokenAdminRegistry         solanago.PublicKey `json:"token_admin_registry"`
	TokenAdminRegistryWritable bool               `json:"token_admin_registry_writable"`
	Mint                       solanago.PublicKey `json:"mint"`
	Authority                  solanago.PublicKey `json:"authority"`
	AuthorityWritable          bool               `json:"authority_writable"`
	AuthoritySigner            bool               `json:"authority_signer"`
	SystemProgram              solanago.PublicKey `json:"system_program"`
}

func (obj *OwnerProposeAdministratorInstruction) GetDiscriminator() []byte {
	return Instruction_OwnerProposeAdministrator[:]
}

// UnmarshalWithDecoder unmarshals the OwnerProposeAdministratorInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *OwnerProposeAdministratorInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "OwnerProposeAdministratorInstruction", err)
	}
	if discriminator != Instruction_OwnerProposeAdministrator {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "OwnerProposeAdministratorInstruction", Instruction_OwnerProposeAdministrator, discriminator)
	}
	// Deserialize `TokenAdminRegistryAdmin`:
	err = decoder.Decode(&obj.TokenAdminRegistryAdmin)
	if err != nil {
		return err
	}
	return nil
}

func (obj *OwnerProposeAdministratorInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from token_admin_registry account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_admin_registry", err)
	}
	indices = append(indices, index)
	// Decode from mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "mint", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *OwnerProposeAdministratorInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 5 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 5, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_admin_registry account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_admin_registry", len(accountKeys)-1)
	}
	obj.TokenAdminRegistry = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "mint", len(accountKeys)-1)
	}
	obj.Mint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *OwnerProposeAdministratorInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.TokenAdminRegistry)
	keys = append(keys, obj.Mint)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the OwnerProposeAdministratorInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *OwnerProposeAdministratorInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling OwnerProposeAdministratorInstruction: %w", err)
	}
	return nil
}

// UnmarshalOwnerProposeAdministratorInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalOwnerProposeAdministratorInstruction(buf []byte) (*OwnerProposeAdministratorInstruction, error) {
	obj := new(OwnerProposeAdministratorInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type RemoveOfframpInstruction struct {
	SourceChainSelector uint64             `json:"source_chain_selector"`
	Offramp             solanago.PublicKey `json:"offramp"`

	// Accounts:
	AllowedOfframp         solanago.PublicKey `json:"allowed_offramp"`
	AllowedOfframpWritable bool               `json:"allowed_offramp_writable"`
	Config                 solanago.PublicKey `json:"config"`
	Authority              solanago.PublicKey `json:"authority"`
	AuthorityWritable      bool               `json:"authority_writable"`
	AuthoritySigner        bool               `json:"authority_signer"`
	SystemProgram          solanago.PublicKey `json:"system_program"`
}

func (obj *RemoveOfframpInstruction) GetDiscriminator() []byte {
	return Instruction_RemoveOfframp[:]
}

// UnmarshalWithDecoder unmarshals the RemoveOfframpInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *RemoveOfframpInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "RemoveOfframpInstruction", err)
	}
	if discriminator != Instruction_RemoveOfframp {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "RemoveOfframpInstruction", Instruction_RemoveOfframp, discriminator)
	}
	// Deserialize `SourceChainSelector`:
	err = decoder.Decode(&obj.SourceChainSelector)
	if err != nil {
		return err
	}
	// Deserialize `Offramp`:
	err = decoder.Decode(&obj.Offramp)
	if err != nil {
		return err
	}
	return nil
}

func (obj *RemoveOfframpInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from allowed_offramp account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "allowed_offramp", err)
	}
	indices = append(indices, index)
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *RemoveOfframpInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set allowed_offramp account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "allowed_offramp", len(accountKeys)-1)
	}
	obj.AllowedOfframp = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *RemoveOfframpInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.AllowedOfframp)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the RemoveOfframpInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *RemoveOfframpInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling RemoveOfframpInstruction: %w", err)
	}
	return nil
}

// UnmarshalRemoveOfframpInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalRemoveOfframpInstruction(buf []byte) (*RemoveOfframpInstruction, error) {
	obj := new(RemoveOfframpInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type RollbackCcipVersionForDestChainInstruction struct {
	DestChainSelector uint64 `json:"dest_chain_selector"`

	// Accounts:
	DestChainState         solanago.PublicKey `json:"dest_chain_state"`
	DestChainStateWritable bool               `json:"dest_chain_state_writable"`
	Config                 solanago.PublicKey `json:"config"`
	Authority              solanago.PublicKey `json:"authority"`
	AuthorityWritable      bool               `json:"authority_writable"`
	AuthoritySigner        bool               `json:"authority_signer"`
}

func (obj *RollbackCcipVersionForDestChainInstruction) GetDiscriminator() []byte {
	return Instruction_RollbackCcipVersionForDestChain[:]
}

// UnmarshalWithDecoder unmarshals the RollbackCcipVersionForDestChainInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *RollbackCcipVersionForDestChainInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "RollbackCcipVersionForDestChainInstruction", err)
	}
	if discriminator != Instruction_RollbackCcipVersionForDestChain {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "RollbackCcipVersionForDestChainInstruction", Instruction_RollbackCcipVersionForDestChain, discriminator)
	}
	// Deserialize `DestChainSelector`:
	err = decoder.Decode(&obj.DestChainSelector)
	if err != nil {
		return err
	}
	return nil
}

func (obj *RollbackCcipVersionForDestChainInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from dest_chain_state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "dest_chain_state", err)
	}
	indices = append(indices, index)
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *RollbackCcipVersionForDestChainInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set dest_chain_state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "dest_chain_state", len(accountKeys)-1)
	}
	obj.DestChainState = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *RollbackCcipVersionForDestChainInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.DestChainState)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the RollbackCcipVersionForDestChainInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *RollbackCcipVersionForDestChainInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling RollbackCcipVersionForDestChainInstruction: %w", err)
	}
	return nil
}

// UnmarshalRollbackCcipVersionForDestChainInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalRollbackCcipVersionForDestChainInstruction(buf []byte) (*RollbackCcipVersionForDestChainInstruction, error) {
	obj := new(RollbackCcipVersionForDestChainInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SetDefaultCodeVersionInstruction struct {
	CodeVersion CodeVersion `json:"code_version"`

	// Accounts:
	Config          solanago.PublicKey `json:"config"`
	ConfigWritable  bool               `json:"config_writable"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
	SystemProgram   solanago.PublicKey `json:"system_program"`
}

func (obj *SetDefaultCodeVersionInstruction) GetDiscriminator() []byte {
	return Instruction_SetDefaultCodeVersion[:]
}

// UnmarshalWithDecoder unmarshals the SetDefaultCodeVersionInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *SetDefaultCodeVersionInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "SetDefaultCodeVersionInstruction", err)
	}
	if discriminator != Instruction_SetDefaultCodeVersion {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "SetDefaultCodeVersionInstruction", Instruction_SetDefaultCodeVersion, discriminator)
	}
	// Deserialize `CodeVersion`:
	err = decoder.Decode(&obj.CodeVersion)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SetDefaultCodeVersionInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SetDefaultCodeVersionInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SetDefaultCodeVersionInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the SetDefaultCodeVersionInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *SetDefaultCodeVersionInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SetDefaultCodeVersionInstruction: %w", err)
	}
	return nil
}

// UnmarshalSetDefaultCodeVersionInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalSetDefaultCodeVersionInstruction(buf []byte) (*SetDefaultCodeVersionInstruction, error) {
	obj := new(SetDefaultCodeVersionInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SetLinkTokenMintInstruction struct {
	LinkTokenMint solanago.PublicKey `json:"link_token_mint"`

	// Accounts:
	Config          solanago.PublicKey `json:"config"`
	ConfigWritable  bool               `json:"config_writable"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
	SystemProgram   solanago.PublicKey `json:"system_program"`
}

func (obj *SetLinkTokenMintInstruction) GetDiscriminator() []byte {
	return Instruction_SetLinkTokenMint[:]
}

// UnmarshalWithDecoder unmarshals the SetLinkTokenMintInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *SetLinkTokenMintInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "SetLinkTokenMintInstruction", err)
	}
	if discriminator != Instruction_SetLinkTokenMint {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "SetLinkTokenMintInstruction", Instruction_SetLinkTokenMint, discriminator)
	}
	// Deserialize `LinkTokenMint`:
	err = decoder.Decode(&obj.LinkTokenMint)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SetLinkTokenMintInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SetLinkTokenMintInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SetLinkTokenMintInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the SetLinkTokenMintInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *SetLinkTokenMintInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SetLinkTokenMintInstruction: %w", err)
	}
	return nil
}

// UnmarshalSetLinkTokenMintInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalSetLinkTokenMintInstruction(buf []byte) (*SetLinkTokenMintInstruction, error) {
	obj := new(SetLinkTokenMintInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SetPoolInstruction struct {
	WritableIndexes []byte `json:"writable_indexes"`

	// Accounts:
	Config                     solanago.PublicKey `json:"config"`
	TokenAdminRegistry         solanago.PublicKey `json:"token_admin_registry"`
	TokenAdminRegistryWritable bool               `json:"token_admin_registry_writable"`
	Mint                       solanago.PublicKey `json:"mint"`
	PoolLookuptable            solanago.PublicKey `json:"pool_lookuptable"`
	Authority                  solanago.PublicKey `json:"authority"`
	AuthorityWritable          bool               `json:"authority_writable"`
	AuthoritySigner            bool               `json:"authority_signer"`
}

func (obj *SetPoolInstruction) GetDiscriminator() []byte {
	return Instruction_SetPool[:]
}

// UnmarshalWithDecoder unmarshals the SetPoolInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *SetPoolInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "SetPoolInstruction", err)
	}
	if discriminator != Instruction_SetPool {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "SetPoolInstruction", Instruction_SetPool, discriminator)
	}
	// Deserialize `WritableIndexes`:
	err = decoder.Decode(&obj.WritableIndexes)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SetPoolInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from token_admin_registry account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_admin_registry", err)
	}
	indices = append(indices, index)
	// Decode from mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "mint", err)
	}
	indices = append(indices, index)
	// Decode from pool_lookuptable account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "pool_lookuptable", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SetPoolInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 5 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 5, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_admin_registry account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_admin_registry", len(accountKeys)-1)
	}
	obj.TokenAdminRegistry = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "mint", len(accountKeys)-1)
	}
	obj.Mint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set pool_lookuptable account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "pool_lookuptable", len(accountKeys)-1)
	}
	obj.PoolLookuptable = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SetPoolInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.TokenAdminRegistry)
	keys = append(keys, obj.Mint)
	keys = append(keys, obj.PoolLookuptable)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the SetPoolInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *SetPoolInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SetPoolInstruction: %w", err)
	}
	return nil
}

// UnmarshalSetPoolInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalSetPoolInstruction(buf []byte) (*SetPoolInstruction, error) {
	obj := new(SetPoolInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SetPoolSupportsAutoDerivationInstruction struct {
	Mint                   solanago.PublicKey `json:"mint"`
	SupportsAutoDerivation bool               `json:"supports_auto_derivation"`

	// Accounts:
	Config                     solanago.PublicKey `json:"config"`
	TokenAdminRegistry         solanago.PublicKey `json:"token_admin_registry"`
	TokenAdminRegistryWritable bool               `json:"token_admin_registry_writable"`
	Authority                  solanago.PublicKey `json:"authority"`
	AuthorityWritable          bool               `json:"authority_writable"`
	AuthoritySigner            bool               `json:"authority_signer"`
}

func (obj *SetPoolSupportsAutoDerivationInstruction) GetDiscriminator() []byte {
	return Instruction_SetPoolSupportsAutoDerivation[:]
}

// UnmarshalWithDecoder unmarshals the SetPoolSupportsAutoDerivationInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *SetPoolSupportsAutoDerivationInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "SetPoolSupportsAutoDerivationInstruction", err)
	}
	if discriminator != Instruction_SetPoolSupportsAutoDerivation {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "SetPoolSupportsAutoDerivationInstruction", Instruction_SetPoolSupportsAutoDerivation, discriminator)
	}
	// Deserialize `Mint`:
	err = decoder.Decode(&obj.Mint)
	if err != nil {
		return err
	}
	// Deserialize `SupportsAutoDerivation`:
	err = decoder.Decode(&obj.SupportsAutoDerivation)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SetPoolSupportsAutoDerivationInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from token_admin_registry account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_admin_registry", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SetPoolSupportsAutoDerivationInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_admin_registry account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_admin_registry", len(accountKeys)-1)
	}
	obj.TokenAdminRegistry = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SetPoolSupportsAutoDerivationInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.TokenAdminRegistry)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the SetPoolSupportsAutoDerivationInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *SetPoolSupportsAutoDerivationInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SetPoolSupportsAutoDerivationInstruction: %w", err)
	}
	return nil
}

// UnmarshalSetPoolSupportsAutoDerivationInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalSetPoolSupportsAutoDerivationInstruction(buf []byte) (*SetPoolSupportsAutoDerivationInstruction, error) {
	obj := new(SetPoolSupportsAutoDerivationInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type TransferAdminRoleTokenAdminRegistryInstruction struct {
	NewAdmin solanago.PublicKey `json:"new_admin"`

	// Accounts:
	Config                     solanago.PublicKey `json:"config"`
	TokenAdminRegistry         solanago.PublicKey `json:"token_admin_registry"`
	TokenAdminRegistryWritable bool               `json:"token_admin_registry_writable"`
	Mint                       solanago.PublicKey `json:"mint"`
	Authority                  solanago.PublicKey `json:"authority"`
	AuthorityWritable          bool               `json:"authority_writable"`
	AuthoritySigner            bool               `json:"authority_signer"`
}

func (obj *TransferAdminRoleTokenAdminRegistryInstruction) GetDiscriminator() []byte {
	return Instruction_TransferAdminRoleTokenAdminRegistry[:]
}

// UnmarshalWithDecoder unmarshals the TransferAdminRoleTokenAdminRegistryInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *TransferAdminRoleTokenAdminRegistryInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "TransferAdminRoleTokenAdminRegistryInstruction", err)
	}
	if discriminator != Instruction_TransferAdminRoleTokenAdminRegistry {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "TransferAdminRoleTokenAdminRegistryInstruction", Instruction_TransferAdminRoleTokenAdminRegistry, discriminator)
	}
	// Deserialize `NewAdmin`:
	err = decoder.Decode(&obj.NewAdmin)
	if err != nil {
		return err
	}
	return nil
}

func (obj *TransferAdminRoleTokenAdminRegistryInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from token_admin_registry account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_admin_registry", err)
	}
	indices = append(indices, index)
	// Decode from mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "mint", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *TransferAdminRoleTokenAdminRegistryInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_admin_registry account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_admin_registry", len(accountKeys)-1)
	}
	obj.TokenAdminRegistry = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "mint", len(accountKeys)-1)
	}
	obj.Mint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *TransferAdminRoleTokenAdminRegistryInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.TokenAdminRegistry)
	keys = append(keys, obj.Mint)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the TransferAdminRoleTokenAdminRegistryInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *TransferAdminRoleTokenAdminRegistryInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling TransferAdminRoleTokenAdminRegistryInstruction: %w", err)
	}
	return nil
}

// UnmarshalTransferAdminRoleTokenAdminRegistryInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalTransferAdminRoleTokenAdminRegistryInstruction(buf []byte) (*TransferAdminRoleTokenAdminRegistryInstruction, error) {
	obj := new(TransferAdminRoleTokenAdminRegistryInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type TransferOwnershipInstruction struct {
	ProposedOwner solanago.PublicKey `json:"proposed_owner"`

	// Accounts:
	Config          solanago.PublicKey `json:"config"`
	ConfigWritable  bool               `json:"config_writable"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
}

func (obj *TransferOwnershipInstruction) GetDiscriminator() []byte {
	return Instruction_TransferOwnership[:]
}

// UnmarshalWithDecoder unmarshals the TransferOwnershipInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *TransferOwnershipInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "TransferOwnershipInstruction", err)
	}
	if discriminator != Instruction_TransferOwnership {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "TransferOwnershipInstruction", Instruction_TransferOwnership, discriminator)
	}
	// Deserialize `ProposedOwner`:
	err = decoder.Decode(&obj.ProposedOwner)
	if err != nil {
		return err
	}
	return nil
}

func (obj *TransferOwnershipInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *TransferOwnershipInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 2 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 2, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *TransferOwnershipInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the TransferOwnershipInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *TransferOwnershipInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling TransferOwnershipInstruction: %w", err)
	}
	return nil
}

// UnmarshalTransferOwnershipInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalTransferOwnershipInstruction(buf []byte) (*TransferOwnershipInstruction, error) {
	obj := new(TransferOwnershipInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type TypeVersionInstruction struct {

	// Accounts:
	Clock solanago.PublicKey `json:"clock"`
}

func (obj *TypeVersionInstruction) GetDiscriminator() []byte {
	return Instruction_TypeVersion[:]
}

// UnmarshalWithDecoder unmarshals the TypeVersionInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *TypeVersionInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "TypeVersionInstruction", err)
	}
	if discriminator != Instruction_TypeVersion {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "TypeVersionInstruction", Instruction_TypeVersion, discriminator)
	}
	return nil
}

func (obj *TypeVersionInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from clock account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "clock", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *TypeVersionInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 1 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 1, len(indices))
	}
	indexOffset := 0
	// Set clock account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "clock", len(accountKeys)-1)
	}
	obj.Clock = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *TypeVersionInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Clock)
	return keys
}

// Unmarshal unmarshals the TypeVersionInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *TypeVersionInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling TypeVersionInstruction: %w", err)
	}
	return nil
}

// UnmarshalTypeVersionInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalTypeVersionInstruction(buf []byte) (*TypeVersionInstruction, error) {
	obj := new(TypeVersionInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UpdateDestChainConfigInstruction struct {
	DestChainSelector uint64          `json:"dest_chain_selector"`
	DestChainConfig   DestChainConfig `json:"dest_chain_config"`

	// Accounts:
	DestChainState         solanago.PublicKey `json:"dest_chain_state"`
	DestChainStateWritable bool               `json:"dest_chain_state_writable"`
	Config                 solanago.PublicKey `json:"config"`
	Authority              solanago.PublicKey `json:"authority"`
	AuthorityWritable      bool               `json:"authority_writable"`
	AuthoritySigner        bool               `json:"authority_signer"`
	SystemProgram          solanago.PublicKey `json:"system_program"`
}

func (obj *UpdateDestChainConfigInstruction) GetDiscriminator() []byte {
	return Instruction_UpdateDestChainConfig[:]
}

// UnmarshalWithDecoder unmarshals the UpdateDestChainConfigInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *UpdateDestChainConfigInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "UpdateDestChainConfigInstruction", err)
	}
	if discriminator != Instruction_UpdateDestChainConfig {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "UpdateDestChainConfigInstruction", Instruction_UpdateDestChainConfig, discriminator)
	}
	// Deserialize `DestChainSelector`:
	err = decoder.Decode(&obj.DestChainSelector)
	if err != nil {
		return err
	}
	// Deserialize `DestChainConfig`:
	err = decoder.Decode(&obj.DestChainConfig)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UpdateDestChainConfigInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from dest_chain_state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "dest_chain_state", err)
	}
	indices = append(indices, index)
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *UpdateDestChainConfigInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set dest_chain_state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "dest_chain_state", len(accountKeys)-1)
	}
	obj.DestChainState = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *UpdateDestChainConfigInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.DestChainState)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the UpdateDestChainConfigInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *UpdateDestChainConfigInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdateDestChainConfigInstruction: %w", err)
	}
	return nil
}

// UnmarshalUpdateDestChainConfigInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalUpdateDestChainConfigInstruction(buf []byte) (*UpdateDestChainConfigInstruction, error) {
	obj := new(UpdateDestChainConfigInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UpdateFeeAggregatorInstruction struct {
	FeeAggregator solanago.PublicKey `json:"fee_aggregator"`

	// Accounts:
	Config          solanago.PublicKey `json:"config"`
	ConfigWritable  bool               `json:"config_writable"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
	SystemProgram   solanago.PublicKey `json:"system_program"`
}

func (obj *UpdateFeeAggregatorInstruction) GetDiscriminator() []byte {
	return Instruction_UpdateFeeAggregator[:]
}

// UnmarshalWithDecoder unmarshals the UpdateFeeAggregatorInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *UpdateFeeAggregatorInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "UpdateFeeAggregatorInstruction", err)
	}
	if discriminator != Instruction_UpdateFeeAggregator {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "UpdateFeeAggregatorInstruction", Instruction_UpdateFeeAggregator, discriminator)
	}
	// Deserialize `FeeAggregator`:
	err = decoder.Decode(&obj.FeeAggregator)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UpdateFeeAggregatorInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *UpdateFeeAggregatorInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *UpdateFeeAggregatorInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the UpdateFeeAggregatorInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *UpdateFeeAggregatorInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdateFeeAggregatorInstruction: %w", err)
	}
	return nil
}

// UnmarshalUpdateFeeAggregatorInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalUpdateFeeAggregatorInstruction(buf []byte) (*UpdateFeeAggregatorInstruction, error) {
	obj := new(UpdateFeeAggregatorInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UpdateRmnRemoteInstruction struct {
	RmnRemote solanago.PublicKey `json:"rmn_remote"`

	// Accounts:
	Config          solanago.PublicKey `json:"config"`
	ConfigWritable  bool               `json:"config_writable"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
	SystemProgram   solanago.PublicKey `json:"system_program"`
}

func (obj *UpdateRmnRemoteInstruction) GetDiscriminator() []byte {
	return Instruction_UpdateRmnRemote[:]
}

// UnmarshalWithDecoder unmarshals the UpdateRmnRemoteInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *UpdateRmnRemoteInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "UpdateRmnRemoteInstruction", err)
	}
	if discriminator != Instruction_UpdateRmnRemote {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "UpdateRmnRemoteInstruction", Instruction_UpdateRmnRemote, discriminator)
	}
	// Deserialize `RmnRemote`:
	err = decoder.Decode(&obj.RmnRemote)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UpdateRmnRemoteInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *UpdateRmnRemoteInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *UpdateRmnRemoteInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the UpdateRmnRemoteInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *UpdateRmnRemoteInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdateRmnRemoteInstruction: %w", err)
	}
	return nil
}

// UnmarshalUpdateRmnRemoteInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalUpdateRmnRemoteInstruction(buf []byte) (*UpdateRmnRemoteInstruction, error) {
	obj := new(UpdateRmnRemoteInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UpdateSvmChainSelectorInstruction struct {
	NewChainSelector uint64 `json:"new_chain_selector"`

	// Accounts:
	Config          solanago.PublicKey `json:"config"`
	ConfigWritable  bool               `json:"config_writable"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
	SystemProgram   solanago.PublicKey `json:"system_program"`
}

func (obj *UpdateSvmChainSelectorInstruction) GetDiscriminator() []byte {
	return Instruction_UpdateSvmChainSelector[:]
}

// UnmarshalWithDecoder unmarshals the UpdateSvmChainSelectorInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *UpdateSvmChainSelectorInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "UpdateSvmChainSelectorInstruction", err)
	}
	if discriminator != Instruction_UpdateSvmChainSelector {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "UpdateSvmChainSelectorInstruction", Instruction_UpdateSvmChainSelector, discriminator)
	}
	// Deserialize `NewChainSelector`:
	err = decoder.Decode(&obj.NewChainSelector)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UpdateSvmChainSelectorInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *UpdateSvmChainSelectorInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *UpdateSvmChainSelectorInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the UpdateSvmChainSelectorInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *UpdateSvmChainSelectorInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdateSvmChainSelectorInstruction: %w", err)
	}
	return nil
}

// UnmarshalUpdateSvmChainSelectorInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalUpdateSvmChainSelectorInstruction(buf []byte) (*UpdateSvmChainSelectorInstruction, error) {
	obj := new(UpdateSvmChainSelectorInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UpgradeTokenAdminRegistryFromV1Instruction struct {

	// Accounts:
	Config                     solanago.PublicKey `json:"config"`
	TokenAdminRegistry         solanago.PublicKey `json:"token_admin_registry"`
	TokenAdminRegistryWritable bool               `json:"token_admin_registry_writable"`
	Mint                       solanago.PublicKey `json:"mint"`
	Authority                  solanago.PublicKey `json:"authority"`
	AuthorityWritable          bool               `json:"authority_writable"`
	AuthoritySigner            bool               `json:"authority_signer"`
	SystemProgram              solanago.PublicKey `json:"system_program"`
}

func (obj *UpgradeTokenAdminRegistryFromV1Instruction) GetDiscriminator() []byte {
	return Instruction_UpgradeTokenAdminRegistryFromV1[:]
}

// UnmarshalWithDecoder unmarshals the UpgradeTokenAdminRegistryFromV1Instruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *UpgradeTokenAdminRegistryFromV1Instruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "UpgradeTokenAdminRegistryFromV1Instruction", err)
	}
	if discriminator != Instruction_UpgradeTokenAdminRegistryFromV1 {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "UpgradeTokenAdminRegistryFromV1Instruction", Instruction_UpgradeTokenAdminRegistryFromV1, discriminator)
	}
	return nil
}

func (obj *UpgradeTokenAdminRegistryFromV1Instruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from token_admin_registry account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_admin_registry", err)
	}
	indices = append(indices, index)
	// Decode from mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "mint", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *UpgradeTokenAdminRegistryFromV1Instruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 5 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 5, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_admin_registry account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_admin_registry", len(accountKeys)-1)
	}
	obj.TokenAdminRegistry = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "mint", len(accountKeys)-1)
	}
	obj.Mint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *UpgradeTokenAdminRegistryFromV1Instruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.TokenAdminRegistry)
	keys = append(keys, obj.Mint)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the UpgradeTokenAdminRegistryFromV1Instruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *UpgradeTokenAdminRegistryFromV1Instruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpgradeTokenAdminRegistryFromV1Instruction: %w", err)
	}
	return nil
}

// UnmarshalUpgradeTokenAdminRegistryFromV1Instruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalUpgradeTokenAdminRegistryFromV1Instruction(buf []byte) (*UpgradeTokenAdminRegistryFromV1Instruction, error) {
	obj := new(UpgradeTokenAdminRegistryFromV1Instruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type WithdrawBilledFundsInstruction struct {
	TransferAll   bool   `json:"transfer_all"`
	DesiredAmount uint64 `json:"desired_amount"`

	// Accounts:
	FeeTokenMint          solanago.PublicKey `json:"fee_token_mint"`
	FeeTokenAccum         solanago.PublicKey `json:"fee_token_accum"`
	FeeTokenAccumWritable bool               `json:"fee_token_accum_writable"`
	Recipient             solanago.PublicKey `json:"recipient"`
	RecipientWritable     bool               `json:"recipient_writable"`
	TokenProgram          solanago.PublicKey `json:"token_program"`
	FeeBillingSigner      solanago.PublicKey `json:"fee_billing_signer"`
	Config                solanago.PublicKey `json:"config"`
	Authority             solanago.PublicKey `json:"authority"`
	AuthorityWritable     bool               `json:"authority_writable"`
	AuthoritySigner       bool               `json:"authority_signer"`
}

func (obj *WithdrawBilledFundsInstruction) GetDiscriminator() []byte {
	return Instruction_WithdrawBilledFunds[:]
}

// UnmarshalWithDecoder unmarshals the WithdrawBilledFundsInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *WithdrawBilledFundsInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "WithdrawBilledFundsInstruction", err)
	}
	if discriminator != Instruction_WithdrawBilledFunds {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "WithdrawBilledFundsInstruction", Instruction_WithdrawBilledFunds, discriminator)
	}
	// Deserialize `TransferAll`:
	err = decoder.Decode(&obj.TransferAll)
	if err != nil {
		return err
	}
	// Deserialize `DesiredAmount`:
	err = decoder.Decode(&obj.DesiredAmount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *WithdrawBilledFundsInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from fee_token_mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_token_mint", err)
	}
	indices = append(indices, index)
	// Decode from fee_token_accum account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_token_accum", err)
	}
	indices = append(indices, index)
	// Decode from recipient account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "recipient", err)
	}
	indices = append(indices, index)
	// Decode from token_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_program", err)
	}
	indices = append(indices, index)
	// Decode from fee_billing_signer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "fee_billing_signer", err)
	}
	indices = append(indices, index)
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *WithdrawBilledFundsInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 7 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 7, len(indices))
	}
	indexOffset := 0
	// Set fee_token_mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_token_mint", len(accountKeys)-1)
	}
	obj.FeeTokenMint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_token_accum account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_token_accum", len(accountKeys)-1)
	}
	obj.FeeTokenAccum = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set recipient account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "recipient", len(accountKeys)-1)
	}
	obj.Recipient = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_program", len(accountKeys)-1)
	}
	obj.TokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set fee_billing_signer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "fee_billing_signer", len(accountKeys)-1)
	}
	obj.FeeBillingSigner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *WithdrawBilledFundsInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.FeeTokenMint)
	keys = append(keys, obj.FeeTokenAccum)
	keys = append(keys, obj.Recipient)
	keys = append(keys, obj.TokenProgram)
	keys = append(keys, obj.FeeBillingSigner)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the WithdrawBilledFundsInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *WithdrawBilledFundsInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling WithdrawBilledFundsInstruction: %w", err)
	}
	return nil
}

// UnmarshalWithdrawBilledFundsInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalWithdrawBilledFundsInstruction(buf []byte) (*WithdrawBilledFundsInstruction, error) {
	obj := new(WithdrawBilledFundsInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Instruction interface defines common methods for all instruction types
type Instruction interface {
	GetDiscriminator() []byte

	UnmarshalWithDecoder(decoder *binary.Decoder) error

	UnmarshalAccountIndices(buf []byte) ([]uint8, error)

	PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error

	GetAccountKeys() []solanago.PublicKey
}

// ParseInstruction parses instruction data and optionally populates accounts
// If accountIndicesData is nil or empty, accounts will not be populated
func ParseInstruction(instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (Instruction, error) {
	// Validate inputs
	if len(instructionData) < 8 {
		return nil, fmt.Errorf("instruction data too short: expected at least 8 bytes, got %d", len(instructionData))
	}
	// Extract discriminator
	discriminator := [8]byte{}
	copy(discriminator[:], instructionData[0:8])
	// Parse based on discriminator
	switch discriminator {
	case Instruction_AcceptAdminRoleTokenAdminRegistry:
		instruction := new(AcceptAdminRoleTokenAdminRegistryInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AcceptAdminRoleTokenAdminRegistryInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_AcceptOwnership:
		instruction := new(AcceptOwnershipInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AcceptOwnershipInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_AddChainSelector:
		instruction := new(AddChainSelectorInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AddChainSelectorInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_AddOfframp:
		instruction := new(AddOfframpInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AddOfframpInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_BumpCcipVersionForDestChain:
		instruction := new(BumpCcipVersionForDestChainInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as BumpCcipVersionForDestChainInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_CcipAdminOverridePendingAdministrator:
		instruction := new(CcipAdminOverridePendingAdministratorInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as CcipAdminOverridePendingAdministratorInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_CcipAdminProposeAdministrator:
		instruction := new(CcipAdminProposeAdministratorInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as CcipAdminProposeAdministratorInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_CcipSend:
		instruction := new(CcipSendInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as CcipSendInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_DeriveAccountsCcipSend:
		instruction := new(DeriveAccountsCcipSendInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as DeriveAccountsCcipSendInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_GetFee:
		instruction := new(GetFeeInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as GetFeeInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_Initialize:
		instruction := new(InitializeInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitializeInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_OwnerOverridePendingAdministrator:
		instruction := new(OwnerOverridePendingAdministratorInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as OwnerOverridePendingAdministratorInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_OwnerProposeAdministrator:
		instruction := new(OwnerProposeAdministratorInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as OwnerProposeAdministratorInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_RemoveOfframp:
		instruction := new(RemoveOfframpInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as RemoveOfframpInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_RollbackCcipVersionForDestChain:
		instruction := new(RollbackCcipVersionForDestChainInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as RollbackCcipVersionForDestChainInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SetDefaultCodeVersion:
		instruction := new(SetDefaultCodeVersionInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SetDefaultCodeVersionInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SetLinkTokenMint:
		instruction := new(SetLinkTokenMintInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SetLinkTokenMintInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SetPool:
		instruction := new(SetPoolInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SetPoolInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SetPoolSupportsAutoDerivation:
		instruction := new(SetPoolSupportsAutoDerivationInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SetPoolSupportsAutoDerivationInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_TransferAdminRoleTokenAdminRegistry:
		instruction := new(TransferAdminRoleTokenAdminRegistryInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as TransferAdminRoleTokenAdminRegistryInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_TransferOwnership:
		instruction := new(TransferOwnershipInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as TransferOwnershipInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_TypeVersion:
		instruction := new(TypeVersionInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as TypeVersionInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_UpdateDestChainConfig:
		instruction := new(UpdateDestChainConfigInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as UpdateDestChainConfigInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_UpdateFeeAggregator:
		instruction := new(UpdateFeeAggregatorInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as UpdateFeeAggregatorInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_UpdateRmnRemote:
		instruction := new(UpdateRmnRemoteInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as UpdateRmnRemoteInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_UpdateSvmChainSelector:
		instruction := new(UpdateSvmChainSelectorInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as UpdateSvmChainSelectorInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_UpgradeTokenAdminRegistryFromV1:
		instruction := new(UpgradeTokenAdminRegistryFromV1Instruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as UpgradeTokenAdminRegistryFromV1Instruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_WithdrawBilledFunds:
		instruction := new(WithdrawBilledFundsInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as WithdrawBilledFundsInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	default:
		return nil, fmt.Errorf("unknown instruction discriminator: %s", binary.FormatDiscriminator(discriminator))
	}
}

// ParseInstructionTyped parses instruction data and returns a specific instruction type // T must implement the Instruction interface
func ParseInstructionTyped[T Instruction](instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (T, error) {
	instruction, err := ParseInstruction(instructionData, accountIndicesData, accountKeys)
	if err != nil {
		return *new(T), err
	}
	typed, ok := instruction.(T)
	if !ok {
		return *new(T), fmt.Errorf("instruction is not of expected type")
	}
	return typed, nil
}

// ParseInstructionWithoutAccounts parses instruction data without account information
func ParseInstructionWithoutAccounts(instructionData []byte) (Instruction, error) {
	return ParseInstruction(instructionData, nil, []solanago.PublicKey{})
}

// ParseInstructionWithAccounts parses instruction data with account information
func ParseInstructionWithAccounts(instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (Instruction, error) {
	return ParseInstruction(instructionData, accountIndicesData, accountKeys)
}
