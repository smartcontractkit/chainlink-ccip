// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains parsers for the events defined in the IDL.

package ccip_router

import (
	"fmt"
	binary "github.com/gagliardetto/binary"
)

func ParseAnyEvent(eventData []byte) (any, error) {
	decoder := binary.NewBorshDecoder(eventData)
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return nil, fmt.Errorf("failed to peek event discriminator: %w", err)
	}
	switch discriminator {
	case Event_AdministratorTransferRequested:
		value := new(AdministratorTransferRequested)
		err := value.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal event as AdministratorTransferRequested: %w", err)
		}
		return value, nil
	case Event_AdministratorTransferred:
		value := new(AdministratorTransferred)
		err := value.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal event as AdministratorTransferred: %w", err)
		}
		return value, nil
	case Event_CcipMessageSent:
		value := new(CcipMessageSent)
		err := value.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal event as CcipMessageSent: %w", err)
		}
		return value, nil
	case Event_CcipVersionForDestChainVersionBumped:
		value := new(CcipVersionForDestChainVersionBumped)
		err := value.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal event as CcipVersionForDestChainVersionBumped: %w", err)
		}
		return value, nil
	case Event_CcipVersionForDestChainVersionRolledBack:
		value := new(CcipVersionForDestChainVersionRolledBack)
		err := value.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal event as CcipVersionForDestChainVersionRolledBack: %w", err)
		}
		return value, nil
	case Event_ConfigSet:
		value := new(ConfigSet)
		err := value.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal event as ConfigSet: %w", err)
		}
		return value, nil
	case Event_DestChainAdded:
		value := new(DestChainAdded)
		err := value.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal event as DestChainAdded: %w", err)
		}
		return value, nil
	case Event_DestChainConfigUpdated:
		value := new(DestChainConfigUpdated)
		err := value.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal event as DestChainConfigUpdated: %w", err)
		}
		return value, nil
	case Event_FeeTokenAdded:
		value := new(FeeTokenAdded)
		err := value.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal event as FeeTokenAdded: %w", err)
		}
		return value, nil
	case Event_FeeTokenDisabled:
		value := new(FeeTokenDisabled)
		err := value.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal event as FeeTokenDisabled: %w", err)
		}
		return value, nil
	case Event_FeeTokenEnabled:
		value := new(FeeTokenEnabled)
		err := value.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal event as FeeTokenEnabled: %w", err)
		}
		return value, nil
	case Event_FeeTokenRemoved:
		value := new(FeeTokenRemoved)
		err := value.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal event as FeeTokenRemoved: %w", err)
		}
		return value, nil
	case Event_IdlBuildTypeExport:
		value := new(IdlBuildTypeExport)
		err := value.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal event as IdlBuildTypeExport: %w", err)
		}
		return value, nil
	case Event_OfframpAdded:
		value := new(OfframpAdded)
		err := value.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal event as OfframpAdded: %w", err)
		}
		return value, nil
	case Event_OfframpRemoved:
		value := new(OfframpRemoved)
		err := value.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal event as OfframpRemoved: %w", err)
		}
		return value, nil
	case Event_OwnershipTransferRequested:
		value := new(OwnershipTransferRequested)
		err := value.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal event as OwnershipTransferRequested: %w", err)
		}
		return value, nil
	case Event_OwnershipTransferred:
		value := new(OwnershipTransferred)
		err := value.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal event as OwnershipTransferred: %w", err)
		}
		return value, nil
	case Event_PdaUpgraded:
		value := new(PdaUpgraded)
		err := value.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal event as PdaUpgraded: %w", err)
		}
		return value, nil
	case Event_PoolEdited:
		value := new(PoolEdited)
		err := value.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal event as PoolEdited: %w", err)
		}
		return value, nil
	case Event_PoolSet:
		value := new(PoolSet)
		err := value.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal event as PoolSet: %w", err)
		}
		return value, nil
	default:
		return nil, fmt.Errorf("unknown discriminator: %s", binary.FormatDiscriminator(discriminator))
	}
}

func ParseEvent_AdministratorTransferRequested(eventData []byte) (*AdministratorTransferRequested, error) {
	decoder := binary.NewBorshDecoder(eventData)
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return nil, fmt.Errorf("failed to peek discriminator: %w", err)
	}
	if discriminator != Event_AdministratorTransferRequested {
		return nil, fmt.Errorf("expected discriminator %v, got %s", Event_AdministratorTransferRequested, binary.FormatDiscriminator(discriminator))
	}
	event := new(AdministratorTransferRequested)
	err = event.UnmarshalWithDecoder(decoder)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal event of type AdministratorTransferRequested: %w", err)
	}
	return event, nil
}

func ParseEvent_AdministratorTransferred(eventData []byte) (*AdministratorTransferred, error) {
	decoder := binary.NewBorshDecoder(eventData)
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return nil, fmt.Errorf("failed to peek discriminator: %w", err)
	}
	if discriminator != Event_AdministratorTransferred {
		return nil, fmt.Errorf("expected discriminator %v, got %s", Event_AdministratorTransferred, binary.FormatDiscriminator(discriminator))
	}
	event := new(AdministratorTransferred)
	err = event.UnmarshalWithDecoder(decoder)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal event of type AdministratorTransferred: %w", err)
	}
	return event, nil
}

func ParseEvent_CcipMessageSent(eventData []byte) (*CcipMessageSent, error) {
	decoder := binary.NewBorshDecoder(eventData)
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return nil, fmt.Errorf("failed to peek discriminator: %w", err)
	}
	if discriminator != Event_CcipMessageSent {
		return nil, fmt.Errorf("expected discriminator %v, got %s", Event_CcipMessageSent, binary.FormatDiscriminator(discriminator))
	}
	event := new(CcipMessageSent)
	err = event.UnmarshalWithDecoder(decoder)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal event of type CcipMessageSent: %w", err)
	}
	return event, nil
}

func ParseEvent_CcipVersionForDestChainVersionBumped(eventData []byte) (*CcipVersionForDestChainVersionBumped, error) {
	decoder := binary.NewBorshDecoder(eventData)
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return nil, fmt.Errorf("failed to peek discriminator: %w", err)
	}
	if discriminator != Event_CcipVersionForDestChainVersionBumped {
		return nil, fmt.Errorf("expected discriminator %v, got %s", Event_CcipVersionForDestChainVersionBumped, binary.FormatDiscriminator(discriminator))
	}
	event := new(CcipVersionForDestChainVersionBumped)
	err = event.UnmarshalWithDecoder(decoder)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal event of type CcipVersionForDestChainVersionBumped: %w", err)
	}
	return event, nil
}

func ParseEvent_CcipVersionForDestChainVersionRolledBack(eventData []byte) (*CcipVersionForDestChainVersionRolledBack, error) {
	decoder := binary.NewBorshDecoder(eventData)
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return nil, fmt.Errorf("failed to peek discriminator: %w", err)
	}
	if discriminator != Event_CcipVersionForDestChainVersionRolledBack {
		return nil, fmt.Errorf("expected discriminator %v, got %s", Event_CcipVersionForDestChainVersionRolledBack, binary.FormatDiscriminator(discriminator))
	}
	event := new(CcipVersionForDestChainVersionRolledBack)
	err = event.UnmarshalWithDecoder(decoder)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal event of type CcipVersionForDestChainVersionRolledBack: %w", err)
	}
	return event, nil
}

func ParseEvent_ConfigSet(eventData []byte) (*ConfigSet, error) {
	decoder := binary.NewBorshDecoder(eventData)
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return nil, fmt.Errorf("failed to peek discriminator: %w", err)
	}
	if discriminator != Event_ConfigSet {
		return nil, fmt.Errorf("expected discriminator %v, got %s", Event_ConfigSet, binary.FormatDiscriminator(discriminator))
	}
	event := new(ConfigSet)
	err = event.UnmarshalWithDecoder(decoder)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal event of type ConfigSet: %w", err)
	}
	return event, nil
}

func ParseEvent_DestChainAdded(eventData []byte) (*DestChainAdded, error) {
	decoder := binary.NewBorshDecoder(eventData)
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return nil, fmt.Errorf("failed to peek discriminator: %w", err)
	}
	if discriminator != Event_DestChainAdded {
		return nil, fmt.Errorf("expected discriminator %v, got %s", Event_DestChainAdded, binary.FormatDiscriminator(discriminator))
	}
	event := new(DestChainAdded)
	err = event.UnmarshalWithDecoder(decoder)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal event of type DestChainAdded: %w", err)
	}
	return event, nil
}

func ParseEvent_DestChainConfigUpdated(eventData []byte) (*DestChainConfigUpdated, error) {
	decoder := binary.NewBorshDecoder(eventData)
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return nil, fmt.Errorf("failed to peek discriminator: %w", err)
	}
	if discriminator != Event_DestChainConfigUpdated {
		return nil, fmt.Errorf("expected discriminator %v, got %s", Event_DestChainConfigUpdated, binary.FormatDiscriminator(discriminator))
	}
	event := new(DestChainConfigUpdated)
	err = event.UnmarshalWithDecoder(decoder)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal event of type DestChainConfigUpdated: %w", err)
	}
	return event, nil
}

func ParseEvent_FeeTokenAdded(eventData []byte) (*FeeTokenAdded, error) {
	decoder := binary.NewBorshDecoder(eventData)
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return nil, fmt.Errorf("failed to peek discriminator: %w", err)
	}
	if discriminator != Event_FeeTokenAdded {
		return nil, fmt.Errorf("expected discriminator %v, got %s", Event_FeeTokenAdded, binary.FormatDiscriminator(discriminator))
	}
	event := new(FeeTokenAdded)
	err = event.UnmarshalWithDecoder(decoder)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal event of type FeeTokenAdded: %w", err)
	}
	return event, nil
}

func ParseEvent_FeeTokenDisabled(eventData []byte) (*FeeTokenDisabled, error) {
	decoder := binary.NewBorshDecoder(eventData)
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return nil, fmt.Errorf("failed to peek discriminator: %w", err)
	}
	if discriminator != Event_FeeTokenDisabled {
		return nil, fmt.Errorf("expected discriminator %v, got %s", Event_FeeTokenDisabled, binary.FormatDiscriminator(discriminator))
	}
	event := new(FeeTokenDisabled)
	err = event.UnmarshalWithDecoder(decoder)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal event of type FeeTokenDisabled: %w", err)
	}
	return event, nil
}

func ParseEvent_FeeTokenEnabled(eventData []byte) (*FeeTokenEnabled, error) {
	decoder := binary.NewBorshDecoder(eventData)
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return nil, fmt.Errorf("failed to peek discriminator: %w", err)
	}
	if discriminator != Event_FeeTokenEnabled {
		return nil, fmt.Errorf("expected discriminator %v, got %s", Event_FeeTokenEnabled, binary.FormatDiscriminator(discriminator))
	}
	event := new(FeeTokenEnabled)
	err = event.UnmarshalWithDecoder(decoder)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal event of type FeeTokenEnabled: %w", err)
	}
	return event, nil
}

func ParseEvent_FeeTokenRemoved(eventData []byte) (*FeeTokenRemoved, error) {
	decoder := binary.NewBorshDecoder(eventData)
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return nil, fmt.Errorf("failed to peek discriminator: %w", err)
	}
	if discriminator != Event_FeeTokenRemoved {
		return nil, fmt.Errorf("expected discriminator %v, got %s", Event_FeeTokenRemoved, binary.FormatDiscriminator(discriminator))
	}
	event := new(FeeTokenRemoved)
	err = event.UnmarshalWithDecoder(decoder)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal event of type FeeTokenRemoved: %w", err)
	}
	return event, nil
}

func ParseEvent_IdlBuildTypeExport(eventData []byte) (*IdlBuildTypeExport, error) {
	decoder := binary.NewBorshDecoder(eventData)
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return nil, fmt.Errorf("failed to peek discriminator: %w", err)
	}
	if discriminator != Event_IdlBuildTypeExport {
		return nil, fmt.Errorf("expected discriminator %v, got %s", Event_IdlBuildTypeExport, binary.FormatDiscriminator(discriminator))
	}
	event := new(IdlBuildTypeExport)
	err = event.UnmarshalWithDecoder(decoder)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal event of type IdlBuildTypeExport: %w", err)
	}
	return event, nil
}

func ParseEvent_OfframpAdded(eventData []byte) (*OfframpAdded, error) {
	decoder := binary.NewBorshDecoder(eventData)
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return nil, fmt.Errorf("failed to peek discriminator: %w", err)
	}
	if discriminator != Event_OfframpAdded {
		return nil, fmt.Errorf("expected discriminator %v, got %s", Event_OfframpAdded, binary.FormatDiscriminator(discriminator))
	}
	event := new(OfframpAdded)
	err = event.UnmarshalWithDecoder(decoder)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal event of type OfframpAdded: %w", err)
	}
	return event, nil
}

func ParseEvent_OfframpRemoved(eventData []byte) (*OfframpRemoved, error) {
	decoder := binary.NewBorshDecoder(eventData)
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return nil, fmt.Errorf("failed to peek discriminator: %w", err)
	}
	if discriminator != Event_OfframpRemoved {
		return nil, fmt.Errorf("expected discriminator %v, got %s", Event_OfframpRemoved, binary.FormatDiscriminator(discriminator))
	}
	event := new(OfframpRemoved)
	err = event.UnmarshalWithDecoder(decoder)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal event of type OfframpRemoved: %w", err)
	}
	return event, nil
}

func ParseEvent_OwnershipTransferRequested(eventData []byte) (*OwnershipTransferRequested, error) {
	decoder := binary.NewBorshDecoder(eventData)
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return nil, fmt.Errorf("failed to peek discriminator: %w", err)
	}
	if discriminator != Event_OwnershipTransferRequested {
		return nil, fmt.Errorf("expected discriminator %v, got %s", Event_OwnershipTransferRequested, binary.FormatDiscriminator(discriminator))
	}
	event := new(OwnershipTransferRequested)
	err = event.UnmarshalWithDecoder(decoder)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal event of type OwnershipTransferRequested: %w", err)
	}
	return event, nil
}

func ParseEvent_OwnershipTransferred(eventData []byte) (*OwnershipTransferred, error) {
	decoder := binary.NewBorshDecoder(eventData)
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return nil, fmt.Errorf("failed to peek discriminator: %w", err)
	}
	if discriminator != Event_OwnershipTransferred {
		return nil, fmt.Errorf("expected discriminator %v, got %s", Event_OwnershipTransferred, binary.FormatDiscriminator(discriminator))
	}
	event := new(OwnershipTransferred)
	err = event.UnmarshalWithDecoder(decoder)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal event of type OwnershipTransferred: %w", err)
	}
	return event, nil
}

func ParseEvent_PdaUpgraded(eventData []byte) (*PdaUpgraded, error) {
	decoder := binary.NewBorshDecoder(eventData)
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return nil, fmt.Errorf("failed to peek discriminator: %w", err)
	}
	if discriminator != Event_PdaUpgraded {
		return nil, fmt.Errorf("expected discriminator %v, got %s", Event_PdaUpgraded, binary.FormatDiscriminator(discriminator))
	}
	event := new(PdaUpgraded)
	err = event.UnmarshalWithDecoder(decoder)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal event of type PdaUpgraded: %w", err)
	}
	return event, nil
}

func ParseEvent_PoolEdited(eventData []byte) (*PoolEdited, error) {
	decoder := binary.NewBorshDecoder(eventData)
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return nil, fmt.Errorf("failed to peek discriminator: %w", err)
	}
	if discriminator != Event_PoolEdited {
		return nil, fmt.Errorf("expected discriminator %v, got %s", Event_PoolEdited, binary.FormatDiscriminator(discriminator))
	}
	event := new(PoolEdited)
	err = event.UnmarshalWithDecoder(decoder)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal event of type PoolEdited: %w", err)
	}
	return event, nil
}

func ParseEvent_PoolSet(eventData []byte) (*PoolSet, error) {
	decoder := binary.NewBorshDecoder(eventData)
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return nil, fmt.Errorf("failed to peek discriminator: %w", err)
	}
	if discriminator != Event_PoolSet {
		return nil, fmt.Errorf("expected discriminator %v, got %s", Event_PoolSet, binary.FormatDiscriminator(discriminator))
	}
	event := new(PoolSet)
	err = event.UnmarshalWithDecoder(decoder)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal event of type PoolSet: %w", err)
	}
	return event, nil
}
