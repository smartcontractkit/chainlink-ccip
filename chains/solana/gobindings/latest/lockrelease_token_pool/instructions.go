// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains instructions.

package lockrelease_token_pool

import (
	"bytes"
	"fmt"
	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "accept_ownership" instruction.
func NewAcceptOwnershipInstruction(
	stateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "append_remote_pool_addresses" instruction.
func NewAppendRemotePoolAddressesInstruction(
	// Params:
	remoteChainSelectorParam uint64,
	mintParam solanago.PublicKey,
	addressesParam []RemoteAddress,

	// Accounts:
	stateAccount solanago.PublicKey,
	chainConfigAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AppendRemotePoolAddresses[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `remoteChainSelectorParam`:
		err = enc__.Encode(remoteChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("remoteChainSelectorParam", err)
		}
		// Serialize `mintParam`:
		err = enc__.Encode(mintParam)
		if err != nil {
			return nil, errors.NewField("mintParam", err)
		}
		// Serialize `addressesParam`:
		err = enc__.Encode(addressesParam)
		if err != nil {
			return nil, errors.NewField("addressesParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "chain_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(chainConfigAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "configure_allow_list" instruction.
func NewConfigureAllowListInstruction(
	// Params:
	addParam []solanago.PublicKey,
	enabledParam bool,

	// Accounts:
	stateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ConfigureAllowList[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `addParam`:
		err = enc__.Encode(addParam)
		if err != nil {
			return nil, errors.NewField("addParam", err)
		}
		// Serialize `enabledParam`:
		err = enc__.Encode(enabledParam)
		if err != nil {
			return nil, errors.NewField("enabledParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "delete_chain_config" instruction.
func NewDeleteChainConfigInstruction(
	// Params:
	remoteChainSelectorParam uint64,
	mintParam solanago.PublicKey,

	// Accounts:
	stateAccount solanago.PublicKey,
	chainConfigAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_DeleteChainConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `remoteChainSelectorParam`:
		err = enc__.Encode(remoteChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("remoteChainSelectorParam", err)
		}
		// Serialize `mintParam`:
		err = enc__.Encode(mintParam)
		if err != nil {
			return nil, errors.NewField("mintParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "chain_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(chainConfigAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "edit_chain_remote_config" instruction.
func NewEditChainRemoteConfigInstruction(
	// Params:
	remoteChainSelectorParam uint64,
	mintParam solanago.PublicKey,
	cfgParam RemoteConfig,

	// Accounts:
	stateAccount solanago.PublicKey,
	chainConfigAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_EditChainRemoteConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `remoteChainSelectorParam`:
		err = enc__.Encode(remoteChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("remoteChainSelectorParam", err)
		}
		// Serialize `mintParam`:
		err = enc__.Encode(mintParam)
		if err != nil {
			return nil, errors.NewField("mintParam", err)
		}
		// Serialize `cfgParam`:
		err = enc__.Encode(cfgParam)
		if err != nil {
			return nil, errors.NewField("cfgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "chain_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(chainConfigAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "init_chain_remote_config" instruction.
func NewInitChainRemoteConfigInstruction(
	// Params:
	remoteChainSelectorParam uint64,
	mintParam solanago.PublicKey,
	cfgParam RemoteConfig,

	// Accounts:
	stateAccount solanago.PublicKey,
	chainConfigAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitChainRemoteConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `remoteChainSelectorParam`:
		err = enc__.Encode(remoteChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("remoteChainSelectorParam", err)
		}
		// Serialize `mintParam`:
		err = enc__.Encode(mintParam)
		if err != nil {
			return nil, errors.NewField("mintParam", err)
		}
		// Serialize `cfgParam`:
		err = enc__.Encode(cfgParam)
		if err != nil {
			return nil, errors.NewField("cfgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "chain_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(chainConfigAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "init_global_config" instruction.
func NewInitGlobalConfigInstruction(
	// Params:
	routerAddressParam solanago.PublicKey,
	rmnAddressParam solanago.PublicKey,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
	programDataAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitGlobalConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `routerAddressParam`:
		err = enc__.Encode(routerAddressParam)
		if err != nil {
			return nil, errors.NewField("routerAddressParam", err)
		}
		// Serialize `rmnAddressParam`:
		err = enc__.Encode(rmnAddressParam)
		if err != nil {
			return nil, errors.NewField("rmnAddressParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 3 "program": Read-only, Non-signer, Required, Address: 8eqh8wppT9c5rw4ERqNCffvU6cNFJWff9WmkcYtmGiqC
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
		// Account 4 "program_data": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programDataAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize" instruction.
func NewInitializeInstruction(
	stateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
	programDataAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 4 "program": Read-only, Non-signer, Required, Address: 8eqh8wppT9c5rw4ERqNCffvU6cNFJWff9WmkcYtmGiqC
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
		// Account 5 "program_data": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programDataAccount, false, false))
		// Account 6 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "initialize_state_version" instruction.
func NewInitializeStateVersionInstruction(
	// Params:
	mintParam solanago.PublicKey,

	// Accounts:
	stateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeStateVersion[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `mintParam`:
		err = enc__.Encode(mintParam)
		if err != nil {
			return nil, errors.NewField("mintParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "lock_or_burn_tokens" instruction.
func NewLockOrBurnTokensInstruction(
	// Params:
	lockOrBurnParam LockOrBurnInV1,

	// Accounts:
	authorityAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	poolSignerAccount solanago.PublicKey,
	poolTokenAccountAccount solanago.PublicKey,
	rmnRemoteAccount solanago.PublicKey,
	rmnRemoteCursesAccount solanago.PublicKey,
	rmnRemoteConfigAccount solanago.PublicKey,
	chainConfigAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_LockOrBurnTokens[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `lockOrBurnParam`:
		err = enc__.Encode(lockOrBurnParam)
		if err != nil {
			return nil, errors.NewField("lockOrBurnParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 3 "mint": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, false))
		// Account 4 "pool_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolSignerAccount, false, false))
		// Account 5 "pool_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolTokenAccountAccount, true, false))
		// Account 6 "rmn_remote": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteAccount, false, false))
		// Account 7 "rmn_remote_curses": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteCursesAccount, false, false))
		// Account 8 "rmn_remote_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteConfigAccount, false, false))
		// Account 9 "chain_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(chainConfigAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "provide_liquidity" instruction.
func NewProvideLiquidityInstruction(
	// Params:
	amountParam uint64,

	// Accounts:
	stateAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	poolSignerAccount solanago.PublicKey,
	poolTokenAccountAccount solanago.PublicKey,
	remoteTokenAccountAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ProvideLiquidity[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `amountParam`:
		err = enc__.Encode(amountParam)
		if err != nil {
			return nil, errors.NewField("amountParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 2 "mint": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, false))
		// Account 3 "pool_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolSignerAccount, false, false))
		// Account 4 "pool_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolTokenAccountAccount, true, false))
		// Account 5 "remote_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(remoteTokenAccountAccount, true, false))
		// Account 6 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "release_or_mint_tokens" instruction.
func NewReleaseOrMintTokensInstruction(
	// Params:
	releaseOrMintParam ReleaseOrMintInV1,

	// Accounts:
	authorityAccount solanago.PublicKey,
	offrampProgramAccount solanago.PublicKey,
	allowedOfframpAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	poolSignerAccount solanago.PublicKey,
	poolTokenAccountAccount solanago.PublicKey,
	chainConfigAccount solanago.PublicKey,
	rmnRemoteAccount solanago.PublicKey,
	rmnRemoteCursesAccount solanago.PublicKey,
	rmnRemoteConfigAccount solanago.PublicKey,
	receiverTokenAccountAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ReleaseOrMintTokens[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `releaseOrMintParam`:
		err = enc__.Encode(releaseOrMintParam)
		if err != nil {
			return nil, errors.NewField("releaseOrMintParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 1 "offramp_program": Read-only, Non-signer, Required
		// CHECK offramp program: exists only to derive the allowed offramp PDA
		// and the authority PDA.
		accounts__.Append(solanago.NewAccountMeta(offrampProgramAccount, false, false))
		// Account 2 "allowed_offramp": Read-only, Non-signer, Required
		// CHECK PDA of the router program verifying the signer is an allowed offramp.
		// If PDA does not exist, the router doesn't allow this offramp
		accounts__.Append(solanago.NewAccountMeta(allowedOfframpAccount, false, false))
		// Account 3 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 4 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 5 "mint": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, false))
		// Account 6 "pool_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolSignerAccount, false, false))
		// Account 7 "pool_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolTokenAccountAccount, true, false))
		// Account 8 "chain_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(chainConfigAccount, true, false))
		// Account 9 "rmn_remote": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteAccount, false, false))
		// Account 10 "rmn_remote_curses": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteCursesAccount, false, false))
		// Account 11 "rmn_remote_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteConfigAccount, false, false))
		// Account 12 "receiver_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(receiverTokenAccountAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "remove_from_allow_list" instruction.
func NewRemoveFromAllowListInstruction(
	// Params:
	removeParam []solanago.PublicKey,

	// Accounts:
	stateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RemoveFromAllowList[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `removeParam`:
		err = enc__.Encode(removeParam)
		if err != nil {
			return nil, errors.NewField("removeParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_can_accept_liquidity" instruction.
func NewSetCanAcceptLiquidityInstruction(
	// Params:
	allowParam bool,

	// Accounts:
	stateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetCanAcceptLiquidity[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `allowParam`:
		err = enc__.Encode(allowParam)
		if err != nil {
			return nil, errors.NewField("allowParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_chain_rate_limit" instruction.
func NewSetChainRateLimitInstruction(
	// Params:
	remoteChainSelectorParam uint64,
	mintParam solanago.PublicKey,
	inboundParam RateLimitConfig,
	outboundParam RateLimitConfig,

	// Accounts:
	stateAccount solanago.PublicKey,
	chainConfigAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetChainRateLimit[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `remoteChainSelectorParam`:
		err = enc__.Encode(remoteChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("remoteChainSelectorParam", err)
		}
		// Serialize `mintParam`:
		err = enc__.Encode(mintParam)
		if err != nil {
			return nil, errors.NewField("mintParam", err)
		}
		// Serialize `inboundParam`:
		err = enc__.Encode(inboundParam)
		if err != nil {
			return nil, errors.NewField("inboundParam", err)
		}
		// Serialize `outboundParam`:
		err = enc__.Encode(outboundParam)
		if err != nil {
			return nil, errors.NewField("outboundParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "chain_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(chainConfigAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_rate_limit_admin" instruction.
func NewSetRateLimitAdminInstruction(
	// Params:
	mintParam solanago.PublicKey,
	newRateLimitAdminParam solanago.PublicKey,

	// Accounts:
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetRateLimitAdmin[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `mintParam`:
		err = enc__.Encode(mintParam)
		if err != nil {
			return nil, errors.NewField("mintParam", err)
		}
		// Serialize `newRateLimitAdminParam`:
		err = enc__.Encode(newRateLimitAdminParam)
		if err != nil {
			return nil, errors.NewField("newRateLimitAdminParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_rebalancer" instruction.
func NewSetRebalancerInstruction(
	// Params:
	rebalancerParam solanago.PublicKey,

	// Accounts:
	stateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetRebalancer[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `rebalancerParam`:
		err = enc__.Encode(rebalancerParam)
		if err != nil {
			return nil, errors.NewField("rebalancerParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_rmn" instruction.
func NewSetRmnInstruction(
	// Params:
	rmnAddressParam solanago.PublicKey,

	// Accounts:
	stateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
	programDataAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetRmn[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `rmnAddressParam`:
		err = enc__.Encode(rmnAddressParam)
		if err != nil {
			return nil, errors.NewField("rmnAddressParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "program": Read-only, Non-signer, Required, Address: 8eqh8wppT9c5rw4ERqNCffvU6cNFJWff9WmkcYtmGiqC
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
		// Account 4 "program_data": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programDataAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_router" instruction.
func NewSetRouterInstruction(
	// Params:
	newRouterParam solanago.PublicKey,

	// Accounts:
	stateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
	programDataAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetRouter[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newRouterParam`:
		err = enc__.Encode(newRouterParam)
		if err != nil {
			return nil, errors.NewField("newRouterParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "program": Read-only, Non-signer, Required, Address: 8eqh8wppT9c5rw4ERqNCffvU6cNFJWff9WmkcYtmGiqC
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
		// Account 4 "program_data": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programDataAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "transfer_ownership" instruction.
func NewTransferOwnershipInstruction(
	// Params:
	proposedOwnerParam solanago.PublicKey,

	// Accounts:
	stateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_TransferOwnership[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `proposedOwnerParam`:
		err = enc__.Encode(proposedOwnerParam)
		if err != nil {
			return nil, errors.NewField("proposedOwnerParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "type_version" instruction.
// Returns the program type (name) and version. // Used by offchain code to easily determine which program & version is being interacted with. //  // # Arguments // * `ctx` - The context
func NewTypeVersionInstruction(
	clockAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "clock": Read-only, Non-signer, Required, Address: SysvarC1ock11111111111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(clockAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "update_default_rmn" instruction.
func NewUpdateDefaultRmnInstruction(
	// Params:
	rmnAddressParam solanago.PublicKey,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
	programDataAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateDefaultRmn[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `rmnAddressParam`:
		err = enc__.Encode(rmnAddressParam)
		if err != nil {
			return nil, errors.NewField("rmnAddressParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 2 "program": Read-only, Non-signer, Required, Address: 8eqh8wppT9c5rw4ERqNCffvU6cNFJWff9WmkcYtmGiqC
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
		// Account 3 "program_data": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programDataAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_default_router" instruction.
func NewUpdateDefaultRouterInstruction(
	// Params:
	routerAddressParam solanago.PublicKey,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
	programDataAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateDefaultRouter[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `routerAddressParam`:
		err = enc__.Encode(routerAddressParam)
		if err != nil {
			return nil, errors.NewField("routerAddressParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 2 "program": Read-only, Non-signer, Required, Address: 8eqh8wppT9c5rw4ERqNCffvU6cNFJWff9WmkcYtmGiqC
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
		// Account 3 "program_data": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programDataAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_self_served_allowed" instruction.
func NewUpdateSelfServedAllowedInstruction(
	// Params:
	selfServedAllowedParam bool,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
	programDataAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateSelfServedAllowed[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `selfServedAllowedParam`:
		err = enc__.Encode(selfServedAllowedParam)
		if err != nil {
			return nil, errors.NewField("selfServedAllowedParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 2 "program": Read-only, Non-signer, Required, Address: 8eqh8wppT9c5rw4ERqNCffvU6cNFJWff9WmkcYtmGiqC
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
		// Account 3 "program_data": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programDataAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "withdraw_liquidity" instruction.
func NewWithdrawLiquidityInstruction(
	// Params:
	amountParam uint64,

	// Accounts:
	stateAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	poolSignerAccount solanago.PublicKey,
	poolTokenAccountAccount solanago.PublicKey,
	remoteTokenAccountAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_WithdrawLiquidity[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `amountParam`:
		err = enc__.Encode(amountParam)
		if err != nil {
			return nil, errors.NewField("amountParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 2 "mint": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, false))
		// Account 3 "pool_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolSignerAccount, false, false))
		// Account 4 "pool_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolTokenAccountAccount, true, false))
		// Account 5 "remote_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(remoteTokenAccountAccount, true, false))
		// Account 6 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}
