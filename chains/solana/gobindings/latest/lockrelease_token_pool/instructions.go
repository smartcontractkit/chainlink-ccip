// Code generated by https://github.com/Unheilbar/anchor-go. DO NOT EDIT.
// This file contains instructions and instruction parsers.

package lockrelease_token_pool

import (
	"bytes"
	"fmt"
	errors "github.com/Unheilbar/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "accept_ownership" instruction.
func NewAcceptOwnershipInstruction(
	stateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AcceptOwnership[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "append_remote_pool_addresses" instruction.
func NewAppendRemotePoolAddressesInstruction(
	// Params:
	remoteChainSelectorParam uint64,
	mintParam solanago.PublicKey,
	addressesParam []RemoteAddress,

	// Accounts:
	stateAccount solanago.PublicKey,
	chainConfigAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AppendRemotePoolAddresses[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `remoteChainSelectorParam`:
		err = enc__.Encode(remoteChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("remoteChainSelectorParam", err)
		}
		// Serialize `mintParam`:
		err = enc__.Encode(mintParam)
		if err != nil {
			return nil, errors.NewField("mintParam", err)
		}
		// Serialize `addressesParam`:
		err = enc__.Encode(addressesParam)
		if err != nil {
			return nil, errors.NewField("addressesParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "chain_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(chainConfigAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "configure_allow_list" instruction.
func NewConfigureAllowListInstruction(
	// Params:
	addParam []solanago.PublicKey,
	enabledParam bool,

	// Accounts:
	stateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ConfigureAllowList[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `addParam`:
		err = enc__.Encode(addParam)
		if err != nil {
			return nil, errors.NewField("addParam", err)
		}
		// Serialize `enabledParam`:
		err = enc__.Encode(enabledParam)
		if err != nil {
			return nil, errors.NewField("enabledParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "delete_chain_config" instruction.
func NewDeleteChainConfigInstruction(
	// Params:
	remoteChainSelectorParam uint64,
	mintParam solanago.PublicKey,

	// Accounts:
	stateAccount solanago.PublicKey,
	chainConfigAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_DeleteChainConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `remoteChainSelectorParam`:
		err = enc__.Encode(remoteChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("remoteChainSelectorParam", err)
		}
		// Serialize `mintParam`:
		err = enc__.Encode(mintParam)
		if err != nil {
			return nil, errors.NewField("mintParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "chain_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(chainConfigAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "edit_chain_remote_config" instruction.
func NewEditChainRemoteConfigInstruction(
	// Params:
	remoteChainSelectorParam uint64,
	mintParam solanago.PublicKey,
	cfgParam RemoteConfig,

	// Accounts:
	stateAccount solanago.PublicKey,
	chainConfigAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_EditChainRemoteConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `remoteChainSelectorParam`:
		err = enc__.Encode(remoteChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("remoteChainSelectorParam", err)
		}
		// Serialize `mintParam`:
		err = enc__.Encode(mintParam)
		if err != nil {
			return nil, errors.NewField("mintParam", err)
		}
		// Serialize `cfgParam`:
		err = enc__.Encode(cfgParam)
		if err != nil {
			return nil, errors.NewField("cfgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "chain_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(chainConfigAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "init_chain_remote_config" instruction.
func NewInitChainRemoteConfigInstruction(
	// Params:
	remoteChainSelectorParam uint64,
	mintParam solanago.PublicKey,
	cfgParam RemoteConfig,

	// Accounts:
	stateAccount solanago.PublicKey,
	chainConfigAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitChainRemoteConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `remoteChainSelectorParam`:
		err = enc__.Encode(remoteChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("remoteChainSelectorParam", err)
		}
		// Serialize `mintParam`:
		err = enc__.Encode(mintParam)
		if err != nil {
			return nil, errors.NewField("mintParam", err)
		}
		// Serialize `cfgParam`:
		err = enc__.Encode(cfgParam)
		if err != nil {
			return nil, errors.NewField("cfgParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "chain_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(chainConfigAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "init_global_config" instruction.
func NewInitGlobalConfigInstruction(
	// Params:
	routerAddressParam solanago.PublicKey,
	rmnAddressParam solanago.PublicKey,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
	programDataAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitGlobalConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `routerAddressParam`:
		err = enc__.Encode(routerAddressParam)
		if err != nil {
			return nil, errors.NewField("routerAddressParam", err)
		}
		// Serialize `rmnAddressParam`:
		err = enc__.Encode(rmnAddressParam)
		if err != nil {
			return nil, errors.NewField("rmnAddressParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 3 "program": Read-only, Non-signer, Required, Address: 8eqh8wppT9c5rw4ERqNCffvU6cNFJWff9WmkcYtmGiqC
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
		// Account 4 "program_data": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programDataAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize" instruction.
func NewInitializeInstruction(
	stateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
	programDataAccount solanago.PublicKey,
	configAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Initialize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 4 "program": Read-only, Non-signer, Required, Address: 8eqh8wppT9c5rw4ERqNCffvU6cNFJWff9WmkcYtmGiqC
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
		// Account 5 "program_data": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programDataAccount, false, false))
		// Account 6 "config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_state_version" instruction.
func NewInitializeStateVersionInstruction(
	// Params:
	mintParam solanago.PublicKey,

	// Accounts:
	stateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeStateVersion[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `mintParam`:
		err = enc__.Encode(mintParam)
		if err != nil {
			return nil, errors.NewField("mintParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "lock_or_burn_tokens" instruction.
func NewLockOrBurnTokensInstruction(
	// Params:
	lockOrBurnParam LockOrBurnInV1,

	// Accounts:
	authorityAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	poolSignerAccount solanago.PublicKey,
	poolTokenAccountAccount solanago.PublicKey,
	rmnRemoteAccount solanago.PublicKey,
	rmnRemoteCursesAccount solanago.PublicKey,
	rmnRemoteConfigAccount solanago.PublicKey,
	chainConfigAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_LockOrBurnTokens[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `lockOrBurnParam`:
		err = enc__.Encode(lockOrBurnParam)
		if err != nil {
			return nil, errors.NewField("lockOrBurnParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 1 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 2 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 3 "mint": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, false))
		// Account 4 "pool_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolSignerAccount, false, false))
		// Account 5 "pool_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolTokenAccountAccount, true, false))
		// Account 6 "rmn_remote": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteAccount, false, false))
		// Account 7 "rmn_remote_curses": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteCursesAccount, false, false))
		// Account 8 "rmn_remote_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteConfigAccount, false, false))
		// Account 9 "chain_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(chainConfigAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "provide_liquidity" instruction.
func NewProvideLiquidityInstruction(
	// Params:
	amountParam uint64,

	// Accounts:
	stateAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	poolSignerAccount solanago.PublicKey,
	poolTokenAccountAccount solanago.PublicKey,
	remoteTokenAccountAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ProvideLiquidity[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `amountParam`:
		err = enc__.Encode(amountParam)
		if err != nil {
			return nil, errors.NewField("amountParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 2 "mint": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, false))
		// Account 3 "pool_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolSignerAccount, false, false))
		// Account 4 "pool_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolTokenAccountAccount, true, false))
		// Account 5 "remote_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(remoteTokenAccountAccount, true, false))
		// Account 6 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "release_or_mint_tokens" instruction.
func NewReleaseOrMintTokensInstruction(
	// Params:
	releaseOrMintParam ReleaseOrMintInV1,

	// Accounts:
	authorityAccount solanago.PublicKey,
	offrampProgramAccount solanago.PublicKey,
	allowedOfframpAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	poolSignerAccount solanago.PublicKey,
	poolTokenAccountAccount solanago.PublicKey,
	chainConfigAccount solanago.PublicKey,
	rmnRemoteAccount solanago.PublicKey,
	rmnRemoteCursesAccount solanago.PublicKey,
	rmnRemoteConfigAccount solanago.PublicKey,
	receiverTokenAccountAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ReleaseOrMintTokens[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `releaseOrMintParam`:
		err = enc__.Encode(releaseOrMintParam)
		if err != nil {
			return nil, errors.NewField("releaseOrMintParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 1 "offramp_program": Read-only, Non-signer, Required
		// CHECK offramp program: exists only to derive the allowed offramp PDA
		// and the authority PDA.
		accounts__.Append(solanago.NewAccountMeta(offrampProgramAccount, false, false))
		// Account 2 "allowed_offramp": Read-only, Non-signer, Required
		// CHECK PDA of the router program verifying the signer is an allowed offramp.
		// If PDA does not exist, the router doesn't allow this offramp
		accounts__.Append(solanago.NewAccountMeta(allowedOfframpAccount, false, false))
		// Account 3 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 4 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 5 "mint": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, false))
		// Account 6 "pool_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolSignerAccount, false, false))
		// Account 7 "pool_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolTokenAccountAccount, true, false))
		// Account 8 "chain_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(chainConfigAccount, true, false))
		// Account 9 "rmn_remote": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteAccount, false, false))
		// Account 10 "rmn_remote_curses": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteCursesAccount, false, false))
		// Account 11 "rmn_remote_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteConfigAccount, false, false))
		// Account 12 "receiver_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(receiverTokenAccountAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "remove_from_allow_list" instruction.
func NewRemoveFromAllowListInstruction(
	// Params:
	removeParam []solanago.PublicKey,

	// Accounts:
	stateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RemoveFromAllowList[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `removeParam`:
		err = enc__.Encode(removeParam)
		if err != nil {
			return nil, errors.NewField("removeParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_can_accept_liquidity" instruction.
func NewSetCanAcceptLiquidityInstruction(
	// Params:
	allowParam bool,

	// Accounts:
	stateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetCanAcceptLiquidity[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `allowParam`:
		err = enc__.Encode(allowParam)
		if err != nil {
			return nil, errors.NewField("allowParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_chain_rate_limit" instruction.
func NewSetChainRateLimitInstruction(
	// Params:
	remoteChainSelectorParam uint64,
	mintParam solanago.PublicKey,
	inboundParam RateLimitConfig,
	outboundParam RateLimitConfig,

	// Accounts:
	stateAccount solanago.PublicKey,
	chainConfigAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetChainRateLimit[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `remoteChainSelectorParam`:
		err = enc__.Encode(remoteChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("remoteChainSelectorParam", err)
		}
		// Serialize `mintParam`:
		err = enc__.Encode(mintParam)
		if err != nil {
			return nil, errors.NewField("mintParam", err)
		}
		// Serialize `inboundParam`:
		err = enc__.Encode(inboundParam)
		if err != nil {
			return nil, errors.NewField("inboundParam", err)
		}
		// Serialize `outboundParam`:
		err = enc__.Encode(outboundParam)
		if err != nil {
			return nil, errors.NewField("outboundParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "chain_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(chainConfigAccount, true, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_rate_limit_admin" instruction.
func NewSetRateLimitAdminInstruction(
	// Params:
	mintParam solanago.PublicKey,
	newRateLimitAdminParam solanago.PublicKey,

	// Accounts:
	stateAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetRateLimitAdmin[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `mintParam`:
		err = enc__.Encode(mintParam)
		if err != nil {
			return nil, errors.NewField("mintParam", err)
		}
		// Serialize `newRateLimitAdminParam`:
		err = enc__.Encode(newRateLimitAdminParam)
		if err != nil {
			return nil, errors.NewField("newRateLimitAdminParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_rebalancer" instruction.
func NewSetRebalancerInstruction(
	// Params:
	rebalancerParam solanago.PublicKey,

	// Accounts:
	stateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetRebalancer[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `rebalancerParam`:
		err = enc__.Encode(rebalancerParam)
		if err != nil {
			return nil, errors.NewField("rebalancerParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_rmn" instruction.
func NewSetRmnInstruction(
	// Params:
	rmnAddressParam solanago.PublicKey,

	// Accounts:
	stateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
	programDataAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetRmn[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `rmnAddressParam`:
		err = enc__.Encode(rmnAddressParam)
		if err != nil {
			return nil, errors.NewField("rmnAddressParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "program": Read-only, Non-signer, Required, Address: 8eqh8wppT9c5rw4ERqNCffvU6cNFJWff9WmkcYtmGiqC
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
		// Account 4 "program_data": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programDataAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_router" instruction.
func NewSetRouterInstruction(
	// Params:
	newRouterParam solanago.PublicKey,

	// Accounts:
	stateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
	programDataAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetRouter[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newRouterParam`:
		err = enc__.Encode(newRouterParam)
		if err != nil {
			return nil, errors.NewField("newRouterParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 2 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 3 "program": Read-only, Non-signer, Required, Address: 8eqh8wppT9c5rw4ERqNCffvU6cNFJWff9WmkcYtmGiqC
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
		// Account 4 "program_data": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programDataAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "transfer_ownership" instruction.
func NewTransferOwnershipInstruction(
	// Params:
	proposedOwnerParam solanago.PublicKey,

	// Accounts:
	stateAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_TransferOwnership[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `proposedOwnerParam`:
		err = enc__.Encode(proposedOwnerParam)
		if err != nil {
			return nil, errors.NewField("proposedOwnerParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 1 "mint": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, false, false))
		// Account 2 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "type_version" instruction.
// Returns the program type (name) and version. // Used by offchain code to easily determine which program & version is being interacted with. //  // # Arguments // * `ctx` - The context
func NewTypeVersionInstruction(
	clockAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_TypeVersion[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "clock": Read-only, Non-signer, Required, Address: SysvarC1ock11111111111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(clockAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_default_rmn" instruction.
func NewUpdateDefaultRmnInstruction(
	// Params:
	rmnAddressParam solanago.PublicKey,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
	programDataAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateDefaultRmn[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `rmnAddressParam`:
		err = enc__.Encode(rmnAddressParam)
		if err != nil {
			return nil, errors.NewField("rmnAddressParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 2 "program": Read-only, Non-signer, Required, Address: 8eqh8wppT9c5rw4ERqNCffvU6cNFJWff9WmkcYtmGiqC
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
		// Account 3 "program_data": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programDataAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_default_router" instruction.
func NewUpdateDefaultRouterInstruction(
	// Params:
	routerAddressParam solanago.PublicKey,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
	programDataAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateDefaultRouter[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `routerAddressParam`:
		err = enc__.Encode(routerAddressParam)
		if err != nil {
			return nil, errors.NewField("routerAddressParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 2 "program": Read-only, Non-signer, Required, Address: 8eqh8wppT9c5rw4ERqNCffvU6cNFJWff9WmkcYtmGiqC
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
		// Account 3 "program_data": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programDataAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_self_served_allowed" instruction.
func NewUpdateSelfServedAllowedInstruction(
	// Params:
	selfServedAllowedParam bool,

	// Accounts:
	configAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
	programDataAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateSelfServedAllowed[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `selfServedAllowedParam`:
		err = enc__.Encode(selfServedAllowedParam)
		if err != nil {
			return nil, errors.NewField("selfServedAllowedParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(configAccount, true, false))
		// Account 1 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 2 "program": Read-only, Non-signer, Required, Address: 8eqh8wppT9c5rw4ERqNCffvU6cNFJWff9WmkcYtmGiqC
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
		// Account 3 "program_data": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programDataAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "withdraw_liquidity" instruction.
func NewWithdrawLiquidityInstruction(
	// Params:
	amountParam uint64,

	// Accounts:
	stateAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	poolSignerAccount solanago.PublicKey,
	poolTokenAccountAccount solanago.PublicKey,
	remoteTokenAccountAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_WithdrawLiquidity[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `amountParam`:
		err = enc__.Encode(amountParam)
		if err != nil {
			return nil, errors.NewField("amountParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "state": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(stateAccount, false, false))
		// Account 1 "token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 2 "mint": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, false))
		// Account 3 "pool_signer": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolSignerAccount, false, false))
		// Account 4 "pool_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolTokenAccountAccount, true, false))
		// Account 5 "remote_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(remoteTokenAccountAccount, true, false))
		// Account 6 "authority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

type AcceptOwnershipInstruction struct {

	// Accounts:
	State           solanago.PublicKey `json:"state"`
	StateWritable   bool               `json:"state_writable"`
	Mint            solanago.PublicKey `json:"mint"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
}

func (obj *AcceptOwnershipInstruction) GetDiscriminator() []byte {
	return Instruction_AcceptOwnership[:]
}

// UnmarshalWithDecoder unmarshals the AcceptOwnershipInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *AcceptOwnershipInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "AcceptOwnershipInstruction", err)
	}
	if discriminator != Instruction_AcceptOwnership {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "AcceptOwnershipInstruction", Instruction_AcceptOwnership, discriminator)
	}
	return nil
}

func (obj *AcceptOwnershipInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "mint", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AcceptOwnershipInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "mint", len(accountKeys)-1)
	}
	obj.Mint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AcceptOwnershipInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.State)
	keys = append(keys, obj.Mint)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the AcceptOwnershipInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *AcceptOwnershipInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AcceptOwnershipInstruction: %w", err)
	}
	return nil
}

// UnmarshalAcceptOwnershipInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalAcceptOwnershipInstruction(buf []byte) (*AcceptOwnershipInstruction, error) {
	obj := new(AcceptOwnershipInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type AppendRemotePoolAddressesInstruction struct {
	RemoteChainSelector uint64             `json:"remote_chain_selector"`
	Mint                solanago.PublicKey `json:"_mint"`
	Addresses           []RemoteAddress    `json:"addresses"`

	// Accounts:
	State               solanago.PublicKey `json:"state"`
	ChainConfig         solanago.PublicKey `json:"chain_config"`
	ChainConfigWritable bool               `json:"chain_config_writable"`
	Authority           solanago.PublicKey `json:"authority"`
	AuthorityWritable   bool               `json:"authority_writable"`
	AuthoritySigner     bool               `json:"authority_signer"`
	SystemProgram       solanago.PublicKey `json:"system_program"`
}

func (obj *AppendRemotePoolAddressesInstruction) GetDiscriminator() []byte {
	return Instruction_AppendRemotePoolAddresses[:]
}

// UnmarshalWithDecoder unmarshals the AppendRemotePoolAddressesInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *AppendRemotePoolAddressesInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "AppendRemotePoolAddressesInstruction", err)
	}
	if discriminator != Instruction_AppendRemotePoolAddresses {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "AppendRemotePoolAddressesInstruction", Instruction_AppendRemotePoolAddresses, discriminator)
	}
	// Deserialize `RemoteChainSelector`:
	err = decoder.Decode(&obj.RemoteChainSelector)
	if err != nil {
		return err
	}
	// Deserialize `Mint`:
	err = decoder.Decode(&obj.Mint)
	if err != nil {
		return err
	}
	// Deserialize `Addresses`:
	err = decoder.Decode(&obj.Addresses)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AppendRemotePoolAddressesInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from chain_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "chain_config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AppendRemotePoolAddressesInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set chain_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "chain_config", len(accountKeys)-1)
	}
	obj.ChainConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AppendRemotePoolAddressesInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.State)
	keys = append(keys, obj.ChainConfig)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the AppendRemotePoolAddressesInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *AppendRemotePoolAddressesInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AppendRemotePoolAddressesInstruction: %w", err)
	}
	return nil
}

// UnmarshalAppendRemotePoolAddressesInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalAppendRemotePoolAddressesInstruction(buf []byte) (*AppendRemotePoolAddressesInstruction, error) {
	obj := new(AppendRemotePoolAddressesInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ConfigureAllowListInstruction struct {
	Add     []solanago.PublicKey `json:"add"`
	Enabled bool                 `json:"enabled"`

	// Accounts:
	State             solanago.PublicKey `json:"state"`
	StateWritable     bool               `json:"state_writable"`
	Mint              solanago.PublicKey `json:"mint"`
	Authority         solanago.PublicKey `json:"authority"`
	AuthorityWritable bool               `json:"authority_writable"`
	AuthoritySigner   bool               `json:"authority_signer"`
	SystemProgram     solanago.PublicKey `json:"system_program"`
}

func (obj *ConfigureAllowListInstruction) GetDiscriminator() []byte {
	return Instruction_ConfigureAllowList[:]
}

// UnmarshalWithDecoder unmarshals the ConfigureAllowListInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *ConfigureAllowListInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "ConfigureAllowListInstruction", err)
	}
	if discriminator != Instruction_ConfigureAllowList {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "ConfigureAllowListInstruction", Instruction_ConfigureAllowList, discriminator)
	}
	// Deserialize `Add`:
	err = decoder.Decode(&obj.Add)
	if err != nil {
		return err
	}
	// Deserialize `Enabled`:
	err = decoder.Decode(&obj.Enabled)
	if err != nil {
		return err
	}
	return nil
}

func (obj *ConfigureAllowListInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "mint", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *ConfigureAllowListInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "mint", len(accountKeys)-1)
	}
	obj.Mint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *ConfigureAllowListInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.State)
	keys = append(keys, obj.Mint)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the ConfigureAllowListInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *ConfigureAllowListInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ConfigureAllowListInstruction: %w", err)
	}
	return nil
}

// UnmarshalConfigureAllowListInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalConfigureAllowListInstruction(buf []byte) (*ConfigureAllowListInstruction, error) {
	obj := new(ConfigureAllowListInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type DeleteChainConfigInstruction struct {
	RemoteChainSelector uint64             `json:"remote_chain_selector"`
	Mint                solanago.PublicKey `json:"mint"`

	// Accounts:
	State               solanago.PublicKey `json:"state"`
	ChainConfig         solanago.PublicKey `json:"chain_config"`
	ChainConfigWritable bool               `json:"chain_config_writable"`
	Authority           solanago.PublicKey `json:"authority"`
	AuthorityWritable   bool               `json:"authority_writable"`
	AuthoritySigner     bool               `json:"authority_signer"`
}

func (obj *DeleteChainConfigInstruction) GetDiscriminator() []byte {
	return Instruction_DeleteChainConfig[:]
}

// UnmarshalWithDecoder unmarshals the DeleteChainConfigInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *DeleteChainConfigInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "DeleteChainConfigInstruction", err)
	}
	if discriminator != Instruction_DeleteChainConfig {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "DeleteChainConfigInstruction", Instruction_DeleteChainConfig, discriminator)
	}
	// Deserialize `RemoteChainSelector`:
	err = decoder.Decode(&obj.RemoteChainSelector)
	if err != nil {
		return err
	}
	// Deserialize `Mint`:
	err = decoder.Decode(&obj.Mint)
	if err != nil {
		return err
	}
	return nil
}

func (obj *DeleteChainConfigInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from chain_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "chain_config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *DeleteChainConfigInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set chain_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "chain_config", len(accountKeys)-1)
	}
	obj.ChainConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *DeleteChainConfigInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.State)
	keys = append(keys, obj.ChainConfig)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the DeleteChainConfigInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *DeleteChainConfigInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling DeleteChainConfigInstruction: %w", err)
	}
	return nil
}

// UnmarshalDeleteChainConfigInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalDeleteChainConfigInstruction(buf []byte) (*DeleteChainConfigInstruction, error) {
	obj := new(DeleteChainConfigInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type EditChainRemoteConfigInstruction struct {
	RemoteChainSelector uint64             `json:"remote_chain_selector"`
	Mint                solanago.PublicKey `json:"mint"`
	Cfg                 RemoteConfig       `json:"cfg"`

	// Accounts:
	State               solanago.PublicKey `json:"state"`
	ChainConfig         solanago.PublicKey `json:"chain_config"`
	ChainConfigWritable bool               `json:"chain_config_writable"`
	Authority           solanago.PublicKey `json:"authority"`
	AuthorityWritable   bool               `json:"authority_writable"`
	AuthoritySigner     bool               `json:"authority_signer"`
	SystemProgram       solanago.PublicKey `json:"system_program"`
}

func (obj *EditChainRemoteConfigInstruction) GetDiscriminator() []byte {
	return Instruction_EditChainRemoteConfig[:]
}

// UnmarshalWithDecoder unmarshals the EditChainRemoteConfigInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *EditChainRemoteConfigInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "EditChainRemoteConfigInstruction", err)
	}
	if discriminator != Instruction_EditChainRemoteConfig {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "EditChainRemoteConfigInstruction", Instruction_EditChainRemoteConfig, discriminator)
	}
	// Deserialize `RemoteChainSelector`:
	err = decoder.Decode(&obj.RemoteChainSelector)
	if err != nil {
		return err
	}
	// Deserialize `Mint`:
	err = decoder.Decode(&obj.Mint)
	if err != nil {
		return err
	}
	// Deserialize `Cfg`:
	err = decoder.Decode(&obj.Cfg)
	if err != nil {
		return err
	}
	return nil
}

func (obj *EditChainRemoteConfigInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from chain_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "chain_config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *EditChainRemoteConfigInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set chain_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "chain_config", len(accountKeys)-1)
	}
	obj.ChainConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *EditChainRemoteConfigInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.State)
	keys = append(keys, obj.ChainConfig)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the EditChainRemoteConfigInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *EditChainRemoteConfigInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling EditChainRemoteConfigInstruction: %w", err)
	}
	return nil
}

// UnmarshalEditChainRemoteConfigInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalEditChainRemoteConfigInstruction(buf []byte) (*EditChainRemoteConfigInstruction, error) {
	obj := new(EditChainRemoteConfigInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitChainRemoteConfigInstruction struct {
	RemoteChainSelector uint64             `json:"remote_chain_selector"`
	Mint                solanago.PublicKey `json:"mint"`
	Cfg                 RemoteConfig       `json:"cfg"`

	// Accounts:
	State               solanago.PublicKey `json:"state"`
	ChainConfig         solanago.PublicKey `json:"chain_config"`
	ChainConfigWritable bool               `json:"chain_config_writable"`
	Authority           solanago.PublicKey `json:"authority"`
	AuthorityWritable   bool               `json:"authority_writable"`
	AuthoritySigner     bool               `json:"authority_signer"`
	SystemProgram       solanago.PublicKey `json:"system_program"`
}

func (obj *InitChainRemoteConfigInstruction) GetDiscriminator() []byte {
	return Instruction_InitChainRemoteConfig[:]
}

// UnmarshalWithDecoder unmarshals the InitChainRemoteConfigInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *InitChainRemoteConfigInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "InitChainRemoteConfigInstruction", err)
	}
	if discriminator != Instruction_InitChainRemoteConfig {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "InitChainRemoteConfigInstruction", Instruction_InitChainRemoteConfig, discriminator)
	}
	// Deserialize `RemoteChainSelector`:
	err = decoder.Decode(&obj.RemoteChainSelector)
	if err != nil {
		return err
	}
	// Deserialize `Mint`:
	err = decoder.Decode(&obj.Mint)
	if err != nil {
		return err
	}
	// Deserialize `Cfg`:
	err = decoder.Decode(&obj.Cfg)
	if err != nil {
		return err
	}
	return nil
}

func (obj *InitChainRemoteConfigInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from chain_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "chain_config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitChainRemoteConfigInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set chain_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "chain_config", len(accountKeys)-1)
	}
	obj.ChainConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitChainRemoteConfigInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.State)
	keys = append(keys, obj.ChainConfig)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the InitChainRemoteConfigInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *InitChainRemoteConfigInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitChainRemoteConfigInstruction: %w", err)
	}
	return nil
}

// UnmarshalInitChainRemoteConfigInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalInitChainRemoteConfigInstruction(buf []byte) (*InitChainRemoteConfigInstruction, error) {
	obj := new(InitChainRemoteConfigInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitGlobalConfigInstruction struct {
	RouterAddress solanago.PublicKey `json:"router_address"`
	RmnAddress    solanago.PublicKey `json:"rmn_address"`

	// Accounts:
	Config            solanago.PublicKey `json:"config"`
	ConfigWritable    bool               `json:"config_writable"`
	Authority         solanago.PublicKey `json:"authority"`
	AuthorityWritable bool               `json:"authority_writable"`
	AuthoritySigner   bool               `json:"authority_signer"`
	SystemProgram     solanago.PublicKey `json:"system_program"`
	Program           solanago.PublicKey `json:"program"`
	ProgramData       solanago.PublicKey `json:"program_data"`
}

func (obj *InitGlobalConfigInstruction) GetDiscriminator() []byte {
	return Instruction_InitGlobalConfig[:]
}

// UnmarshalWithDecoder unmarshals the InitGlobalConfigInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *InitGlobalConfigInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "InitGlobalConfigInstruction", err)
	}
	if discriminator != Instruction_InitGlobalConfig {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "InitGlobalConfigInstruction", Instruction_InitGlobalConfig, discriminator)
	}
	// Deserialize `RouterAddress`:
	err = decoder.Decode(&obj.RouterAddress)
	if err != nil {
		return err
	}
	// Deserialize `RmnAddress`:
	err = decoder.Decode(&obj.RmnAddress)
	if err != nil {
		return err
	}
	return nil
}

func (obj *InitGlobalConfigInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	// Decode from program_data account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program_data", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitGlobalConfigInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 5 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 5, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program_data account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program_data", len(accountKeys)-1)
	}
	obj.ProgramData = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitGlobalConfigInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.Program)
	keys = append(keys, obj.ProgramData)
	return keys
}

// Unmarshal unmarshals the InitGlobalConfigInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *InitGlobalConfigInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitGlobalConfigInstruction: %w", err)
	}
	return nil
}

// UnmarshalInitGlobalConfigInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalInitGlobalConfigInstruction(buf []byte) (*InitGlobalConfigInstruction, error) {
	obj := new(InitGlobalConfigInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitializeInstruction struct {

	// Accounts:
	State             solanago.PublicKey `json:"state"`
	StateWritable     bool               `json:"state_writable"`
	Mint              solanago.PublicKey `json:"mint"`
	Authority         solanago.PublicKey `json:"authority"`
	AuthorityWritable bool               `json:"authority_writable"`
	AuthoritySigner   bool               `json:"authority_signer"`
	SystemProgram     solanago.PublicKey `json:"system_program"`
	Program           solanago.PublicKey `json:"program"`
	ProgramData       solanago.PublicKey `json:"program_data"`
	Config            solanago.PublicKey `json:"config"`
}

func (obj *InitializeInstruction) GetDiscriminator() []byte {
	return Instruction_Initialize[:]
}

// UnmarshalWithDecoder unmarshals the InitializeInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *InitializeInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "InitializeInstruction", err)
	}
	if discriminator != Instruction_Initialize {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "InitializeInstruction", Instruction_Initialize, discriminator)
	}
	return nil
}

func (obj *InitializeInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "mint", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	// Decode from program_data account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program_data", err)
	}
	indices = append(indices, index)
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitializeInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 7 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 7, len(indices))
	}
	indexOffset := 0
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "mint", len(accountKeys)-1)
	}
	obj.Mint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program_data account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program_data", len(accountKeys)-1)
	}
	obj.ProgramData = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitializeInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.State)
	keys = append(keys, obj.Mint)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.Program)
	keys = append(keys, obj.ProgramData)
	keys = append(keys, obj.Config)
	return keys
}

// Unmarshal unmarshals the InitializeInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *InitializeInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitializeInstruction: %w", err)
	}
	return nil
}

// UnmarshalInitializeInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalInitializeInstruction(buf []byte) (*InitializeInstruction, error) {
	obj := new(InitializeInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitializeStateVersionInstruction struct {
	Mint solanago.PublicKey `json:"_mint"`

	// Accounts:
	State         solanago.PublicKey `json:"state"`
	StateWritable bool               `json:"state_writable"`
}

func (obj *InitializeStateVersionInstruction) GetDiscriminator() []byte {
	return Instruction_InitializeStateVersion[:]
}

// UnmarshalWithDecoder unmarshals the InitializeStateVersionInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *InitializeStateVersionInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "InitializeStateVersionInstruction", err)
	}
	if discriminator != Instruction_InitializeStateVersion {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "InitializeStateVersionInstruction", Instruction_InitializeStateVersion, discriminator)
	}
	// Deserialize `Mint`:
	err = decoder.Decode(&obj.Mint)
	if err != nil {
		return err
	}
	return nil
}

func (obj *InitializeStateVersionInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitializeStateVersionInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 1 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 1, len(indices))
	}
	indexOffset := 0
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitializeStateVersionInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.State)
	return keys
}

// Unmarshal unmarshals the InitializeStateVersionInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *InitializeStateVersionInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitializeStateVersionInstruction: %w", err)
	}
	return nil
}

// UnmarshalInitializeStateVersionInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalInitializeStateVersionInstruction(buf []byte) (*InitializeStateVersionInstruction, error) {
	obj := new(InitializeStateVersionInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type LockOrBurnTokensInstruction struct {
	LockOrBurn LockOrBurnInV1 `json:"lock_or_burn"`

	// Accounts:
	Authority                solanago.PublicKey `json:"authority"`
	AuthoritySigner          bool               `json:"authority_signer"`
	State                    solanago.PublicKey `json:"state"`
	TokenProgram             solanago.PublicKey `json:"token_program"`
	Mint                     solanago.PublicKey `json:"mint"`
	MintWritable             bool               `json:"mint_writable"`
	PoolSigner               solanago.PublicKey `json:"pool_signer"`
	PoolTokenAccount         solanago.PublicKey `json:"pool_token_account"`
	PoolTokenAccountWritable bool               `json:"pool_token_account_writable"`
	RmnRemote                solanago.PublicKey `json:"rmn_remote"`
	RmnRemoteCurses          solanago.PublicKey `json:"rmn_remote_curses"`
	RmnRemoteConfig          solanago.PublicKey `json:"rmn_remote_config"`
	ChainConfig              solanago.PublicKey `json:"chain_config"`
	ChainConfigWritable      bool               `json:"chain_config_writable"`
}

func (obj *LockOrBurnTokensInstruction) GetDiscriminator() []byte {
	return Instruction_LockOrBurnTokens[:]
}

// UnmarshalWithDecoder unmarshals the LockOrBurnTokensInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *LockOrBurnTokensInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "LockOrBurnTokensInstruction", err)
	}
	if discriminator != Instruction_LockOrBurnTokens {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "LockOrBurnTokensInstruction", Instruction_LockOrBurnTokens, discriminator)
	}
	// Deserialize `LockOrBurn`:
	err = decoder.Decode(&obj.LockOrBurn)
	if err != nil {
		return err
	}
	return nil
}

func (obj *LockOrBurnTokensInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from token_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_program", err)
	}
	indices = append(indices, index)
	// Decode from mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "mint", err)
	}
	indices = append(indices, index)
	// Decode from pool_signer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "pool_signer", err)
	}
	indices = append(indices, index)
	// Decode from pool_token_account account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "pool_token_account", err)
	}
	indices = append(indices, index)
	// Decode from rmn_remote account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rmn_remote", err)
	}
	indices = append(indices, index)
	// Decode from rmn_remote_curses account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rmn_remote_curses", err)
	}
	indices = append(indices, index)
	// Decode from rmn_remote_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rmn_remote_config", err)
	}
	indices = append(indices, index)
	// Decode from chain_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "chain_config", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *LockOrBurnTokensInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 10 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 10, len(indices))
	}
	indexOffset := 0
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_program", len(accountKeys)-1)
	}
	obj.TokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "mint", len(accountKeys)-1)
	}
	obj.Mint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set pool_signer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "pool_signer", len(accountKeys)-1)
	}
	obj.PoolSigner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set pool_token_account account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "pool_token_account", len(accountKeys)-1)
	}
	obj.PoolTokenAccount = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rmn_remote account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rmn_remote", len(accountKeys)-1)
	}
	obj.RmnRemote = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rmn_remote_curses account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rmn_remote_curses", len(accountKeys)-1)
	}
	obj.RmnRemoteCurses = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rmn_remote_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rmn_remote_config", len(accountKeys)-1)
	}
	obj.RmnRemoteConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set chain_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "chain_config", len(accountKeys)-1)
	}
	obj.ChainConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *LockOrBurnTokensInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.State)
	keys = append(keys, obj.TokenProgram)
	keys = append(keys, obj.Mint)
	keys = append(keys, obj.PoolSigner)
	keys = append(keys, obj.PoolTokenAccount)
	keys = append(keys, obj.RmnRemote)
	keys = append(keys, obj.RmnRemoteCurses)
	keys = append(keys, obj.RmnRemoteConfig)
	keys = append(keys, obj.ChainConfig)
	return keys
}

// Unmarshal unmarshals the LockOrBurnTokensInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *LockOrBurnTokensInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling LockOrBurnTokensInstruction: %w", err)
	}
	return nil
}

// UnmarshalLockOrBurnTokensInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalLockOrBurnTokensInstruction(buf []byte) (*LockOrBurnTokensInstruction, error) {
	obj := new(LockOrBurnTokensInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ProvideLiquidityInstruction struct {
	Amount uint64 `json:"amount"`

	// Accounts:
	State                      solanago.PublicKey `json:"state"`
	TokenProgram               solanago.PublicKey `json:"token_program"`
	Mint                       solanago.PublicKey `json:"mint"`
	MintWritable               bool               `json:"mint_writable"`
	PoolSigner                 solanago.PublicKey `json:"pool_signer"`
	PoolTokenAccount           solanago.PublicKey `json:"pool_token_account"`
	PoolTokenAccountWritable   bool               `json:"pool_token_account_writable"`
	RemoteTokenAccount         solanago.PublicKey `json:"remote_token_account"`
	RemoteTokenAccountWritable bool               `json:"remote_token_account_writable"`
	Authority                  solanago.PublicKey `json:"authority"`
	AuthoritySigner            bool               `json:"authority_signer"`
}

func (obj *ProvideLiquidityInstruction) GetDiscriminator() []byte {
	return Instruction_ProvideLiquidity[:]
}

// UnmarshalWithDecoder unmarshals the ProvideLiquidityInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *ProvideLiquidityInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "ProvideLiquidityInstruction", err)
	}
	if discriminator != Instruction_ProvideLiquidity {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "ProvideLiquidityInstruction", Instruction_ProvideLiquidity, discriminator)
	}
	// Deserialize `Amount`:
	err = decoder.Decode(&obj.Amount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *ProvideLiquidityInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from token_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_program", err)
	}
	indices = append(indices, index)
	// Decode from mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "mint", err)
	}
	indices = append(indices, index)
	// Decode from pool_signer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "pool_signer", err)
	}
	indices = append(indices, index)
	// Decode from pool_token_account account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "pool_token_account", err)
	}
	indices = append(indices, index)
	// Decode from remote_token_account account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "remote_token_account", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *ProvideLiquidityInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 7 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 7, len(indices))
	}
	indexOffset := 0
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_program", len(accountKeys)-1)
	}
	obj.TokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "mint", len(accountKeys)-1)
	}
	obj.Mint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set pool_signer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "pool_signer", len(accountKeys)-1)
	}
	obj.PoolSigner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set pool_token_account account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "pool_token_account", len(accountKeys)-1)
	}
	obj.PoolTokenAccount = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set remote_token_account account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "remote_token_account", len(accountKeys)-1)
	}
	obj.RemoteTokenAccount = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *ProvideLiquidityInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.State)
	keys = append(keys, obj.TokenProgram)
	keys = append(keys, obj.Mint)
	keys = append(keys, obj.PoolSigner)
	keys = append(keys, obj.PoolTokenAccount)
	keys = append(keys, obj.RemoteTokenAccount)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the ProvideLiquidityInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *ProvideLiquidityInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ProvideLiquidityInstruction: %w", err)
	}
	return nil
}

// UnmarshalProvideLiquidityInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalProvideLiquidityInstruction(buf []byte) (*ProvideLiquidityInstruction, error) {
	obj := new(ProvideLiquidityInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ReleaseOrMintTokensInstruction struct {
	ReleaseOrMint ReleaseOrMintInV1 `json:"release_or_mint"`

	// Accounts:
	Authority                    solanago.PublicKey `json:"authority"`
	AuthoritySigner              bool               `json:"authority_signer"`
	OfframpProgram               solanago.PublicKey `json:"offramp_program"`
	AllowedOfframp               solanago.PublicKey `json:"allowed_offramp"`
	State                        solanago.PublicKey `json:"state"`
	TokenProgram                 solanago.PublicKey `json:"token_program"`
	Mint                         solanago.PublicKey `json:"mint"`
	MintWritable                 bool               `json:"mint_writable"`
	PoolSigner                   solanago.PublicKey `json:"pool_signer"`
	PoolTokenAccount             solanago.PublicKey `json:"pool_token_account"`
	PoolTokenAccountWritable     bool               `json:"pool_token_account_writable"`
	ChainConfig                  solanago.PublicKey `json:"chain_config"`
	ChainConfigWritable          bool               `json:"chain_config_writable"`
	RmnRemote                    solanago.PublicKey `json:"rmn_remote"`
	RmnRemoteCurses              solanago.PublicKey `json:"rmn_remote_curses"`
	RmnRemoteConfig              solanago.PublicKey `json:"rmn_remote_config"`
	ReceiverTokenAccount         solanago.PublicKey `json:"receiver_token_account"`
	ReceiverTokenAccountWritable bool               `json:"receiver_token_account_writable"`
}

func (obj *ReleaseOrMintTokensInstruction) GetDiscriminator() []byte {
	return Instruction_ReleaseOrMintTokens[:]
}

// UnmarshalWithDecoder unmarshals the ReleaseOrMintTokensInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *ReleaseOrMintTokensInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "ReleaseOrMintTokensInstruction", err)
	}
	if discriminator != Instruction_ReleaseOrMintTokens {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "ReleaseOrMintTokensInstruction", Instruction_ReleaseOrMintTokens, discriminator)
	}
	// Deserialize `ReleaseOrMint`:
	err = decoder.Decode(&obj.ReleaseOrMint)
	if err != nil {
		return err
	}
	return nil
}

func (obj *ReleaseOrMintTokensInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from offramp_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "offramp_program", err)
	}
	indices = append(indices, index)
	// Decode from allowed_offramp account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "allowed_offramp", err)
	}
	indices = append(indices, index)
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from token_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_program", err)
	}
	indices = append(indices, index)
	// Decode from mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "mint", err)
	}
	indices = append(indices, index)
	// Decode from pool_signer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "pool_signer", err)
	}
	indices = append(indices, index)
	// Decode from pool_token_account account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "pool_token_account", err)
	}
	indices = append(indices, index)
	// Decode from chain_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "chain_config", err)
	}
	indices = append(indices, index)
	// Decode from rmn_remote account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rmn_remote", err)
	}
	indices = append(indices, index)
	// Decode from rmn_remote_curses account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rmn_remote_curses", err)
	}
	indices = append(indices, index)
	// Decode from rmn_remote_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rmn_remote_config", err)
	}
	indices = append(indices, index)
	// Decode from receiver_token_account account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "receiver_token_account", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *ReleaseOrMintTokensInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 13 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 13, len(indices))
	}
	indexOffset := 0
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set offramp_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "offramp_program", len(accountKeys)-1)
	}
	obj.OfframpProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set allowed_offramp account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "allowed_offramp", len(accountKeys)-1)
	}
	obj.AllowedOfframp = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_program", len(accountKeys)-1)
	}
	obj.TokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "mint", len(accountKeys)-1)
	}
	obj.Mint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set pool_signer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "pool_signer", len(accountKeys)-1)
	}
	obj.PoolSigner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set pool_token_account account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "pool_token_account", len(accountKeys)-1)
	}
	obj.PoolTokenAccount = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set chain_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "chain_config", len(accountKeys)-1)
	}
	obj.ChainConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rmn_remote account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rmn_remote", len(accountKeys)-1)
	}
	obj.RmnRemote = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rmn_remote_curses account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rmn_remote_curses", len(accountKeys)-1)
	}
	obj.RmnRemoteCurses = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rmn_remote_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rmn_remote_config", len(accountKeys)-1)
	}
	obj.RmnRemoteConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set receiver_token_account account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "receiver_token_account", len(accountKeys)-1)
	}
	obj.ReceiverTokenAccount = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *ReleaseOrMintTokensInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.OfframpProgram)
	keys = append(keys, obj.AllowedOfframp)
	keys = append(keys, obj.State)
	keys = append(keys, obj.TokenProgram)
	keys = append(keys, obj.Mint)
	keys = append(keys, obj.PoolSigner)
	keys = append(keys, obj.PoolTokenAccount)
	keys = append(keys, obj.ChainConfig)
	keys = append(keys, obj.RmnRemote)
	keys = append(keys, obj.RmnRemoteCurses)
	keys = append(keys, obj.RmnRemoteConfig)
	keys = append(keys, obj.ReceiverTokenAccount)
	return keys
}

// Unmarshal unmarshals the ReleaseOrMintTokensInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *ReleaseOrMintTokensInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ReleaseOrMintTokensInstruction: %w", err)
	}
	return nil
}

// UnmarshalReleaseOrMintTokensInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalReleaseOrMintTokensInstruction(buf []byte) (*ReleaseOrMintTokensInstruction, error) {
	obj := new(ReleaseOrMintTokensInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type RemoveFromAllowListInstruction struct {
	Remove []solanago.PublicKey `json:"remove"`

	// Accounts:
	State             solanago.PublicKey `json:"state"`
	StateWritable     bool               `json:"state_writable"`
	Mint              solanago.PublicKey `json:"mint"`
	Authority         solanago.PublicKey `json:"authority"`
	AuthorityWritable bool               `json:"authority_writable"`
	AuthoritySigner   bool               `json:"authority_signer"`
	SystemProgram     solanago.PublicKey `json:"system_program"`
}

func (obj *RemoveFromAllowListInstruction) GetDiscriminator() []byte {
	return Instruction_RemoveFromAllowList[:]
}

// UnmarshalWithDecoder unmarshals the RemoveFromAllowListInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *RemoveFromAllowListInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "RemoveFromAllowListInstruction", err)
	}
	if discriminator != Instruction_RemoveFromAllowList {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "RemoveFromAllowListInstruction", Instruction_RemoveFromAllowList, discriminator)
	}
	// Deserialize `Remove`:
	err = decoder.Decode(&obj.Remove)
	if err != nil {
		return err
	}
	return nil
}

func (obj *RemoveFromAllowListInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "mint", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *RemoveFromAllowListInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "mint", len(accountKeys)-1)
	}
	obj.Mint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *RemoveFromAllowListInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.State)
	keys = append(keys, obj.Mint)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the RemoveFromAllowListInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *RemoveFromAllowListInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling RemoveFromAllowListInstruction: %w", err)
	}
	return nil
}

// UnmarshalRemoveFromAllowListInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalRemoveFromAllowListInstruction(buf []byte) (*RemoveFromAllowListInstruction, error) {
	obj := new(RemoveFromAllowListInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SetCanAcceptLiquidityInstruction struct {
	Allow bool `json:"allow"`

	// Accounts:
	State           solanago.PublicKey `json:"state"`
	StateWritable   bool               `json:"state_writable"`
	Mint            solanago.PublicKey `json:"mint"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
}

func (obj *SetCanAcceptLiquidityInstruction) GetDiscriminator() []byte {
	return Instruction_SetCanAcceptLiquidity[:]
}

// UnmarshalWithDecoder unmarshals the SetCanAcceptLiquidityInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *SetCanAcceptLiquidityInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "SetCanAcceptLiquidityInstruction", err)
	}
	if discriminator != Instruction_SetCanAcceptLiquidity {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "SetCanAcceptLiquidityInstruction", Instruction_SetCanAcceptLiquidity, discriminator)
	}
	// Deserialize `Allow`:
	err = decoder.Decode(&obj.Allow)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SetCanAcceptLiquidityInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "mint", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SetCanAcceptLiquidityInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "mint", len(accountKeys)-1)
	}
	obj.Mint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SetCanAcceptLiquidityInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.State)
	keys = append(keys, obj.Mint)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the SetCanAcceptLiquidityInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *SetCanAcceptLiquidityInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SetCanAcceptLiquidityInstruction: %w", err)
	}
	return nil
}

// UnmarshalSetCanAcceptLiquidityInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalSetCanAcceptLiquidityInstruction(buf []byte) (*SetCanAcceptLiquidityInstruction, error) {
	obj := new(SetCanAcceptLiquidityInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SetChainRateLimitInstruction struct {
	RemoteChainSelector uint64             `json:"remote_chain_selector"`
	Mint                solanago.PublicKey `json:"mint"`
	Inbound             RateLimitConfig    `json:"inbound"`
	Outbound            RateLimitConfig    `json:"outbound"`

	// Accounts:
	State               solanago.PublicKey `json:"state"`
	ChainConfig         solanago.PublicKey `json:"chain_config"`
	ChainConfigWritable bool               `json:"chain_config_writable"`
	Authority           solanago.PublicKey `json:"authority"`
	AuthorityWritable   bool               `json:"authority_writable"`
	AuthoritySigner     bool               `json:"authority_signer"`
}

func (obj *SetChainRateLimitInstruction) GetDiscriminator() []byte {
	return Instruction_SetChainRateLimit[:]
}

// UnmarshalWithDecoder unmarshals the SetChainRateLimitInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *SetChainRateLimitInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "SetChainRateLimitInstruction", err)
	}
	if discriminator != Instruction_SetChainRateLimit {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "SetChainRateLimitInstruction", Instruction_SetChainRateLimit, discriminator)
	}
	// Deserialize `RemoteChainSelector`:
	err = decoder.Decode(&obj.RemoteChainSelector)
	if err != nil {
		return err
	}
	// Deserialize `Mint`:
	err = decoder.Decode(&obj.Mint)
	if err != nil {
		return err
	}
	// Deserialize `Inbound`:
	err = decoder.Decode(&obj.Inbound)
	if err != nil {
		return err
	}
	// Deserialize `Outbound`:
	err = decoder.Decode(&obj.Outbound)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SetChainRateLimitInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from chain_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "chain_config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SetChainRateLimitInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set chain_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "chain_config", len(accountKeys)-1)
	}
	obj.ChainConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SetChainRateLimitInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.State)
	keys = append(keys, obj.ChainConfig)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the SetChainRateLimitInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *SetChainRateLimitInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SetChainRateLimitInstruction: %w", err)
	}
	return nil
}

// UnmarshalSetChainRateLimitInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalSetChainRateLimitInstruction(buf []byte) (*SetChainRateLimitInstruction, error) {
	obj := new(SetChainRateLimitInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SetRateLimitAdminInstruction struct {
	Mint              solanago.PublicKey `json:"_mint"`
	NewRateLimitAdmin solanago.PublicKey `json:"new_rate_limit_admin"`

	// Accounts:
	State             solanago.PublicKey `json:"state"`
	StateWritable     bool               `json:"state_writable"`
	Authority         solanago.PublicKey `json:"authority"`
	AuthorityWritable bool               `json:"authority_writable"`
	AuthoritySigner   bool               `json:"authority_signer"`
}

func (obj *SetRateLimitAdminInstruction) GetDiscriminator() []byte {
	return Instruction_SetRateLimitAdmin[:]
}

// UnmarshalWithDecoder unmarshals the SetRateLimitAdminInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *SetRateLimitAdminInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "SetRateLimitAdminInstruction", err)
	}
	if discriminator != Instruction_SetRateLimitAdmin {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "SetRateLimitAdminInstruction", Instruction_SetRateLimitAdmin, discriminator)
	}
	// Deserialize `Mint`:
	err = decoder.Decode(&obj.Mint)
	if err != nil {
		return err
	}
	// Deserialize `NewRateLimitAdmin`:
	err = decoder.Decode(&obj.NewRateLimitAdmin)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SetRateLimitAdminInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SetRateLimitAdminInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 2 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 2, len(indices))
	}
	indexOffset := 0
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SetRateLimitAdminInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.State)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the SetRateLimitAdminInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *SetRateLimitAdminInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SetRateLimitAdminInstruction: %w", err)
	}
	return nil
}

// UnmarshalSetRateLimitAdminInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalSetRateLimitAdminInstruction(buf []byte) (*SetRateLimitAdminInstruction, error) {
	obj := new(SetRateLimitAdminInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SetRebalancerInstruction struct {
	Rebalancer solanago.PublicKey `json:"rebalancer"`

	// Accounts:
	State           solanago.PublicKey `json:"state"`
	StateWritable   bool               `json:"state_writable"`
	Mint            solanago.PublicKey `json:"mint"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
}

func (obj *SetRebalancerInstruction) GetDiscriminator() []byte {
	return Instruction_SetRebalancer[:]
}

// UnmarshalWithDecoder unmarshals the SetRebalancerInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *SetRebalancerInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "SetRebalancerInstruction", err)
	}
	if discriminator != Instruction_SetRebalancer {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "SetRebalancerInstruction", Instruction_SetRebalancer, discriminator)
	}
	// Deserialize `Rebalancer`:
	err = decoder.Decode(&obj.Rebalancer)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SetRebalancerInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "mint", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SetRebalancerInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "mint", len(accountKeys)-1)
	}
	obj.Mint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SetRebalancerInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.State)
	keys = append(keys, obj.Mint)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the SetRebalancerInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *SetRebalancerInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SetRebalancerInstruction: %w", err)
	}
	return nil
}

// UnmarshalSetRebalancerInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalSetRebalancerInstruction(buf []byte) (*SetRebalancerInstruction, error) {
	obj := new(SetRebalancerInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SetRmnInstruction struct {
	RmnAddress solanago.PublicKey `json:"rmn_address"`

	// Accounts:
	State             solanago.PublicKey `json:"state"`
	Mint              solanago.PublicKey `json:"mint"`
	Authority         solanago.PublicKey `json:"authority"`
	AuthorityWritable bool               `json:"authority_writable"`
	AuthoritySigner   bool               `json:"authority_signer"`
	Program           solanago.PublicKey `json:"program"`
	ProgramData       solanago.PublicKey `json:"program_data"`
}

func (obj *SetRmnInstruction) GetDiscriminator() []byte {
	return Instruction_SetRmn[:]
}

// UnmarshalWithDecoder unmarshals the SetRmnInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *SetRmnInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "SetRmnInstruction", err)
	}
	if discriminator != Instruction_SetRmn {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "SetRmnInstruction", Instruction_SetRmn, discriminator)
	}
	// Deserialize `RmnAddress`:
	err = decoder.Decode(&obj.RmnAddress)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SetRmnInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "mint", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	// Decode from program_data account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program_data", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SetRmnInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 5 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 5, len(indices))
	}
	indexOffset := 0
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "mint", len(accountKeys)-1)
	}
	obj.Mint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program_data account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program_data", len(accountKeys)-1)
	}
	obj.ProgramData = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SetRmnInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.State)
	keys = append(keys, obj.Mint)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.Program)
	keys = append(keys, obj.ProgramData)
	return keys
}

// Unmarshal unmarshals the SetRmnInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *SetRmnInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SetRmnInstruction: %w", err)
	}
	return nil
}

// UnmarshalSetRmnInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalSetRmnInstruction(buf []byte) (*SetRmnInstruction, error) {
	obj := new(SetRmnInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SetRouterInstruction struct {
	NewRouter solanago.PublicKey `json:"new_router"`

	// Accounts:
	State             solanago.PublicKey `json:"state"`
	Mint              solanago.PublicKey `json:"mint"`
	Authority         solanago.PublicKey `json:"authority"`
	AuthorityWritable bool               `json:"authority_writable"`
	AuthoritySigner   bool               `json:"authority_signer"`
	Program           solanago.PublicKey `json:"program"`
	ProgramData       solanago.PublicKey `json:"program_data"`
}

func (obj *SetRouterInstruction) GetDiscriminator() []byte {
	return Instruction_SetRouter[:]
}

// UnmarshalWithDecoder unmarshals the SetRouterInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *SetRouterInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "SetRouterInstruction", err)
	}
	if discriminator != Instruction_SetRouter {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "SetRouterInstruction", Instruction_SetRouter, discriminator)
	}
	// Deserialize `NewRouter`:
	err = decoder.Decode(&obj.NewRouter)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SetRouterInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "mint", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	// Decode from program_data account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program_data", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SetRouterInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 5 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 5, len(indices))
	}
	indexOffset := 0
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "mint", len(accountKeys)-1)
	}
	obj.Mint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program_data account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program_data", len(accountKeys)-1)
	}
	obj.ProgramData = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SetRouterInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.State)
	keys = append(keys, obj.Mint)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.Program)
	keys = append(keys, obj.ProgramData)
	return keys
}

// Unmarshal unmarshals the SetRouterInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *SetRouterInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SetRouterInstruction: %w", err)
	}
	return nil
}

// UnmarshalSetRouterInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalSetRouterInstruction(buf []byte) (*SetRouterInstruction, error) {
	obj := new(SetRouterInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type TransferOwnershipInstruction struct {
	ProposedOwner solanago.PublicKey `json:"proposed_owner"`

	// Accounts:
	State           solanago.PublicKey `json:"state"`
	StateWritable   bool               `json:"state_writable"`
	Mint            solanago.PublicKey `json:"mint"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
}

func (obj *TransferOwnershipInstruction) GetDiscriminator() []byte {
	return Instruction_TransferOwnership[:]
}

// UnmarshalWithDecoder unmarshals the TransferOwnershipInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *TransferOwnershipInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "TransferOwnershipInstruction", err)
	}
	if discriminator != Instruction_TransferOwnership {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "TransferOwnershipInstruction", Instruction_TransferOwnership, discriminator)
	}
	// Deserialize `ProposedOwner`:
	err = decoder.Decode(&obj.ProposedOwner)
	if err != nil {
		return err
	}
	return nil
}

func (obj *TransferOwnershipInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "mint", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *TransferOwnershipInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "mint", len(accountKeys)-1)
	}
	obj.Mint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *TransferOwnershipInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.State)
	keys = append(keys, obj.Mint)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the TransferOwnershipInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *TransferOwnershipInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling TransferOwnershipInstruction: %w", err)
	}
	return nil
}

// UnmarshalTransferOwnershipInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalTransferOwnershipInstruction(buf []byte) (*TransferOwnershipInstruction, error) {
	obj := new(TransferOwnershipInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type TypeVersionInstruction struct {

	// Accounts:
	Clock solanago.PublicKey `json:"clock"`
}

func (obj *TypeVersionInstruction) GetDiscriminator() []byte {
	return Instruction_TypeVersion[:]
}

// UnmarshalWithDecoder unmarshals the TypeVersionInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *TypeVersionInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "TypeVersionInstruction", err)
	}
	if discriminator != Instruction_TypeVersion {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "TypeVersionInstruction", Instruction_TypeVersion, discriminator)
	}
	return nil
}

func (obj *TypeVersionInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from clock account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "clock", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *TypeVersionInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 1 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 1, len(indices))
	}
	indexOffset := 0
	// Set clock account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "clock", len(accountKeys)-1)
	}
	obj.Clock = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *TypeVersionInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Clock)
	return keys
}

// Unmarshal unmarshals the TypeVersionInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *TypeVersionInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling TypeVersionInstruction: %w", err)
	}
	return nil
}

// UnmarshalTypeVersionInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalTypeVersionInstruction(buf []byte) (*TypeVersionInstruction, error) {
	obj := new(TypeVersionInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UpdateDefaultRmnInstruction struct {
	RmnAddress solanago.PublicKey `json:"rmn_address"`

	// Accounts:
	Config          solanago.PublicKey `json:"config"`
	ConfigWritable  bool               `json:"config_writable"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
	Program         solanago.PublicKey `json:"program"`
	ProgramData     solanago.PublicKey `json:"program_data"`
}

func (obj *UpdateDefaultRmnInstruction) GetDiscriminator() []byte {
	return Instruction_UpdateDefaultRmn[:]
}

// UnmarshalWithDecoder unmarshals the UpdateDefaultRmnInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *UpdateDefaultRmnInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "UpdateDefaultRmnInstruction", err)
	}
	if discriminator != Instruction_UpdateDefaultRmn {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "UpdateDefaultRmnInstruction", Instruction_UpdateDefaultRmn, discriminator)
	}
	// Deserialize `RmnAddress`:
	err = decoder.Decode(&obj.RmnAddress)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UpdateDefaultRmnInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	// Decode from program_data account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program_data", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *UpdateDefaultRmnInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program_data account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program_data", len(accountKeys)-1)
	}
	obj.ProgramData = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *UpdateDefaultRmnInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.Program)
	keys = append(keys, obj.ProgramData)
	return keys
}

// Unmarshal unmarshals the UpdateDefaultRmnInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *UpdateDefaultRmnInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdateDefaultRmnInstruction: %w", err)
	}
	return nil
}

// UnmarshalUpdateDefaultRmnInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalUpdateDefaultRmnInstruction(buf []byte) (*UpdateDefaultRmnInstruction, error) {
	obj := new(UpdateDefaultRmnInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UpdateDefaultRouterInstruction struct {
	RouterAddress solanago.PublicKey `json:"router_address"`

	// Accounts:
	Config          solanago.PublicKey `json:"config"`
	ConfigWritable  bool               `json:"config_writable"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
	Program         solanago.PublicKey `json:"program"`
	ProgramData     solanago.PublicKey `json:"program_data"`
}

func (obj *UpdateDefaultRouterInstruction) GetDiscriminator() []byte {
	return Instruction_UpdateDefaultRouter[:]
}

// UnmarshalWithDecoder unmarshals the UpdateDefaultRouterInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *UpdateDefaultRouterInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "UpdateDefaultRouterInstruction", err)
	}
	if discriminator != Instruction_UpdateDefaultRouter {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "UpdateDefaultRouterInstruction", Instruction_UpdateDefaultRouter, discriminator)
	}
	// Deserialize `RouterAddress`:
	err = decoder.Decode(&obj.RouterAddress)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UpdateDefaultRouterInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	// Decode from program_data account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program_data", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *UpdateDefaultRouterInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program_data account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program_data", len(accountKeys)-1)
	}
	obj.ProgramData = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *UpdateDefaultRouterInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.Program)
	keys = append(keys, obj.ProgramData)
	return keys
}

// Unmarshal unmarshals the UpdateDefaultRouterInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *UpdateDefaultRouterInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdateDefaultRouterInstruction: %w", err)
	}
	return nil
}

// UnmarshalUpdateDefaultRouterInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalUpdateDefaultRouterInstruction(buf []byte) (*UpdateDefaultRouterInstruction, error) {
	obj := new(UpdateDefaultRouterInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UpdateSelfServedAllowedInstruction struct {
	SelfServedAllowed bool `json:"self_served_allowed"`

	// Accounts:
	Config          solanago.PublicKey `json:"config"`
	ConfigWritable  bool               `json:"config_writable"`
	Authority       solanago.PublicKey `json:"authority"`
	AuthoritySigner bool               `json:"authority_signer"`
	Program         solanago.PublicKey `json:"program"`
	ProgramData     solanago.PublicKey `json:"program_data"`
}

func (obj *UpdateSelfServedAllowedInstruction) GetDiscriminator() []byte {
	return Instruction_UpdateSelfServedAllowed[:]
}

// UnmarshalWithDecoder unmarshals the UpdateSelfServedAllowedInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *UpdateSelfServedAllowedInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "UpdateSelfServedAllowedInstruction", err)
	}
	if discriminator != Instruction_UpdateSelfServedAllowed {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "UpdateSelfServedAllowedInstruction", Instruction_UpdateSelfServedAllowed, discriminator)
	}
	// Deserialize `SelfServedAllowed`:
	err = decoder.Decode(&obj.SelfServedAllowed)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UpdateSelfServedAllowedInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "config", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	// Decode from program_data account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program_data", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *UpdateSelfServedAllowedInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "config", len(accountKeys)-1)
	}
	obj.Config = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program_data account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program_data", len(accountKeys)-1)
	}
	obj.ProgramData = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *UpdateSelfServedAllowedInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Config)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.Program)
	keys = append(keys, obj.ProgramData)
	return keys
}

// Unmarshal unmarshals the UpdateSelfServedAllowedInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *UpdateSelfServedAllowedInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdateSelfServedAllowedInstruction: %w", err)
	}
	return nil
}

// UnmarshalUpdateSelfServedAllowedInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalUpdateSelfServedAllowedInstruction(buf []byte) (*UpdateSelfServedAllowedInstruction, error) {
	obj := new(UpdateSelfServedAllowedInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type WithdrawLiquidityInstruction struct {
	Amount uint64 `json:"amount"`

	// Accounts:
	State                      solanago.PublicKey `json:"state"`
	TokenProgram               solanago.PublicKey `json:"token_program"`
	Mint                       solanago.PublicKey `json:"mint"`
	MintWritable               bool               `json:"mint_writable"`
	PoolSigner                 solanago.PublicKey `json:"pool_signer"`
	PoolTokenAccount           solanago.PublicKey `json:"pool_token_account"`
	PoolTokenAccountWritable   bool               `json:"pool_token_account_writable"`
	RemoteTokenAccount         solanago.PublicKey `json:"remote_token_account"`
	RemoteTokenAccountWritable bool               `json:"remote_token_account_writable"`
	Authority                  solanago.PublicKey `json:"authority"`
	AuthoritySigner            bool               `json:"authority_signer"`
}

func (obj *WithdrawLiquidityInstruction) GetDiscriminator() []byte {
	return Instruction_WithdrawLiquidity[:]
}

// UnmarshalWithDecoder unmarshals the WithdrawLiquidityInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *WithdrawLiquidityInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "WithdrawLiquidityInstruction", err)
	}
	if discriminator != Instruction_WithdrawLiquidity {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "WithdrawLiquidityInstruction", Instruction_WithdrawLiquidity, discriminator)
	}
	// Deserialize `Amount`:
	err = decoder.Decode(&obj.Amount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *WithdrawLiquidityInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from token_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_program", err)
	}
	indices = append(indices, index)
	// Decode from mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "mint", err)
	}
	indices = append(indices, index)
	// Decode from pool_signer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "pool_signer", err)
	}
	indices = append(indices, index)
	// Decode from pool_token_account account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "pool_token_account", err)
	}
	indices = append(indices, index)
	// Decode from remote_token_account account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "remote_token_account", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *WithdrawLiquidityInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 7 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 7, len(indices))
	}
	indexOffset := 0
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_program", len(accountKeys)-1)
	}
	obj.TokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "mint", len(accountKeys)-1)
	}
	obj.Mint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set pool_signer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "pool_signer", len(accountKeys)-1)
	}
	obj.PoolSigner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set pool_token_account account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "pool_token_account", len(accountKeys)-1)
	}
	obj.PoolTokenAccount = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set remote_token_account account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "remote_token_account", len(accountKeys)-1)
	}
	obj.RemoteTokenAccount = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *WithdrawLiquidityInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.State)
	keys = append(keys, obj.TokenProgram)
	keys = append(keys, obj.Mint)
	keys = append(keys, obj.PoolSigner)
	keys = append(keys, obj.PoolTokenAccount)
	keys = append(keys, obj.RemoteTokenAccount)
	keys = append(keys, obj.Authority)
	return keys
}

// Unmarshal unmarshals the WithdrawLiquidityInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *WithdrawLiquidityInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling WithdrawLiquidityInstruction: %w", err)
	}
	return nil
}

// UnmarshalWithdrawLiquidityInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalWithdrawLiquidityInstruction(buf []byte) (*WithdrawLiquidityInstruction, error) {
	obj := new(WithdrawLiquidityInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Instruction interface defines common methods for all instruction types
type Instruction interface {
	GetDiscriminator() []byte

	UnmarshalWithDecoder(decoder *binary.Decoder) error

	UnmarshalAccountIndices(buf []byte) ([]uint8, error)

	PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error

	GetAccountKeys() []solanago.PublicKey
}

// ParseInstruction parses instruction data and optionally populates accounts
// If accountIndicesData is nil or empty, accounts will not be populated
func ParseInstruction(instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (Instruction, error) {
	// Validate inputs
	if len(instructionData) < 8 {
		return nil, fmt.Errorf("instruction data too short: expected at least 8 bytes, got %d", len(instructionData))
	}
	// Extract discriminator
	discriminator := [8]byte{}
	copy(discriminator[:], instructionData[0:8])
	// Parse based on discriminator
	switch discriminator {
	case Instruction_AcceptOwnership:
		instruction := new(AcceptOwnershipInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AcceptOwnershipInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_AppendRemotePoolAddresses:
		instruction := new(AppendRemotePoolAddressesInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AppendRemotePoolAddressesInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_ConfigureAllowList:
		instruction := new(ConfigureAllowListInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as ConfigureAllowListInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_DeleteChainConfig:
		instruction := new(DeleteChainConfigInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as DeleteChainConfigInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_EditChainRemoteConfig:
		instruction := new(EditChainRemoteConfigInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as EditChainRemoteConfigInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_InitChainRemoteConfig:
		instruction := new(InitChainRemoteConfigInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitChainRemoteConfigInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_InitGlobalConfig:
		instruction := new(InitGlobalConfigInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitGlobalConfigInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_Initialize:
		instruction := new(InitializeInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitializeInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_InitializeStateVersion:
		instruction := new(InitializeStateVersionInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitializeStateVersionInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_LockOrBurnTokens:
		instruction := new(LockOrBurnTokensInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as LockOrBurnTokensInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_ProvideLiquidity:
		instruction := new(ProvideLiquidityInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as ProvideLiquidityInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_ReleaseOrMintTokens:
		instruction := new(ReleaseOrMintTokensInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as ReleaseOrMintTokensInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_RemoveFromAllowList:
		instruction := new(RemoveFromAllowListInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as RemoveFromAllowListInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SetCanAcceptLiquidity:
		instruction := new(SetCanAcceptLiquidityInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SetCanAcceptLiquidityInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SetChainRateLimit:
		instruction := new(SetChainRateLimitInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SetChainRateLimitInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SetRateLimitAdmin:
		instruction := new(SetRateLimitAdminInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SetRateLimitAdminInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SetRebalancer:
		instruction := new(SetRebalancerInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SetRebalancerInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SetRmn:
		instruction := new(SetRmnInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SetRmnInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SetRouter:
		instruction := new(SetRouterInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SetRouterInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_TransferOwnership:
		instruction := new(TransferOwnershipInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as TransferOwnershipInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_TypeVersion:
		instruction := new(TypeVersionInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as TypeVersionInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_UpdateDefaultRmn:
		instruction := new(UpdateDefaultRmnInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as UpdateDefaultRmnInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_UpdateDefaultRouter:
		instruction := new(UpdateDefaultRouterInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as UpdateDefaultRouterInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_UpdateSelfServedAllowed:
		instruction := new(UpdateSelfServedAllowedInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as UpdateSelfServedAllowedInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_WithdrawLiquidity:
		instruction := new(WithdrawLiquidityInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as WithdrawLiquidityInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	default:
		return nil, fmt.Errorf("unknown instruction discriminator: %s", binary.FormatDiscriminator(discriminator))
	}
}

// ParseInstructionTyped parses instruction data and returns a specific instruction type // T must implement the Instruction interface
func ParseInstructionTyped[T Instruction](instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (T, error) {
	instruction, err := ParseInstruction(instructionData, accountIndicesData, accountKeys)
	if err != nil {
		return *new(T), err
	}
	typed, ok := instruction.(T)
	if !ok {
		return *new(T), fmt.Errorf("instruction is not of expected type")
	}
	return typed, nil
}

// ParseInstructionWithoutAccounts parses instruction data without account information
func ParseInstructionWithoutAccounts(instructionData []byte) (Instruction, error) {
	return ParseInstruction(instructionData, nil, []solanago.PublicKey{})
}

// ParseInstructionWithAccounts parses instruction data with account information
func ParseInstructionWithAccounts(instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (Instruction, error) {
	return ParseInstruction(instructionData, accountIndicesData, accountKeys)
}
