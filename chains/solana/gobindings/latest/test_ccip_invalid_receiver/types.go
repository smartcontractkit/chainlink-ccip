// Code generated by https://github.com/Unheilbar/anchor-go. DO NOT EDIT.
// This file contains parsers for the types defined in the IDL.

package test_ccip_invalid_receiver

import (
	"bytes"
	"fmt"
	errors "github.com/Unheilbar/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

type AllowedOfframp struct{}

func (obj AllowedOfframp) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj AllowedOfframp) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding AllowedOfframp: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *AllowedOfframp) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *AllowedOfframp) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AllowedOfframp: %w", err)
	}
	return nil
}

func UnmarshalAllowedOfframp(buf []byte) (*AllowedOfframp, error) {
	obj := new(AllowedOfframp)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type Any2SvmMessage struct {
	MessageId           [32]uint8        `json:"message_id"`
	SourceChainSelector uint64           `json:"source_chain_selector"`
	Sender              []byte           `json:"sender"`
	Data                []byte           `json:"data"`
	TokenAmounts        []SvmTokenAmount `json:"token_amounts"`
}

func (obj Any2SvmMessage) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `MessageId`:
	err = encoder.Encode(obj.MessageId)
	if err != nil {
		return errors.NewField("MessageId", err)
	}
	// Serialize `SourceChainSelector`:
	err = encoder.Encode(obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Serialize `Sender`:
	err = encoder.Encode(obj.Sender)
	if err != nil {
		return errors.NewField("Sender", err)
	}
	// Serialize `Data`:
	err = encoder.Encode(obj.Data)
	if err != nil {
		return errors.NewField("Data", err)
	}
	// Serialize `TokenAmounts`:
	err = encoder.Encode(obj.TokenAmounts)
	if err != nil {
		return errors.NewField("TokenAmounts", err)
	}
	return nil
}

func (obj Any2SvmMessage) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Any2SvmMessage: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Any2SvmMessage) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `MessageId`:
	err = decoder.Decode(&obj.MessageId)
	if err != nil {
		return errors.NewField("MessageId", err)
	}
	// Deserialize `SourceChainSelector`:
	err = decoder.Decode(&obj.SourceChainSelector)
	if err != nil {
		return errors.NewField("SourceChainSelector", err)
	}
	// Deserialize `Sender`:
	err = decoder.Decode(&obj.Sender)
	if err != nil {
		return errors.NewField("Sender", err)
	}
	// Deserialize `Data`:
	err = decoder.Decode(&obj.Data)
	if err != nil {
		return errors.NewField("Data", err)
	}
	// Deserialize `TokenAmounts`:
	err = decoder.Decode(&obj.TokenAmounts)
	if err != nil {
		return errors.NewField("TokenAmounts", err)
	}
	return nil
}

func (obj *Any2SvmMessage) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Any2SvmMessage: %w", err)
	}
	return nil
}

func UnmarshalAny2SvmMessage(buf []byte) (*Any2SvmMessage, error) {
	obj := new(Any2SvmMessage)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type Counter struct {
	Value uint8 `json:"value"`
}

func (obj Counter) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Value`:
	err = encoder.Encode(obj.Value)
	if err != nil {
		return errors.NewField("Value", err)
	}
	return nil
}

func (obj Counter) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Counter: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Counter) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Value`:
	err = decoder.Decode(&obj.Value)
	if err != nil {
		return errors.NewField("Value", err)
	}
	return nil
}

func (obj *Counter) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Counter: %w", err)
	}
	return nil
}

func UnmarshalCounter(buf []byte) (*Counter, error) {
	obj := new(Counter)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type LockOrBurnInV1 struct {
	Receiver            []byte             `json:"receiver"`
	RemoteChainSelector uint64             `json:"remote_chain_selector"`
	OriginalSender      solanago.PublicKey `json:"original_sender"`
	Amount              uint64             `json:"amount"`
	LocalToken          solanago.PublicKey `json:"local_token"`
	MsgTotalNonce       uint64             `json:"msg_total_nonce"`
}

func (obj LockOrBurnInV1) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Receiver`:
	err = encoder.Encode(obj.Receiver)
	if err != nil {
		return errors.NewField("Receiver", err)
	}
	// Serialize `RemoteChainSelector`:
	err = encoder.Encode(obj.RemoteChainSelector)
	if err != nil {
		return errors.NewField("RemoteChainSelector", err)
	}
	// Serialize `OriginalSender`:
	err = encoder.Encode(obj.OriginalSender)
	if err != nil {
		return errors.NewField("OriginalSender", err)
	}
	// Serialize `Amount`:
	err = encoder.Encode(obj.Amount)
	if err != nil {
		return errors.NewField("Amount", err)
	}
	// Serialize `LocalToken`:
	err = encoder.Encode(obj.LocalToken)
	if err != nil {
		return errors.NewField("LocalToken", err)
	}
	// Serialize `MsgTotalNonce`:
	err = encoder.Encode(obj.MsgTotalNonce)
	if err != nil {
		return errors.NewField("MsgTotalNonce", err)
	}
	return nil
}

func (obj LockOrBurnInV1) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding LockOrBurnInV1: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *LockOrBurnInV1) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Receiver`:
	err = decoder.Decode(&obj.Receiver)
	if err != nil {
		return errors.NewField("Receiver", err)
	}
	// Deserialize `RemoteChainSelector`:
	err = decoder.Decode(&obj.RemoteChainSelector)
	if err != nil {
		return errors.NewField("RemoteChainSelector", err)
	}
	// Deserialize `OriginalSender`:
	err = decoder.Decode(&obj.OriginalSender)
	if err != nil {
		return errors.NewField("OriginalSender", err)
	}
	// Deserialize `Amount`:
	err = decoder.Decode(&obj.Amount)
	if err != nil {
		return errors.NewField("Amount", err)
	}
	// Deserialize `LocalToken`:
	err = decoder.Decode(&obj.LocalToken)
	if err != nil {
		return errors.NewField("LocalToken", err)
	}
	// Deserialize `MsgTotalNonce`:
	err = decoder.Decode(&obj.MsgTotalNonce)
	if err != nil {
		return errors.NewField("MsgTotalNonce", err)
	}
	return nil
}

func (obj *LockOrBurnInV1) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling LockOrBurnInV1: %w", err)
	}
	return nil
}

func UnmarshalLockOrBurnInV1(buf []byte) (*LockOrBurnInV1, error) {
	obj := new(LockOrBurnInV1)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ReleaseOrMintInV1 struct {
	OriginalSender      []byte             `json:"original_sender"`
	RemoteChainSelector uint64             `json:"remote_chain_selector"`
	Receiver            solanago.PublicKey `json:"receiver"`
	Amount              [32]uint8          `json:"amount"`
	LocalToken          solanago.PublicKey `json:"local_token"`

	// @dev WARNING: sourcePoolAddress should be checked prior to any processing of funds. Make sure it matches the
	// expected pool address for the given remoteChainSelector.
	SourcePoolAddress []byte `json:"source_pool_address"`
	SourcePoolData    []byte `json:"source_pool_data"`

	// @dev WARNING: offchainTokenData is untrusted data.
	OffchainTokenData []byte `json:"offchain_token_data"`
}

func (obj ReleaseOrMintInV1) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `OriginalSender`:
	err = encoder.Encode(obj.OriginalSender)
	if err != nil {
		return errors.NewField("OriginalSender", err)
	}
	// Serialize `RemoteChainSelector`:
	err = encoder.Encode(obj.RemoteChainSelector)
	if err != nil {
		return errors.NewField("RemoteChainSelector", err)
	}
	// Serialize `Receiver`:
	err = encoder.Encode(obj.Receiver)
	if err != nil {
		return errors.NewField("Receiver", err)
	}
	// Serialize `Amount`:
	err = encoder.Encode(obj.Amount)
	if err != nil {
		return errors.NewField("Amount", err)
	}
	// Serialize `LocalToken`:
	err = encoder.Encode(obj.LocalToken)
	if err != nil {
		return errors.NewField("LocalToken", err)
	}
	// Serialize `SourcePoolAddress`:
	err = encoder.Encode(obj.SourcePoolAddress)
	if err != nil {
		return errors.NewField("SourcePoolAddress", err)
	}
	// Serialize `SourcePoolData`:
	err = encoder.Encode(obj.SourcePoolData)
	if err != nil {
		return errors.NewField("SourcePoolData", err)
	}
	// Serialize `OffchainTokenData`:
	err = encoder.Encode(obj.OffchainTokenData)
	if err != nil {
		return errors.NewField("OffchainTokenData", err)
	}
	return nil
}

func (obj ReleaseOrMintInV1) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding ReleaseOrMintInV1: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *ReleaseOrMintInV1) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `OriginalSender`:
	err = decoder.Decode(&obj.OriginalSender)
	if err != nil {
		return errors.NewField("OriginalSender", err)
	}
	// Deserialize `RemoteChainSelector`:
	err = decoder.Decode(&obj.RemoteChainSelector)
	if err != nil {
		return errors.NewField("RemoteChainSelector", err)
	}
	// Deserialize `Receiver`:
	err = decoder.Decode(&obj.Receiver)
	if err != nil {
		return errors.NewField("Receiver", err)
	}
	// Deserialize `Amount`:
	err = decoder.Decode(&obj.Amount)
	if err != nil {
		return errors.NewField("Amount", err)
	}
	// Deserialize `LocalToken`:
	err = decoder.Decode(&obj.LocalToken)
	if err != nil {
		return errors.NewField("LocalToken", err)
	}
	// Deserialize `SourcePoolAddress`:
	err = decoder.Decode(&obj.SourcePoolAddress)
	if err != nil {
		return errors.NewField("SourcePoolAddress", err)
	}
	// Deserialize `SourcePoolData`:
	err = decoder.Decode(&obj.SourcePoolData)
	if err != nil {
		return errors.NewField("SourcePoolData", err)
	}
	// Deserialize `OffchainTokenData`:
	err = decoder.Decode(&obj.OffchainTokenData)
	if err != nil {
		return errors.NewField("OffchainTokenData", err)
	}
	return nil
}

func (obj *ReleaseOrMintInV1) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ReleaseOrMintInV1: %w", err)
	}
	return nil
}

func UnmarshalReleaseOrMintInV1(buf []byte) (*ReleaseOrMintInV1, error) {
	obj := new(ReleaseOrMintInV1)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SvmTokenAmount struct {
	Token  solanago.PublicKey `json:"token"`
	Amount uint64             `json:"amount"`
}

func (obj SvmTokenAmount) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Token`:
	err = encoder.Encode(obj.Token)
	if err != nil {
		return errors.NewField("Token", err)
	}
	// Serialize `Amount`:
	err = encoder.Encode(obj.Amount)
	if err != nil {
		return errors.NewField("Amount", err)
	}
	return nil
}

func (obj SvmTokenAmount) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding SvmTokenAmount: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *SvmTokenAmount) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Token`:
	err = decoder.Decode(&obj.Token)
	if err != nil {
		return errors.NewField("Token", err)
	}
	// Deserialize `Amount`:
	err = decoder.Decode(&obj.Amount)
	if err != nil {
		return errors.NewField("Amount", err)
	}
	return nil
}

func (obj *SvmTokenAmount) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SvmTokenAmount: %w", err)
	}
	return nil
}

func UnmarshalSvmTokenAmount(buf []byte) (*SvmTokenAmount, error) {
	obj := new(SvmTokenAmount)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}
