// Code generated by https://github.com/Unheilbar/anchor-go. DO NOT EDIT.
// This file contains instructions and instruction parsers.

package test_ccip_invalid_receiver

import (
	"bytes"
	"fmt"
	errors "github.com/Unheilbar/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "add_offramp" instruction.
func NewAddOfframpInstruction(
	// Params:
	sourceChainSelectorParam uint64,
	offrampParam solanago.PublicKey,

	// Accounts:
	allowedOfframpAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AddOfframp[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `sourceChainSelectorParam`:
		err = enc__.Encode(sourceChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("sourceChainSelectorParam", err)
		}
		// Serialize `offrampParam`:
		err = enc__.Encode(offrampParam)
		if err != nil {
			return nil, errors.NewField("offrampParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "allowed_offramp": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(allowedOfframpAccount, true, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "ccip_receive" instruction.
func NewCcipReceiveInstruction(
	// Params:
	messageParam Any2SvmMessage,

	// Accounts:
	authorityAccount solanago.PublicKey,
	offrampProgramAccount solanago.PublicKey,
	allowedOfframpAccount solanago.PublicKey,
	counterAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CcipReceive[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `messageParam`:
		err = enc__.Encode(messageParam)
		if err != nil {
			return nil, errors.NewField("messageParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 1 "offramp_program": Read-only, Non-signer, Required
		// CHECK offramp program: exists only to derive the allowed offramp PDA
		// and the authority PDA. Must be second.
		accounts__.Append(solanago.NewAccountMeta(offrampProgramAccount, false, false))
		// Account 2 "allowed_offramp": Read-only, Non-signer, Required
		// CHECK PDA of the router program verifying the signer is an allowed offramp.
		// If PDA does not exist, the router doesn't allow this offramp
		accounts__.Append(solanago.NewAccountMeta(allowedOfframpAccount, false, false))
		// Account 3 "counter": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(counterAccount, true, false))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "pool_proxy_lock_or_burn" instruction.
func NewPoolProxyLockOrBurnInstruction(
	// Params:
	lockOrBurnParam LockOrBurnInV1,

	// Accounts:
	testPoolAccount solanago.PublicKey,
	cpiSignerAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	poolSignerAccount solanago.PublicKey,
	poolTokenAccountAccount solanago.PublicKey,
	rmnRemoteAccount solanago.PublicKey,
	rmnRemoteCursesAccount solanago.PublicKey,
	rmnRemoteConfigAccount solanago.PublicKey,
	chainConfigAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_PoolProxyLockOrBurn[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `lockOrBurnParam`:
		err = enc__.Encode(lockOrBurnParam)
		if err != nil {
			return nil, errors.NewField("lockOrBurnParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "test_pool": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(testPoolAccount, false, false))
		// Account 1 "cpi_signer": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(cpiSignerAccount, false, false))
		// Account 2 "state": Writable, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 3 "token_program": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 4 "mint": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, false))
		// Account 5 "pool_signer": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(poolSignerAccount, false, false))
		// Account 6 "pool_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolTokenAccountAccount, true, false))
		// Account 7 "rmn_remote": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteAccount, false, false))
		// Account 8 "rmn_remote_curses": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteCursesAccount, false, false))
		// Account 9 "rmn_remote_config": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteConfigAccount, false, false))
		// Account 10 "chain_config": Writable, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(chainConfigAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "pool_proxy_release_or_mint" instruction.
func NewPoolProxyReleaseOrMintInstruction(
	// Params:
	releaseOrMintParam ReleaseOrMintInV1,

	// Accounts:
	testPoolAccount solanago.PublicKey,
	cpiSignerAccount solanago.PublicKey,
	offrampProgramAccount solanago.PublicKey,
	allowedOfframpAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	poolSignerAccount solanago.PublicKey,
	poolTokenAccountAccount solanago.PublicKey,
	chainConfigAccount solanago.PublicKey,
	rmnRemoteAccount solanago.PublicKey,
	rmnRemoteCursesAccount solanago.PublicKey,
	rmnRemoteConfigAccount solanago.PublicKey,
	receiverTokenAccountAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_PoolProxyReleaseOrMint[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `releaseOrMintParam`:
		err = enc__.Encode(releaseOrMintParam)
		if err != nil {
			return nil, errors.NewField("releaseOrMintParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "test_pool": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(testPoolAccount, false, false))
		// Account 1 "cpi_signer": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(cpiSignerAccount, false, false))
		// Account 2 "offramp_program": Read-only, Non-signer, Required, Address: FmyF3oW69MSAhyPSiZ69C4RKBdCPv5vAFTScisV7Me2j
		accounts__.Append(solanago.NewAccountMeta(offrampProgramAccount, false, false))
		// Account 3 "allowed_offramp": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(allowedOfframpAccount, false, false))
		// Account 4 "state": Writable, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 5 "token_program": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 6 "mint": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, false))
		// Account 7 "pool_signer": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(poolSignerAccount, false, false))
		// Account 8 "pool_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolTokenAccountAccount, true, false))
		// Account 9 "chain_config": Writable, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(chainConfigAccount, true, false))
		// Account 10 "rmn_remote": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteAccount, false, false))
		// Account 11 "rmn_remote_curses": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteCursesAccount, false, false))
		// Account 12 "rmn_remote_config": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteConfigAccount, false, false))
		// Account 13 "receiver_token_account": Writable, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(receiverTokenAccountAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "receiver_proxy_execute" instruction.
func NewReceiverProxyExecuteInstruction(
	// Params:
	messageParam Any2SvmMessage,

	// Accounts:
	testReceiverAccount solanago.PublicKey,
	cpiSignerAccount solanago.PublicKey,
	offrampProgramAccount solanago.PublicKey,
	allowedOfframpAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ReceiverProxyExecute[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `messageParam`:
		err = enc__.Encode(messageParam)
		if err != nil {
			return nil, errors.NewField("messageParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "test_receiver": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(testReceiverAccount, false, false))
		// Account 1 "cpi_signer": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(cpiSignerAccount, false, false))
		// Account 2 "offramp_program": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(offrampProgramAccount, false, false))
		// Account 3 "allowed_offramp": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(allowedOfframpAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

type AddOfframpInstruction struct {
	SourceChainSelector uint64             `json:"_source_chain_selector"`
	Offramp             solanago.PublicKey `json:"_offramp"`

	// Accounts:
	AllowedOfframp         solanago.PublicKey `json:"allowed_offramp"`
	AllowedOfframpWritable bool               `json:"allowed_offramp_writable"`
	Authority              solanago.PublicKey `json:"authority"`
	AuthorityWritable      bool               `json:"authority_writable"`
	AuthoritySigner        bool               `json:"authority_signer"`
	SystemProgram          solanago.PublicKey `json:"system_program"`
}

func (obj *AddOfframpInstruction) GetDiscriminator() []byte {
	return Instruction_AddOfframp[:]
}

// UnmarshalWithDecoder unmarshals the AddOfframpInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *AddOfframpInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "AddOfframpInstruction", err)
	}
	if discriminator != Instruction_AddOfframp {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "AddOfframpInstruction", Instruction_AddOfframp, discriminator)
	}
	// Deserialize `SourceChainSelector`:
	err = decoder.Decode(&obj.SourceChainSelector)
	if err != nil {
		return err
	}
	// Deserialize `Offramp`:
	err = decoder.Decode(&obj.Offramp)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AddOfframpInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from allowed_offramp account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "allowed_offramp", err)
	}
	indices = append(indices, index)
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AddOfframpInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set allowed_offramp account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "allowed_offramp", len(accountKeys)-1)
	}
	obj.AllowedOfframp = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AddOfframpInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.AllowedOfframp)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the AddOfframpInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *AddOfframpInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AddOfframpInstruction: %w", err)
	}
	return nil
}

// UnmarshalAddOfframpInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalAddOfframpInstruction(buf []byte) (*AddOfframpInstruction, error) {
	obj := new(AddOfframpInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type CcipReceiveInstruction struct {
	Message Any2SvmMessage `json:"_message"`

	// Accounts:
	Authority         solanago.PublicKey `json:"authority"`
	AuthorityWritable bool               `json:"authority_writable"`
	AuthoritySigner   bool               `json:"authority_signer"`
	OfframpProgram    solanago.PublicKey `json:"offramp_program"`
	AllowedOfframp    solanago.PublicKey `json:"allowed_offramp"`
	Counter           solanago.PublicKey `json:"counter"`
	CounterWritable   bool               `json:"counter_writable"`
	SystemProgram     solanago.PublicKey `json:"system_program"`
}

func (obj *CcipReceiveInstruction) GetDiscriminator() []byte {
	return Instruction_CcipReceive[:]
}

// UnmarshalWithDecoder unmarshals the CcipReceiveInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *CcipReceiveInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "CcipReceiveInstruction", err)
	}
	if discriminator != Instruction_CcipReceive {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "CcipReceiveInstruction", Instruction_CcipReceive, discriminator)
	}
	// Deserialize `Message`:
	err = decoder.Decode(&obj.Message)
	if err != nil {
		return err
	}
	return nil
}

func (obj *CcipReceiveInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from authority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authority", err)
	}
	indices = append(indices, index)
	// Decode from offramp_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "offramp_program", err)
	}
	indices = append(indices, index)
	// Decode from allowed_offramp account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "allowed_offramp", err)
	}
	indices = append(indices, index)
	// Decode from counter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "counter", err)
	}
	indices = append(indices, index)
	// Decode from system_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "system_program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *CcipReceiveInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 5 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 5, len(indices))
	}
	indexOffset := 0
	// Set authority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authority", len(accountKeys)-1)
	}
	obj.Authority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set offramp_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "offramp_program", len(accountKeys)-1)
	}
	obj.OfframpProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set allowed_offramp account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "allowed_offramp", len(accountKeys)-1)
	}
	obj.AllowedOfframp = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set counter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "counter", len(accountKeys)-1)
	}
	obj.Counter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set system_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "system_program", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *CcipReceiveInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Authority)
	keys = append(keys, obj.OfframpProgram)
	keys = append(keys, obj.AllowedOfframp)
	keys = append(keys, obj.Counter)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the CcipReceiveInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *CcipReceiveInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CcipReceiveInstruction: %w", err)
	}
	return nil
}

// UnmarshalCcipReceiveInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalCcipReceiveInstruction(buf []byte) (*CcipReceiveInstruction, error) {
	obj := new(CcipReceiveInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type PoolProxyLockOrBurnInstruction struct {
	LockOrBurn LockOrBurnInV1 `json:"lock_or_burn"`

	// Accounts:
	TestPool                 solanago.PublicKey `json:"test_pool"`
	CpiSigner                solanago.PublicKey `json:"cpi_signer"`
	State                    solanago.PublicKey `json:"state"`
	StateWritable            bool               `json:"state_writable"`
	TokenProgram             solanago.PublicKey `json:"token_program"`
	Mint                     solanago.PublicKey `json:"mint"`
	MintWritable             bool               `json:"mint_writable"`
	PoolSigner               solanago.PublicKey `json:"pool_signer"`
	PoolTokenAccount         solanago.PublicKey `json:"pool_token_account"`
	PoolTokenAccountWritable bool               `json:"pool_token_account_writable"`
	RmnRemote                solanago.PublicKey `json:"rmn_remote"`
	RmnRemoteCurses          solanago.PublicKey `json:"rmn_remote_curses"`
	RmnRemoteConfig          solanago.PublicKey `json:"rmn_remote_config"`
	ChainConfig              solanago.PublicKey `json:"chain_config"`
	ChainConfigWritable      bool               `json:"chain_config_writable"`
}

func (obj *PoolProxyLockOrBurnInstruction) GetDiscriminator() []byte {
	return Instruction_PoolProxyLockOrBurn[:]
}

// UnmarshalWithDecoder unmarshals the PoolProxyLockOrBurnInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *PoolProxyLockOrBurnInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "PoolProxyLockOrBurnInstruction", err)
	}
	if discriminator != Instruction_PoolProxyLockOrBurn {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "PoolProxyLockOrBurnInstruction", Instruction_PoolProxyLockOrBurn, discriminator)
	}
	// Deserialize `LockOrBurn`:
	err = decoder.Decode(&obj.LockOrBurn)
	if err != nil {
		return err
	}
	return nil
}

func (obj *PoolProxyLockOrBurnInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from test_pool account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "test_pool", err)
	}
	indices = append(indices, index)
	// Decode from cpi_signer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "cpi_signer", err)
	}
	indices = append(indices, index)
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from token_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_program", err)
	}
	indices = append(indices, index)
	// Decode from mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "mint", err)
	}
	indices = append(indices, index)
	// Decode from pool_signer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "pool_signer", err)
	}
	indices = append(indices, index)
	// Decode from pool_token_account account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "pool_token_account", err)
	}
	indices = append(indices, index)
	// Decode from rmn_remote account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rmn_remote", err)
	}
	indices = append(indices, index)
	// Decode from rmn_remote_curses account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rmn_remote_curses", err)
	}
	indices = append(indices, index)
	// Decode from rmn_remote_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rmn_remote_config", err)
	}
	indices = append(indices, index)
	// Decode from chain_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "chain_config", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *PoolProxyLockOrBurnInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 11 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 11, len(indices))
	}
	indexOffset := 0
	// Set test_pool account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "test_pool", len(accountKeys)-1)
	}
	obj.TestPool = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set cpi_signer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "cpi_signer", len(accountKeys)-1)
	}
	obj.CpiSigner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_program", len(accountKeys)-1)
	}
	obj.TokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "mint", len(accountKeys)-1)
	}
	obj.Mint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set pool_signer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "pool_signer", len(accountKeys)-1)
	}
	obj.PoolSigner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set pool_token_account account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "pool_token_account", len(accountKeys)-1)
	}
	obj.PoolTokenAccount = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rmn_remote account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rmn_remote", len(accountKeys)-1)
	}
	obj.RmnRemote = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rmn_remote_curses account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rmn_remote_curses", len(accountKeys)-1)
	}
	obj.RmnRemoteCurses = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rmn_remote_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rmn_remote_config", len(accountKeys)-1)
	}
	obj.RmnRemoteConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set chain_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "chain_config", len(accountKeys)-1)
	}
	obj.ChainConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *PoolProxyLockOrBurnInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.TestPool)
	keys = append(keys, obj.CpiSigner)
	keys = append(keys, obj.State)
	keys = append(keys, obj.TokenProgram)
	keys = append(keys, obj.Mint)
	keys = append(keys, obj.PoolSigner)
	keys = append(keys, obj.PoolTokenAccount)
	keys = append(keys, obj.RmnRemote)
	keys = append(keys, obj.RmnRemoteCurses)
	keys = append(keys, obj.RmnRemoteConfig)
	keys = append(keys, obj.ChainConfig)
	return keys
}

// Unmarshal unmarshals the PoolProxyLockOrBurnInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *PoolProxyLockOrBurnInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling PoolProxyLockOrBurnInstruction: %w", err)
	}
	return nil
}

// UnmarshalPoolProxyLockOrBurnInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalPoolProxyLockOrBurnInstruction(buf []byte) (*PoolProxyLockOrBurnInstruction, error) {
	obj := new(PoolProxyLockOrBurnInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type PoolProxyReleaseOrMintInstruction struct {
	ReleaseOrMint ReleaseOrMintInV1 `json:"release_or_mint"`

	// Accounts:
	TestPool                     solanago.PublicKey `json:"test_pool"`
	CpiSigner                    solanago.PublicKey `json:"cpi_signer"`
	OfframpProgram               solanago.PublicKey `json:"offramp_program"`
	AllowedOfframp               solanago.PublicKey `json:"allowed_offramp"`
	State                        solanago.PublicKey `json:"state"`
	StateWritable                bool               `json:"state_writable"`
	TokenProgram                 solanago.PublicKey `json:"token_program"`
	Mint                         solanago.PublicKey `json:"mint"`
	MintWritable                 bool               `json:"mint_writable"`
	PoolSigner                   solanago.PublicKey `json:"pool_signer"`
	PoolTokenAccount             solanago.PublicKey `json:"pool_token_account"`
	PoolTokenAccountWritable     bool               `json:"pool_token_account_writable"`
	ChainConfig                  solanago.PublicKey `json:"chain_config"`
	ChainConfigWritable          bool               `json:"chain_config_writable"`
	RmnRemote                    solanago.PublicKey `json:"rmn_remote"`
	RmnRemoteCurses              solanago.PublicKey `json:"rmn_remote_curses"`
	RmnRemoteConfig              solanago.PublicKey `json:"rmn_remote_config"`
	ReceiverTokenAccount         solanago.PublicKey `json:"receiver_token_account"`
	ReceiverTokenAccountWritable bool               `json:"receiver_token_account_writable"`
}

func (obj *PoolProxyReleaseOrMintInstruction) GetDiscriminator() []byte {
	return Instruction_PoolProxyReleaseOrMint[:]
}

// UnmarshalWithDecoder unmarshals the PoolProxyReleaseOrMintInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *PoolProxyReleaseOrMintInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "PoolProxyReleaseOrMintInstruction", err)
	}
	if discriminator != Instruction_PoolProxyReleaseOrMint {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "PoolProxyReleaseOrMintInstruction", Instruction_PoolProxyReleaseOrMint, discriminator)
	}
	// Deserialize `ReleaseOrMint`:
	err = decoder.Decode(&obj.ReleaseOrMint)
	if err != nil {
		return err
	}
	return nil
}

func (obj *PoolProxyReleaseOrMintInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from test_pool account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "test_pool", err)
	}
	indices = append(indices, index)
	// Decode from cpi_signer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "cpi_signer", err)
	}
	indices = append(indices, index)
	// Decode from offramp_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "offramp_program", err)
	}
	indices = append(indices, index)
	// Decode from allowed_offramp account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "allowed_offramp", err)
	}
	indices = append(indices, index)
	// Decode from state account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "state", err)
	}
	indices = append(indices, index)
	// Decode from token_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "token_program", err)
	}
	indices = append(indices, index)
	// Decode from mint account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "mint", err)
	}
	indices = append(indices, index)
	// Decode from pool_signer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "pool_signer", err)
	}
	indices = append(indices, index)
	// Decode from pool_token_account account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "pool_token_account", err)
	}
	indices = append(indices, index)
	// Decode from chain_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "chain_config", err)
	}
	indices = append(indices, index)
	// Decode from rmn_remote account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rmn_remote", err)
	}
	indices = append(indices, index)
	// Decode from rmn_remote_curses account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rmn_remote_curses", err)
	}
	indices = append(indices, index)
	// Decode from rmn_remote_config account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "rmn_remote_config", err)
	}
	indices = append(indices, index)
	// Decode from receiver_token_account account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "receiver_token_account", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *PoolProxyReleaseOrMintInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 14 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 14, len(indices))
	}
	indexOffset := 0
	// Set test_pool account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "test_pool", len(accountKeys)-1)
	}
	obj.TestPool = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set cpi_signer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "cpi_signer", len(accountKeys)-1)
	}
	obj.CpiSigner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set offramp_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "offramp_program", len(accountKeys)-1)
	}
	obj.OfframpProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set allowed_offramp account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "allowed_offramp", len(accountKeys)-1)
	}
	obj.AllowedOfframp = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set state account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "state", len(accountKeys)-1)
	}
	obj.State = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set token_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "token_program", len(accountKeys)-1)
	}
	obj.TokenProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set mint account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "mint", len(accountKeys)-1)
	}
	obj.Mint = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set pool_signer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "pool_signer", len(accountKeys)-1)
	}
	obj.PoolSigner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set pool_token_account account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "pool_token_account", len(accountKeys)-1)
	}
	obj.PoolTokenAccount = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set chain_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "chain_config", len(accountKeys)-1)
	}
	obj.ChainConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rmn_remote account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rmn_remote", len(accountKeys)-1)
	}
	obj.RmnRemote = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rmn_remote_curses account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rmn_remote_curses", len(accountKeys)-1)
	}
	obj.RmnRemoteCurses = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set rmn_remote_config account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "rmn_remote_config", len(accountKeys)-1)
	}
	obj.RmnRemoteConfig = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set receiver_token_account account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "receiver_token_account", len(accountKeys)-1)
	}
	obj.ReceiverTokenAccount = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *PoolProxyReleaseOrMintInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.TestPool)
	keys = append(keys, obj.CpiSigner)
	keys = append(keys, obj.OfframpProgram)
	keys = append(keys, obj.AllowedOfframp)
	keys = append(keys, obj.State)
	keys = append(keys, obj.TokenProgram)
	keys = append(keys, obj.Mint)
	keys = append(keys, obj.PoolSigner)
	keys = append(keys, obj.PoolTokenAccount)
	keys = append(keys, obj.ChainConfig)
	keys = append(keys, obj.RmnRemote)
	keys = append(keys, obj.RmnRemoteCurses)
	keys = append(keys, obj.RmnRemoteConfig)
	keys = append(keys, obj.ReceiverTokenAccount)
	return keys
}

// Unmarshal unmarshals the PoolProxyReleaseOrMintInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *PoolProxyReleaseOrMintInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling PoolProxyReleaseOrMintInstruction: %w", err)
	}
	return nil
}

// UnmarshalPoolProxyReleaseOrMintInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalPoolProxyReleaseOrMintInstruction(buf []byte) (*PoolProxyReleaseOrMintInstruction, error) {
	obj := new(PoolProxyReleaseOrMintInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ReceiverProxyExecuteInstruction struct {
	Message Any2SvmMessage `json:"message"`

	// Accounts:
	TestReceiver   solanago.PublicKey `json:"test_receiver"`
	CpiSigner      solanago.PublicKey `json:"cpi_signer"`
	OfframpProgram solanago.PublicKey `json:"offramp_program"`
	AllowedOfframp solanago.PublicKey `json:"allowed_offramp"`
}

func (obj *ReceiverProxyExecuteInstruction) GetDiscriminator() []byte {
	return Instruction_ReceiverProxyExecute[:]
}

// UnmarshalWithDecoder unmarshals the ReceiverProxyExecuteInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *ReceiverProxyExecuteInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "ReceiverProxyExecuteInstruction", err)
	}
	if discriminator != Instruction_ReceiverProxyExecute {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "ReceiverProxyExecuteInstruction", Instruction_ReceiverProxyExecute, discriminator)
	}
	// Deserialize `Message`:
	err = decoder.Decode(&obj.Message)
	if err != nil {
		return err
	}
	return nil
}

func (obj *ReceiverProxyExecuteInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from test_receiver account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "test_receiver", err)
	}
	indices = append(indices, index)
	// Decode from cpi_signer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "cpi_signer", err)
	}
	indices = append(indices, index)
	// Decode from offramp_program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "offramp_program", err)
	}
	indices = append(indices, index)
	// Decode from allowed_offramp account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "allowed_offramp", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *ReceiverProxyExecuteInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set test_receiver account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "test_receiver", len(accountKeys)-1)
	}
	obj.TestReceiver = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set cpi_signer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "cpi_signer", len(accountKeys)-1)
	}
	obj.CpiSigner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set offramp_program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "offramp_program", len(accountKeys)-1)
	}
	obj.OfframpProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set allowed_offramp account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "allowed_offramp", len(accountKeys)-1)
	}
	obj.AllowedOfframp = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *ReceiverProxyExecuteInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.TestReceiver)
	keys = append(keys, obj.CpiSigner)
	keys = append(keys, obj.OfframpProgram)
	keys = append(keys, obj.AllowedOfframp)
	return keys
}

// Unmarshal unmarshals the ReceiverProxyExecuteInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *ReceiverProxyExecuteInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ReceiverProxyExecuteInstruction: %w", err)
	}
	return nil
}

// UnmarshalReceiverProxyExecuteInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalReceiverProxyExecuteInstruction(buf []byte) (*ReceiverProxyExecuteInstruction, error) {
	obj := new(ReceiverProxyExecuteInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Instruction interface defines common methods for all instruction types
type Instruction interface {
	GetDiscriminator() []byte

	UnmarshalWithDecoder(decoder *binary.Decoder) error

	UnmarshalAccountIndices(buf []byte) ([]uint8, error)

	PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error

	GetAccountKeys() []solanago.PublicKey
}

// ParseInstruction parses instruction data and optionally populates accounts
// If accountIndicesData is nil or empty, accounts will not be populated
func ParseInstruction(instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (Instruction, error) {
	// Validate inputs
	if len(instructionData) < 8 {
		return nil, fmt.Errorf("instruction data too short: expected at least 8 bytes, got %d", len(instructionData))
	}
	// Extract discriminator
	discriminator := [8]byte{}
	copy(discriminator[:], instructionData[0:8])
	// Parse based on discriminator
	switch discriminator {
	case Instruction_AddOfframp:
		instruction := new(AddOfframpInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AddOfframpInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_CcipReceive:
		instruction := new(CcipReceiveInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as CcipReceiveInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_PoolProxyLockOrBurn:
		instruction := new(PoolProxyLockOrBurnInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as PoolProxyLockOrBurnInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_PoolProxyReleaseOrMint:
		instruction := new(PoolProxyReleaseOrMintInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as PoolProxyReleaseOrMintInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_ReceiverProxyExecute:
		instruction := new(ReceiverProxyExecuteInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as ReceiverProxyExecuteInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	default:
		return nil, fmt.Errorf("unknown instruction discriminator: %s", binary.FormatDiscriminator(discriminator))
	}
}

// ParseInstructionTyped parses instruction data and returns a specific instruction type // T must implement the Instruction interface
func ParseInstructionTyped[T Instruction](instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (T, error) {
	instruction, err := ParseInstruction(instructionData, accountIndicesData, accountKeys)
	if err != nil {
		return *new(T), err
	}
	typed, ok := instruction.(T)
	if !ok {
		return *new(T), fmt.Errorf("instruction is not of expected type")
	}
	return typed, nil
}

// ParseInstructionWithoutAccounts parses instruction data without account information
func ParseInstructionWithoutAccounts(instructionData []byte) (Instruction, error) {
	return ParseInstruction(instructionData, nil, []solanago.PublicKey{})
}

// ParseInstructionWithAccounts parses instruction data with account information
func ParseInstructionWithAccounts(instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (Instruction, error) {
	return ParseInstruction(instructionData, accountIndicesData, accountKeys)
}
