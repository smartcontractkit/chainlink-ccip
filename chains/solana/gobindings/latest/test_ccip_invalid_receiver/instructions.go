// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains instructions.

package test_ccip_invalid_receiver

import (
	"bytes"
	"fmt"
	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "add_offramp" instruction.
func NewAddOfframpInstruction(
	// Params:
	sourceChainSelectorParam uint64,
	offrampParam solanago.PublicKey,

	// Accounts:
	allowedOfframpAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AddOfframp[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `sourceChainSelectorParam`:
		err = enc__.Encode(sourceChainSelectorParam)
		if err != nil {
			return nil, errors.NewField("sourceChainSelectorParam", err)
		}
		// Serialize `offrampParam`:
		err = enc__.Encode(offrampParam)
		if err != nil {
			return nil, errors.NewField("offrampParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "allowed_offramp": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(allowedOfframpAccount, true, false))
		// Account 1 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "ccip_receive" instruction.
func NewCcipReceiveInstruction(
	// Params:
	messageParam Any2SvmMessage,

	// Accounts:
	authorityAccount solanago.PublicKey,
	offrampProgramAccount solanago.PublicKey,
	allowedOfframpAccount solanago.PublicKey,
	counterAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CcipReceive[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `messageParam`:
		err = enc__.Encode(messageParam)
		if err != nil {
			return nil, errors.NewField("messageParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "authority": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, true, true))
		// Account 1 "offramp_program": Read-only, Non-signer, Required
		// CHECK offramp program: exists only to derive the allowed offramp PDA
		// and the authority PDA. Must be second.
		accounts__.Append(solanago.NewAccountMeta(offrampProgramAccount, false, false))
		// Account 2 "allowed_offramp": Read-only, Non-signer, Required
		// CHECK PDA of the router program verifying the signer is an allowed offramp.
		// If PDA does not exist, the router doesn't allow this offramp
		accounts__.Append(solanago.NewAccountMeta(allowedOfframpAccount, false, false))
		// Account 3 "counter": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(counterAccount, true, false))
		// Account 4 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "pool_proxy_lock_or_burn" instruction.
func NewPoolProxyLockOrBurnInstruction(
	// Params:
	lockOrBurnParam LockOrBurnInV1,

	// Accounts:
	testPoolAccount solanago.PublicKey,
	cpiSignerAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	poolSignerAccount solanago.PublicKey,
	poolTokenAccountAccount solanago.PublicKey,
	rmnRemoteAccount solanago.PublicKey,
	rmnRemoteCursesAccount solanago.PublicKey,
	rmnRemoteConfigAccount solanago.PublicKey,
	chainConfigAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_PoolProxyLockOrBurn[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `lockOrBurnParam`:
		err = enc__.Encode(lockOrBurnParam)
		if err != nil {
			return nil, errors.NewField("lockOrBurnParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "test_pool": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(testPoolAccount, false, false))
		// Account 1 "cpi_signer": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(cpiSignerAccount, false, false))
		// Account 2 "state": Writable, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 3 "token_program": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 4 "mint": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, false))
		// Account 5 "pool_signer": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(poolSignerAccount, false, false))
		// Account 6 "pool_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolTokenAccountAccount, true, false))
		// Account 7 "rmn_remote": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteAccount, false, false))
		// Account 8 "rmn_remote_curses": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteCursesAccount, false, false))
		// Account 9 "rmn_remote_config": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteConfigAccount, false, false))
		// Account 10 "chain_config": Writable, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(chainConfigAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "pool_proxy_release_or_mint" instruction.
func NewPoolProxyReleaseOrMintInstruction(
	// Params:
	releaseOrMintParam ReleaseOrMintInV1,

	// Accounts:
	testPoolAccount solanago.PublicKey,
	cpiSignerAccount solanago.PublicKey,
	offrampProgramAccount solanago.PublicKey,
	allowedOfframpAccount solanago.PublicKey,
	stateAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	poolSignerAccount solanago.PublicKey,
	poolTokenAccountAccount solanago.PublicKey,
	chainConfigAccount solanago.PublicKey,
	rmnRemoteAccount solanago.PublicKey,
	rmnRemoteCursesAccount solanago.PublicKey,
	rmnRemoteConfigAccount solanago.PublicKey,
	receiverTokenAccountAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_PoolProxyReleaseOrMint[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `releaseOrMintParam`:
		err = enc__.Encode(releaseOrMintParam)
		if err != nil {
			return nil, errors.NewField("releaseOrMintParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "test_pool": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(testPoolAccount, false, false))
		// Account 1 "cpi_signer": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(cpiSignerAccount, false, false))
		// Account 2 "offramp_program": Read-only, Non-signer, Required, Address: FmyF3oW69MSAhyPSiZ69C4RKBdCPv5vAFTScisV7Me2j
		accounts__.Append(solanago.NewAccountMeta(offrampProgramAccount, false, false))
		// Account 3 "allowed_offramp": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(allowedOfframpAccount, false, false))
		// Account 4 "state": Writable, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(stateAccount, true, false))
		// Account 5 "token_program": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 6 "mint": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, false))
		// Account 7 "pool_signer": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(poolSignerAccount, false, false))
		// Account 8 "pool_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolTokenAccountAccount, true, false))
		// Account 9 "chain_config": Writable, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(chainConfigAccount, true, false))
		// Account 10 "rmn_remote": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteAccount, false, false))
		// Account 11 "rmn_remote_curses": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteCursesAccount, false, false))
		// Account 12 "rmn_remote_config": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(rmnRemoteConfigAccount, false, false))
		// Account 13 "receiver_token_account": Writable, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(receiverTokenAccountAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "receiver_proxy_execute" instruction.
func NewReceiverProxyExecuteInstruction(
	// Params:
	messageParam Any2SvmMessage,

	// Accounts:
	testReceiverAccount solanago.PublicKey,
	cpiSignerAccount solanago.PublicKey,
	offrampProgramAccount solanago.PublicKey,
	allowedOfframpAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ReceiverProxyExecute[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `messageParam`:
		err = enc__.Encode(messageParam)
		if err != nil {
			return nil, errors.NewField("messageParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "test_receiver": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(testReceiverAccount, false, false))
		// Account 1 "cpi_signer": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(cpiSignerAccount, false, false))
		// Account 2 "offramp_program": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(offrampProgramAccount, false, false))
		// Account 3 "allowed_offramp": Read-only, Non-signer, Required
		// CHECK
		accounts__.Append(solanago.NewAccountMeta(allowedOfframpAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}
