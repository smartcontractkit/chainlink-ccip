// Code generated by https://github.com/Unheilbar/anchor-go. DO NOT EDIT.
// This file contains instructions and instruction parsers.

package message_transmitter

import (
	"bytes"
	"fmt"
	errors "github.com/Unheilbar/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "initialize" instruction.
func NewInitializeInstruction(
	// Params:
	paramsParam InitializeParams,

	// Accounts:
	payerAccount solanago.PublicKey,
	upgradeAuthorityAccount solanago.PublicKey,
	messageTransmitterAccount solanago.PublicKey,
	messageTransmitterProgramDataAccount solanago.PublicKey,
	messageTransmitterProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Initialize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 1 "upgradeAuthority": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(upgradeAuthorityAccount, false, true))
		// Account 2 "messageTransmitter": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(messageTransmitterAccount, true, false))
		// Account 3 "messageTransmitterProgramData": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(messageTransmitterProgramDataAccount, false, false))
		// Account 4 "messageTransmitterProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(messageTransmitterProgramAccount, false, false))
		// Account 5 "systemProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 6 "eventAuthority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 7 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "transferOwnership" instruction.
func NewTransferOwnershipInstruction(
	// Params:
	paramsParam TransferOwnershipParams,

	// Accounts:
	ownerAccount solanago.PublicKey,
	messageTransmitterAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_TransferOwnership[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "owner": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
		// Account 1 "messageTransmitter": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(messageTransmitterAccount, true, false))
		// Account 2 "eventAuthority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 3 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "acceptOwnership" instruction.
func NewAcceptOwnershipInstruction(
	// Params:
	paramsParam AcceptOwnershipParams,

	// Accounts:
	pendingOwnerAccount solanago.PublicKey,
	messageTransmitterAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AcceptOwnership[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "pendingOwner": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(pendingOwnerAccount, false, true))
		// Account 1 "messageTransmitter": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(messageTransmitterAccount, true, false))
		// Account 2 "eventAuthority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 3 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "updatePauser" instruction.
func NewUpdatePauserInstruction(
	// Params:
	paramsParam UpdatePauserParams,

	// Accounts:
	ownerAccount solanago.PublicKey,
	messageTransmitterAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePauser[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "owner": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
		// Account 1 "messageTransmitter": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(messageTransmitterAccount, true, false))
		// Account 2 "eventAuthority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 3 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "updateAttesterManager" instruction.
func NewUpdateAttesterManagerInstruction(
	// Params:
	paramsParam UpdateAttesterManagerParams,

	// Accounts:
	ownerAccount solanago.PublicKey,
	messageTransmitterAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateAttesterManager[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "owner": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
		// Account 1 "messageTransmitter": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(messageTransmitterAccount, true, false))
		// Account 2 "eventAuthority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 3 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "pause" instruction.
func NewPauseInstruction(
	// Params:
	paramsParam PauseParams,

	// Accounts:
	pauserAccount solanago.PublicKey,
	messageTransmitterAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Pause[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "pauser": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(pauserAccount, false, true))
		// Account 1 "messageTransmitter": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(messageTransmitterAccount, true, false))
		// Account 2 "eventAuthority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 3 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "unpause" instruction.
func NewUnpauseInstruction(
	// Params:
	paramsParam UnpauseParams,

	// Accounts:
	pauserAccount solanago.PublicKey,
	messageTransmitterAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Unpause[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "pauser": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(pauserAccount, false, true))
		// Account 1 "messageTransmitter": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(messageTransmitterAccount, true, false))
		// Account 2 "eventAuthority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 3 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "setMaxMessageBodySize" instruction.
func NewSetMaxMessageBodySizeInstruction(
	// Params:
	paramsParam SetMaxMessageBodySizeParams,

	// Accounts:
	ownerAccount solanago.PublicKey,
	messageTransmitterAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetMaxMessageBodySize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "owner": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
		// Account 1 "messageTransmitter": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(messageTransmitterAccount, true, false))
		// Account 2 "eventAuthority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 3 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "enableAttester" instruction.
func NewEnableAttesterInstruction(
	// Params:
	paramsParam EnableAttesterParams,

	// Accounts:
	payerAccount solanago.PublicKey,
	attesterManagerAccount solanago.PublicKey,
	messageTransmitterAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_EnableAttester[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 1 "attesterManager": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(attesterManagerAccount, false, true))
		// Account 2 "messageTransmitter": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(messageTransmitterAccount, true, false))
		// Account 3 "systemProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 4 "eventAuthority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 5 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "disableAttester" instruction.
func NewDisableAttesterInstruction(
	// Params:
	paramsParam DisableAttesterParams,

	// Accounts:
	payerAccount solanago.PublicKey,
	attesterManagerAccount solanago.PublicKey,
	messageTransmitterAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_DisableAttester[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 1 "attesterManager": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(attesterManagerAccount, false, true))
		// Account 2 "messageTransmitter": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(messageTransmitterAccount, true, false))
		// Account 3 "systemProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 4 "eventAuthority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 5 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "setSignatureThreshold" instruction.
func NewSetSignatureThresholdInstruction(
	// Params:
	paramsParam SetSignatureThresholdParams,

	// Accounts:
	attesterManagerAccount solanago.PublicKey,
	messageTransmitterAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetSignatureThreshold[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "attesterManager": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(attesterManagerAccount, false, true))
		// Account 1 "messageTransmitter": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(messageTransmitterAccount, true, false))
		// Account 2 "eventAuthority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 3 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "sendMessage" instruction.
func NewSendMessageInstruction(
	// Params:
	paramsParam SendMessageParams,

	// Accounts:
	eventRentPayerAccount solanago.PublicKey,
	senderAuthorityPdaAccount solanago.PublicKey,
	messageTransmitterAccount solanago.PublicKey,
	messageSentEventDataAccount solanago.PublicKey,
	senderProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SendMessage[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "eventRentPayer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventRentPayerAccount, true, true))
		// Account 1 "senderAuthorityPda": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(senderAuthorityPdaAccount, false, true))
		// Account 2 "messageTransmitter": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(messageTransmitterAccount, true, false))
		// Account 3 "messageSentEventData": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(messageSentEventDataAccount, true, true))
		// Account 4 "senderProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(senderProgramAccount, false, false))
		// Account 5 "systemProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "sendMessageWithCaller" instruction.
func NewSendMessageWithCallerInstruction(
	// Params:
	paramsParam SendMessageWithCallerParams,

	// Accounts:
	eventRentPayerAccount solanago.PublicKey,
	senderAuthorityPdaAccount solanago.PublicKey,
	messageTransmitterAccount solanago.PublicKey,
	messageSentEventDataAccount solanago.PublicKey,
	senderProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SendMessageWithCaller[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "eventRentPayer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventRentPayerAccount, true, true))
		// Account 1 "senderAuthorityPda": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(senderAuthorityPdaAccount, false, true))
		// Account 2 "messageTransmitter": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(messageTransmitterAccount, true, false))
		// Account 3 "messageSentEventData": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(messageSentEventDataAccount, true, true))
		// Account 4 "senderProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(senderProgramAccount, false, false))
		// Account 5 "systemProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "replaceMessage" instruction.
func NewReplaceMessageInstruction(
	// Params:
	paramsParam ReplaceMessageParams,

	// Accounts:
	eventRentPayerAccount solanago.PublicKey,
	senderAuthorityPdaAccount solanago.PublicKey,
	messageTransmitterAccount solanago.PublicKey,
	messageSentEventDataAccount solanago.PublicKey,
	senderProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ReplaceMessage[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "eventRentPayer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventRentPayerAccount, true, true))
		// Account 1 "senderAuthorityPda": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(senderAuthorityPdaAccount, false, true))
		// Account 2 "messageTransmitter": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(messageTransmitterAccount, true, false))
		// Account 3 "messageSentEventData": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(messageSentEventDataAccount, true, true))
		// Account 4 "senderProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(senderProgramAccount, false, false))
		// Account 5 "systemProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "receiveMessage" instruction.
func NewReceiveMessageInstruction(
	// Params:
	paramsParam ReceiveMessageParams,

	// Accounts:
	payerAccount solanago.PublicKey,
	callerAccount solanago.PublicKey,
	authorityPdaAccount solanago.PublicKey,
	messageTransmitterAccount solanago.PublicKey,
	usedNoncesAccount solanago.PublicKey,
	receiverAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	eventAuthorityAccount solanago.PublicKey,
	programAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ReceiveMessage[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "payer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 1 "caller": Read-only, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(callerAccount, false, true))
		// Account 2 "authorityPda": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityPdaAccount, false, false))
		// Account 3 "messageTransmitter": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(messageTransmitterAccount, false, false))
		// Account 4 "usedNonces": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(usedNoncesAccount, true, false))
		// Account 5 "receiver": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(receiverAccount, false, false))
		// Account 6 "systemProgram": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 7 "eventAuthority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(eventAuthorityAccount, false, false))
		// Account 8 "program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(programAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "reclaimEventAccount" instruction.
func NewReclaimEventAccountInstruction(
	// Params:
	paramsParam ReclaimEventAccountParams,

	// Accounts:
	payeeAccount solanago.PublicKey,
	messageTransmitterAccount solanago.PublicKey,
	messageSentEventDataAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_ReclaimEventAccount[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "payee": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(payeeAccount, true, true))
		// Account 1 "messageTransmitter": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(messageTransmitterAccount, true, false))
		// Account 2 "messageSentEventData": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(messageSentEventDataAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "getNoncePda" instruction.
func NewGetNoncePdaInstruction(
	// Params:
	paramsParam GetNoncePdaParams,

	// Accounts:
	messageTransmitterAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_GetNoncePda[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "messageTransmitter": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(messageTransmitterAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "isNonceUsed" instruction.
func NewIsNonceUsedInstruction(
	// Params:
	paramsParam IsNonceUsedParams,

	// Accounts:
	usedNoncesAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_IsNonceUsed[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramsParam`:
		err = enc__.Encode(paramsParam)
		if err != nil {
			return nil, errors.NewField("paramsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "usedNonces": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(usedNoncesAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

type InitializeInstruction struct {
	Params InitializeParams `json:"params"`

	// Accounts:
	Payer                         solanago.PublicKey `json:"payer"`
	PayerWritable                 bool               `json:"payer_writable"`
	PayerSigner                   bool               `json:"payer_signer"`
	UpgradeAuthority              solanago.PublicKey `json:"upgradeAuthority"`
	UpgradeAuthoritySigner        bool               `json:"upgradeAuthority_signer"`
	MessageTransmitter            solanago.PublicKey `json:"messageTransmitter"`
	MessageTransmitterWritable    bool               `json:"messageTransmitter_writable"`
	MessageTransmitterProgramData solanago.PublicKey `json:"messageTransmitterProgramData"`
	MessageTransmitterProgram     solanago.PublicKey `json:"messageTransmitterProgram"`
	SystemProgram                 solanago.PublicKey `json:"systemProgram"`
	EventAuthority                solanago.PublicKey `json:"eventAuthority"`
	Program                       solanago.PublicKey `json:"program"`
}

func (obj *InitializeInstruction) GetDiscriminator() []byte {
	return Instruction_Initialize[:]
}

// UnmarshalWithDecoder unmarshals the InitializeInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *InitializeInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "InitializeInstruction", err)
	}
	if discriminator != Instruction_Initialize {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "InitializeInstruction", Instruction_Initialize, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *InitializeInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from payer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "payer", err)
	}
	indices = append(indices, index)
	// Decode from upgradeAuthority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "upgradeAuthority", err)
	}
	indices = append(indices, index)
	// Decode from messageTransmitter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "messageTransmitter", err)
	}
	indices = append(indices, index)
	// Decode from messageTransmitterProgramData account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "messageTransmitterProgramData", err)
	}
	indices = append(indices, index)
	// Decode from messageTransmitterProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "messageTransmitterProgram", err)
	}
	indices = append(indices, index)
	// Decode from systemProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "systemProgram", err)
	}
	indices = append(indices, index)
	// Decode from eventAuthority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventAuthority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *InitializeInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 8 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 8, len(indices))
	}
	indexOffset := 0
	// Set payer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "payer", len(accountKeys)-1)
	}
	obj.Payer = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set upgradeAuthority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "upgradeAuthority", len(accountKeys)-1)
	}
	obj.UpgradeAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set messageTransmitter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "messageTransmitter", len(accountKeys)-1)
	}
	obj.MessageTransmitter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set messageTransmitterProgramData account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "messageTransmitterProgramData", len(accountKeys)-1)
	}
	obj.MessageTransmitterProgramData = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set messageTransmitterProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "messageTransmitterProgram", len(accountKeys)-1)
	}
	obj.MessageTransmitterProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set systemProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "systemProgram", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set eventAuthority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventAuthority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *InitializeInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Payer)
	keys = append(keys, obj.UpgradeAuthority)
	keys = append(keys, obj.MessageTransmitter)
	keys = append(keys, obj.MessageTransmitterProgramData)
	keys = append(keys, obj.MessageTransmitterProgram)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

// Unmarshal unmarshals the InitializeInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *InitializeInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitializeInstruction: %w", err)
	}
	return nil
}

// UnmarshalInitializeInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalInitializeInstruction(buf []byte) (*InitializeInstruction, error) {
	obj := new(InitializeInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type TransferOwnershipInstruction struct {
	Params TransferOwnershipParams `json:"params"`

	// Accounts:
	Owner                      solanago.PublicKey `json:"owner"`
	OwnerSigner                bool               `json:"owner_signer"`
	MessageTransmitter         solanago.PublicKey `json:"messageTransmitter"`
	MessageTransmitterWritable bool               `json:"messageTransmitter_writable"`
	EventAuthority             solanago.PublicKey `json:"eventAuthority"`
	Program                    solanago.PublicKey `json:"program"`
}

func (obj *TransferOwnershipInstruction) GetDiscriminator() []byte {
	return Instruction_TransferOwnership[:]
}

// UnmarshalWithDecoder unmarshals the TransferOwnershipInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *TransferOwnershipInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "TransferOwnershipInstruction", err)
	}
	if discriminator != Instruction_TransferOwnership {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "TransferOwnershipInstruction", Instruction_TransferOwnership, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *TransferOwnershipInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from owner account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "owner", err)
	}
	indices = append(indices, index)
	// Decode from messageTransmitter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "messageTransmitter", err)
	}
	indices = append(indices, index)
	// Decode from eventAuthority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventAuthority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *TransferOwnershipInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set owner account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "owner", len(accountKeys)-1)
	}
	obj.Owner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set messageTransmitter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "messageTransmitter", len(accountKeys)-1)
	}
	obj.MessageTransmitter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set eventAuthority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventAuthority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *TransferOwnershipInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Owner)
	keys = append(keys, obj.MessageTransmitter)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

// Unmarshal unmarshals the TransferOwnershipInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *TransferOwnershipInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling TransferOwnershipInstruction: %w", err)
	}
	return nil
}

// UnmarshalTransferOwnershipInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalTransferOwnershipInstruction(buf []byte) (*TransferOwnershipInstruction, error) {
	obj := new(TransferOwnershipInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type AcceptOwnershipInstruction struct {
	Params AcceptOwnershipParams `json:"params"`

	// Accounts:
	PendingOwner               solanago.PublicKey `json:"pendingOwner"`
	PendingOwnerSigner         bool               `json:"pendingOwner_signer"`
	MessageTransmitter         solanago.PublicKey `json:"messageTransmitter"`
	MessageTransmitterWritable bool               `json:"messageTransmitter_writable"`
	EventAuthority             solanago.PublicKey `json:"eventAuthority"`
	Program                    solanago.PublicKey `json:"program"`
}

func (obj *AcceptOwnershipInstruction) GetDiscriminator() []byte {
	return Instruction_AcceptOwnership[:]
}

// UnmarshalWithDecoder unmarshals the AcceptOwnershipInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *AcceptOwnershipInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "AcceptOwnershipInstruction", err)
	}
	if discriminator != Instruction_AcceptOwnership {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "AcceptOwnershipInstruction", Instruction_AcceptOwnership, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AcceptOwnershipInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from pendingOwner account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "pendingOwner", err)
	}
	indices = append(indices, index)
	// Decode from messageTransmitter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "messageTransmitter", err)
	}
	indices = append(indices, index)
	// Decode from eventAuthority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventAuthority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *AcceptOwnershipInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set pendingOwner account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "pendingOwner", len(accountKeys)-1)
	}
	obj.PendingOwner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set messageTransmitter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "messageTransmitter", len(accountKeys)-1)
	}
	obj.MessageTransmitter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set eventAuthority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventAuthority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *AcceptOwnershipInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.PendingOwner)
	keys = append(keys, obj.MessageTransmitter)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

// Unmarshal unmarshals the AcceptOwnershipInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *AcceptOwnershipInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AcceptOwnershipInstruction: %w", err)
	}
	return nil
}

// UnmarshalAcceptOwnershipInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalAcceptOwnershipInstruction(buf []byte) (*AcceptOwnershipInstruction, error) {
	obj := new(AcceptOwnershipInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UpdatePauserInstruction struct {
	Params UpdatePauserParams `json:"params"`

	// Accounts:
	Owner                      solanago.PublicKey `json:"owner"`
	OwnerSigner                bool               `json:"owner_signer"`
	MessageTransmitter         solanago.PublicKey `json:"messageTransmitter"`
	MessageTransmitterWritable bool               `json:"messageTransmitter_writable"`
	EventAuthority             solanago.PublicKey `json:"eventAuthority"`
	Program                    solanago.PublicKey `json:"program"`
}

func (obj *UpdatePauserInstruction) GetDiscriminator() []byte {
	return Instruction_UpdatePauser[:]
}

// UnmarshalWithDecoder unmarshals the UpdatePauserInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *UpdatePauserInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "UpdatePauserInstruction", err)
	}
	if discriminator != Instruction_UpdatePauser {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "UpdatePauserInstruction", Instruction_UpdatePauser, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UpdatePauserInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from owner account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "owner", err)
	}
	indices = append(indices, index)
	// Decode from messageTransmitter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "messageTransmitter", err)
	}
	indices = append(indices, index)
	// Decode from eventAuthority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventAuthority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *UpdatePauserInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set owner account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "owner", len(accountKeys)-1)
	}
	obj.Owner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set messageTransmitter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "messageTransmitter", len(accountKeys)-1)
	}
	obj.MessageTransmitter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set eventAuthority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventAuthority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *UpdatePauserInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Owner)
	keys = append(keys, obj.MessageTransmitter)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

// Unmarshal unmarshals the UpdatePauserInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *UpdatePauserInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdatePauserInstruction: %w", err)
	}
	return nil
}

// UnmarshalUpdatePauserInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalUpdatePauserInstruction(buf []byte) (*UpdatePauserInstruction, error) {
	obj := new(UpdatePauserInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UpdateAttesterManagerInstruction struct {
	Params UpdateAttesterManagerParams `json:"params"`

	// Accounts:
	Owner                      solanago.PublicKey `json:"owner"`
	OwnerSigner                bool               `json:"owner_signer"`
	MessageTransmitter         solanago.PublicKey `json:"messageTransmitter"`
	MessageTransmitterWritable bool               `json:"messageTransmitter_writable"`
	EventAuthority             solanago.PublicKey `json:"eventAuthority"`
	Program                    solanago.PublicKey `json:"program"`
}

func (obj *UpdateAttesterManagerInstruction) GetDiscriminator() []byte {
	return Instruction_UpdateAttesterManager[:]
}

// UnmarshalWithDecoder unmarshals the UpdateAttesterManagerInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *UpdateAttesterManagerInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "UpdateAttesterManagerInstruction", err)
	}
	if discriminator != Instruction_UpdateAttesterManager {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "UpdateAttesterManagerInstruction", Instruction_UpdateAttesterManager, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UpdateAttesterManagerInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from owner account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "owner", err)
	}
	indices = append(indices, index)
	// Decode from messageTransmitter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "messageTransmitter", err)
	}
	indices = append(indices, index)
	// Decode from eventAuthority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventAuthority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *UpdateAttesterManagerInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set owner account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "owner", len(accountKeys)-1)
	}
	obj.Owner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set messageTransmitter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "messageTransmitter", len(accountKeys)-1)
	}
	obj.MessageTransmitter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set eventAuthority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventAuthority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *UpdateAttesterManagerInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Owner)
	keys = append(keys, obj.MessageTransmitter)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

// Unmarshal unmarshals the UpdateAttesterManagerInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *UpdateAttesterManagerInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdateAttesterManagerInstruction: %w", err)
	}
	return nil
}

// UnmarshalUpdateAttesterManagerInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalUpdateAttesterManagerInstruction(buf []byte) (*UpdateAttesterManagerInstruction, error) {
	obj := new(UpdateAttesterManagerInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type PauseInstruction struct {
	Params PauseParams `json:"params"`

	// Accounts:
	Pauser                     solanago.PublicKey `json:"pauser"`
	PauserSigner               bool               `json:"pauser_signer"`
	MessageTransmitter         solanago.PublicKey `json:"messageTransmitter"`
	MessageTransmitterWritable bool               `json:"messageTransmitter_writable"`
	EventAuthority             solanago.PublicKey `json:"eventAuthority"`
	Program                    solanago.PublicKey `json:"program"`
}

func (obj *PauseInstruction) GetDiscriminator() []byte {
	return Instruction_Pause[:]
}

// UnmarshalWithDecoder unmarshals the PauseInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *PauseInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "PauseInstruction", err)
	}
	if discriminator != Instruction_Pause {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "PauseInstruction", Instruction_Pause, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *PauseInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from pauser account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "pauser", err)
	}
	indices = append(indices, index)
	// Decode from messageTransmitter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "messageTransmitter", err)
	}
	indices = append(indices, index)
	// Decode from eventAuthority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventAuthority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *PauseInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set pauser account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "pauser", len(accountKeys)-1)
	}
	obj.Pauser = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set messageTransmitter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "messageTransmitter", len(accountKeys)-1)
	}
	obj.MessageTransmitter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set eventAuthority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventAuthority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *PauseInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Pauser)
	keys = append(keys, obj.MessageTransmitter)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

// Unmarshal unmarshals the PauseInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *PauseInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling PauseInstruction: %w", err)
	}
	return nil
}

// UnmarshalPauseInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalPauseInstruction(buf []byte) (*PauseInstruction, error) {
	obj := new(PauseInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UnpauseInstruction struct {
	Params UnpauseParams `json:"params"`

	// Accounts:
	Pauser                     solanago.PublicKey `json:"pauser"`
	PauserSigner               bool               `json:"pauser_signer"`
	MessageTransmitter         solanago.PublicKey `json:"messageTransmitter"`
	MessageTransmitterWritable bool               `json:"messageTransmitter_writable"`
	EventAuthority             solanago.PublicKey `json:"eventAuthority"`
	Program                    solanago.PublicKey `json:"program"`
}

func (obj *UnpauseInstruction) GetDiscriminator() []byte {
	return Instruction_Unpause[:]
}

// UnmarshalWithDecoder unmarshals the UnpauseInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *UnpauseInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "UnpauseInstruction", err)
	}
	if discriminator != Instruction_Unpause {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "UnpauseInstruction", Instruction_Unpause, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *UnpauseInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from pauser account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "pauser", err)
	}
	indices = append(indices, index)
	// Decode from messageTransmitter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "messageTransmitter", err)
	}
	indices = append(indices, index)
	// Decode from eventAuthority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventAuthority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *UnpauseInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set pauser account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "pauser", len(accountKeys)-1)
	}
	obj.Pauser = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set messageTransmitter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "messageTransmitter", len(accountKeys)-1)
	}
	obj.MessageTransmitter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set eventAuthority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventAuthority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *UnpauseInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Pauser)
	keys = append(keys, obj.MessageTransmitter)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

// Unmarshal unmarshals the UnpauseInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *UnpauseInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UnpauseInstruction: %w", err)
	}
	return nil
}

// UnmarshalUnpauseInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalUnpauseInstruction(buf []byte) (*UnpauseInstruction, error) {
	obj := new(UnpauseInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SetMaxMessageBodySizeInstruction struct {
	Params SetMaxMessageBodySizeParams `json:"params"`

	// Accounts:
	Owner                      solanago.PublicKey `json:"owner"`
	OwnerSigner                bool               `json:"owner_signer"`
	MessageTransmitter         solanago.PublicKey `json:"messageTransmitter"`
	MessageTransmitterWritable bool               `json:"messageTransmitter_writable"`
	EventAuthority             solanago.PublicKey `json:"eventAuthority"`
	Program                    solanago.PublicKey `json:"program"`
}

func (obj *SetMaxMessageBodySizeInstruction) GetDiscriminator() []byte {
	return Instruction_SetMaxMessageBodySize[:]
}

// UnmarshalWithDecoder unmarshals the SetMaxMessageBodySizeInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *SetMaxMessageBodySizeInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "SetMaxMessageBodySizeInstruction", err)
	}
	if discriminator != Instruction_SetMaxMessageBodySize {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "SetMaxMessageBodySizeInstruction", Instruction_SetMaxMessageBodySize, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SetMaxMessageBodySizeInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from owner account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "owner", err)
	}
	indices = append(indices, index)
	// Decode from messageTransmitter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "messageTransmitter", err)
	}
	indices = append(indices, index)
	// Decode from eventAuthority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventAuthority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SetMaxMessageBodySizeInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set owner account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "owner", len(accountKeys)-1)
	}
	obj.Owner = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set messageTransmitter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "messageTransmitter", len(accountKeys)-1)
	}
	obj.MessageTransmitter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set eventAuthority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventAuthority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SetMaxMessageBodySizeInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Owner)
	keys = append(keys, obj.MessageTransmitter)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

// Unmarshal unmarshals the SetMaxMessageBodySizeInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *SetMaxMessageBodySizeInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SetMaxMessageBodySizeInstruction: %w", err)
	}
	return nil
}

// UnmarshalSetMaxMessageBodySizeInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalSetMaxMessageBodySizeInstruction(buf []byte) (*SetMaxMessageBodySizeInstruction, error) {
	obj := new(SetMaxMessageBodySizeInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type EnableAttesterInstruction struct {
	Params EnableAttesterParams `json:"params"`

	// Accounts:
	Payer                      solanago.PublicKey `json:"payer"`
	PayerWritable              bool               `json:"payer_writable"`
	PayerSigner                bool               `json:"payer_signer"`
	AttesterManager            solanago.PublicKey `json:"attesterManager"`
	AttesterManagerSigner      bool               `json:"attesterManager_signer"`
	MessageTransmitter         solanago.PublicKey `json:"messageTransmitter"`
	MessageTransmitterWritable bool               `json:"messageTransmitter_writable"`
	SystemProgram              solanago.PublicKey `json:"systemProgram"`
	EventAuthority             solanago.PublicKey `json:"eventAuthority"`
	Program                    solanago.PublicKey `json:"program"`
}

func (obj *EnableAttesterInstruction) GetDiscriminator() []byte {
	return Instruction_EnableAttester[:]
}

// UnmarshalWithDecoder unmarshals the EnableAttesterInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *EnableAttesterInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "EnableAttesterInstruction", err)
	}
	if discriminator != Instruction_EnableAttester {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "EnableAttesterInstruction", Instruction_EnableAttester, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *EnableAttesterInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from payer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "payer", err)
	}
	indices = append(indices, index)
	// Decode from attesterManager account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "attesterManager", err)
	}
	indices = append(indices, index)
	// Decode from messageTransmitter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "messageTransmitter", err)
	}
	indices = append(indices, index)
	// Decode from systemProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "systemProgram", err)
	}
	indices = append(indices, index)
	// Decode from eventAuthority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventAuthority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *EnableAttesterInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 6 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 6, len(indices))
	}
	indexOffset := 0
	// Set payer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "payer", len(accountKeys)-1)
	}
	obj.Payer = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set attesterManager account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "attesterManager", len(accountKeys)-1)
	}
	obj.AttesterManager = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set messageTransmitter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "messageTransmitter", len(accountKeys)-1)
	}
	obj.MessageTransmitter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set systemProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "systemProgram", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set eventAuthority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventAuthority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *EnableAttesterInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Payer)
	keys = append(keys, obj.AttesterManager)
	keys = append(keys, obj.MessageTransmitter)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

// Unmarshal unmarshals the EnableAttesterInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *EnableAttesterInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling EnableAttesterInstruction: %w", err)
	}
	return nil
}

// UnmarshalEnableAttesterInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalEnableAttesterInstruction(buf []byte) (*EnableAttesterInstruction, error) {
	obj := new(EnableAttesterInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type DisableAttesterInstruction struct {
	Params DisableAttesterParams `json:"params"`

	// Accounts:
	Payer                      solanago.PublicKey `json:"payer"`
	PayerWritable              bool               `json:"payer_writable"`
	PayerSigner                bool               `json:"payer_signer"`
	AttesterManager            solanago.PublicKey `json:"attesterManager"`
	AttesterManagerSigner      bool               `json:"attesterManager_signer"`
	MessageTransmitter         solanago.PublicKey `json:"messageTransmitter"`
	MessageTransmitterWritable bool               `json:"messageTransmitter_writable"`
	SystemProgram              solanago.PublicKey `json:"systemProgram"`
	EventAuthority             solanago.PublicKey `json:"eventAuthority"`
	Program                    solanago.PublicKey `json:"program"`
}

func (obj *DisableAttesterInstruction) GetDiscriminator() []byte {
	return Instruction_DisableAttester[:]
}

// UnmarshalWithDecoder unmarshals the DisableAttesterInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *DisableAttesterInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "DisableAttesterInstruction", err)
	}
	if discriminator != Instruction_DisableAttester {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "DisableAttesterInstruction", Instruction_DisableAttester, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *DisableAttesterInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from payer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "payer", err)
	}
	indices = append(indices, index)
	// Decode from attesterManager account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "attesterManager", err)
	}
	indices = append(indices, index)
	// Decode from messageTransmitter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "messageTransmitter", err)
	}
	indices = append(indices, index)
	// Decode from systemProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "systemProgram", err)
	}
	indices = append(indices, index)
	// Decode from eventAuthority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventAuthority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *DisableAttesterInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 6 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 6, len(indices))
	}
	indexOffset := 0
	// Set payer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "payer", len(accountKeys)-1)
	}
	obj.Payer = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set attesterManager account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "attesterManager", len(accountKeys)-1)
	}
	obj.AttesterManager = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set messageTransmitter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "messageTransmitter", len(accountKeys)-1)
	}
	obj.MessageTransmitter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set systemProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "systemProgram", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set eventAuthority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventAuthority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *DisableAttesterInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Payer)
	keys = append(keys, obj.AttesterManager)
	keys = append(keys, obj.MessageTransmitter)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

// Unmarshal unmarshals the DisableAttesterInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *DisableAttesterInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling DisableAttesterInstruction: %w", err)
	}
	return nil
}

// UnmarshalDisableAttesterInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalDisableAttesterInstruction(buf []byte) (*DisableAttesterInstruction, error) {
	obj := new(DisableAttesterInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SetSignatureThresholdInstruction struct {
	Params SetSignatureThresholdParams `json:"params"`

	// Accounts:
	AttesterManager            solanago.PublicKey `json:"attesterManager"`
	AttesterManagerSigner      bool               `json:"attesterManager_signer"`
	MessageTransmitter         solanago.PublicKey `json:"messageTransmitter"`
	MessageTransmitterWritable bool               `json:"messageTransmitter_writable"`
	EventAuthority             solanago.PublicKey `json:"eventAuthority"`
	Program                    solanago.PublicKey `json:"program"`
}

func (obj *SetSignatureThresholdInstruction) GetDiscriminator() []byte {
	return Instruction_SetSignatureThreshold[:]
}

// UnmarshalWithDecoder unmarshals the SetSignatureThresholdInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *SetSignatureThresholdInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "SetSignatureThresholdInstruction", err)
	}
	if discriminator != Instruction_SetSignatureThreshold {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "SetSignatureThresholdInstruction", Instruction_SetSignatureThreshold, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SetSignatureThresholdInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from attesterManager account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "attesterManager", err)
	}
	indices = append(indices, index)
	// Decode from messageTransmitter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "messageTransmitter", err)
	}
	indices = append(indices, index)
	// Decode from eventAuthority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventAuthority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SetSignatureThresholdInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 4 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 4, len(indices))
	}
	indexOffset := 0
	// Set attesterManager account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "attesterManager", len(accountKeys)-1)
	}
	obj.AttesterManager = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set messageTransmitter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "messageTransmitter", len(accountKeys)-1)
	}
	obj.MessageTransmitter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set eventAuthority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventAuthority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SetSignatureThresholdInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.AttesterManager)
	keys = append(keys, obj.MessageTransmitter)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

// Unmarshal unmarshals the SetSignatureThresholdInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *SetSignatureThresholdInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SetSignatureThresholdInstruction: %w", err)
	}
	return nil
}

// UnmarshalSetSignatureThresholdInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalSetSignatureThresholdInstruction(buf []byte) (*SetSignatureThresholdInstruction, error) {
	obj := new(SetSignatureThresholdInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SendMessageInstruction struct {
	Params SendMessageParams `json:"params"`

	// Accounts:
	EventRentPayer               solanago.PublicKey `json:"eventRentPayer"`
	EventRentPayerWritable       bool               `json:"eventRentPayer_writable"`
	EventRentPayerSigner         bool               `json:"eventRentPayer_signer"`
	SenderAuthorityPda           solanago.PublicKey `json:"senderAuthorityPda"`
	SenderAuthorityPdaSigner     bool               `json:"senderAuthorityPda_signer"`
	MessageTransmitter           solanago.PublicKey `json:"messageTransmitter"`
	MessageTransmitterWritable   bool               `json:"messageTransmitter_writable"`
	MessageSentEventData         solanago.PublicKey `json:"messageSentEventData"`
	MessageSentEventDataWritable bool               `json:"messageSentEventData_writable"`
	MessageSentEventDataSigner   bool               `json:"messageSentEventData_signer"`
	SenderProgram                solanago.PublicKey `json:"senderProgram"`
	SystemProgram                solanago.PublicKey `json:"systemProgram"`
}

func (obj *SendMessageInstruction) GetDiscriminator() []byte {
	return Instruction_SendMessage[:]
}

// UnmarshalWithDecoder unmarshals the SendMessageInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *SendMessageInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "SendMessageInstruction", err)
	}
	if discriminator != Instruction_SendMessage {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "SendMessageInstruction", Instruction_SendMessage, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SendMessageInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from eventRentPayer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventRentPayer", err)
	}
	indices = append(indices, index)
	// Decode from senderAuthorityPda account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "senderAuthorityPda", err)
	}
	indices = append(indices, index)
	// Decode from messageTransmitter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "messageTransmitter", err)
	}
	indices = append(indices, index)
	// Decode from messageSentEventData account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "messageSentEventData", err)
	}
	indices = append(indices, index)
	// Decode from senderProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "senderProgram", err)
	}
	indices = append(indices, index)
	// Decode from systemProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "systemProgram", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SendMessageInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 6 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 6, len(indices))
	}
	indexOffset := 0
	// Set eventRentPayer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventRentPayer", len(accountKeys)-1)
	}
	obj.EventRentPayer = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set senderAuthorityPda account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "senderAuthorityPda", len(accountKeys)-1)
	}
	obj.SenderAuthorityPda = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set messageTransmitter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "messageTransmitter", len(accountKeys)-1)
	}
	obj.MessageTransmitter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set messageSentEventData account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "messageSentEventData", len(accountKeys)-1)
	}
	obj.MessageSentEventData = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set senderProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "senderProgram", len(accountKeys)-1)
	}
	obj.SenderProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set systemProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "systemProgram", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SendMessageInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.EventRentPayer)
	keys = append(keys, obj.SenderAuthorityPda)
	keys = append(keys, obj.MessageTransmitter)
	keys = append(keys, obj.MessageSentEventData)
	keys = append(keys, obj.SenderProgram)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the SendMessageInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *SendMessageInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SendMessageInstruction: %w", err)
	}
	return nil
}

// UnmarshalSendMessageInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalSendMessageInstruction(buf []byte) (*SendMessageInstruction, error) {
	obj := new(SendMessageInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SendMessageWithCallerInstruction struct {
	Params SendMessageWithCallerParams `json:"params"`

	// Accounts:
	EventRentPayer               solanago.PublicKey `json:"eventRentPayer"`
	EventRentPayerWritable       bool               `json:"eventRentPayer_writable"`
	EventRentPayerSigner         bool               `json:"eventRentPayer_signer"`
	SenderAuthorityPda           solanago.PublicKey `json:"senderAuthorityPda"`
	SenderAuthorityPdaSigner     bool               `json:"senderAuthorityPda_signer"`
	MessageTransmitter           solanago.PublicKey `json:"messageTransmitter"`
	MessageTransmitterWritable   bool               `json:"messageTransmitter_writable"`
	MessageSentEventData         solanago.PublicKey `json:"messageSentEventData"`
	MessageSentEventDataWritable bool               `json:"messageSentEventData_writable"`
	MessageSentEventDataSigner   bool               `json:"messageSentEventData_signer"`
	SenderProgram                solanago.PublicKey `json:"senderProgram"`
	SystemProgram                solanago.PublicKey `json:"systemProgram"`
}

func (obj *SendMessageWithCallerInstruction) GetDiscriminator() []byte {
	return Instruction_SendMessageWithCaller[:]
}

// UnmarshalWithDecoder unmarshals the SendMessageWithCallerInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *SendMessageWithCallerInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "SendMessageWithCallerInstruction", err)
	}
	if discriminator != Instruction_SendMessageWithCaller {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "SendMessageWithCallerInstruction", Instruction_SendMessageWithCaller, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *SendMessageWithCallerInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from eventRentPayer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventRentPayer", err)
	}
	indices = append(indices, index)
	// Decode from senderAuthorityPda account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "senderAuthorityPda", err)
	}
	indices = append(indices, index)
	// Decode from messageTransmitter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "messageTransmitter", err)
	}
	indices = append(indices, index)
	// Decode from messageSentEventData account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "messageSentEventData", err)
	}
	indices = append(indices, index)
	// Decode from senderProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "senderProgram", err)
	}
	indices = append(indices, index)
	// Decode from systemProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "systemProgram", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *SendMessageWithCallerInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 6 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 6, len(indices))
	}
	indexOffset := 0
	// Set eventRentPayer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventRentPayer", len(accountKeys)-1)
	}
	obj.EventRentPayer = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set senderAuthorityPda account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "senderAuthorityPda", len(accountKeys)-1)
	}
	obj.SenderAuthorityPda = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set messageTransmitter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "messageTransmitter", len(accountKeys)-1)
	}
	obj.MessageTransmitter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set messageSentEventData account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "messageSentEventData", len(accountKeys)-1)
	}
	obj.MessageSentEventData = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set senderProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "senderProgram", len(accountKeys)-1)
	}
	obj.SenderProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set systemProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "systemProgram", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *SendMessageWithCallerInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.EventRentPayer)
	keys = append(keys, obj.SenderAuthorityPda)
	keys = append(keys, obj.MessageTransmitter)
	keys = append(keys, obj.MessageSentEventData)
	keys = append(keys, obj.SenderProgram)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the SendMessageWithCallerInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *SendMessageWithCallerInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SendMessageWithCallerInstruction: %w", err)
	}
	return nil
}

// UnmarshalSendMessageWithCallerInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalSendMessageWithCallerInstruction(buf []byte) (*SendMessageWithCallerInstruction, error) {
	obj := new(SendMessageWithCallerInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ReplaceMessageInstruction struct {
	Params ReplaceMessageParams `json:"params"`

	// Accounts:
	EventRentPayer               solanago.PublicKey `json:"eventRentPayer"`
	EventRentPayerWritable       bool               `json:"eventRentPayer_writable"`
	EventRentPayerSigner         bool               `json:"eventRentPayer_signer"`
	SenderAuthorityPda           solanago.PublicKey `json:"senderAuthorityPda"`
	SenderAuthorityPdaSigner     bool               `json:"senderAuthorityPda_signer"`
	MessageTransmitter           solanago.PublicKey `json:"messageTransmitter"`
	MessageTransmitterWritable   bool               `json:"messageTransmitter_writable"`
	MessageSentEventData         solanago.PublicKey `json:"messageSentEventData"`
	MessageSentEventDataWritable bool               `json:"messageSentEventData_writable"`
	MessageSentEventDataSigner   bool               `json:"messageSentEventData_signer"`
	SenderProgram                solanago.PublicKey `json:"senderProgram"`
	SystemProgram                solanago.PublicKey `json:"systemProgram"`
}

func (obj *ReplaceMessageInstruction) GetDiscriminator() []byte {
	return Instruction_ReplaceMessage[:]
}

// UnmarshalWithDecoder unmarshals the ReplaceMessageInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *ReplaceMessageInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "ReplaceMessageInstruction", err)
	}
	if discriminator != Instruction_ReplaceMessage {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "ReplaceMessageInstruction", Instruction_ReplaceMessage, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *ReplaceMessageInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from eventRentPayer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventRentPayer", err)
	}
	indices = append(indices, index)
	// Decode from senderAuthorityPda account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "senderAuthorityPda", err)
	}
	indices = append(indices, index)
	// Decode from messageTransmitter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "messageTransmitter", err)
	}
	indices = append(indices, index)
	// Decode from messageSentEventData account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "messageSentEventData", err)
	}
	indices = append(indices, index)
	// Decode from senderProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "senderProgram", err)
	}
	indices = append(indices, index)
	// Decode from systemProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "systemProgram", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *ReplaceMessageInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 6 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 6, len(indices))
	}
	indexOffset := 0
	// Set eventRentPayer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventRentPayer", len(accountKeys)-1)
	}
	obj.EventRentPayer = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set senderAuthorityPda account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "senderAuthorityPda", len(accountKeys)-1)
	}
	obj.SenderAuthorityPda = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set messageTransmitter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "messageTransmitter", len(accountKeys)-1)
	}
	obj.MessageTransmitter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set messageSentEventData account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "messageSentEventData", len(accountKeys)-1)
	}
	obj.MessageSentEventData = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set senderProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "senderProgram", len(accountKeys)-1)
	}
	obj.SenderProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set systemProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "systemProgram", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *ReplaceMessageInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.EventRentPayer)
	keys = append(keys, obj.SenderAuthorityPda)
	keys = append(keys, obj.MessageTransmitter)
	keys = append(keys, obj.MessageSentEventData)
	keys = append(keys, obj.SenderProgram)
	keys = append(keys, obj.SystemProgram)
	return keys
}

// Unmarshal unmarshals the ReplaceMessageInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *ReplaceMessageInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ReplaceMessageInstruction: %w", err)
	}
	return nil
}

// UnmarshalReplaceMessageInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalReplaceMessageInstruction(buf []byte) (*ReplaceMessageInstruction, error) {
	obj := new(ReplaceMessageInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ReceiveMessageInstruction struct {
	Params ReceiveMessageParams `json:"params"`

	// Accounts:
	Payer              solanago.PublicKey `json:"payer"`
	PayerWritable      bool               `json:"payer_writable"`
	PayerSigner        bool               `json:"payer_signer"`
	Caller             solanago.PublicKey `json:"caller"`
	CallerSigner       bool               `json:"caller_signer"`
	AuthorityPda       solanago.PublicKey `json:"authorityPda"`
	MessageTransmitter solanago.PublicKey `json:"messageTransmitter"`
	UsedNonces         solanago.PublicKey `json:"usedNonces"`
	UsedNoncesWritable bool               `json:"usedNonces_writable"`
	Receiver           solanago.PublicKey `json:"receiver"`
	SystemProgram      solanago.PublicKey `json:"systemProgram"`
	EventAuthority     solanago.PublicKey `json:"eventAuthority"`
	Program            solanago.PublicKey `json:"program"`
}

func (obj *ReceiveMessageInstruction) GetDiscriminator() []byte {
	return Instruction_ReceiveMessage[:]
}

// UnmarshalWithDecoder unmarshals the ReceiveMessageInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *ReceiveMessageInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "ReceiveMessageInstruction", err)
	}
	if discriminator != Instruction_ReceiveMessage {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "ReceiveMessageInstruction", Instruction_ReceiveMessage, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *ReceiveMessageInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from payer account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "payer", err)
	}
	indices = append(indices, index)
	// Decode from caller account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "caller", err)
	}
	indices = append(indices, index)
	// Decode from authorityPda account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "authorityPda", err)
	}
	indices = append(indices, index)
	// Decode from messageTransmitter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "messageTransmitter", err)
	}
	indices = append(indices, index)
	// Decode from usedNonces account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "usedNonces", err)
	}
	indices = append(indices, index)
	// Decode from receiver account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "receiver", err)
	}
	indices = append(indices, index)
	// Decode from systemProgram account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "systemProgram", err)
	}
	indices = append(indices, index)
	// Decode from eventAuthority account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "eventAuthority", err)
	}
	indices = append(indices, index)
	// Decode from program account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "program", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *ReceiveMessageInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 9 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 9, len(indices))
	}
	indexOffset := 0
	// Set payer account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "payer", len(accountKeys)-1)
	}
	obj.Payer = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set caller account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "caller", len(accountKeys)-1)
	}
	obj.Caller = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set authorityPda account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "authorityPda", len(accountKeys)-1)
	}
	obj.AuthorityPda = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set messageTransmitter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "messageTransmitter", len(accountKeys)-1)
	}
	obj.MessageTransmitter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set usedNonces account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "usedNonces", len(accountKeys)-1)
	}
	obj.UsedNonces = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set receiver account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "receiver", len(accountKeys)-1)
	}
	obj.Receiver = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set systemProgram account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "systemProgram", len(accountKeys)-1)
	}
	obj.SystemProgram = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set eventAuthority account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "eventAuthority", len(accountKeys)-1)
	}
	obj.EventAuthority = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set program account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "program", len(accountKeys)-1)
	}
	obj.Program = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *ReceiveMessageInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Payer)
	keys = append(keys, obj.Caller)
	keys = append(keys, obj.AuthorityPda)
	keys = append(keys, obj.MessageTransmitter)
	keys = append(keys, obj.UsedNonces)
	keys = append(keys, obj.Receiver)
	keys = append(keys, obj.SystemProgram)
	keys = append(keys, obj.EventAuthority)
	keys = append(keys, obj.Program)
	return keys
}

// Unmarshal unmarshals the ReceiveMessageInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *ReceiveMessageInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ReceiveMessageInstruction: %w", err)
	}
	return nil
}

// UnmarshalReceiveMessageInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalReceiveMessageInstruction(buf []byte) (*ReceiveMessageInstruction, error) {
	obj := new(ReceiveMessageInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ReclaimEventAccountInstruction struct {
	Params ReclaimEventAccountParams `json:"params"`

	// Accounts:
	Payee                        solanago.PublicKey `json:"payee"`
	PayeeWritable                bool               `json:"payee_writable"`
	PayeeSigner                  bool               `json:"payee_signer"`
	MessageTransmitter           solanago.PublicKey `json:"messageTransmitter"`
	MessageTransmitterWritable   bool               `json:"messageTransmitter_writable"`
	MessageSentEventData         solanago.PublicKey `json:"messageSentEventData"`
	MessageSentEventDataWritable bool               `json:"messageSentEventData_writable"`
}

func (obj *ReclaimEventAccountInstruction) GetDiscriminator() []byte {
	return Instruction_ReclaimEventAccount[:]
}

// UnmarshalWithDecoder unmarshals the ReclaimEventAccountInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *ReclaimEventAccountInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "ReclaimEventAccountInstruction", err)
	}
	if discriminator != Instruction_ReclaimEventAccount {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "ReclaimEventAccountInstruction", Instruction_ReclaimEventAccount, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *ReclaimEventAccountInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from payee account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "payee", err)
	}
	indices = append(indices, index)
	// Decode from messageTransmitter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "messageTransmitter", err)
	}
	indices = append(indices, index)
	// Decode from messageSentEventData account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "messageSentEventData", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *ReclaimEventAccountInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 3 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 3, len(indices))
	}
	indexOffset := 0
	// Set payee account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "payee", len(accountKeys)-1)
	}
	obj.Payee = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set messageTransmitter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "messageTransmitter", len(accountKeys)-1)
	}
	obj.MessageTransmitter = accountKeys[indices[indexOffset]]
	indexOffset++
	// Set messageSentEventData account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "messageSentEventData", len(accountKeys)-1)
	}
	obj.MessageSentEventData = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *ReclaimEventAccountInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.Payee)
	keys = append(keys, obj.MessageTransmitter)
	keys = append(keys, obj.MessageSentEventData)
	return keys
}

// Unmarshal unmarshals the ReclaimEventAccountInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *ReclaimEventAccountInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ReclaimEventAccountInstruction: %w", err)
	}
	return nil
}

// UnmarshalReclaimEventAccountInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalReclaimEventAccountInstruction(buf []byte) (*ReclaimEventAccountInstruction, error) {
	obj := new(ReclaimEventAccountInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type GetNoncePdaInstruction struct {
	Params GetNoncePdaParams `json:"params"`

	// Accounts:
	MessageTransmitter solanago.PublicKey `json:"messageTransmitter"`
}

func (obj *GetNoncePdaInstruction) GetDiscriminator() []byte {
	return Instruction_GetNoncePda[:]
}

// UnmarshalWithDecoder unmarshals the GetNoncePdaInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *GetNoncePdaInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "GetNoncePdaInstruction", err)
	}
	if discriminator != Instruction_GetNoncePda {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "GetNoncePdaInstruction", Instruction_GetNoncePda, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *GetNoncePdaInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from messageTransmitter account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "messageTransmitter", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *GetNoncePdaInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 1 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 1, len(indices))
	}
	indexOffset := 0
	// Set messageTransmitter account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "messageTransmitter", len(accountKeys)-1)
	}
	obj.MessageTransmitter = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *GetNoncePdaInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.MessageTransmitter)
	return keys
}

// Unmarshal unmarshals the GetNoncePdaInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *GetNoncePdaInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling GetNoncePdaInstruction: %w", err)
	}
	return nil
}

// UnmarshalGetNoncePdaInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalGetNoncePdaInstruction(buf []byte) (*GetNoncePdaInstruction, error) {
	obj := new(GetNoncePdaInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type IsNonceUsedInstruction struct {
	Params IsNonceUsedParams `json:"params"`

	// Accounts:
	UsedNonces solanago.PublicKey `json:"usedNonces"`
}

func (obj *IsNonceUsedInstruction) GetDiscriminator() []byte {
	return Instruction_IsNonceUsed[:]
}

// UnmarshalWithDecoder unmarshals the IsNonceUsedInstruction from Borsh-encoded bytes prefixed with its discriminator.
func (obj *IsNonceUsedInstruction) UnmarshalWithDecoder(decoder *binary.Decoder) error {
	var err error
	// Read the discriminator and check it against the expected value:
	discriminator, err := decoder.ReadDiscriminator()
	if err != nil {
		return fmt.Errorf("failed to read instruction discriminator for %s: %w", "IsNonceUsedInstruction", err)
	}
	if discriminator != Instruction_IsNonceUsed {
		return fmt.Errorf("instruction discriminator mismatch for %s: expected %s, got %s", "IsNonceUsedInstruction", Instruction_IsNonceUsed, discriminator)
	}
	// Deserialize `Params`:
	err = decoder.Decode(&obj.Params)
	if err != nil {
		return err
	}
	return nil
}

func (obj *IsNonceUsedInstruction) UnmarshalAccountIndices(buf []byte) ([]uint8, error) {
	// UnmarshalAccountIndices decodes account indices from Borsh-encoded bytes
	decoder := binary.NewBorshDecoder(buf)
	indices := make([]uint8, 0)
	index := uint8(0)
	var err error
	// Decode from usedNonces account index
	index = uint8(0)
	err = decoder.Decode(&index)
	if err != nil {
		return nil, fmt.Errorf("failed to decode %s account index: %w", "usedNonces", err)
	}
	indices = append(indices, index)
	return indices, nil
}

func (obj *IsNonceUsedInstruction) PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error {
	// PopulateFromAccountIndices sets account public keys from indices and account keys array
	if len(indices) != 1 {
		return fmt.Errorf("mismatch between expected accounts (%d) and provided indices (%d)", 1, len(indices))
	}
	indexOffset := 0
	// Set usedNonces account from index
	if indices[indexOffset] >= uint8(len(accountKeys)) {
		return fmt.Errorf("account index %d for %s is out of bounds (max: %d)", indices[indexOffset], "usedNonces", len(accountKeys)-1)
	}
	obj.UsedNonces = accountKeys[indices[indexOffset]]
	indexOffset++
	return nil
}

func (obj *IsNonceUsedInstruction) GetAccountKeys() []solanago.PublicKey {
	keys := make([]solanago.PublicKey, 0)
	keys = append(keys, obj.UsedNonces)
	return keys
}

// Unmarshal unmarshals the IsNonceUsedInstruction from Borsh-encoded bytes prefixed with the discriminator.
func (obj *IsNonceUsedInstruction) Unmarshal(buf []byte) error {
	var err error
	err = obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling IsNonceUsedInstruction: %w", err)
	}
	return nil
}

// UnmarshalIsNonceUsedInstruction unmarshals the instruction from Borsh-encoded bytes prefixed with the discriminator.
func UnmarshalIsNonceUsedInstruction(buf []byte) (*IsNonceUsedInstruction, error) {
	obj := new(IsNonceUsedInstruction)
	var err error
	err = obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Instruction interface defines common methods for all instruction types
type Instruction interface {
	GetDiscriminator() []byte

	UnmarshalWithDecoder(decoder *binary.Decoder) error

	UnmarshalAccountIndices(buf []byte) ([]uint8, error)

	PopulateFromAccountIndices(indices []uint8, accountKeys []solanago.PublicKey) error

	GetAccountKeys() []solanago.PublicKey
}

// ParseInstruction parses instruction data and optionally populates accounts
// If accountIndicesData is nil or empty, accounts will not be populated
func ParseInstruction(instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (Instruction, error) {
	// Validate inputs
	if len(instructionData) < 8 {
		return nil, fmt.Errorf("instruction data too short: expected at least 8 bytes, got %d", len(instructionData))
	}
	// Extract discriminator
	discriminator := [8]byte{}
	copy(discriminator[:], instructionData[0:8])
	// Parse based on discriminator
	switch discriminator {
	case Instruction_Initialize:
		instruction := new(InitializeInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as InitializeInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_TransferOwnership:
		instruction := new(TransferOwnershipInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as TransferOwnershipInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_AcceptOwnership:
		instruction := new(AcceptOwnershipInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as AcceptOwnershipInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_UpdatePauser:
		instruction := new(UpdatePauserInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as UpdatePauserInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_UpdateAttesterManager:
		instruction := new(UpdateAttesterManagerInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as UpdateAttesterManagerInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_Pause:
		instruction := new(PauseInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as PauseInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_Unpause:
		instruction := new(UnpauseInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as UnpauseInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SetMaxMessageBodySize:
		instruction := new(SetMaxMessageBodySizeInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SetMaxMessageBodySizeInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_EnableAttester:
		instruction := new(EnableAttesterInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as EnableAttesterInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_DisableAttester:
		instruction := new(DisableAttesterInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as DisableAttesterInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SetSignatureThreshold:
		instruction := new(SetSignatureThresholdInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SetSignatureThresholdInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SendMessage:
		instruction := new(SendMessageInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SendMessageInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_SendMessageWithCaller:
		instruction := new(SendMessageWithCallerInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as SendMessageWithCallerInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_ReplaceMessage:
		instruction := new(ReplaceMessageInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as ReplaceMessageInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_ReceiveMessage:
		instruction := new(ReceiveMessageInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as ReceiveMessageInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_ReclaimEventAccount:
		instruction := new(ReclaimEventAccountInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as ReclaimEventAccountInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_GetNoncePda:
		instruction := new(GetNoncePdaInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as GetNoncePdaInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	case Instruction_IsNonceUsed:
		instruction := new(IsNonceUsedInstruction)
		decoder := binary.NewBorshDecoder(instructionData)
		err := instruction.UnmarshalWithDecoder(decoder)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal instruction as IsNonceUsedInstruction: %w", err)
		}
		if accountIndicesData != nil && len(accountIndicesData) > 0 {
			indices, err := instruction.UnmarshalAccountIndices(accountIndicesData)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal account indices: %w", err)
			}
			err = instruction.PopulateFromAccountIndices(indices, accountKeys)
			if err != nil {
				return nil, fmt.Errorf("failed to populate accounts: %w", err)
			}
		}
		return instruction, nil
	default:
		return nil, fmt.Errorf("unknown instruction discriminator: %s", binary.FormatDiscriminator(discriminator))
	}
}

// ParseInstructionTyped parses instruction data and returns a specific instruction type // T must implement the Instruction interface
func ParseInstructionTyped[T Instruction](instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (T, error) {
	instruction, err := ParseInstruction(instructionData, accountIndicesData, accountKeys)
	if err != nil {
		return *new(T), err
	}
	typed, ok := instruction.(T)
	if !ok {
		return *new(T), fmt.Errorf("instruction is not of expected type")
	}
	return typed, nil
}

// ParseInstructionWithoutAccounts parses instruction data without account information
func ParseInstructionWithoutAccounts(instructionData []byte) (Instruction, error) {
	return ParseInstruction(instructionData, nil, []solanago.PublicKey{})
}

// ParseInstructionWithAccounts parses instruction data with account information
func ParseInstructionWithAccounts(instructionData []byte, accountIndicesData []byte, accountKeys []solanago.PublicKey) (Instruction, error) {
	return ParseInstruction(instructionData, accountIndicesData, accountKeys)
}
