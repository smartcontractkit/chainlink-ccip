{
  "version": "0.1.1",
  "name": "ccip_offramp",
  "constants": [
    {
      "name": "MAX_ORACLES",
      "type": {
        "defined": "usize"
      },
      "value": "16"
    }
  ],
  "instructions": [
    {
      "name": "initialize",
      "docs": [
        "Initialization Flow //",
        "Initializes the CCIP Offramp, except for the config account (due to stack size limitations).",
        "",
        "The initialization of the Offramp is responsibility of Admin, nothing more than calling these",
        "initialization methods should be done first.",
        "",
        "# Arguments",
        "",
        "* `ctx` - The context containing the accounts required for initialization."
      ],
      "accounts": [
        {
          "name": "referenceAddresses",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "router",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "feeQuoter",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rmnRemote",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "offrampLookupTable",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "state",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "authority",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "programData",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": []
    },
    {
      "name": "initializeConfig",
      "docs": [
        "Initializes the CCIP Offramp Config account.",
        "",
        "The initialization of the Offramp is responsibility of Admin, nothing more than calling these",
        "initialization methods should be done first.",
        "",
        "# Arguments",
        "",
        "* `ctx` - The context containing the accounts required for initialization of the config.",
        "* `svm_chain_selector` - The chain selector for SVM.",
        "* `enable_execution_after` - The minimum amount of time required between a message has been committed and can be manually executed."
      ],
      "accounts": [
        {
          "name": "config",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "authority",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "program",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "programData",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "svmChainSelector",
          "type": "u64"
        },
        {
          "name": "enableExecutionAfter",
          "type": "i64"
        }
      ]
    },
    {
      "name": "typeVersion",
      "docs": [
        "Returns the program type (name) and version.",
        "Used by offchain code to easily determine which program & version is being interacted with.",
        "",
        "# Arguments",
        "* `ctx` - The context"
      ],
      "accounts": [
        {
          "name": "clock",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [],
      "returns": "string"
    },
    {
      "name": "transferOwnership",
      "docs": [
        "Transfers the ownership of the router to a new proposed owner.",
        "",
        "Shared func signature with other programs",
        "",
        "# Arguments",
        "",
        "* `ctx` - The context containing the accounts required for the transfer.",
        "* `proposed_owner` - The public key of the new proposed owner."
      ],
      "accounts": [
        {
          "name": "config",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "authority",
          "isMut": false,
          "isSigner": true
        }
      ],
      "args": [
        {
          "name": "proposedOwner",
          "type": "publicKey"
        }
      ]
    },
    {
      "name": "acceptOwnership",
      "docs": [
        "Accepts the ownership of the router by the proposed owner.",
        "",
        "Shared func signature with other programs",
        "",
        "# Arguments",
        "",
        "* `ctx` - The context containing the accounts required for accepting ownership.",
        "The new owner must be a signer of the transaction."
      ],
      "accounts": [
        {
          "name": "config",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "authority",
          "isMut": false,
          "isSigner": true
        }
      ],
      "args": []
    },
    {
      "name": "setDefaultCodeVersion",
      "docs": [
        "Sets the default code version to be used. This is then used by the slim routing layer to determine",
        "which version of the versioned business logic module (`instructions`) to use. Only the admin may set this.",
        "",
        "Shared func signature with other programs",
        "",
        "# Arguments",
        "",
        "* `ctx` - The context containing the accounts required for updating the configuration.",
        "* `code_version` - The new code version to be set as default."
      ],
      "accounts": [
        {
          "name": "config",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "authority",
          "isMut": false,
          "isSigner": true
        }
      ],
      "args": [
        {
          "name": "codeVersion",
          "type": {
            "defined": "CodeVersion"
          }
        }
      ]
    },
    {
      "name": "updateReferenceAddresses",
      "docs": [
        "Updates reference addresses in the offramp contract, such as",
        "the CCIP router, Fee Quoter, and the Offramp Lookup Table.",
        "Only the Admin may update these addresses.",
        "",
        "# Arguments",
        "",
        "* `ctx` - The context containing the accounts required for updating the reference addresses.",
        "* `router` - The router address to be set.",
        "* `fee_quoter` - The fee_quoter address to be set.",
        "* `offramp_lookup_table` - The offramp_lookup_table address to be set.",
        "* `rmn_remote` - The rmn_remote address to be set."
      ],
      "accounts": [
        {
          "name": "config",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "referenceAddresses",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "authority",
          "isMut": false,
          "isSigner": true
        }
      ],
      "args": [
        {
          "name": "router",
          "type": "publicKey"
        },
        {
          "name": "feeQuoter",
          "type": "publicKey"
        },
        {
          "name": "offrampLookupTable",
          "type": "publicKey"
        },
        {
          "name": "rmnRemote",
          "type": "publicKey"
        }
      ]
    },
    {
      "name": "addSourceChain",
      "docs": [
        "Adds a new source chain selector with its config to the offramp.",
        "",
        "The Admin needs to add any new chain supported.",
        "When adding a new chain, the Admin needs to specify if it's enabled or not.",
        "",
        "# Arguments"
      ],
      "accounts": [
        {
          "name": "sourceChain",
          "isMut": true,
          "isSigner": false,
          "docs": [
            "Adding a chain selector implies initializing the state for a new chain"
          ]
        },
        {
          "name": "config",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "authority",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "newChainSelector",
          "type": "u64"
        },
        {
          "name": "sourceChainConfig",
          "type": {
            "defined": "SourceChainConfig"
          }
        }
      ]
    },
    {
      "name": "disableSourceChainSelector",
      "docs": [
        "Disables the source chain selector.",
        "",
        "The Admin is the only one able to disable the chain selector as source. This method is thought of as an emergency kill-switch.",
        "",
        "# Arguments",
        "",
        "* `ctx` - The context containing the accounts required for disabling the chain selector.",
        "* `source_chain_selector` - The source chain selector to be disabled."
      ],
      "accounts": [
        {
          "name": "sourceChain",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "config",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "authority",
          "isMut": true,
          "isSigner": true
        }
      ],
      "args": [
        {
          "name": "sourceChainSelector",
          "type": "u64"
        }
      ]
    },
    {
      "name": "updateSourceChainConfig",
      "docs": [
        "Updates the configuration of the source chain selector.",
        "",
        "The Admin is the only one able to update the source chain config.",
        "",
        "# Arguments",
        "",
        "* `ctx` - The context containing the accounts required for updating the chain selector.",
        "* `source_chain_selector` - The source chain selector to be updated.",
        "* `source_chain_config` - The new configuration for the source chain."
      ],
      "accounts": [
        {
          "name": "sourceChain",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "config",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "authority",
          "isMut": true,
          "isSigner": true
        }
      ],
      "args": [
        {
          "name": "sourceChainSelector",
          "type": "u64"
        },
        {
          "name": "sourceChainConfig",
          "type": {
            "defined": "SourceChainConfig"
          }
        }
      ]
    },
    {
      "name": "updateSvmChainSelector",
      "docs": [
        "Updates the SVM chain selector in the offramp configuration.",
        "",
        "This method should only be used if there was an error with the initial configuration or if the solana chain selector changes.",
        "",
        "# Arguments",
        "",
        "* `ctx` - The context containing the accounts required for updating the configuration.",
        "* `new_chain_selector` - The new chain selector for SVM."
      ],
      "accounts": [
        {
          "name": "config",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "authority",
          "isMut": false,
          "isSigner": true
        }
      ],
      "args": [
        {
          "name": "newChainSelector",
          "type": "u64"
        }
      ]
    },
    {
      "name": "updateEnableManualExecutionAfter",
      "docs": [
        "Updates the minimum amount of time required between a message being committed and when it can be manually executed.",
        "",
        "This is part of the OffRamp Configuration for SVM.",
        "The Admin is the only one able to update this config.",
        "",
        "# Arguments",
        "",
        "* `ctx` - The context containing the accounts required for updating the configuration.",
        "* `new_enable_manual_execution_after` - The new minimum amount of time required."
      ],
      "accounts": [
        {
          "name": "config",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "authority",
          "isMut": false,
          "isSigner": true
        }
      ],
      "args": [
        {
          "name": "newEnableManualExecutionAfter",
          "type": "i64"
        }
      ]
    },
    {
      "name": "setOcrConfig",
      "docs": [
        "Sets the OCR configuration.",
        "Only CCIP Admin can set the OCR configuration.",
        "",
        "# Arguments",
        "",
        "* `ctx` - The context containing the accounts required for setting the OCR configuration.",
        "* `plugin_type` - The type of OCR plugin [0: Commit, 1: Execution].",
        "* `config_info` - The OCR configuration information.",
        "* `signers` - The list of signers.",
        "* `transmitters` - The list of transmitters."
      ],
      "accounts": [
        {
          "name": "config",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "state",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "authority",
          "isMut": false,
          "isSigner": true
        }
      ],
      "args": [
        {
          "name": "pluginType",
          "type": {
            "defined": "OcrPluginType"
          }
        },
        {
          "name": "configInfo",
          "type": {
            "defined": "Ocr3ConfigInfo"
          }
        },
        {
          "name": "signers",
          "type": {
            "vec": {
              "array": [
                "u8",
                20
              ]
            }
          }
        },
        {
          "name": "transmitters",
          "type": {
            "vec": "publicKey"
          }
        }
      ]
    },
    {
      "name": "commit",
      "docs": [
        "Off Ramp Flow //",
        "Commits a report to the router, containing a Merkle Root.",
        "",
        "The method name needs to be commit with Anchor encoding.",
        "",
        "This function is called by the OffChain when committing one Report to the SVM Router.",
        "In this Flow only one report is sent, the Commit Report. This is different as EVM does,",
        "this is because here all the chain state is stored in one account per Merkle Tree Root.",
        "So, to avoid having to send a dynamic size array of accounts, in this message only one Commit Report Account is sent.",
        "This message validates the signatures of the report and stores the Merkle Root in the Commit Report Account.",
        "The Report must contain an interval of messages, and the min of them must be the next sequence number expected.",
        "The max size of the interval is 64.",
        "This message emits two events: CommitReportAccepted and Transmitted.",
        "",
        "# Arguments",
        "",
        "* `ctx` - The context containing the accounts required for the commit.",
        "* `report_context_byte_words` - consists of:",
        "* report_context_byte_words[0]: ConfigDigest",
        "* report_context_byte_words[1]: 24 byte padding, 8 byte sequence number",
        "* `raw_report` - The serialized commit input report, single merkle root with RMN signatures and price updates",
        "* `rs` - slice of R components of signatures",
        "* `ss` - slice of S components of signatures",
        "* `raw_vs` - array of V components of signatures"
      ],
      "accounts": [
        {
          "name": "config",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "referenceAddresses",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "sourceChain",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "commitReport",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "authority",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "sysvarInstructions",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "feeBillingSigner",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "feeQuoter",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "feeQuoterAllowedPriceUpdater",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "so that it can authorize the call made by this offramp"
          ]
        },
        {
          "name": "feeQuoterConfig",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rmnRemote",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rmnRemoteCurses",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rmnRemoteConfig",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "reportContextByteWords",
          "type": {
            "array": [
              {
                "array": [
                  "u8",
                  32
                ]
              },
              2
            ]
          }
        },
        {
          "name": "rawReport",
          "type": "bytes"
        },
        {
          "name": "rs",
          "type": {
            "vec": {
              "array": [
                "u8",
                32
              ]
            }
          }
        },
        {
          "name": "ss",
          "type": {
            "vec": {
              "array": [
                "u8",
                32
              ]
            }
          }
        },
        {
          "name": "rawVs",
          "type": {
            "array": [
              "u8",
              32
            ]
          }
        }
      ]
    },
    {
      "name": "commitPriceOnly",
      "docs": [
        "Commits a report to the router, with price updates only.",
        "",
        "The method name needs to be commit with Anchor encoding.",
        "",
        "This function is called by the OffChain when committing one Report to the SVM Router,",
        "containing only price updates and no merkle root.",
        "",
        "# Arguments",
        "",
        "* `ctx` - The context containing the accounts required for the commit.",
        "* `report_context_byte_words` - consists of:",
        "* report_context_byte_words[0]: ConfigDigest",
        "* report_context_byte_words[1]: 24 byte padding, 8 byte sequence number",
        "* `raw_report` - The serialized commit input report containing the price updates,",
        "with no merkle root.",
        "* `rs` - slice of R components of signatures",
        "* `ss` - slice of S components of signatures",
        "* `raw_vs` - array of V components of signatures"
      ],
      "accounts": [
        {
          "name": "config",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "referenceAddresses",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "authority",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "sysvarInstructions",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "feeBillingSigner",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "feeQuoter",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "feeQuoterAllowedPriceUpdater",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "so that it can authorize the call made by this offramp"
          ]
        },
        {
          "name": "feeQuoterConfig",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rmnRemote",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rmnRemoteCurses",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rmnRemoteConfig",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "reportContextByteWords",
          "type": {
            "array": [
              {
                "array": [
                  "u8",
                  32
                ]
              },
              2
            ]
          }
        },
        {
          "name": "rawReport",
          "type": "bytes"
        },
        {
          "name": "rs",
          "type": {
            "vec": {
              "array": [
                "u8",
                32
              ]
            }
          }
        },
        {
          "name": "ss",
          "type": {
            "vec": {
              "array": [
                "u8",
                32
              ]
            }
          }
        },
        {
          "name": "rawVs",
          "type": {
            "array": [
              "u8",
              32
            ]
          }
        }
      ]
    },
    {
      "name": "execute",
      "docs": [
        "Executes a message on the destination chain.",
        "",
        "The method name needs to be execute with Anchor encoding.",
        "",
        "This function is called by the OffChain when executing one Report to the SVM Router.",
        "In this Flow only one message is sent, the Execution Report. This is different as EVM does,",
        "this is because there is no try/catch mechanism to allow batch execution.",
        "This message validates that the Merkle Tree Proof of the given message is correct and is stored in the Commit Report Account.",
        "The message must be untouched to be executed.",
        "This message emits the event ExecutionStateChanged with the new state of the message.",
        "Finally, executes the CPI instruction to the receiver program in the ccip_receive message.",
        "",
        "# Arguments",
        "",
        "* `ctx` - The context containing the accounts required for the execute.",
        "* `raw_execution_report` - the serialized execution report containing only one message and proofs",
        "* `report_context_byte_words` - report_context after execution_report to match context for manually execute (proper decoding order)",
        "*  consists of:",
        "* report_context_byte_words[0]: ConfigDigest",
        "* report_context_byte_words[1]: 24 byte padding, 8 byte sequence number"
      ],
      "accounts": [
        {
          "name": "config",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "referenceAddresses",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "sourceChain",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "commitReport",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "offramp",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "allowedOfframp",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "CHECK PDA of the router program verifying the signer is an allowed offramp.",
            "If PDA does not exist, the router doesn't allow this offramp. This is just used",
            "so that token pools and receivers can then check that the caller is an actual offramp that",
            "has been registered in the router as such for that source chain."
          ]
        },
        {
          "name": "authority",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "sysvarInstructions",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rmnRemote",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rmnRemoteCurses",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rmnRemoteConfig",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "rawExecutionReport",
          "type": "bytes"
        },
        {
          "name": "reportContextByteWords",
          "type": {
            "array": [
              {
                "array": [
                  "u8",
                  32
                ]
              },
              2
            ]
          }
        },
        {
          "name": "tokenIndexes",
          "type": "bytes"
        }
      ]
    },
    {
      "name": "manuallyExecute",
      "docs": [
        "Manually executes a report to the router.",
        "",
        "When a message is not being executed, then the user can trigger the execution manually.",
        "No verification over the transmitter, but the message needs to be in some commit report.",
        "It validates that the required time has passed since the commit and then executes the report.",
        "",
        "# Arguments",
        "",
        "* `ctx` - The context containing the accounts required for the execution.",
        "* `raw_execution_report` - The serialized execution report containing the message and proofs."
      ],
      "accounts": [
        {
          "name": "config",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "referenceAddresses",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "sourceChain",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "commitReport",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "offramp",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "allowedOfframp",
          "isMut": false,
          "isSigner": false,
          "docs": [
            "CHECK PDA of the router program verifying the signer is an allowed offramp.",
            "If PDA does not exist, the router doesn't allow this offramp. This is just used",
            "so that token pools and receivers can then check that the caller is an actual offramp that",
            "has been registered in the router as such for that source chain."
          ]
        },
        {
          "name": "authority",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "sysvarInstructions",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rmnRemote",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rmnRemoteCurses",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "rmnRemoteConfig",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "rawExecutionReport",
          "type": "bytes"
        },
        {
          "name": "tokenIndexes",
          "type": "bytes"
        }
      ]
    },
    {
      "name": "bufferExecutionReport",
      "docs": [
        "Initializes and/or inserts a chunk of report data to an execution report buffer.",
        "",
        "When execution reports are too large to fit in a single transaction, they can be chopped",
        "up in chunks first (as a special case, one chunk is also acceptable), and pre-buffered",
        "via multiple calls to this instruction.",
        "",
        "There's no need to pre-initialize the buffer: all chunks can be sent concurrently, and the",
        "first one to arrive will initialize the buffer.",
        "",
        "To benefit from buffering, the eventual call to `execute` or `manually_execute` must",
        "include an additional `remaining_account` with the PDA derived from",
        "[\"execution_report_buffer\", <buffer_id>, <caller_pubkey>].",
        "",
        "# Arguments",
        "",
        "* `ctx` - The context containing the accounts required for buffering.",
        "* `buffer_id` - An arbitrary buffer id defined by the caller (could be the message_id). Max 32 bytes.",
        "* `report_length` - Total length in bytes of the execution report.",
        "* `chunk` - The specific chunk to add to the buffer. Chunk must have a consistent size, except",
        "the last one in the buffer, which may be smaller.",
        "* `chunk_index` - The index of this chunk.",
        "* `num_chunks` - The total number of chunks in the report."
      ],
      "accounts": [
        {
          "name": "executionReportBuffer",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "config",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "authority",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "bufferId",
          "type": "bytes"
        },
        {
          "name": "reportLength",
          "type": "u32"
        },
        {
          "name": "chunk",
          "type": "bytes"
        },
        {
          "name": "chunkIndex",
          "type": "u8"
        },
        {
          "name": "numChunks",
          "type": "u8"
        }
      ]
    },
    {
      "name": "closeExecutionReportBuffer",
      "docs": [
        "Closes the execution report buffer to reclaim funds.",
        "",
        "Note this is only necessary when aborting a buffered transaction, or when a mistake",
        "was made when buffering data. The buffer account will otherwise automatically close",
        "and return funds to the caller whenever buffered execution succeeds."
      ],
      "accounts": [
        {
          "name": "executionReportBuffer",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "config",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "authority",
          "isMut": true,
          "isSigner": true
        },
        {
          "name": "systemProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "bufferId",
          "type": "bytes"
        }
      ]
    },
    {
      "name": "deriveAccountsExecute",
      "docs": [
        "Automatically derives all acounts required to call `ccip_execute`.",
        "",
        "This method receives the bare minimum amount of information needed to construct",
        "the entire account list to execute a transaction, and builds it iteratively",
        "over the course of multiple calls.",
        "",
        "The return type contains:",
        "",
        "* `accounts_to_save`: The caller must append these accounts to a list they maintain.",
        "When complete, this list will contain all accounts needed to call `ccip_execute`.",
        "* `ask_again_with`: When `next_stage` is not empty, the caller must call `derive_accounts_execute`",
        "again, including exactly these accounts as the `remaining_accounts`.",
        "* `lookup_tables_to_save`: The caller must save those LUTs. They can be used for `ccip_execute`.",
        "* `current_stage`: A string describing the current stage of the derivation process. When the stage",
        "is \"TokenTransferStaticAccounts/<N>/0\", it means the `accounts_to_save` block in this response contains",
        "all accounts relating to the Nth token being transferred. Use this information to construct",
        "the `token_indexes` vector that `execute` requires.",
        "* `next_stage`: If nonempty, this means the instruction must get called again with this value",
        "as the `stage` argument.",
        "",
        "Therefore, and starting with an empty `remaining_accounts` list, the caller must repeteadly",
        "call `derive_accounts_execute` until `next_stage` is returned empty.",
        "",
        "# Arguments",
        "",
        "* `ctx`: Context containing only the offramp config.",
        "* `stage`: Requested derivation stage. Pass \"Start\" the first time, then for each subsequent",
        "call, pass the value returned in `response.next_stage` until empty.",
        "* `params`:",
        "* `execute_caller`: Public key of the account that will sign the call to `ccip_execute`.",
        "* `message_accounts`: If the transaction involves messaging, the message accounts.",
        "* `source_chain_selector`: CCIP chain selector for the source chain.",
        "* `mints_of_transferred_token`: List of all token mints for tokens being transferred (i.e.",
        "the entries in `report.message.token_amounts.destination_address`.)",
        "* `merkle_root`: Merkle root as per the commit report.",
        "* `buffer_id`: If the execution will be buffered, the buffer id that will be used by the",
        "`execute_caller`: If the execution will not be buffered, this should be empty.",
        "* `token_receiver`: Receiver of token transfers, if any (i.e. report.message.token_receiver)"
      ],
      "accounts": [
        {
          "name": "config",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "params",
          "type": {
            "defined": "DeriveAccountsExecuteParams"
          }
        },
        {
          "name": "stage",
          "type": "string"
        }
      ],
      "returns": {
        "defined": "DeriveAccountsResponse"
      }
    },
    {
      "name": "closeCommitReportAccount",
      "accounts": [
        {
          "name": "config",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "commitReport",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "referenceAddresses",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "wsolMint",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "feeTokenReceiver",
          "isMut": true,
          "isSigner": false
        },
        {
          "name": "feeBillingSigner",
          "isMut": false,
          "isSigner": false
        },
        {
          "name": "tokenProgram",
          "isMut": false,
          "isSigner": false
        }
      ],
      "args": [
        {
          "name": "sourceChainSelector",
          "type": "u64"
        },
        {
          "name": "root",
          "type": "bytes"
        }
      ]
    }
  ],
  "accounts": [
    {
      "name": "Config",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "version",
            "type": "u8"
          },
          {
            "name": "defaultCodeVersion",
            "type": "u8"
          },
          {
            "name": "padding0",
            "type": {
              "array": [
                "u8",
                6
              ]
            }
          },
          {
            "name": "svmChainSelector",
            "type": "u64"
          },
          {
            "name": "enableManualExecutionAfter",
            "type": "i64"
          },
          {
            "name": "padding1",
            "type": {
              "array": [
                "u8",
                8
              ]
            }
          },
          {
            "name": "owner",
            "type": "publicKey"
          },
          {
            "name": "proposedOwner",
            "type": "publicKey"
          },
          {
            "name": "padding2",
            "type": {
              "array": [
                "u8",
                8
              ]
            }
          },
          {
            "name": "ocr3",
            "type": {
              "array": [
                {
                  "defined": "Ocr3Config"
                },
                2
              ]
            }
          }
        ]
      }
    },
    {
      "name": "ReferenceAddresses",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "version",
            "type": "u8"
          },
          {
            "name": "router",
            "type": "publicKey"
          },
          {
            "name": "feeQuoter",
            "type": "publicKey"
          },
          {
            "name": "offrampLookupTable",
            "type": "publicKey"
          },
          {
            "name": "rmnRemote",
            "type": "publicKey"
          }
        ]
      }
    },
    {
      "name": "GlobalState",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "latestPriceSequenceNumber",
            "type": "u64"
          }
        ]
      }
    },
    {
      "name": "ExecutionReportBuffer",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "version",
            "type": "u8"
          },
          {
            "name": "chunkBitmap",
            "type": "u64"
          },
          {
            "name": "numChunks",
            "type": "u8"
          },
          {
            "name": "chunkLength",
            "type": "u32"
          },
          {
            "name": "data",
            "type": "bytes"
          }
        ]
      }
    },
    {
      "name": "SourceChain",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "version",
            "type": "u8"
          },
          {
            "name": "chainSelector",
            "type": "u64"
          },
          {
            "name": "state",
            "type": {
              "defined": "SourceChainState"
            }
          },
          {
            "name": "config",
            "type": {
              "defined": "SourceChainConfig"
            }
          }
        ]
      }
    },
    {
      "name": "CommitReport",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "version",
            "type": "u8"
          },
          {
            "name": "chainSelector",
            "type": "u64"
          },
          {
            "name": "merkleRoot",
            "type": {
              "array": [
                "u8",
                32
              ]
            }
          },
          {
            "name": "timestamp",
            "type": "i64"
          },
          {
            "name": "minMsgNr",
            "type": "u64"
          },
          {
            "name": "maxMsgNr",
            "type": "u64"
          },
          {
            "name": "executionStates",
            "type": "u128"
          }
        ]
      }
    }
  ],
  "types": [
    {
      "name": "CommitInput",
      "docs": [
        "Input from an offchain node, containing the Merkle root and interval for",
        "the source chain, and optionally some price updates alongside it"
      ],
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "priceUpdates",
            "type": {
              "defined": "PriceUpdates"
            }
          },
          {
            "name": "merkleRoot",
            "type": {
              "option": {
                "defined": "MerkleRoot"
              }
            }
          },
          {
            "name": "rmnSignatures",
            "type": {
              "vec": {
                "array": [
                  "u8",
                  64
                ]
              }
            }
          }
        ]
      }
    },
    {
      "name": "PriceUpdates",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "tokenPriceUpdates",
            "type": {
              "vec": {
                "defined": "TokenPriceUpdate"
              }
            }
          },
          {
            "name": "gasPriceUpdates",
            "type": {
              "vec": {
                "defined": "GasPriceUpdate"
              }
            }
          }
        ]
      }
    },
    {
      "name": "TokenPriceUpdate",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "sourceToken",
            "type": "publicKey"
          },
          {
            "name": "usdPerToken",
            "type": {
              "array": [
                "u8",
                28
              ]
            }
          }
        ]
      }
    },
    {
      "name": "GasPriceUpdate",
      "docs": [
        "Gas price for a given chain in USD; its value may contain tightly packed fields."
      ],
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "destChainSelector",
            "type": "u64"
          },
          {
            "name": "usdPerUnitGas",
            "type": {
              "array": [
                "u8",
                28
              ]
            }
          }
        ]
      }
    },
    {
      "name": "MerkleRoot",
      "docs": [
        "Struct to hold a merkle root and an interval for a source chain"
      ],
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "sourceChainSelector",
            "type": "u64"
          },
          {
            "name": "onRampAddress",
            "type": "bytes"
          },
          {
            "name": "minSeqNr",
            "type": "u64"
          },
          {
            "name": "maxSeqNr",
            "type": "u64"
          },
          {
            "name": "merkleRoot",
            "type": {
              "array": [
                "u8",
                32
              ]
            }
          }
        ]
      }
    },
    {
      "name": "ConfigOcrPluginType",
      "docs": [
        "It's not possible to store enums in zero_copy accounts, so we wrap the discriminant",
        "in a struct to store in config."
      ],
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "discriminant",
            "type": "u8"
          }
        ]
      }
    },
    {
      "name": "ExecutionReportSingleChain",
      "docs": [
        "Report that is submitted by the execution DON at the execution phase. (including chain selector data)"
      ],
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "sourceChainSelector",
            "type": "u64"
          },
          {
            "name": "message",
            "type": {
              "defined": "Any2SVMRampMessage"
            }
          },
          {
            "name": "offchainTokenData",
            "type": {
              "vec": "bytes"
            }
          },
          {
            "name": "proofs",
            "type": {
              "vec": {
                "array": [
                  "u8",
                  32
                ]
              }
            }
          }
        ]
      }
    },
    {
      "name": "RampMessageHeader",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "messageId",
            "type": {
              "array": [
                "u8",
                32
              ]
            }
          },
          {
            "name": "sourceChainSelector",
            "type": "u64"
          },
          {
            "name": "destChainSelector",
            "type": "u64"
          },
          {
            "name": "sequenceNumber",
            "type": "u64"
          },
          {
            "name": "nonce",
            "type": "u64"
          }
        ]
      }
    },
    {
      "name": "Any2SVMRampExtraArgs",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "computeUnits",
            "type": "u32"
          },
          {
            "name": "isWritableBitmap",
            "type": "u64"
          }
        ]
      }
    },
    {
      "name": "Any2SVMRampMessage",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "header",
            "type": {
              "defined": "RampMessageHeader"
            }
          },
          {
            "name": "sender",
            "type": "bytes"
          },
          {
            "name": "data",
            "type": "bytes"
          },
          {
            "name": "tokenReceiver",
            "type": "publicKey"
          },
          {
            "name": "tokenAmounts",
            "type": {
              "vec": {
                "defined": "Any2SVMTokenTransfer"
              }
            }
          },
          {
            "name": "extraArgs",
            "type": {
              "defined": "Any2SVMRampExtraArgs"
            }
          }
        ]
      }
    },
    {
      "name": "Any2SVMTokenTransfer",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "sourcePoolAddress",
            "type": "bytes"
          },
          {
            "name": "destTokenAddress",
            "type": "publicKey"
          },
          {
            "name": "destGasAmount",
            "type": "u32"
          },
          {
            "name": "extraData",
            "type": "bytes"
          },
          {
            "name": "amount",
            "type": {
              "defined": "CrossChainAmount"
            }
          }
        ]
      }
    },
    {
      "name": "SVMTokenAmount",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "token",
            "type": "publicKey"
          },
          {
            "name": "amount",
            "type": "u64"
          }
        ]
      }
    },
    {
      "name": "CrossChainAmount",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "leBytes",
            "type": {
              "array": [
                "u8",
                32
              ]
            }
          }
        ]
      }
    },
    {
      "name": "DeriveAccountsExecuteParams",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "executeCaller",
            "type": "publicKey"
          },
          {
            "name": "tokenReceiver",
            "type": "publicKey"
          },
          {
            "name": "tokenTransfers",
            "type": {
              "vec": {
                "defined": "TokenTransferAndOffchainData"
              }
            }
          },
          {
            "name": "messageAccounts",
            "type": {
              "vec": {
                "defined": "CcipAccountMeta"
              }
            }
          },
          {
            "name": "sourceChainSelector",
            "type": "u64"
          },
          {
            "name": "originalSender",
            "type": "bytes"
          },
          {
            "name": "merkleRoot",
            "type": {
              "array": [
                "u8",
                32
              ]
            }
          },
          {
            "name": "bufferId",
            "type": "bytes"
          }
        ]
      }
    },
    {
      "name": "TokenTransferAndOffchainData",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "transfer",
            "type": {
              "defined": "Any2SVMTokenTransfer"
            }
          },
          {
            "name": "data",
            "type": "bytes"
          }
        ]
      }
    },
    {
      "name": "DeriveAccountsResponse",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "askAgainWith",
            "docs": [
              "If this vector is not empty, you must call the `derive_` method again including",
              "exactly these accounts as the `remaining_accounts` field."
            ],
            "type": {
              "vec": {
                "defined": "CcipAccountMeta"
              }
            }
          },
          {
            "name": "accountsToSave",
            "docs": [
              "You must append these accounts at the end of a separate list. When `next_stage`",
              "is finally empty, this separate list will contain all the accounts to use for the",
              "instruction of interest."
            ],
            "type": {
              "vec": {
                "defined": "CcipAccountMeta"
              }
            }
          },
          {
            "name": "lookUpTablesToSave",
            "docs": [
              "Append these look up tables at the end of a list. It will contain all LUTs",
              "that the instruction of interest can use."
            ],
            "type": {
              "vec": "publicKey"
            }
          },
          {
            "name": "currentStage",
            "docs": [
              "Identifies the derivation stage."
            ],
            "type": "string"
          },
          {
            "name": "nextStage",
            "docs": [
              "Identifies the next derivation stage. If empty, the derivation is complete."
            ],
            "type": "string"
          }
        ]
      }
    },
    {
      "name": "CcipAccountMeta",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "pubkey",
            "type": "publicKey"
          },
          {
            "name": "isSigner",
            "type": "bool"
          },
          {
            "name": "isWritable",
            "type": "bool"
          }
        ]
      }
    },
    {
      "name": "Ocr3ConfigInfo",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "configDigest",
            "type": {
              "array": [
                "u8",
                32
              ]
            }
          },
          {
            "name": "f",
            "type": "u8"
          },
          {
            "name": "n",
            "type": "u8"
          },
          {
            "name": "isSignatureVerificationEnabled",
            "type": "u8"
          }
        ]
      }
    },
    {
      "name": "Ocr3Config",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "pluginType",
            "type": {
              "defined": "ConfigOcrPluginType"
            }
          },
          {
            "name": "configInfo",
            "type": {
              "defined": "Ocr3ConfigInfo"
            }
          },
          {
            "name": "signers",
            "type": {
              "array": [
                {
                  "array": [
                    "u8",
                    20
                  ]
                },
                16
              ]
            }
          },
          {
            "name": "transmitters",
            "type": {
              "array": [
                {
                  "array": [
                    "u8",
                    32
                  ]
                },
                16
              ]
            }
          }
        ]
      }
    },
    {
      "name": "SourceChainConfig",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "isEnabled",
            "type": "bool"
          },
          {
            "name": "isRmnVerificationDisabled",
            "type": "bool"
          },
          {
            "name": "laneCodeVersion",
            "type": {
              "defined": "CodeVersion"
            }
          },
          {
            "name": "onRamp",
            "type": {
              "defined": "OnRampAddress"
            }
          }
        ]
      }
    },
    {
      "name": "OnRampAddress",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "bytes",
            "type": {
              "array": [
                "u8",
                64
              ]
            }
          },
          {
            "name": "len",
            "type": "u32"
          }
        ]
      }
    },
    {
      "name": "SourceChainState",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "minSeqNr",
            "type": "u64"
          }
        ]
      }
    },
    {
      "name": "OcrPluginType",
      "type": {
        "kind": "enum",
        "variants": [
          {
            "name": "Commit"
          },
          {
            "name": "Execution"
          }
        ]
      }
    },
    {
      "name": "DeriveAccountsExecuteStage",
      "type": {
        "kind": "enum",
        "variants": [
          {
            "name": "Start"
          },
          {
            "name": "FinishMainAccountList"
          },
          {
            "name": "RetrieveTokenLUTs"
          },
          {
            "name": "RetrievePoolPrograms"
          },
          {
            "name": "TokenTransferStaticAccounts",
            "fields": [
              {
                "name": "token",
                "type": "u32"
              },
              {
                "name": "page",
                "type": "u32"
              }
            ]
          },
          {
            "name": "NestedTokenDerive",
            "fields": [
              {
                "name": "token",
                "type": "u32"
              },
              {
                "name": "tokenSubstage",
                "type": "string"
              }
            ]
          }
        ]
      }
    },
    {
      "name": "MessageExecutionState",
      "type": {
        "kind": "enum",
        "variants": [
          {
            "name": "Untouched"
          },
          {
            "name": "InProgress"
          },
          {
            "name": "Success"
          },
          {
            "name": "Failure"
          }
        ]
      }
    },
    {
      "name": "CodeVersion",
      "type": {
        "kind": "enum",
        "variants": [
          {
            "name": "Default"
          },
          {
            "name": "V1"
          }
        ]
      }
    }
  ],
  "events": [
    {
      "name": "SourceChainConfigUpdated",
      "fields": [
        {
          "name": "sourceChainSelector",
          "type": "u64",
          "index": false
        },
        {
          "name": "sourceChainConfig",
          "type": {
            "defined": "SourceChainConfig"
          },
          "index": false
        }
      ]
    },
    {
      "name": "SourceChainAdded",
      "fields": [
        {
          "name": "sourceChainSelector",
          "type": "u64",
          "index": false
        },
        {
          "name": "sourceChainConfig",
          "type": {
            "defined": "SourceChainConfig"
          },
          "index": false
        }
      ]
    },
    {
      "name": "OwnershipTransferRequested",
      "fields": [
        {
          "name": "from",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "to",
          "type": "publicKey",
          "index": false
        }
      ]
    },
    {
      "name": "OwnershipTransferred",
      "fields": [
        {
          "name": "from",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "to",
          "type": "publicKey",
          "index": false
        }
      ]
    },
    {
      "name": "ConfigSet",
      "fields": [
        {
          "name": "svmChainSelector",
          "type": "u64",
          "index": false
        },
        {
          "name": "enableManualExecutionAfter",
          "type": "i64",
          "index": false
        }
      ]
    },
    {
      "name": "ReferenceAddressesSet",
      "fields": [
        {
          "name": "router",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "feeQuoter",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "offrampLookupTable",
          "type": "publicKey",
          "index": false
        },
        {
          "name": "rmnRemote",
          "type": "publicKey",
          "index": false
        }
      ]
    },
    {
      "name": "CommitReportAccepted",
      "fields": [
        {
          "name": "merkleRoot",
          "type": {
            "option": {
              "defined": "MerkleRoot"
            }
          },
          "index": false
        },
        {
          "name": "priceUpdates",
          "type": {
            "defined": "PriceUpdates"
          },
          "index": false
        }
      ]
    },
    {
      "name": "CommitReportPDAClosed",
      "fields": [
        {
          "name": "sourceChainSelector",
          "type": "u64",
          "index": false
        },
        {
          "name": "merkleRoot",
          "type": {
            "array": [
              "u8",
              32
            ]
          },
          "index": false
        }
      ]
    },
    {
      "name": "SkippedAlreadyExecutedMessage",
      "fields": [
        {
          "name": "sourceChainSelector",
          "type": "u64",
          "index": false
        },
        {
          "name": "sequenceNumber",
          "type": "u64",
          "index": false
        }
      ]
    },
    {
      "name": "ExecutionStateChanged",
      "fields": [
        {
          "name": "sourceChainSelector",
          "type": "u64",
          "index": false
        },
        {
          "name": "sequenceNumber",
          "type": "u64",
          "index": false
        },
        {
          "name": "messageId",
          "type": {
            "array": [
              "u8",
              32
            ]
          },
          "index": false
        },
        {
          "name": "messageHash",
          "type": {
            "array": [
              "u8",
              32
            ]
          },
          "index": false
        },
        {
          "name": "state",
          "type": {
            "defined": "MessageExecutionState"
          },
          "index": false
        }
      ]
    },
    {
      "name": "ConfigSet",
      "fields": [
        {
          "name": "ocrPluginType",
          "type": {
            "defined": "OcrPluginType"
          },
          "index": false
        },
        {
          "name": "configDigest",
          "type": {
            "array": [
              "u8",
              32
            ]
          },
          "index": false
        },
        {
          "name": "signers",
          "type": {
            "vec": {
              "array": [
                "u8",
                20
              ]
            }
          },
          "index": false
        },
        {
          "name": "transmitters",
          "type": {
            "vec": "publicKey"
          },
          "index": false
        },
        {
          "name": "f",
          "type": "u8",
          "index": false
        }
      ]
    },
    {
      "name": "Transmitted",
      "fields": [
        {
          "name": "ocrPluginType",
          "type": {
            "defined": "OcrPluginType"
          },
          "index": false
        },
        {
          "name": "configDigest",
          "type": {
            "array": [
              "u8",
              32
            ]
          },
          "index": false
        },
        {
          "name": "sequenceNumber",
          "type": "u64",
          "index": false
        }
      ]
    }
  ],
  "errors": [
    {
      "code": 9000,
      "name": "InvalidSequenceInterval",
      "msg": "The given sequence interval is invalid"
    },
    {
      "code": 9001,
      "name": "RootNotCommitted",
      "msg": "The given Merkle Root is missing"
    },
    {
      "code": 9002,
      "name": "InvalidRMNRemoteAddress",
      "msg": "Invalid RMN Remote Address"
    },
    {
      "code": 9003,
      "name": "ExistingMerkleRoot",
      "msg": "The given Merkle Root is already committed"
    },
    {
      "code": 9004,
      "name": "Unauthorized",
      "msg": "The signer is unauthorized"
    },
    {
      "code": 9005,
      "name": "InvalidNonce",
      "msg": "Invalid Nonce"
    },
    {
      "code": 9006,
      "name": "InvalidInputsMissingWritable",
      "msg": "Account should be writable"
    },
    {
      "code": 9007,
      "name": "OnrampNotConfigured",
      "msg": "Onramp was not configured"
    },
    {
      "code": 9008,
      "name": "FailedToDeserializeReport",
      "msg": "Failed to deserialize report"
    },
    {
      "code": 9009,
      "name": "InvalidPluginType",
      "msg": "Invalid plugin type"
    },
    {
      "code": 9010,
      "name": "InvalidVersion",
      "msg": "Invalid version of the onchain state"
    },
    {
      "code": 9011,
      "name": "MissingExpectedPriceUpdates",
      "msg": "Commit report is missing expected price updates"
    },
    {
      "code": 9012,
      "name": "MissingExpectedMerkleRoot",
      "msg": "Commit report is missing expected merkle root"
    },
    {
      "code": 9013,
      "name": "UnexpectedMerkleRoot",
      "msg": "Commit report contains unexpected merkle root"
    },
    {
      "code": 9014,
      "name": "RedundantOwnerProposal",
      "msg": "Proposed owner is the current owner"
    },
    {
      "code": 9015,
      "name": "UnsupportedSourceChainSelector",
      "msg": "Source chain selector not supported"
    },
    {
      "code": 9016,
      "name": "UnsupportedDestinationChainSelector",
      "msg": "Destination chain selector not supported"
    },
    {
      "code": 9017,
      "name": "InvalidProof",
      "msg": "Invalid Proof for Merkle Root"
    },
    {
      "code": 9018,
      "name": "InvalidMessage",
      "msg": "Invalid message format"
    },
    {
      "code": 9019,
      "name": "ReachedMaxSequenceNumber",
      "msg": "Reached max sequence number"
    },
    {
      "code": 9020,
      "name": "ManualExecutionNotAllowed",
      "msg": "Manual execution not allowed"
    },
    {
      "code": 9021,
      "name": "InvalidInputsNumberOfAccounts",
      "msg": "Number of accounts is invalid"
    },
    {
      "code": 9022,
      "name": "InvalidInputsGlobalStateAccount",
      "msg": "Invalid global state account address"
    },
    {
      "code": 9023,
      "name": "InvalidInputsTokenIndices",
      "msg": "Invalid pool account account indices"
    },
    {
      "code": 9024,
      "name": "InvalidInputsPoolAccounts",
      "msg": "Invalid pool accounts"
    },
    {
      "code": 9025,
      "name": "InvalidInputsTokenAccounts",
      "msg": "Invalid token accounts"
    },
    {
      "code": 9026,
      "name": "InvalidInputsSysvarAccount",
      "msg": "Invalid sysvar instructions account"
    },
    {
      "code": 9027,
      "name": "InvalidInputsFeeQuoterAccount",
      "msg": "Invalid fee quoter account"
    },
    {
      "code": 9028,
      "name": "InvalidInputsAllowedOfframpAccount",
      "msg": "Invalid offramp authorization account"
    },
    {
      "code": 9029,
      "name": "InvalidInputsTokenAdminRegistryAccounts",
      "msg": "Invalid Token Admin Registry account"
    },
    {
      "code": 9030,
      "name": "InvalidInputsLookupTableAccounts",
      "msg": "Invalid LookupTable account"
    },
    {
      "code": 9031,
      "name": "InvalidInputsLookupTableAccountWritable",
      "msg": "Invalid LookupTable account writable access"
    },
    {
      "code": 9032,
      "name": "OfframpReleaseMintBalanceMismatch",
      "msg": "Release or mint balance mismatch"
    },
    {
      "code": 9033,
      "name": "OfframpInvalidDataLength",
      "msg": "Invalid data length"
    },
    {
      "code": 9034,
      "name": "StaleCommitReport",
      "msg": "Stale commit report"
    },
    {
      "code": 9035,
      "name": "InvalidWritabilityBitmap",
      "msg": "Invalid writability bitmap"
    },
    {
      "code": 9036,
      "name": "InvalidCodeVersion",
      "msg": "Invalid code version"
    },
    {
      "code": 9037,
      "name": "Ocr3InvalidConfigFMustBePositive",
      "msg": "Invalid config: F must be positive"
    },
    {
      "code": 9038,
      "name": "Ocr3InvalidConfigTooManyTransmitters",
      "msg": "Invalid config: Too many transmitters"
    },
    {
      "code": 9039,
      "name": "Ocr3InvalidConfigNoTransmitters",
      "msg": "Invalid config: No transmitters"
    },
    {
      "code": 9040,
      "name": "Ocr3InvalidConfigTooManySigners",
      "msg": "Invalid config: Too many signers"
    },
    {
      "code": 9041,
      "name": "Ocr3InvalidConfigFIsTooHigh",
      "msg": "Invalid config: F is too high"
    },
    {
      "code": 9042,
      "name": "Ocr3InvalidConfigRepeatedOracle",
      "msg": "Invalid config: Repeated oracle address"
    },
    {
      "code": 9043,
      "name": "Ocr3WrongMessageLength",
      "msg": "Wrong message length"
    },
    {
      "code": 9044,
      "name": "Ocr3ConfigDigestMismatch",
      "msg": "Config digest mismatch"
    },
    {
      "code": 9045,
      "name": "Ocr3WrongNumberOfSignatures",
      "msg": "Wrong number signatures"
    },
    {
      "code": 9046,
      "name": "Ocr3UnauthorizedTransmitter",
      "msg": "Unauthorized transmitter"
    },
    {
      "code": 9047,
      "name": "Ocr3UnauthorizedSigner",
      "msg": "Unauthorized signer"
    },
    {
      "code": 9048,
      "name": "Ocr3NonUniqueSignatures",
      "msg": "Non unique signatures"
    },
    {
      "code": 9049,
      "name": "Ocr3OracleCannotBeZeroAddress",
      "msg": "Oracle cannot be zero address"
    },
    {
      "code": 9050,
      "name": "Ocr3StaticConfigCannotBeChanged",
      "msg": "Static config cannot be changed"
    },
    {
      "code": 9051,
      "name": "Ocr3InvalidPluginType",
      "msg": "Incorrect plugin type"
    },
    {
      "code": 9052,
      "name": "Ocr3InvalidSignature",
      "msg": "Invalid signature"
    },
    {
      "code": 9053,
      "name": "Ocr3SignaturesOutOfRegistration",
      "msg": "Signatures out of registration"
    },
    {
      "code": 9054,
      "name": "InvalidOnrampAddress",
      "msg": "Invalid onramp address"
    },
    {
      "code": 9055,
      "name": "InvalidInputsExternalExecutionSignerAccount",
      "msg": "Invalid external execution signer account"
    },
    {
      "code": 9056,
      "name": "CommitReportHasPendingMessages",
      "msg": "Commit report has pending messages"
    },
    {
      "code": 9057,
      "name": "ExecutionReportBufferAlreadyContainsChunk",
      "msg": "The execution report buffer already contains that chunk"
    },
    {
      "code": 9058,
      "name": "ExecutionReportBufferAlreadyInitialized",
      "msg": "The execution report buffer is already initialized"
    },
    {
      "code": 9059,
      "name": "ExecutionReportBufferInvalidLength",
      "msg": "Invalid length for execution report buffer"
    },
    {
      "code": 9060,
      "name": "ExecutionReportBufferInvalidChunkIndex",
      "msg": "Chunk lies outside the execution report buffer"
    },
    {
      "code": 9061,
      "name": "ExecutionReportBufferInvalidChunkNumber",
      "msg": "Total number of chunks is not consistent"
    },
    {
      "code": 9062,
      "name": "ExecutionReportBufferChunkSizeTooSmall",
      "msg": "Chunk size is too small"
    },
    {
      "code": 9063,
      "name": "ExecutionReportBufferInvalidChunkSize",
      "msg": "Invalid chunk size"
    },
    {
      "code": 9064,
      "name": "ExecutionReportBufferInvalidIdSize",
      "msg": "Invalid ID size for buffer"
    },
    {
      "code": 9065,
      "name": "ExecutionReportBufferIncomplete",
      "msg": "Execution report buffer is not complete: chunks are missing"
    },
    {
      "code": 9066,
      "name": "ExecutionReportUnavailable",
      "msg": "Execution report wasn't provided either directly or via buffer"
    },
    {
      "code": 9067,
      "name": "InvalidAccountListForPdaDerivation",
      "msg": "Invalid account list for PDA derivation"
    },
    {
      "code": 9068,
      "name": "InvalidDerivationStage",
      "msg": "Unexpected account derivation stage"
    },
    {
      "code": 9069,
      "name": "InvalidTokenPoolAccountDerivationResponse",
      "msg": "Token pool returned an unexpected derivation response"
    },
    {
      "code": 9070,
      "name": "AccountDerivationResponseTooLarge",
      "msg": "Can't fit account derivation response."
    },
    {
      "code": 9071,
      "name": "DefaultOwnerProposal",
      "msg": "Proposed owner is the default pubkey"
    }
  ]
}