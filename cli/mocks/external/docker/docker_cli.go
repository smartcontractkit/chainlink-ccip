// Code generated by mockery v2.45.1. DO NOT EDIT.

package docker

import (
	command "github.com/docker/cli/cli/command"
	client "github.com/docker/docker/client"

	configfile "github.com/docker/cli/cli/config/configfile"

	docker "github.com/docker/cli/cli/context/docker"

	manifeststore "github.com/docker/cli/cli/manifest/store"

	metric "go.opentelemetry.io/otel/metric"

	mock "github.com/stretchr/testify/mock"

	notaryclient "github.com/theupdateframework/notary/client"

	registryclient "github.com/docker/cli/cli/registry/client"

	resource "go.opentelemetry.io/otel/sdk/resource"

	store "github.com/docker/cli/cli/context/store"

	streams "github.com/docker/cli/cli/streams"

	trace "go.opentelemetry.io/otel/trace"

	trust "github.com/docker/cli/cli/trust"
)

// DockerCli is an autogenerated mock type for the Cli type
type DockerCli struct {
	mock.Mock
}

type DockerCli_Expecter struct {
	mock *mock.Mock
}

func (_m *DockerCli) EXPECT() *DockerCli_Expecter {
	return &DockerCli_Expecter{mock: &_m.Mock}
}

// Apply provides a mock function with given fields: ops
func (_m *DockerCli) Apply(ops ...command.CLIOption) error {
	_va := make([]interface{}, len(ops))
	for _i := range ops {
		_va[_i] = ops[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Apply")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(...command.CLIOption) error); ok {
		r0 = rf(ops...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DockerCli_Apply_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Apply'
type DockerCli_Apply_Call struct {
	*mock.Call
}

// Apply is a helper method to define mock.On call
//   - ops ...command.CLIOption
func (_e *DockerCli_Expecter) Apply(ops ...interface{}) *DockerCli_Apply_Call {
	return &DockerCli_Apply_Call{Call: _e.mock.On("Apply",
		append([]interface{}{}, ops...)...)}
}

func (_c *DockerCli_Apply_Call) Run(run func(ops ...command.CLIOption)) *DockerCli_Apply_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]command.CLIOption, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(command.CLIOption)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *DockerCli_Apply_Call) Return(_a0 error) *DockerCli_Apply_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *DockerCli_Apply_Call) RunAndReturn(run func(...command.CLIOption) error) *DockerCli_Apply_Call {
	_c.Call.Return(run)
	return _c
}

// BuildKitEnabled provides a mock function with given fields:
func (_m *DockerCli) BuildKitEnabled() (bool, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for BuildKitEnabled")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func() (bool, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DockerCli_BuildKitEnabled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BuildKitEnabled'
type DockerCli_BuildKitEnabled_Call struct {
	*mock.Call
}

// BuildKitEnabled is a helper method to define mock.On call
func (_e *DockerCli_Expecter) BuildKitEnabled() *DockerCli_BuildKitEnabled_Call {
	return &DockerCli_BuildKitEnabled_Call{Call: _e.mock.On("BuildKitEnabled")}
}

func (_c *DockerCli_BuildKitEnabled_Call) Run(run func()) *DockerCli_BuildKitEnabled_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DockerCli_BuildKitEnabled_Call) Return(_a0 bool, _a1 error) *DockerCli_BuildKitEnabled_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DockerCli_BuildKitEnabled_Call) RunAndReturn(run func() (bool, error)) *DockerCli_BuildKitEnabled_Call {
	_c.Call.Return(run)
	return _c
}

// Client provides a mock function with given fields:
func (_m *DockerCli) Client() client.APIClient {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Client")
	}

	var r0 client.APIClient
	if rf, ok := ret.Get(0).(func() client.APIClient); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(client.APIClient)
		}
	}

	return r0
}

// DockerCli_Client_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Client'
type DockerCli_Client_Call struct {
	*mock.Call
}

// Client is a helper method to define mock.On call
func (_e *DockerCli_Expecter) Client() *DockerCli_Client_Call {
	return &DockerCli_Client_Call{Call: _e.mock.On("Client")}
}

func (_c *DockerCli_Client_Call) Run(run func()) *DockerCli_Client_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DockerCli_Client_Call) Return(_a0 client.APIClient) *DockerCli_Client_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *DockerCli_Client_Call) RunAndReturn(run func() client.APIClient) *DockerCli_Client_Call {
	_c.Call.Return(run)
	return _c
}

// ConfigFile provides a mock function with given fields:
func (_m *DockerCli) ConfigFile() *configfile.ConfigFile {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ConfigFile")
	}

	var r0 *configfile.ConfigFile
	if rf, ok := ret.Get(0).(func() *configfile.ConfigFile); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*configfile.ConfigFile)
		}
	}

	return r0
}

// DockerCli_ConfigFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConfigFile'
type DockerCli_ConfigFile_Call struct {
	*mock.Call
}

// ConfigFile is a helper method to define mock.On call
func (_e *DockerCli_Expecter) ConfigFile() *DockerCli_ConfigFile_Call {
	return &DockerCli_ConfigFile_Call{Call: _e.mock.On("ConfigFile")}
}

func (_c *DockerCli_ConfigFile_Call) Run(run func()) *DockerCli_ConfigFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DockerCli_ConfigFile_Call) Return(_a0 *configfile.ConfigFile) *DockerCli_ConfigFile_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *DockerCli_ConfigFile_Call) RunAndReturn(run func() *configfile.ConfigFile) *DockerCli_ConfigFile_Call {
	_c.Call.Return(run)
	return _c
}

// ContentTrustEnabled provides a mock function with given fields:
func (_m *DockerCli) ContentTrustEnabled() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ContentTrustEnabled")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// DockerCli_ContentTrustEnabled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ContentTrustEnabled'
type DockerCli_ContentTrustEnabled_Call struct {
	*mock.Call
}

// ContentTrustEnabled is a helper method to define mock.On call
func (_e *DockerCli_Expecter) ContentTrustEnabled() *DockerCli_ContentTrustEnabled_Call {
	return &DockerCli_ContentTrustEnabled_Call{Call: _e.mock.On("ContentTrustEnabled")}
}

func (_c *DockerCli_ContentTrustEnabled_Call) Run(run func()) *DockerCli_ContentTrustEnabled_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DockerCli_ContentTrustEnabled_Call) Return(_a0 bool) *DockerCli_ContentTrustEnabled_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *DockerCli_ContentTrustEnabled_Call) RunAndReturn(run func() bool) *DockerCli_ContentTrustEnabled_Call {
	_c.Call.Return(run)
	return _c
}

// ContextStore provides a mock function with given fields:
func (_m *DockerCli) ContextStore() store.Store {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ContextStore")
	}

	var r0 store.Store
	if rf, ok := ret.Get(0).(func() store.Store); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(store.Store)
		}
	}

	return r0
}

// DockerCli_ContextStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ContextStore'
type DockerCli_ContextStore_Call struct {
	*mock.Call
}

// ContextStore is a helper method to define mock.On call
func (_e *DockerCli_Expecter) ContextStore() *DockerCli_ContextStore_Call {
	return &DockerCli_ContextStore_Call{Call: _e.mock.On("ContextStore")}
}

func (_c *DockerCli_ContextStore_Call) Run(run func()) *DockerCli_ContextStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DockerCli_ContextStore_Call) Return(_a0 store.Store) *DockerCli_ContextStore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *DockerCli_ContextStore_Call) RunAndReturn(run func() store.Store) *DockerCli_ContextStore_Call {
	_c.Call.Return(run)
	return _c
}

// CurrentContext provides a mock function with given fields:
func (_m *DockerCli) CurrentContext() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for CurrentContext")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// DockerCli_CurrentContext_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CurrentContext'
type DockerCli_CurrentContext_Call struct {
	*mock.Call
}

// CurrentContext is a helper method to define mock.On call
func (_e *DockerCli_Expecter) CurrentContext() *DockerCli_CurrentContext_Call {
	return &DockerCli_CurrentContext_Call{Call: _e.mock.On("CurrentContext")}
}

func (_c *DockerCli_CurrentContext_Call) Run(run func()) *DockerCli_CurrentContext_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DockerCli_CurrentContext_Call) Return(_a0 string) *DockerCli_CurrentContext_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *DockerCli_CurrentContext_Call) RunAndReturn(run func() string) *DockerCli_CurrentContext_Call {
	_c.Call.Return(run)
	return _c
}

// CurrentVersion provides a mock function with given fields:
func (_m *DockerCli) CurrentVersion() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for CurrentVersion")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// DockerCli_CurrentVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CurrentVersion'
type DockerCli_CurrentVersion_Call struct {
	*mock.Call
}

// CurrentVersion is a helper method to define mock.On call
func (_e *DockerCli_Expecter) CurrentVersion() *DockerCli_CurrentVersion_Call {
	return &DockerCli_CurrentVersion_Call{Call: _e.mock.On("CurrentVersion")}
}

func (_c *DockerCli_CurrentVersion_Call) Run(run func()) *DockerCli_CurrentVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DockerCli_CurrentVersion_Call) Return(_a0 string) *DockerCli_CurrentVersion_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *DockerCli_CurrentVersion_Call) RunAndReturn(run func() string) *DockerCli_CurrentVersion_Call {
	_c.Call.Return(run)
	return _c
}

// DefaultVersion provides a mock function with given fields:
func (_m *DockerCli) DefaultVersion() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for DefaultVersion")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// DockerCli_DefaultVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DefaultVersion'
type DockerCli_DefaultVersion_Call struct {
	*mock.Call
}

// DefaultVersion is a helper method to define mock.On call
func (_e *DockerCli_Expecter) DefaultVersion() *DockerCli_DefaultVersion_Call {
	return &DockerCli_DefaultVersion_Call{Call: _e.mock.On("DefaultVersion")}
}

func (_c *DockerCli_DefaultVersion_Call) Run(run func()) *DockerCli_DefaultVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DockerCli_DefaultVersion_Call) Return(_a0 string) *DockerCli_DefaultVersion_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *DockerCli_DefaultVersion_Call) RunAndReturn(run func() string) *DockerCli_DefaultVersion_Call {
	_c.Call.Return(run)
	return _c
}

// DockerEndpoint provides a mock function with given fields:
func (_m *DockerCli) DockerEndpoint() docker.Endpoint {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for DockerEndpoint")
	}

	var r0 docker.Endpoint
	if rf, ok := ret.Get(0).(func() docker.Endpoint); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(docker.Endpoint)
	}

	return r0
}

// DockerCli_DockerEndpoint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DockerEndpoint'
type DockerCli_DockerEndpoint_Call struct {
	*mock.Call
}

// DockerEndpoint is a helper method to define mock.On call
func (_e *DockerCli_Expecter) DockerEndpoint() *DockerCli_DockerEndpoint_Call {
	return &DockerCli_DockerEndpoint_Call{Call: _e.mock.On("DockerEndpoint")}
}

func (_c *DockerCli_DockerEndpoint_Call) Run(run func()) *DockerCli_DockerEndpoint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DockerCli_DockerEndpoint_Call) Return(_a0 docker.Endpoint) *DockerCli_DockerEndpoint_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *DockerCli_DockerEndpoint_Call) RunAndReturn(run func() docker.Endpoint) *DockerCli_DockerEndpoint_Call {
	_c.Call.Return(run)
	return _c
}

// Err provides a mock function with given fields:
func (_m *DockerCli) Err() *streams.Out {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Err")
	}

	var r0 *streams.Out
	if rf, ok := ret.Get(0).(func() *streams.Out); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*streams.Out)
		}
	}

	return r0
}

// DockerCli_Err_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Err'
type DockerCli_Err_Call struct {
	*mock.Call
}

// Err is a helper method to define mock.On call
func (_e *DockerCli_Expecter) Err() *DockerCli_Err_Call {
	return &DockerCli_Err_Call{Call: _e.mock.On("Err")}
}

func (_c *DockerCli_Err_Call) Run(run func()) *DockerCli_Err_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DockerCli_Err_Call) Return(_a0 *streams.Out) *DockerCli_Err_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *DockerCli_Err_Call) RunAndReturn(run func() *streams.Out) *DockerCli_Err_Call {
	_c.Call.Return(run)
	return _c
}

// In provides a mock function with given fields:
func (_m *DockerCli) In() *streams.In {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for In")
	}

	var r0 *streams.In
	if rf, ok := ret.Get(0).(func() *streams.In); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*streams.In)
		}
	}

	return r0
}

// DockerCli_In_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'In'
type DockerCli_In_Call struct {
	*mock.Call
}

// In is a helper method to define mock.On call
func (_e *DockerCli_Expecter) In() *DockerCli_In_Call {
	return &DockerCli_In_Call{Call: _e.mock.On("In")}
}

func (_c *DockerCli_In_Call) Run(run func()) *DockerCli_In_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DockerCli_In_Call) Return(_a0 *streams.In) *DockerCli_In_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *DockerCli_In_Call) RunAndReturn(run func() *streams.In) *DockerCli_In_Call {
	_c.Call.Return(run)
	return _c
}

// ManifestStore provides a mock function with given fields:
func (_m *DockerCli) ManifestStore() manifeststore.Store {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ManifestStore")
	}

	var r0 manifeststore.Store
	if rf, ok := ret.Get(0).(func() manifeststore.Store); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(manifeststore.Store)
		}
	}

	return r0
}

// DockerCli_ManifestStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ManifestStore'
type DockerCli_ManifestStore_Call struct {
	*mock.Call
}

// ManifestStore is a helper method to define mock.On call
func (_e *DockerCli_Expecter) ManifestStore() *DockerCli_ManifestStore_Call {
	return &DockerCli_ManifestStore_Call{Call: _e.mock.On("ManifestStore")}
}

func (_c *DockerCli_ManifestStore_Call) Run(run func()) *DockerCli_ManifestStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DockerCli_ManifestStore_Call) Return(_a0 manifeststore.Store) *DockerCli_ManifestStore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *DockerCli_ManifestStore_Call) RunAndReturn(run func() manifeststore.Store) *DockerCli_ManifestStore_Call {
	_c.Call.Return(run)
	return _c
}

// MeterProvider provides a mock function with given fields:
func (_m *DockerCli) MeterProvider() metric.MeterProvider {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for MeterProvider")
	}

	var r0 metric.MeterProvider
	if rf, ok := ret.Get(0).(func() metric.MeterProvider); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(metric.MeterProvider)
		}
	}

	return r0
}

// DockerCli_MeterProvider_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MeterProvider'
type DockerCli_MeterProvider_Call struct {
	*mock.Call
}

// MeterProvider is a helper method to define mock.On call
func (_e *DockerCli_Expecter) MeterProvider() *DockerCli_MeterProvider_Call {
	return &DockerCli_MeterProvider_Call{Call: _e.mock.On("MeterProvider")}
}

func (_c *DockerCli_MeterProvider_Call) Run(run func()) *DockerCli_MeterProvider_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DockerCli_MeterProvider_Call) Return(_a0 metric.MeterProvider) *DockerCli_MeterProvider_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *DockerCli_MeterProvider_Call) RunAndReturn(run func() metric.MeterProvider) *DockerCli_MeterProvider_Call {
	_c.Call.Return(run)
	return _c
}

// NotaryClient provides a mock function with given fields: imgRefAndAuth, actions
func (_m *DockerCli) NotaryClient(imgRefAndAuth trust.ImageRefAndAuth, actions []string) (notaryclient.Repository, error) {
	ret := _m.Called(imgRefAndAuth, actions)

	if len(ret) == 0 {
		panic("no return value specified for NotaryClient")
	}

	var r0 notaryclient.Repository
	var r1 error
	if rf, ok := ret.Get(0).(func(trust.ImageRefAndAuth, []string) (notaryclient.Repository, error)); ok {
		return rf(imgRefAndAuth, actions)
	}
	if rf, ok := ret.Get(0).(func(trust.ImageRefAndAuth, []string) notaryclient.Repository); ok {
		r0 = rf(imgRefAndAuth, actions)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(notaryclient.Repository)
		}
	}

	if rf, ok := ret.Get(1).(func(trust.ImageRefAndAuth, []string) error); ok {
		r1 = rf(imgRefAndAuth, actions)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DockerCli_NotaryClient_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NotaryClient'
type DockerCli_NotaryClient_Call struct {
	*mock.Call
}

// NotaryClient is a helper method to define mock.On call
//   - imgRefAndAuth trust.ImageRefAndAuth
//   - actions []string
func (_e *DockerCli_Expecter) NotaryClient(imgRefAndAuth interface{}, actions interface{}) *DockerCli_NotaryClient_Call {
	return &DockerCli_NotaryClient_Call{Call: _e.mock.On("NotaryClient", imgRefAndAuth, actions)}
}

func (_c *DockerCli_NotaryClient_Call) Run(run func(imgRefAndAuth trust.ImageRefAndAuth, actions []string)) *DockerCli_NotaryClient_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(trust.ImageRefAndAuth), args[1].([]string))
	})
	return _c
}

func (_c *DockerCli_NotaryClient_Call) Return(_a0 notaryclient.Repository, _a1 error) *DockerCli_NotaryClient_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DockerCli_NotaryClient_Call) RunAndReturn(run func(trust.ImageRefAndAuth, []string) (notaryclient.Repository, error)) *DockerCli_NotaryClient_Call {
	_c.Call.Return(run)
	return _c
}

// Out provides a mock function with given fields:
func (_m *DockerCli) Out() *streams.Out {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Out")
	}

	var r0 *streams.Out
	if rf, ok := ret.Get(0).(func() *streams.Out); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*streams.Out)
		}
	}

	return r0
}

// DockerCli_Out_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Out'
type DockerCli_Out_Call struct {
	*mock.Call
}

// Out is a helper method to define mock.On call
func (_e *DockerCli_Expecter) Out() *DockerCli_Out_Call {
	return &DockerCli_Out_Call{Call: _e.mock.On("Out")}
}

func (_c *DockerCli_Out_Call) Run(run func()) *DockerCli_Out_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DockerCli_Out_Call) Return(_a0 *streams.Out) *DockerCli_Out_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *DockerCli_Out_Call) RunAndReturn(run func() *streams.Out) *DockerCli_Out_Call {
	_c.Call.Return(run)
	return _c
}

// RegistryClient provides a mock function with given fields: _a0
func (_m *DockerCli) RegistryClient(_a0 bool) registryclient.RegistryClient {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for RegistryClient")
	}

	var r0 registryclient.RegistryClient
	if rf, ok := ret.Get(0).(func(bool) registryclient.RegistryClient); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(registryclient.RegistryClient)
		}
	}

	return r0
}

// DockerCli_RegistryClient_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegistryClient'
type DockerCli_RegistryClient_Call struct {
	*mock.Call
}

// RegistryClient is a helper method to define mock.On call
//   - _a0 bool
func (_e *DockerCli_Expecter) RegistryClient(_a0 interface{}) *DockerCli_RegistryClient_Call {
	return &DockerCli_RegistryClient_Call{Call: _e.mock.On("RegistryClient", _a0)}
}

func (_c *DockerCli_RegistryClient_Call) Run(run func(_a0 bool)) *DockerCli_RegistryClient_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bool))
	})
	return _c
}

func (_c *DockerCli_RegistryClient_Call) Return(_a0 registryclient.RegistryClient) *DockerCli_RegistryClient_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *DockerCli_RegistryClient_Call) RunAndReturn(run func(bool) registryclient.RegistryClient) *DockerCli_RegistryClient_Call {
	_c.Call.Return(run)
	return _c
}

// Resource provides a mock function with given fields:
func (_m *DockerCli) Resource() *resource.Resource {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Resource")
	}

	var r0 *resource.Resource
	if rf, ok := ret.Get(0).(func() *resource.Resource); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*resource.Resource)
		}
	}

	return r0
}

// DockerCli_Resource_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Resource'
type DockerCli_Resource_Call struct {
	*mock.Call
}

// Resource is a helper method to define mock.On call
func (_e *DockerCli_Expecter) Resource() *DockerCli_Resource_Call {
	return &DockerCli_Resource_Call{Call: _e.mock.On("Resource")}
}

func (_c *DockerCli_Resource_Call) Run(run func()) *DockerCli_Resource_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DockerCli_Resource_Call) Return(_a0 *resource.Resource) *DockerCli_Resource_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *DockerCli_Resource_Call) RunAndReturn(run func() *resource.Resource) *DockerCli_Resource_Call {
	_c.Call.Return(run)
	return _c
}

// ServerInfo provides a mock function with given fields:
func (_m *DockerCli) ServerInfo() command.ServerInfo {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ServerInfo")
	}

	var r0 command.ServerInfo
	if rf, ok := ret.Get(0).(func() command.ServerInfo); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(command.ServerInfo)
	}

	return r0
}

// DockerCli_ServerInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ServerInfo'
type DockerCli_ServerInfo_Call struct {
	*mock.Call
}

// ServerInfo is a helper method to define mock.On call
func (_e *DockerCli_Expecter) ServerInfo() *DockerCli_ServerInfo_Call {
	return &DockerCli_ServerInfo_Call{Call: _e.mock.On("ServerInfo")}
}

func (_c *DockerCli_ServerInfo_Call) Run(run func()) *DockerCli_ServerInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DockerCli_ServerInfo_Call) Return(_a0 command.ServerInfo) *DockerCli_ServerInfo_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *DockerCli_ServerInfo_Call) RunAndReturn(run func() command.ServerInfo) *DockerCli_ServerInfo_Call {
	_c.Call.Return(run)
	return _c
}

// SetIn provides a mock function with given fields: in
func (_m *DockerCli) SetIn(in *streams.In) {
	_m.Called(in)
}

// DockerCli_SetIn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetIn'
type DockerCli_SetIn_Call struct {
	*mock.Call
}

// SetIn is a helper method to define mock.On call
//   - in *streams.In
func (_e *DockerCli_Expecter) SetIn(in interface{}) *DockerCli_SetIn_Call {
	return &DockerCli_SetIn_Call{Call: _e.mock.On("SetIn", in)}
}

func (_c *DockerCli_SetIn_Call) Run(run func(in *streams.In)) *DockerCli_SetIn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*streams.In))
	})
	return _c
}

func (_c *DockerCli_SetIn_Call) Return() *DockerCli_SetIn_Call {
	_c.Call.Return()
	return _c
}

func (_c *DockerCli_SetIn_Call) RunAndReturn(run func(*streams.In)) *DockerCli_SetIn_Call {
	_c.Call.Return(run)
	return _c
}

// TracerProvider provides a mock function with given fields:
func (_m *DockerCli) TracerProvider() trace.TracerProvider {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for TracerProvider")
	}

	var r0 trace.TracerProvider
	if rf, ok := ret.Get(0).(func() trace.TracerProvider); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(trace.TracerProvider)
		}
	}

	return r0
}

// DockerCli_TracerProvider_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TracerProvider'
type DockerCli_TracerProvider_Call struct {
	*mock.Call
}

// TracerProvider is a helper method to define mock.On call
func (_e *DockerCli_Expecter) TracerProvider() *DockerCli_TracerProvider_Call {
	return &DockerCli_TracerProvider_Call{Call: _e.mock.On("TracerProvider")}
}

func (_c *DockerCli_TracerProvider_Call) Run(run func()) *DockerCli_TracerProvider_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *DockerCli_TracerProvider_Call) Return(_a0 trace.TracerProvider) *DockerCli_TracerProvider_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *DockerCli_TracerProvider_Call) RunAndReturn(run func() trace.TracerProvider) *DockerCli_TracerProvider_Call {
	_c.Call.Return(run)
	return _c
}

// NewDockerCli creates a new instance of DockerCli. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewDockerCli(t interface {
	mock.TestingT
	Cleanup(func())
}) *DockerCli {
	mock := &DockerCli{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
