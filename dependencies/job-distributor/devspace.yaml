version: v2beta1

vars:
  DEPENDENCIES_DIR:
    source: env
    default: "../../dependencies"
  DEVSPACE_INGRESS_CIDRS:
    source: env
    default: "0.0.0.0/0"
  # This is the base domain in AWS Route 53 that our ingress subdomains will use.
  DEVSPACE_INGRESS_BASE_DOMAIN:
    source: env
    default: "main.stage.cldev.sh"
  JOB_DISTRIBUTOR_IMAGE_TAG:
    source: env
    default: "0.9.0"

dependencies:
  postgres:
    path: ${DEPENDENCIES_DIR}/postgres/devspace.yaml
    namespace: ${DEVSPACE_NAMESPACE}

pipelines:
  deploy:
    run: |-
      if [ "$PROVIDER" == "kind" ]; then
        ensure_pull_secrets --all
      fi

      run_dependency_pipelines postgres

      create_deployments job-distributor

deployments:
  job-distributor:
    namespace: ${DEVSPACE_NAMESPACE}
    helm:
      releaseName: "job-distributor"
      chart:
        name: ${CHAINLINK_HELM_REGISTRY_URI}/job-distributor
        version: "0.2.11"
      values:
        image:
          tag: ${JOB_DISTRIBUTOR_IMAGE_TAG}
        envVars:
          ENVIRONMENT: development
          DATABASE_URL: postgresql://chainlink:JGVgp7M2Emcg7Av8KKVUgMZb@postgres:5432/chainlink?sslmode=disable
          CSA_KEY_ENCRYPTION_SECRET: supersecret
          SERVER_ENABLE_REFLECTION: true
        ingress:
          enabled: true
          host: ${DEVSPACE_NAMESPACE}-job-distributor-grpc.${DEVSPACE_INGRESS_BASE_DOMAIN}
          annotations:
            external-dns.alpha.kubernetes.io/ttl: "120"
        networkPolicyDefault:
          ingress:
            allowCustomCidrs: true
            # Should be a comma separated list of CIDR blocks. To include
            # AWS ALB private CIDRs and optionally other custom CIDRs.
            # Example format: 10.0.0.0/16,192.168.0.1/24
            customCidrs: ${DEVSPACE_INGRESS_CIDRS}
hooks:
  # sometimes it takes a little bit of time for cert-manage to provision dynamic certs, we need to wait for that
  - name: Wait for GRPC endpoint to be ready
    command: |
      if [ "$CRIB_CI_ENV" == "true" ]; then
        # we can call GRPC endpoint as it would require invoking via GAP
        echo "running In CI env, skip waiting for grpc endpoint to be ready"
      else
        grpc_endpoint="${DEVSPACE_NAMESPACE}-job-distributor-grpc.${DEVSPACE_INGRESS_BASE_DOMAIN}:443"
        ${SCRIPTS_DIR}/wait_for_grpc_url.sh "$grpc_endpoint" "grpc.health.v1.Health/Check" "600"
      fi
    events: ["after:deploy:job-distributor"]
  - wait:
      running: true
      # This can be needed for init containers
      # that terminate instead of become running.
      terminatedWithCode: 0
    container:
      labelSelector:
        "app.kubernetes.io/name": "job-distributor"
    name: "wait-for-pods"
    events: ["after:deploy:job-distributor"]
profiles:
  - name: git-charts
    merge:
      deployments:
        job-distributor:
          helm:
            chart:
              git: https://github.com/smartcontractkit/job-distributor
              subPath: charts/job-distributor
              revision: 51a811d3d1061e606e05ca7e11530b778ab15528
  - name: local-charts
    merge:
      deployments:
        job-distributor:
          helm:
            chart:
              name: job-distributor
              path: ${CHAINLINK_CODE_DIR}/job-distributor/charts/job-distributor
              version: null
  - name: aws-main-stage-cluster
    activation:
      - vars:
          PROVIDER: "aws"
    merge:
      deployments:
        job-distributor:
          helm:
            values:
              nodeSelector:
                node-role: crib
              tolerations:
                - key: "node-role"
                  operator: "Equal"
                  value: "crib"
                  effect: "NoSchedule"
              noderpc:
                annotations:
                  external-dns.alpha.kubernetes.io/hostname: ${DEVSPACE_NAMESPACE}-job-distributor-node-rpc.${DEVSPACE_INGRESS_BASE_DOMAIN}
                  external-dns.alpha.kubernetes.io/ttl: "120"
                  service.beta.kubernetes.io/aws-load-balancer-scheme: internal
                  service.beta.kubernetes.io/load-balancer-source-ranges: "10.0.0.0/8"
                  service.beta.kubernetes.io/aws-load-balancer-type: external
                  service.beta.kubernetes.io/aws-load-balancer-nlb-target-type: ip
                  service.beta.kubernetes.io/aws-load-balancer-healthcheck-protocol: http
                  service.beta.kubernetes.io/aws-load-balancer-healthcheck-port: "8081"
                  service.beta.kubernetes.io/aws-load-balancer-healthcheck-path: /healthz
              ingress:
                className: nginx-internal
                enabled: true
                annotations:
                  nginx.ingress.kubernetes.io/backend-protocol: "GRPC"
                  external-dns.alpha.kubernetes.io/ttl: "120"
  - name: size-medium
    merge:
      dependencies:
        postgres:
          profiles:
            - job-distributor-size-medium
  - name: kind
    activation:
      - vars:
          PROVIDER: "kind"
    merge:
      pullSecrets:
        regcred-prod-ecr:
          registry: 804282218731.dkr.ecr.us-west-2.amazonaws.com
          secret: regcred-prod-ecr
      deployments:
        job-distributor:
          helm:
            values:
              imagePullSecrets:
                - name: regcred-prod-ecr
              ingress:
                tls:
                  enabled: true
                annotations:
                  cert-manager.io/cluster-issuer: mkcert-issuer
                  nginx.ingress.kubernetes.io/ssl-redirect: "true"
                  nginx.ingress.kubernetes.io/backend-protocol: "GRPC"
  - name: aws-main-fwog
    activation:
      - vars:
          PROVIDER: "aws"
          CRIB_EKS_CLUSTER_NAME: "main-fwog"
    merge:
      deployments:
        job-distributor:
          helm:
            values:
              ingress:
                className: alb
                annotations:
                  alb.ingress.kubernetes.io/backend-protocol-version: GRPC
                  alb.ingress.kubernetes.io/certificate-arn: arn:aws:acm:us-west-2:273354650086:certificate/cff3fbc7-e14c-4d79-af82-dc66d747ebf0
                  alb.ingress.kubernetes.io/group.name: sandbox
                  alb.ingress.kubernetes.io/listen-ports: '[{"HTTP": 80}, {"HTTPS":443}]'
                  alb.ingress.kubernetes.io/scheme: internal
                  alb.ingress.kubernetes.io/ssl-redirect: "443"
                  alb.ingress.kubernetes.io/target-type: ip
