package usdc_test

import (
	"context"
	"encoding/hex"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
	"time"

	sel "github.com/smartcontractkit/chain-selectors"
	commonconfig "github.com/smartcontractkit/chainlink-common/pkg/config"
	"github.com/smartcontractkit/chainlink-common/pkg/logger"
	"github.com/smartcontractkit/chainlink-common/pkg/types"
	cciptypes "github.com/smartcontractkit/chainlink-common/pkg/types/ccipocr3"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"

	"github.com/smartcontractkit/chainlink-ccip/execute/exectypes"
	"github.com/smartcontractkit/chainlink-ccip/execute/tokendata/usdc"
	"github.com/smartcontractkit/chainlink-ccip/internal"
	readermock "github.com/smartcontractkit/chainlink-ccip/mocks/pkg/contractreader"
	"github.com/smartcontractkit/chainlink-ccip/pkg/contractreader"
	readerpkg "github.com/smartcontractkit/chainlink-ccip/pkg/reader"
	"github.com/smartcontractkit/chainlink-ccip/pluginconfig"
)

type usdcMessage struct {
	// nonce is the nonce of the message, generated by Circle MessageTransmitter
	nonce uint64
	// sourceDomain is the domain of the source chain, check CCTPDestDomains
	sourceDomain uint32
	// eventPayload is the data from the MessageSent(bytes) event, taken directly from chain explorer
	eventPayload string
	// urlMessageHash is the keccak of the eventPayload, used as msg identifier in Attestation API
	urlMessageHash string
	// attestationResponse is the response from the Attestation API
	attestationResponse string
	// attestationResponseStatus is the status code of the response from the Attestation API
	attestationResponseStatus int
}

func (u *usdcMessage) attestationBytes() []byte {
	var result map[string]interface{}

	err := json.Unmarshal([]byte(u.attestationResponse), &result)
	if err != nil {
		panic(err)
	}

	attestation, ok := result["attestation"].(string)
	if !ok {
		panic("attestation not found")
	}

	bytes, err := cciptypes.NewBytesFromString(attestation)
	if err != nil {
		panic(err)
	}
	return bytes
}

//nolint:lll
var (
	//https://testnet.snowtrace.io/tx/0xeeb0ad6b26bacd1570a9361724a36e338f4aacf1170dec64399220b7483b7eed/eventlog?chainid=43113
	//https://iris-api-sandbox.circle.com/v1/attestations/0x69fb1b419d648cf6c9512acad303746dc85af3b864af81985c76764aba60bf6b
	m1 = usdcMessage{
		nonce:          306189,
		sourceDomain:   1, // Avalanche Fuji
		eventPayload:   "000000000000000100000006000000000004ac0d000000000000000000000000eb08f243e5d3fcff26a9e38ae5520a669f4019d00000000000000000000000009f3b8679c73c2fef8b59b4f3444d4e156fb70aa5000000000000000000000000c08835adf4884e51ff076066706e407506826d9d000000000000000000000000000000005425890298aed601595a70ab815c96711a31bc650000000000000000000000004f32ae7f112c26b109357785e5c66dc5d747fbce00000000000000000000000000000000000000000000000000000000000000640000000000000000000000007a4d8f8c18762d362e64b411d7490fba112811cd",
		urlMessageHash: "0x69fb1b419d648cf6c9512acad303746dc85af3b864af81985c76764aba60bf6b",
		attestationResponse: `{
			"attestation":"0xee466fbd340596aa56e3e40d249869573e4008d84d795b4f2c3cba8649083d08653d38190d0df7e0ee12ae685df2f806d100a03b3716ab1ff2013c7201f1c2d01c9af959b55a4b52dbd0319eed69ce9ace25259830e0b1bff79faf0c9c5d1b5e6d6304e824d657db38f802bcff3e97d0bd30f2ffc62b62381f52c1668ceaa5a73a1b",
			"status":"complete"
		}`,
		attestationResponseStatus: 200,
	}

	//https://testnet.snowtrace.io/tx/0xa7dd97e149c496c52b747bac999d3753a846ea373e1c84b463ffb056516a981b/eventlog?chainid=43113
	//https://iris-api-sandbox.circle.com/v1/attestations/0x6ebe09cc552207bdc7bc688ff9fc149d2fd1b712a9bf369e04f37beee55e959d
	m2 = usdcMessage{
		nonce:          306190,
		sourceDomain:   1, // Avalanche Fuji
		eventPayload:   "000000000000000100000006000000000004ac0e000000000000000000000000eb08f243e5d3fcff26a9e38ae5520a669f4019d00000000000000000000000009f3b8679c73c2fef8b59b4f3444d4e156fb70aa5000000000000000000000000c08835adf4884e51ff076066706e407506826d9d000000000000000000000000000000005425890298aed601595a70ab815c96711a31bc650000000000000000000000004f32ae7f112c26b109357785e5c66dc5d747fbce000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007a4d8f8c18762d362e64b411d7490fba112811cd",
		urlMessageHash: "0x6ebe09cc552207bdc7bc688ff9fc149d2fd1b712a9bf369e04f37beee55e959d",
		attestationResponse: `{
			"attestation":"0xda3130f99f9029757d3326c48ffada1b0886a463181b65e59d7cc40a8984059f641454ccc9907772e64aa52e3e735b62947eea015d35a6bb1bd2d4822ebbb5b51b630cd1c600c0c5a8646ae64ae7778aa8ce52bd074e4d0414a30d19aad0b50b2408659b2f51e5960e372f8f1277045464cf83bc96154027f7ed2008ece45267641c",
			"status":"complete"
		}`,
		attestationResponseStatus: 200,
	}

	//https://testnet.snowtrace.io/tx/0x389b95c11e2dbe7bf4b8734c4854316707e50e34023299dd37f0f0ebdef9142f
	//https://iris-api-sandbox.circle.com/v1/attestations/0x4d83caf347edd730ccb39afdefdbd312e9ae22a6ec8992087ab0b71818220964
	m3 = usdcMessage{
		nonce:          306191,
		sourceDomain:   1, // Avalanche Fuji
		eventPayload:   "000000000000000100000006000000000004ac0f000000000000000000000000eb08f243e5d3fcff26a9e38ae5520a669f4019d00000000000000000000000009f3b8679c73c2fef8b59b4f3444d4e156fb70aa5000000000000000000000000c08835adf4884e51ff076066706e407506826d9d000000000000000000000000000000005425890298aed601595a70ab815c96711a31bc650000000000000000000000004f32ae7f112c26b109357785e5c66dc5d747fbce0000000000000000000000000000000000000000000000000000000000030d400000000000000000000000007a4d8f8c18762d362e64b411d7490fba112811cd",
		urlMessageHash: "0x4d83caf347edd730ccb39afdefdbd312e9ae22a6ec8992087ab0b71818220964",
		attestationResponse: `{
			"attestation":"0x068c6043f95632cf22eaa552cc08b9ee8fdf635897978ebccbe171a73838ca277248f4ec75d7f677e3bed73868fb08041ba8b71fc9222e63ae9b479d870c2deb1cb68f12cacc918a6638cabea8c36c9ceb8328e149f0465f986ea240a4a5888be43232a90505cb59a66f68a73d23ace3f91c584f9df87cf9012c5a4ca5a746b6ed1b",
			"status":"complete"
		}`,
		attestationResponseStatus: 200,
	}

	//https://sepolia.etherscan.io/tx/0x63eddd816fbf10872aaf27905a07c37cd5c675c785f55175e9f5529bf94ff7e5
	m4 = usdcMessage{
		sourceDomain: 0, // Ethereum Sepolia
		eventPayload: "00000000000000000000000300000000000401C30000000000000000000000009F3B8679C73C2FEF8B59B4F3444D4E156FB70AA50000000000000000000000009F3B8679C73C2FEF8B59B4F3444D4E156FB70AA50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001C7D4B196CB0C7B01D743FBC6116A902379C7238000000000000000000000000FF814813D48D79A6A81E55EF2F96426BA1E37AF50000000000000000000000000000000000000000000000000000000000A037A0000000000000000000000000C5D952CE7100D7D1A9A578FB55346B870062BAFC",
	}

	//https://sepolia.etherscan.io/tx/0x028a2a08f9b6cd74aa013b5300768585eb2ef10a11e24c25bc456eb2223ad34e
	m5 = usdcMessage{
		sourceDomain: 0, // Ethereum Sepolia
		eventPayload: "https://sepolia.etherscan.io/tx/0x028a2a08f9b6cd74aa013b5300768585eb2ef10a11e24c25bc456eb2223ad34e",
	}
)

// This test focuses on almost e2e flows for USDC message
// It aims to make it as real as possible by using real payloads from the chain and
// real responses from the Attestation API. As long as the Attestation API is supporting old events
// you should be able to just copy-paste block explorer and attestation requests to the browser
// and see those responses in action
func Test_USDC_CCTP_Flow(t *testing.T) {
	fujiChain := cciptypes.ChainSelector(sel.AVALANCHE_TESTNET_FUJI.Selector)
	fujiPool := internal.RandBytes().String()
	fujiTransmitter := "0xa9fB1b3009DCb79E2fe346c16a604B8Fa8aE0a79"

	sepoliaChain := cciptypes.ChainSelector(sel.ETHEREUM_TESTNET_SEPOLIA.Selector)
	sepoliaPool := internal.RandBytes().String()
	sepoliaTransmitter := "0x7865fAfC2db2093669d92c0F33AeEF291086BEFD"

	baseChain := cciptypes.ChainSelector(sel.ETHEREUM_TESTNET_SEPOLIA_BASE_1.Selector)

	config := map[cciptypes.ChainSelector]pluginconfig.USDCCCTPTokenConfig{
		fujiChain: {
			SourcePoolAddress:            fujiPool,
			SourceMessageTransmitterAddr: fujiTransmitter,
		},
		sepoliaChain: {
			SourcePoolAddress:            sepoliaPool,
			SourceMessageTransmitterAddr: sepoliaTransmitter,
		},
	}

	fuji := []usdcMessage{m1, m2, m3}
	sepolia := []usdcMessage{}
	all := []usdcMessage{m1, m2, m3, m4, m5}

	// Mock http server to return proper payloads
	server := mockHTTPServerResponse(t, all)
	defer server.Close()

	// Always return all the events
	fujiReader := mockReader(t, fuji)
	sepoliaReader := mockReader(t, sepolia)

	usdcReader, err := readerpkg.NewUSDCMessageReader(
		config,
		map[cciptypes.ChainSelector]contractreader.ContractReaderFacade{
			fujiChain:    fujiReader,
			sepoliaChain: sepoliaReader,
		})
	require.NoError(t, err)

	attestation, err := usdc.NewSequentialAttestationClient(
		pluginconfig.USDCCCTPObserverConfig{
			AttestationAPI:         server.URL,
			AttestationAPIInterval: commonconfig.MustNewDuration(1 * time.Microsecond),
			AttestationAPITimeout:  commonconfig.MustNewDuration(1 * time.Second),
		})
	require.NoError(t, err)

	tkReader := usdc.NewTokenDataObserver(
		logger.Test(t),
		baseChain,
		config,
		usdcReader,
		attestation,
	)

	tt := []struct {
		name     string
		messages exectypes.MessageObservations
		want     exectypes.TokenDataObservations
	}{
		{
			name: "single valid message from fuji to base",
			messages: exectypes.MessageObservations{
				fujiChain: {
					1: cciptypes.Message{
						TokenAmounts: []cciptypes.RampTokenAmount{
							createToken(t, m1.nonce, m1.sourceDomain, fujiPool),
						},
					},
				},
			},
			want: exectypes.TokenDataObservations{
				fujiChain: {
					1: exectypes.MessageTokenData{
						TokenData: []exectypes.TokenData{
							exectypes.NewSuccessTokenData(m1.attestationBytes()),
						},
					},
				},
			},
		},
	}

	for _, tc := range tt {
		t.Run(tc.name, func(t *testing.T) {
			got, err1 := tkReader.Observe(context.Background(), tc.messages)
			require.NoError(t, err1)
			require.Equal(t, tc.want, got)
		})

	}
}

func createToken(t *testing.T, nonce uint64, sourceDomain uint32, pool string) cciptypes.RampTokenAmount {
	p, err := cciptypes.NewBytesFromString(pool)
	require.NoError(t, err)

	return cciptypes.RampTokenAmount{
		SourcePoolAddress: p,
		ExtraData:         readerpkg.NewSourceTokenDataPayload(nonce, sourceDomain).ToBytes(),
		Amount:            cciptypes.NewBigIntFromInt64(100),
	}
}

func mockReader(t *testing.T, message []usdcMessage) *readermock.MockContractReaderFacade {
	items := make([]types.Sequence, len(message))
	for i, m := range message {
		items[i] = types.Sequence{Data: newUSDCMessageEvent(t, m.eventPayload)}
	}

	r := readermock.NewMockContractReaderFacade(t)
	r.EXPECT().Bind(mock.Anything, mock.Anything).Return(nil).Maybe()
	r.EXPECT().QueryKey(
		mock.Anything,
		mock.Anything,
		mock.Anything,
		mock.Anything,
		mock.Anything,
	).Return(items, nil).Maybe()
	return r
}

func mockHTTPServerResponse(t *testing.T, messages []usdcMessage) *httptest.Server {
	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		for _, m := range messages {
			if strings.Contains(r.RequestURI, m.urlMessageHash) {
				w.WriteHeader(m.attestationResponseStatus)
				_, err := w.Write([]byte(m.attestationResponse))
				require.NoError(t, err)
				return
			}
		}
	}))
	return ts
}

func newUSDCMessageEvent(t *testing.T, messageBody string) *readerpkg.MessageSentEvent {
	body, err := hex.DecodeString(messageBody)
	require.NoError(t, err)

	return &readerpkg.MessageSentEvent{
		Arg0: body,
	}
}
